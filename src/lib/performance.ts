// Performance monitoring and optimization utilities\n\n// Performance metrics tracking\ninterface PerformanceMetrics {\n  name: string\n  duration: number\n  timestamp: number\n  memory?: number\n}\n\nclass PerformanceMonitor {\n  private metrics: PerformanceMetrics[] = []\n  private maxMetrics = 1000 // Prevent memory leaks\n\n  measure<T>(name: string, fn: () => T): T {\n    const start = performance.now()\n    const startMemory = (performance as any).memory?.usedJSHeapSize\n    \n    const result = fn()\n    \n    const end = performance.now()\n    const endMemory = (performance as any).memory?.usedJSHeapSize\n    \n    const metric: PerformanceMetrics = {\n      name,\n      duration: end - start,\n      timestamp: Date.now(),\n      memory: endMemory - startMemory\n    }\n    \n    this.addMetric(metric)\n    \n    if (process.env.NODE_ENV === 'development') {\n      console.log(`⚡ ${name}: ${metric.duration.toFixed(2)}ms`)\n    }\n    \n    return result\n  }\n\n  async measureAsync<T>(name: string, fn: () => Promise<T>): Promise<T> {\n    const start = performance.now()\n    const startMemory = (performance as any).memory?.usedJSHeapSize\n    \n    const result = await fn()\n    \n    const end = performance.now()\n    const endMemory = (performance as any).memory?.usedJSHeapSize\n    \n    const metric: PerformanceMetrics = {\n      name,\n      duration: end - start,\n      timestamp: Date.now(),\n      memory: endMemory - startMemory\n    }\n    \n    this.addMetric(metric)\n    \n    if (process.env.NODE_ENV === 'development') {\n      console.log(`⚡ ${name}: ${metric.duration.toFixed(2)}ms`)\n    }\n    \n    return result\n  }\n\n  private addMetric(metric: PerformanceMetrics) {\n    this.metrics.push(metric)\n    if (this.metrics.length > this.maxMetrics) {\n      this.metrics.shift()\n    }\n  }\n\n  getMetrics(name?: string): PerformanceMetrics[] {\n    return name ? this.metrics.filter(m => m.name === name) : this.metrics\n  }\n\n  getAverageTime(name: string): number {\n    const metrics = this.getMetrics(name)\n    if (metrics.length === 0) return 0\n    return metrics.reduce((sum, m) => sum + m.duration, 0) / metrics.length\n  }\n\n  clear() {\n    this.metrics = []\n  }\n}\n\n// Global performance monitor instance\nexport const performanceMonitor = new PerformanceMonitor()\n\n// React performance hooks\nimport { useCallback, useEffect, useRef } from 'react'\n\n// Debounced callback hook\nexport function useDebounce<T extends (...args: any[]) => any>(\n  callback: T,\n  delay: number\n): T {\n  const timeoutRef = useRef<NodeJS.Timeout>()\n  \n  return useCallback(\n    ((...args: Parameters<T>) => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n      }\n      \n      timeoutRef.current = setTimeout(() => {\n        callback(...args)\n      }, delay)\n    }) as T,\n    [callback, delay]\n  )\n}\n\n// Throttled callback hook\nexport function useThrottle<T extends (...args: any[]) => any>(\n  callback: T,\n  delay: number\n): T {\n  const lastCallRef = useRef(0)\n  \n  return useCallback(\n    ((...args: Parameters<T>) => {\n      const now = Date.now()\n      if (now - lastCallRef.current >= delay) {\n        lastCallRef.current = now\n        callback(...args)\n      }\n    }) as T,\n    [callback, delay]\n  )\n}\n\n// Performance observer for web vitals\nexport function observeWebVitals() {\n  if (typeof window === 'undefined') return\n  \n  // Core Web Vitals\n  const observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n      if (entry.entryType === 'navigation') {\n        const nav = entry as PerformanceNavigationTiming\n        console.log('🚀 Navigation Timing:', {\n          domContentLoaded: nav.domContentLoadedEventEnd - nav.domContentLoadedEventStart,\n          loadComplete: nav.loadEventEnd - nav.loadEventStart,\n          firstByte: nav.responseStart - nav.requestStart\n        })\n      }\n      \n      if (entry.entryType === 'paint') {\n        console.log(`🎨 ${entry.name}: ${entry.startTime.toFixed(2)}ms`)\n      }\n      \n      if (entry.entryType === 'largest-contentful-paint') {\n        console.log(`📏 LCP: ${entry.startTime.toFixed(2)}ms`)\n      }\n    }\n  })\n  \n  observer.observe({ entryTypes: ['navigation', 'paint', 'largest-contentful-paint'] })\n}\n\n// Memory monitoring\nexport function logMemoryUsage() {\n  if (typeof window === 'undefined' || !(performance as any).memory) return\n  \n  const memory = (performance as any).memory\n  console.log('💾 Memory Usage:', {\n    used: `${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`,\n    total: `${(memory.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`,\n    limit: `${(memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`\n  })\n}\n\n// Bundle size analyzer\nexport function analyzeBundleSize() {\n  if (typeof window === 'undefined') return\n  \n  const scripts = Array.from(document.querySelectorAll('script[src]'))\n  const styles = Array.from(document.querySelectorAll('link[rel=\"stylesheet\"]'))\n  \n  console.log('📦 Bundle Analysis:', {\n    scripts: scripts.length,\n    styles: styles.length,\n    scriptSources: scripts.map(s => (s as HTMLScriptElement).src)\n  })\n}\n\n// Component render tracking\nexport function useRenderTracker(componentName: string) {\n  const renderCount = useRef(0)\n  const lastRender = useRef(Date.now())\n  \n  useEffect(() => {\n    renderCount.current++\n    const now = Date.now()\n    const timeSinceLastRender = now - lastRender.current\n    lastRender.current = now\n    \n    if (process.env.NODE_ENV === 'development') {\n      console.log(`🔄 ${componentName} render #${renderCount.current} (+${timeSinceLastRender}ms)`)\n    }\n  })\n  \n  return renderCount.current\n}\n\n// Intersection observer hook for lazy loading\nexport function useIntersectionObserver(\n  callback: (isIntersecting: boolean) => void,\n  options?: IntersectionObserverInit\n) {\n  const ref = useRef<HTMLElement>(null)\n  \n  useEffect(() => {\n    const element = ref.current\n    if (!element) return\n    \n    const observer = new IntersectionObserver(\n      ([entry]) => callback(entry.isIntersecting),\n      options\n    )\n    \n    observer.observe(element)\n    \n    return () => observer.disconnect()\n  }, [callback, options])\n  \n  return ref\n}\n\n// Image preloader\nexport function preloadImages(urls: string[]): Promise<void[]> {\n  return Promise.all(\n    urls.map(url => \n      new Promise<void>((resolve, reject) => {\n        const img = new Image()\n        img.onload = () => resolve()\n        img.onerror = reject\n        img.src = url\n      })\n    )\n  )\n}\n\n// Resource hints\nexport function addResourceHints(urls: string[], type: 'preload' | 'prefetch' = 'preload') {\n  if (typeof document === 'undefined') return\n  \n  urls.forEach(url => {\n    const link = document.createElement('link')\n    link.rel = type\n    link.href = url\n    link.as = 'fetch'\n    link.crossOrigin = 'anonymous'\n    document.head.appendChild(link)\n  })\n}\n\n// Critical CSS inlining helper\nexport function inlineCriticalCSS(css: string) {\n  if (typeof document === 'undefined') return\n  \n  const style = document.createElement('style')\n  style.textContent = css\n  document.head.appendChild(style)\n}" 