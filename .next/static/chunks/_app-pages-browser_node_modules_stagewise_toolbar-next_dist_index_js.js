"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_stagewise_toolbar-next_dist_index_js"],{

/***/ "(app-pages-browser)/./node_modules/@stagewise/toolbar-next/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@stagewise/toolbar-next/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StagewiseToolbar: () => (/* binding */ StagewiseToolbar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dynamic */ \"(app-pages-browser)/./node_modules/next/dist/api/app-dynamic.js\");\n/* __next_internal_client_entry_do_not_use__ StagewiseToolbar auto */ \n\nvar jsxRuntime = {\n    exports: {}\n};\nvar reactJsxRuntime_production = {};\n/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredReactJsxRuntime_production;\nfunction requireReactJsxRuntime_production() {\n    if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;\n    hasRequiredReactJsxRuntime_production = 1;\n    var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n    function jsxProd(type, config, maybeKey) {\n        var key = null;\n        void 0 !== maybeKey && (key = \"\" + maybeKey);\n        void 0 !== config.key && (key = \"\" + config.key);\n        if (\"key\" in config) {\n            maybeKey = {};\n            for(var propName in config)\"key\" !== propName && (maybeKey[propName] = config[propName]);\n        } else maybeKey = config;\n        config = maybeKey.ref;\n        return {\n            $$typeof: REACT_ELEMENT_TYPE,\n            type,\n            key,\n            ref: void 0 !== config ? config : null,\n            props: maybeKey\n        };\n    }\n    reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;\n    reactJsxRuntime_production.jsx = jsxProd;\n    reactJsxRuntime_production.jsxs = jsxProd;\n    return reactJsxRuntime_production;\n}\nvar reactJsxRuntime_development = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredReactJsxRuntime_development;\nfunction requireReactJsxRuntime_development() {\n    if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;\n    hasRequiredReactJsxRuntime_development = 1;\n     true && function() {\n        function getComponentNameFromType(type) {\n            if (null == type) return null;\n            if (\"function\" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;\n            if (\"string\" === typeof type) return type;\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_ACTIVITY_TYPE:\n                    return \"Activity\";\n            }\n            if (\"object\" === typeof type) switch(\"number\" === typeof type.tag && console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), type.$$typeof){\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_CONTEXT_TYPE:\n                    return (type.displayName || \"Context\") + \".Provider\";\n                case REACT_CONSUMER_TYPE:\n                    return (type._context.displayName || \"Context\") + \".Consumer\";\n                case REACT_FORWARD_REF_TYPE:\n                    var innerType = type.render;\n                    type = type.displayName;\n                    type || (type = innerType.displayName || innerType.name || \"\", type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\");\n                    return type;\n                case REACT_MEMO_TYPE:\n                    return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || \"Memo\";\n                case REACT_LAZY_TYPE:\n                    innerType = type._payload;\n                    type = type._init;\n                    try {\n                        return getComponentNameFromType(type(innerType));\n                    } catch (x) {}\n            }\n            return null;\n        }\n        function testStringCoercion(value) {\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            try {\n                testStringCoercion(value);\n                var JSCompiler_inline_result = false;\n            } catch (e) {\n                JSCompiler_inline_result = true;\n            }\n            if (JSCompiler_inline_result) {\n                JSCompiler_inline_result = console;\n                var JSCompiler_temp_const = JSCompiler_inline_result.error;\n                var JSCompiler_inline_result$jscomp$0 = \"function\" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n                JSCompiler_temp_const.call(JSCompiler_inline_result, \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\", JSCompiler_inline_result$jscomp$0);\n                return testStringCoercion(value);\n            }\n        }\n        function getTaskName(type) {\n            if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n            if (\"object\" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return \"<...>\";\n            try {\n                var name = getComponentNameFromType(type);\n                return name ? \"<\" + name + \">\" : \"<...>\";\n            } catch (x) {\n                return \"<...>\";\n            }\n        }\n        function getOwner() {\n            var dispatcher = ReactSharedInternals.A;\n            return null === dispatcher ? null : dispatcher.getOwner();\n        }\n        function UnknownOwner() {\n            return Error(\"react-stack-top-frame\");\n        }\n        function hasValidKey(config) {\n            if (hasOwnProperty.call(config, \"key\")) {\n                var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                if (getter && getter.isReactWarning) return false;\n            }\n            return void 0 !== config.key;\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            function warnAboutAccessingKey() {\n                specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\", displayName));\n            }\n            warnAboutAccessingKey.isReactWarning = true;\n            Object.defineProperty(props, \"key\", {\n                get: warnAboutAccessingKey,\n                configurable: true\n            });\n        }\n        function elementRefGetterWithDeprecationWarning() {\n            var componentName = getComponentNameFromType(this.type);\n            didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(\"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"));\n            componentName = this.props.ref;\n            return void 0 !== componentName ? componentName : null;\n        }\n        function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {\n            self = props.ref;\n            type = {\n                $$typeof: REACT_ELEMENT_TYPE,\n                type,\n                key,\n                props,\n                _owner: owner\n            };\n            null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, \"ref\", {\n                enumerable: false,\n                get: elementRefGetterWithDeprecationWarning\n            }) : Object.defineProperty(type, \"ref\", {\n                enumerable: false,\n                value: null\n            });\n            type._store = {};\n            Object.defineProperty(type._store, \"validated\", {\n                configurable: false,\n                enumerable: false,\n                writable: true,\n                value: 0\n            });\n            Object.defineProperty(type, \"_debugInfo\", {\n                configurable: false,\n                enumerable: false,\n                writable: true,\n                value: null\n            });\n            Object.defineProperty(type, \"_debugStack\", {\n                configurable: false,\n                enumerable: false,\n                writable: true,\n                value: debugStack\n            });\n            Object.defineProperty(type, \"_debugTask\", {\n                configurable: false,\n                enumerable: false,\n                writable: true,\n                value: debugTask\n            });\n            Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n            return type;\n        }\n        function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {\n            var children = config.children;\n            if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {\n                for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);\n                Object.freeze && Object.freeze(children);\n            } else console.error(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else validateChildKeys(children);\n            if (hasOwnProperty.call(config, \"key\")) {\n                children = getComponentNameFromType(type);\n                var keys = Object.keys(config).filter(function(k) {\n                    return \"key\" !== k;\n                });\n                isStaticChildren = 0 < keys.length ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\", console.error('A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = true);\n            }\n            children = null;\n            void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = \"\" + maybeKey);\n            hasValidKey(config) && (checkKeyStringCoercion(config.key), children = \"\" + config.key);\n            if (\"key\" in config) {\n                maybeKey = {};\n                for(var propName in config)\"key\" !== propName && (maybeKey[propName] = config[propName]);\n            } else maybeKey = config;\n            children && defineKeyPropWarningGetter(maybeKey, \"function\" === typeof type ? type.displayName || type.name || \"Unknown\" : type);\n            return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);\n        }\n        function validateChildKeys(node) {\n            \"object\" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);\n        }\n        var React = react__WEBPACK_IMPORTED_MODULE_0__, REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"), REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {\n            return null;\n        };\n        React = {\n            \"react-stack-bottom-frame\": function(callStackForError) {\n                return callStackForError();\n            }\n        };\n        var specialPropKeyWarningShown;\n        var didWarnAboutElementRef = {};\n        var unknownOwnerDebugStack = React[\"react-stack-bottom-frame\"].bind(React, UnknownOwner)();\n        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n        var didWarnAboutKeySpread = {};\n        reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;\n        reactJsxRuntime_development.jsx = function(type, config, maybeKey, source, self) {\n            var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n            return jsxDEVImpl(type, config, maybeKey, false, source, self, trackActualOwner ? Error(\"react-stack-top-frame\") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);\n        };\n        reactJsxRuntime_development.jsxs = function(type, config, maybeKey, source, self) {\n            var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n            return jsxDEVImpl(type, config, maybeKey, true, source, self, trackActualOwner ? Error(\"react-stack-top-frame\") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);\n        };\n    }();\n    return reactJsxRuntime_development;\n}\nvar hasRequiredJsxRuntime;\nfunction requireJsxRuntime() {\n    if (hasRequiredJsxRuntime) return jsxRuntime.exports;\n    hasRequiredJsxRuntime = 1;\n    if (false) {} else {\n        jsxRuntime.exports = requireReactJsxRuntime_development();\n    }\n    return jsxRuntime.exports;\n}\nvar jsxRuntimeExports = requireJsxRuntime();\nconst DynamicToolbar = (0,next_dynamic__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(()=>__webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_stagewise_toolbar-react_dist_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! @stagewise/toolbar-react */ \"(app-pages-browser)/./node_modules/@stagewise/toolbar-react/dist/index.js\")).then((mod)=>({\n            default: mod.StagewiseToolbar\n        })), {\n    loadableGenerated: {\n        modules: [\n            \"../node_modules/@stagewise/toolbar-next/dist/index.js -> \" + \"@stagewise/toolbar-react\"\n        ]\n    },\n    ssr: false\n});\n_c = DynamicToolbar;\nconst StagewiseToolbar = (param)=>{\n    let { config, enabled = \"development\" === \"development\" } = param;\n    if (!enabled) {\n        return null;\n    }\n    return /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicToolbar, {\n        config,\n        enabled\n    });\n};\n_c1 = StagewiseToolbar;\n\nvar _c, _c1;\n$RefreshReg$(_c, \"DynamicToolbar\");\n$RefreshReg$(_c1, \"StagewiseToolbar\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RhZ2V3aXNlL3Rvb2xiYXItbmV4dC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztzRUFDK0I7QUFDSTtBQUNuQyxJQUFJRSxhQUFhO0lBQUVDLFNBQVMsQ0FBQztBQUFFO0FBQy9CLElBQUlDLDZCQUE2QixDQUFDO0FBQ2xDOzs7Ozs7OztDQVFDLEdBQ0QsSUFBSUM7QUFDSixTQUFTQztJQUNQLElBQUlELHVDQUF1QyxPQUFPRDtJQUNsREMsd0NBQXdDO0lBQ3hDLElBQUlFLHFCQUFxQkMsT0FBT0MsR0FBRyxDQUFDLCtCQUErQkMsc0JBQXNCRixPQUFPQyxHQUFHLENBQUM7SUFDcEcsU0FBU0UsUUFBUUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFFBQVE7UUFDckMsSUFBSUMsTUFBTTtRQUNWLEtBQUssTUFBTUQsWUFBYUMsQ0FBQUEsTUFBTSxLQUFLRCxRQUFPO1FBQzFDLEtBQUssTUFBTUQsT0FBT0UsR0FBRyxJQUFLQSxDQUFBQSxNQUFNLEtBQUtGLE9BQU9FLEdBQUc7UUFDL0MsSUFBSSxTQUFTRixRQUFRO1lBQ25CQyxXQUFXLENBQUM7WUFDWixJQUFLLElBQUlFLFlBQVlILE9BQ25CLFVBQVVHLFlBQWFGLENBQUFBLFFBQVEsQ0FBQ0UsU0FBUyxHQUFHSCxNQUFNLENBQUNHLFNBQVM7UUFDaEUsT0FBT0YsV0FBV0Q7UUFDbEJBLFNBQVNDLFNBQVNHLEdBQUc7UUFDckIsT0FBTztZQUNMQyxVQUFVWDtZQUNWSztZQUNBRztZQUNBRSxLQUFLLEtBQUssTUFBTUosU0FBU0EsU0FBUztZQUNsQ00sT0FBT0w7UUFDVDtJQUNGO0lBQ0FWLDJCQUEyQmdCLFFBQVEsR0FBR1Y7SUFDdENOLDJCQUEyQmlCLEdBQUcsR0FBR1Y7SUFDakNQLDJCQUEyQmtCLElBQUksR0FBR1g7SUFDbEMsT0FBT1A7QUFDVDtBQUNBLElBQUltQiw4QkFBOEIsQ0FBQztBQUNuQzs7Ozs7Ozs7Q0FRQyxHQUNE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O0lBQ3hCLElBQUlFLEtBQXFDLEVBQUUsRUFFMUMsTUFBTTtRQUNMdEgsV0FBV0MsT0FBTyxHQUFHc0I7SUFDdkI7SUFDQSxPQUFPdkIsV0FBV0MsT0FBTztBQUMzQjtBQUNBLElBQUlzSCxvQkFBb0JGO0FBQ3hCLE1BQU1HLGlCQUFpQnpILHdEQUFPQSxDQUM1QixJQUFNLCtRQUFrQyxDQUFDMEgsSUFBSSxDQUFDLENBQUNDLE1BQVM7WUFDdERDLFNBQVNELElBQUlFLGdCQUFnQjtRQUMvQjs7Ozs7O0lBQ0VDLEtBQUs7O0tBSkhMO0FBTU4sTUFBTUksbUJBQW1CO1FBQUMsRUFBRWpILE1BQU0sRUFBRW1ILFVBQVVSLGtCQUF5QixhQUFhLEVBQUU7SUFDcEYsSUFBSSxDQUFDUSxTQUFTO1FBQ1osT0FBTztJQUNUO0lBQ0EsT0FBTyxhQUFhLEdBQUdQLGtCQUFrQnBHLEdBQUcsQ0FBQ3FHLGdCQUFnQjtRQUFFN0c7UUFBUW1IO0lBQVE7QUFDakY7TUFMTUY7QUFRSiIsInNvdXJjZXMiOlsiL1ZvbHVtZXMvU29mdHdhYXJlIFByb2dyYW0vYXBwdGl2aXR5IGZpbmFsIHYxL25vZGVfbW9kdWxlcy9Ac3RhZ2V3aXNlL3Rvb2xiYXItbmV4dC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHJlcXVpcmUkJDAgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgZHluYW1pYyBmcm9tIFwibmV4dC9keW5hbWljXCI7XG52YXIganN4UnVudGltZSA9IHsgZXhwb3J0czoge30gfTtcbnZhciByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbiA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uO1xuZnVuY3Rpb24gcmVxdWlyZVJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uKCkge1xuICBpZiAoaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbikgcmV0dXJuIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uO1xuICBoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uID0gMTtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSwgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcbiAgZnVuY3Rpb24ganN4UHJvZCh0eXBlLCBjb25maWcsIG1heWJlS2V5KSB7XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdm9pZCAwICE9PSBtYXliZUtleSAmJiAoa2V5ID0gXCJcIiArIG1heWJlS2V5KTtcbiAgICB2b2lkIDAgIT09IGNvbmZpZy5rZXkgJiYgKGtleSA9IFwiXCIgKyBjb25maWcua2V5KTtcbiAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgY29uZmlnID0gbWF5YmVLZXkucmVmO1xuICAgIHJldHVybiB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgdHlwZSxcbiAgICAgIGtleSxcbiAgICAgIHJlZjogdm9pZCAwICE9PSBjb25maWcgPyBjb25maWcgOiBudWxsLFxuICAgICAgcHJvcHM6IG1heWJlS2V5XG4gICAgfTtcbiAgfVxuICByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbi5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uLmpzeCA9IGpzeFByb2Q7XG4gIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uLmpzeHMgPSBqc3hQcm9kO1xuICByZXR1cm4gcmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb247XG59XG52YXIgcmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50ID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudDtcbmZ1bmN0aW9uIHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCkgcmV0dXJuIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudDtcbiAgaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQgPSAxO1xuICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID8gbnVsbCA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiYgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKSwgdHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fCAodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiLCB0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCwgbnVsbCAhPT0gaW5uZXJUeXBlID8gaW5uZXJUeXBlIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8IFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSlcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHwgKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZSwgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fCAoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9IHRydWUsIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMsIGRlYnVnU3RhY2ssIGRlYnVnVGFzaykge1xuICAgICAgc2VsZiA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGtleSxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSBzZWxmID8gc2VsZiA6IG51bGwpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgIH0pIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGVidWdTdGFja1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwodHlwZSwgY29uZmlnLCBtYXliZUtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmLCBkZWJ1Z1N0YWNrLCBkZWJ1Z1Rhc2spIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKGlzU3RhdGljQ2hpbGRyZW4gPSAwOyBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoOyBpc1N0YXRpY0NoaWxkcmVuKyspXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwIDwga2V5cy5sZW5ndGggPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dIHx8IChrZXlzID0gMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiwgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyB7Li4ucHJvcHN9IC8+XFxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAga2V5cyxcbiAgICAgICAgICBjaGlsZHJlblxuICAgICAgICApLCBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9IHRydWUpO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdm9pZCAwICE9PSBtYXliZUtleSAmJiAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSksIGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiYgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIGNoaWxkcmVuID0gXCJcIiArIGNvbmZpZy5rZXkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIiA6IHR5cGVcbiAgICAgICk7XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KFxuICAgICAgICB0eXBlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgc2VsZixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBnZXRPd25lcigpLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgZGVidWdTdGFjayxcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJiBudWxsICE9PSBub2RlICYmIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJiBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUkJDAsIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSwgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIHZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLCBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgUkVBQ1RfQUNUSVZJVFlfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5hY3Rpdml0eVwiKSwgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLCBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSwgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2sgPyBjb25zb2xlLmNyZWF0ZVRhc2sgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVhY3QgPSB7XG4gICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbihjYWxsU3RhY2tGb3JFcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbFN0YWNrRm9yRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1N0YWNrID0gUmVhY3RbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICByZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudC5qc3ggPSBmdW5jdGlvbih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAgICAgIHZhciB0cmFja0FjdHVhbE93bmVyID0gMWU0ID4gUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MrKztcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzZWxmLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIikgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfTtcbiAgICByZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQuanN4cyA9IGZ1bmN0aW9uKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICAgICAgdmFyIHRyYWNrQWN0dWFsT3duZXIgPSAxZTQgPiBSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcysrO1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIHRydWUsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc2VsZixcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0oKTtcbiAgcmV0dXJuIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudDtcbn1cbnZhciBoYXNSZXF1aXJlZEpzeFJ1bnRpbWU7XG5mdW5jdGlvbiByZXF1aXJlSnN4UnVudGltZSgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkSnN4UnVudGltZSkgcmV0dXJuIGpzeFJ1bnRpbWUuZXhwb3J0cztcbiAgaGFzUmVxdWlyZWRKc3hSdW50aW1lID0gMTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGpzeFJ1bnRpbWUuZXhwb3J0cyA9IHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIGpzeFJ1bnRpbWUuZXhwb3J0cyA9IHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQoKTtcbiAgfVxuICByZXR1cm4ganN4UnVudGltZS5leHBvcnRzO1xufVxudmFyIGpzeFJ1bnRpbWVFeHBvcnRzID0gcmVxdWlyZUpzeFJ1bnRpbWUoKTtcbmNvbnN0IER5bmFtaWNUb29sYmFyID0gZHluYW1pYyhcbiAgKCkgPT4gaW1wb3J0KFwiQHN0YWdld2lzZS90b29sYmFyLXJlYWN0XCIpLnRoZW4oKG1vZCkgPT4gKHtcbiAgICBkZWZhdWx0OiBtb2QuU3RhZ2V3aXNlVG9vbGJhclxuICB9KSksXG4gIHsgc3NyOiBmYWxzZSB9XG4pO1xuY29uc3QgU3RhZ2V3aXNlVG9vbGJhciA9ICh7IGNvbmZpZywgZW5hYmxlZCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgfSkgPT4ge1xuICBpZiAoIWVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChEeW5hbWljVG9vbGJhciwgeyBjb25maWcsIGVuYWJsZWQgfSk7XG59O1xuZXhwb3J0IHtcbiAgU3RhZ2V3aXNlVG9vbGJhclxufTtcbiJdLCJuYW1lcyI6WyJyZXF1aXJlJCQwIiwiZHluYW1pYyIsImpzeFJ1bnRpbWUiLCJleHBvcnRzIiwicmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb24iLCJoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uIiwicmVxdWlyZVJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsImpzeFByb2QiLCJ0eXBlIiwiY29uZmlnIiwibWF5YmVLZXkiLCJrZXkiLCJwcm9wTmFtZSIsInJlZiIsIiQkdHlwZW9mIiwicHJvcHMiLCJGcmFnbWVudCIsImpzeCIsImpzeHMiLCJyZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQiLCJoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCIsInJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfQUNUSVZJVFlfVFlQRSIsInRhZyIsImNvbnNvbGUiLCJlcnJvciIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfQ09OU1VNRVJfVFlQRSIsIl9jb250ZXh0IiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsImlubmVyVHlwZSIsInJlbmRlciIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIl9wYXlsb2FkIiwiX2luaXQiLCJ4IiwidGVzdFN0cmluZ0NvZXJjaW9uIiwidmFsdWUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IiwiZSIsIkpTQ29tcGlsZXJfdGVtcF9jb25zdCIsIkpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJjYWxsIiwiZ2V0VGFza05hbWUiLCJnZXRPd25lciIsImRpc3BhdGNoZXIiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIkEiLCJVbmtub3duT3duZXIiLCJFcnJvciIsImhhc1ZhbGlkS2V5IiwiaGFzT3duUHJvcGVydHkiLCJnZXR0ZXIiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJpc1JlYWN0V2FybmluZyIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5Iiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nIiwiY29tcG9uZW50TmFtZSIsImRpZFdhcm5BYm91dEVsZW1lbnRSZWYiLCJSZWFjdEVsZW1lbnQiLCJzZWxmIiwic291cmNlIiwib3duZXIiLCJkZWJ1Z1N0YWNrIiwiZGVidWdUYXNrIiwiX293bmVyIiwiZW51bWVyYWJsZSIsIl9zdG9yZSIsIndyaXRhYmxlIiwiZnJlZXplIiwianN4REVWSW1wbCIsImlzU3RhdGljQ2hpbGRyZW4iLCJjaGlsZHJlbiIsImlzQXJyYXlJbXBsIiwibGVuZ3RoIiwidmFsaWRhdGVDaGlsZEtleXMiLCJrZXlzIiwiZmlsdGVyIiwiayIsImpvaW4iLCJkaWRXYXJuQWJvdXRLZXlTcHJlYWQiLCJub2RlIiwidmFsaWRhdGVkIiwiUmVhY3QiLCJfX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJwcm90b3R5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJjcmVhdGVUYXNrIiwiY2FsbFN0YWNrRm9yRXJyb3IiLCJ1bmtub3duT3duZXJEZWJ1Z1N0YWNrIiwiYmluZCIsInVua25vd25Pd25lckRlYnVnVGFzayIsInRyYWNrQWN0dWFsT3duZXIiLCJyZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcyIsImhhc1JlcXVpcmVkSnN4UnVudGltZSIsInJlcXVpcmVKc3hSdW50aW1lIiwicHJvY2VzcyIsImpzeFJ1bnRpbWVFeHBvcnRzIiwiRHluYW1pY1Rvb2xiYXIiLCJ0aGVuIiwibW9kIiwiZGVmYXVsdCIsIlN0YWdld2lzZVRvb2xiYXIiLCJzc3IiLCJlbmFibGVkIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@stagewise/toolbar-next/dist/index.js\n"));

/***/ })

}]);