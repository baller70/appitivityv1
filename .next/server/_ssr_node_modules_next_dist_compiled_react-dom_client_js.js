"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_node_modules_next_dist_compiled_react-dom_client_js";
exports.ids = ["_ssr_node_modules_next_dist_compiled_react-dom_client_js"];
exports.modules = {

/***/ "(ssr)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-client.development.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom-client.development.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-dom-client.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ /*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/ \n true && function() {\n    function findHook(fiber, id) {\n        for(fiber = fiber.memoizedState; null !== fiber && 0 < id;)fiber = fiber.next, id--;\n        return fiber;\n    }\n    function copyWithSetImpl(obj, path, index, value) {\n        if (index >= path.length) return value;\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n        return updated;\n    }\n    function copyWithRename(obj, oldPath, newPath) {\n        if (oldPath.length !== newPath.length) console.warn(\"copyWithRename() expects paths of the same length\");\n        else {\n            for(var i = 0; i < newPath.length - 1; i++)if (oldPath[i] !== newPath[i]) {\n                console.warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                return;\n            }\n            return copyWithRenameImpl(obj, oldPath, newPath, 0);\n        }\n    }\n    function copyWithRenameImpl(obj, oldPath, newPath, index) {\n        var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n        return updated;\n    }\n    function copyWithDeleteImpl(obj, path, index) {\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;\n        updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n        return updated;\n    }\n    function shouldSuspendImpl() {\n        return !1;\n    }\n    function shouldErrorImpl() {\n        return null;\n    }\n    function warnInvalidHookAccess() {\n        console.error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\");\n    }\n    function warnInvalidContextAccess() {\n        console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n    }\n    function noop$2() {}\n    function warnForMissingKey() {}\n    function setToSortedString(set) {\n        var array = [];\n        set.forEach(function(value) {\n            array.push(value);\n        });\n        return array.sort().join(\", \");\n    }\n    function createFiber(tag, pendingProps, key, mode) {\n        return new FiberNode(tag, pendingProps, key, mode);\n    }\n    function scheduleRoot(root, element) {\n        root.context === emptyContextObject && (updateContainerImpl(root.current, 2, element, root, null, null), flushSyncWork$1());\n    }\n    function scheduleRefresh(root, update) {\n        if (null !== resolveFamily) {\n            var staleFamilies = update.staleFamilies;\n            update = update.updatedFamilies;\n            flushPendingEffects();\n            scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);\n            flushSyncWork$1();\n        }\n    }\n    function setRefreshHandler(handler) {\n        resolveFamily = handler;\n    }\n    function isValidContainer(node) {\n        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);\n    }\n    function getNearestMountedFiber(fiber) {\n        var node = fiber, nearestMounted = fiber;\n        if (fiber.alternate) for(; node.return;)node = node.return;\n        else {\n            fiber = node;\n            do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;\n            while (fiber);\n        }\n        return 3 === node.tag ? nearestMounted : null;\n    }\n    function getSuspenseInstanceFromFiber(fiber) {\n        if (13 === fiber.tag) {\n            var suspenseState = fiber.memoizedState;\n            null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));\n            if (null !== suspenseState) return suspenseState.dehydrated;\n        }\n        return null;\n    }\n    function assertIsMounted(fiber) {\n        if (getNearestMountedFiber(fiber) !== fiber) throw Error(\"Unable to find node on an unmounted component.\");\n    }\n    function findCurrentFiberUsingSlowPath(fiber) {\n        var alternate = fiber.alternate;\n        if (!alternate) {\n            alternate = getNearestMountedFiber(fiber);\n            if (null === alternate) throw Error(\"Unable to find node on an unmounted component.\");\n            return alternate !== fiber ? null : fiber;\n        }\n        for(var a = fiber, b = alternate;;){\n            var parentA = a.return;\n            if (null === parentA) break;\n            var parentB = parentA.alternate;\n            if (null === parentB) {\n                b = parentA.return;\n                if (null !== b) {\n                    a = b;\n                    continue;\n                }\n                break;\n            }\n            if (parentA.child === parentB.child) {\n                for(parentB = parentA.child; parentB;){\n                    if (parentB === a) return assertIsMounted(parentA), fiber;\n                    if (parentB === b) return assertIsMounted(parentA), alternate;\n                    parentB = parentB.sibling;\n                }\n                throw Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.return !== b.return) a = parentA, b = parentB;\n            else {\n                for(var didFindChild = !1, _child = parentA.child; _child;){\n                    if (_child === a) {\n                        didFindChild = !0;\n                        a = parentA;\n                        b = parentB;\n                        break;\n                    }\n                    if (_child === b) {\n                        didFindChild = !0;\n                        b = parentA;\n                        a = parentB;\n                        break;\n                    }\n                    _child = _child.sibling;\n                }\n                if (!didFindChild) {\n                    for(_child = parentB.child; _child;){\n                        if (_child === a) {\n                            didFindChild = !0;\n                            a = parentB;\n                            b = parentA;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = !0;\n                            b = parentB;\n                            a = parentA;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) throw Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\n                }\n            }\n            if (a.alternate !== b) throw Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        if (3 !== a.tag) throw Error(\"Unable to find node on an unmounted component.\");\n        return a.stateNode.current === a ? fiber : alternate;\n    }\n    function findCurrentHostFiberImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            tag = findCurrentHostFiberImpl(node);\n            if (null !== tag) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function getIteratorFn(maybeIterable) {\n        if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[\"@@iterator\"];\n        return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function getComponentNameFromType(type) {\n        if (null == type) return null;\n        if (\"function\" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;\n        if (\"string\" === typeof type) return type;\n        switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return \"Fragment\";\n            case REACT_PROFILER_TYPE:\n                return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n                return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n                return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n                return \"SuspenseList\";\n            case REACT_ACTIVITY_TYPE:\n                return \"Activity\";\n        }\n        if (\"object\" === typeof type) switch(\"number\" === typeof type.tag && console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), type.$$typeof){\n            case REACT_PORTAL_TYPE:\n                return \"Portal\";\n            case REACT_CONTEXT_TYPE:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case REACT_CONSUMER_TYPE:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case REACT_FORWARD_REF_TYPE:\n                var innerType = type.render;\n                type = type.displayName;\n                type || (type = innerType.displayName || innerType.name || \"\", type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\");\n                return type;\n            case REACT_MEMO_TYPE:\n                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE:\n                innerType = type._payload;\n                type = type._init;\n                try {\n                    return getComponentNameFromType(type(innerType));\n                } catch (x) {}\n        }\n        return null;\n    }\n    function getComponentNameFromOwner(owner) {\n        return \"number\" === typeof owner.tag ? getComponentNameFromFiber(owner) : \"string\" === typeof owner.name ? owner.name : null;\n    }\n    function getComponentNameFromFiber(fiber) {\n        var type = fiber.type;\n        switch(fiber.tag){\n            case 31:\n                return \"Activity\";\n            case 24:\n                return \"Cache\";\n            case 9:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case 10:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case 18:\n                return \"DehydratedFragment\";\n            case 11:\n                return fiber = type.render, fiber = fiber.displayName || fiber.name || \"\", type.displayName || (\"\" !== fiber ? \"ForwardRef(\" + fiber + \")\" : \"ForwardRef\");\n            case 7:\n                return \"Fragment\";\n            case 26:\n            case 27:\n            case 5:\n                return type;\n            case 4:\n                return \"Portal\";\n            case 3:\n                return \"Root\";\n            case 6:\n                return \"Text\";\n            case 16:\n                return getComponentNameFromType(type);\n            case 8:\n                return type === REACT_STRICT_MODE_TYPE ? \"StrictMode\" : \"Mode\";\n            case 22:\n                return \"Offscreen\";\n            case 12:\n                return \"Profiler\";\n            case 21:\n                return \"Scope\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 25:\n                return \"TracingMarker\";\n            case 1:\n            case 0:\n            case 14:\n            case 15:\n                if (\"function\" === typeof type) return type.displayName || type.name || null;\n                if (\"string\" === typeof type) return type;\n                break;\n            case 29:\n                type = fiber._debugInfo;\n                if (null != type) {\n                    for(var i = type.length - 1; 0 <= i; i--)if (\"string\" === typeof type[i].name) return type[i].name;\n                }\n                if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);\n        }\n        return null;\n    }\n    function createCursor(defaultValue) {\n        return {\n            current: defaultValue\n        };\n    }\n    function pop(cursor, fiber) {\n        0 > index$jscomp$0 ? console.error(\"Unexpected pop.\") : (fiber !== fiberStack[index$jscomp$0] && console.error(\"Unexpected Fiber popped.\"), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);\n    }\n    function push(cursor, value, fiber) {\n        index$jscomp$0++;\n        valueStack[index$jscomp$0] = cursor.current;\n        fiberStack[index$jscomp$0] = fiber;\n        cursor.current = value;\n    }\n    function requiredContext(c) {\n        null === c && console.error(\"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.\");\n        return c;\n    }\n    function pushHostContainer(fiber, nextRootInstance) {\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, null, fiber);\n        var nextRootContext = nextRootInstance.nodeType;\n        switch(nextRootContext){\n            case 9:\n            case 11:\n                nextRootContext = 9 === nextRootContext ? \"#document\" : \"#fragment\";\n                nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;\n                break;\n            default:\n                if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI) nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(nextRootInstance, nextRootContext);\n                else switch(nextRootContext){\n                    case \"svg\":\n                        nextRootInstance = HostContextNamespaceSvg;\n                        break;\n                    case \"math\":\n                        nextRootInstance = HostContextNamespaceMath;\n                        break;\n                    default:\n                        nextRootInstance = HostContextNamespaceNone;\n                }\n        }\n        nextRootContext = nextRootContext.toLowerCase();\n        nextRootContext = updatedAncestorInfoDev(null, nextRootContext);\n        nextRootContext = {\n            context: nextRootInstance,\n            ancestorInfo: nextRootContext\n        };\n        pop(contextStackCursor, fiber);\n        push(contextStackCursor, nextRootContext, fiber);\n    }\n    function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n    }\n    function getHostContext() {\n        return requiredContext(contextStackCursor.current);\n    }\n    function pushHostContext(fiber) {\n        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);\n        var context = requiredContext(contextStackCursor.current);\n        var type = fiber.type;\n        var nextContext = getChildHostContextProd(context.context, type);\n        type = updatedAncestorInfoDev(context.ancestorInfo, type);\n        nextContext = {\n            context: nextContext,\n            ancestorInfo: type\n        };\n        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));\n    }\n    function popHostContext(fiber) {\n        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));\n        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);\n    }\n    function disabledLog() {}\n    function disableLogs() {\n        if (0 === disabledDepth) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                value: disabledLog,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n            });\n        }\n        disabledDepth++;\n    }\n    function reenableLogs() {\n        disabledDepth--;\n        if (0 === disabledDepth) {\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                log: assign({}, props, {\n                    value: prevLog\n                }),\n                info: assign({}, props, {\n                    value: prevInfo\n                }),\n                warn: assign({}, props, {\n                    value: prevWarn\n                }),\n                error: assign({}, props, {\n                    value: prevError\n                }),\n                group: assign({}, props, {\n                    value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                    value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                    value: prevGroupEnd\n                })\n            });\n        }\n        0 > disabledDepth && console.error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n    }\n    function describeBuiltInComponentFrame(name) {\n        if (void 0 === prefix) try {\n            throw Error();\n        } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || \"\";\n            suffix = -1 < x.stack.indexOf(\"\\n    at\") ? \" (<anonymous>)\" : -1 < x.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n        }\n        return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) return \"\";\n        var frame = componentFrameCache.get(fn);\n        if (void 0 !== frame) return frame;\n        reentry = !0;\n        frame = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        var previousDispatcher = null;\n        previousDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = null;\n        disableLogs();\n        try {\n            var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    try {\n                        if (construct) {\n                            var Fake = function() {\n                                throw Error();\n                            };\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    throw Error();\n                                }\n                            });\n                            if (\"object\" === typeof Reflect && Reflect.construct) {\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    var control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x$0) {\n                                    control = x$0;\n                                }\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x$1) {\n                                control = x$1;\n                            }\n                            (Fake = fn()) && \"function\" === typeof Fake.catch && Fake.catch(function() {});\n                        }\n                    } catch (sample) {\n                        if (sample && control && \"string\" === typeof sample.stack) return [\n                            sample.stack,\n                            control.stack\n                        ];\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            };\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\");\n            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, \"name\", {\n                value: \"DetermineComponentFrameRoot\"\n            });\n            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n            if (sampleStack && controlStack) {\n                var sampleLines = sampleStack.split(\"\\n\"), controlLines = controlStack.split(\"\\n\");\n                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(\"DetermineComponentFrameRoot\");)namePropDescriptor++;\n                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(\"DetermineComponentFrameRoot\");)_RunInRootFrame$Deter++;\n                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;\n                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                            var _frame = \"\\n\" + sampleLines[namePropDescriptor].replace(\" at new \", \" at \");\n                            fn.displayName && _frame.includes(\"<anonymous>\") && (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                            \"function\" === typeof fn && componentFrameCache.set(fn, _frame);\n                            return _frame;\n                        }\n                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n                    }\n                    break;\n                }\n            }\n        } finally{\n            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;\n        }\n        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\") ? describeBuiltInComponentFrame(sampleLines) : \"\";\n        \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n        return sampleLines;\n    }\n    function formatOwnerStack(error) {\n        var prevPrepareStackTrace = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        error = error.stack;\n        Error.prepareStackTrace = prevPrepareStackTrace;\n        error.startsWith(\"Error: react-stack-top-frame\\n\") && (error = error.slice(29));\n        prevPrepareStackTrace = error.indexOf(\"\\n\");\n        -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));\n        prevPrepareStackTrace = error.indexOf(\"react-stack-bottom-frame\");\n        -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(\"\\n\", prevPrepareStackTrace));\n        if (-1 !== prevPrepareStackTrace) error = error.slice(0, prevPrepareStackTrace);\n        else return \"\";\n        return error;\n    }\n    function describeFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return describeBuiltInComponentFrame(fiber.type);\n            case 16:\n                return describeBuiltInComponentFrame(\"Lazy\");\n            case 13:\n                return describeBuiltInComponentFrame(\"Suspense\");\n            case 19:\n                return describeBuiltInComponentFrame(\"SuspenseList\");\n            case 0:\n            case 15:\n                return describeNativeComponentFrame(fiber.type, !1);\n            case 11:\n                return describeNativeComponentFrame(fiber.type.render, !1);\n            case 1:\n                return describeNativeComponentFrame(fiber.type, !0);\n            case 31:\n                return describeBuiltInComponentFrame(\"Activity\");\n            default:\n                return \"\";\n        }\n    }\n    function getStackByFiberInDevAndProd(workInProgress) {\n        try {\n            var info = \"\";\n            do {\n                info += describeFiber(workInProgress);\n                var debugInfo = workInProgress._debugInfo;\n                if (debugInfo) for(var i = debugInfo.length - 1; 0 <= i; i--){\n                    var entry = debugInfo[i];\n                    if (\"string\" === typeof entry.name) {\n                        var JSCompiler_temp_const = info, env = entry.env;\n                        var JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (env ? \" [\" + env + \"]\" : \"\"));\n                        info = JSCompiler_temp_const + JSCompiler_inline_result;\n                    }\n                }\n                workInProgress = workInProgress.return;\n            }while (workInProgress);\n            return info;\n        } catch (x) {\n            return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n    }\n    function describeFunctionComponentFrameWithoutLineNumber(fn) {\n        return (fn = fn ? fn.displayName || fn.name : \"\") ? describeBuiltInComponentFrame(fn) : \"\";\n    }\n    function getCurrentFiberOwnerNameInDevOrNull() {\n        if (null === current) return null;\n        var owner = current._debugOwner;\n        return null != owner ? getComponentNameFromOwner(owner) : null;\n    }\n    function getCurrentFiberStackInDev() {\n        if (null === current) return \"\";\n        var workInProgress = current;\n        try {\n            var info = \"\";\n            6 === workInProgress.tag && (workInProgress = workInProgress.return);\n            switch(workInProgress.tag){\n                case 26:\n                case 27:\n                case 5:\n                    info += describeBuiltInComponentFrame(workInProgress.type);\n                    break;\n                case 13:\n                    info += describeBuiltInComponentFrame(\"Suspense\");\n                    break;\n                case 19:\n                    info += describeBuiltInComponentFrame(\"SuspenseList\");\n                    break;\n                case 31:\n                    info += describeBuiltInComponentFrame(\"Activity\");\n                    break;\n                case 30:\n                case 0:\n                case 15:\n                case 1:\n                    workInProgress._debugOwner || \"\" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress.type));\n                    break;\n                case 11:\n                    workInProgress._debugOwner || \"\" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress.type.render));\n            }\n            for(; workInProgress;)if (\"number\" === typeof workInProgress.tag) {\n                var fiber = workInProgress;\n                workInProgress = fiber._debugOwner;\n                var debugStack = fiber._debugStack;\n                workInProgress && debugStack && (\"string\" !== typeof debugStack && (fiber._debugStack = debugStack = formatOwnerStack(debugStack)), \"\" !== debugStack && (info += \"\\n\" + debugStack));\n            } else if (null != workInProgress.debugStack) {\n                var ownerStack = workInProgress.debugStack;\n                (workInProgress = workInProgress.owner) && ownerStack && (info += \"\\n\" + formatOwnerStack(ownerStack));\n            } else break;\n            var JSCompiler_inline_result = info;\n        } catch (x) {\n            JSCompiler_inline_result = \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n        return JSCompiler_inline_result;\n    }\n    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {\n        var previousFiber = current;\n        setCurrentFiber(fiber);\n        try {\n            return null !== fiber && fiber._debugTask ? fiber._debugTask.run(callback.bind(null, arg0, arg1, arg2, arg3, arg4)) : callback(arg0, arg1, arg2, arg3, arg4);\n        } finally{\n            setCurrentFiber(previousFiber);\n        }\n        throw Error(\"runWithFiberInDEV should never be called in production. This is a bug in React.\");\n    }\n    function setCurrentFiber(fiber) {\n        ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;\n        isRendering = !1;\n        current = fiber;\n    }\n    function typeName(value) {\n        return \"function\" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n    }\n    function willCoercionThrow(value) {\n        try {\n            return testStringCoercion(value), !1;\n        } catch (e) {\n            return !0;\n        }\n    }\n    function testStringCoercion(value) {\n        return \"\" + value;\n    }\n    function checkAttributeStringCoercion(value, attributeName) {\n        if (willCoercionThrow(value)) return console.error(\"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.\", attributeName, typeName(value)), testStringCoercion(value);\n    }\n    function checkCSSPropertyStringCoercion(value, propName) {\n        if (willCoercionThrow(value)) return console.error(\"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.\", propName, typeName(value)), testStringCoercion(value);\n    }\n    function checkFormFieldValueStringCoercion(value) {\n        if (willCoercionThrow(value)) return console.error(\"Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.\", typeName(value)), testStringCoercion(value);\n    }\n    function injectInternals(internals) {\n        if (\"undefined\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;\n        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook.isDisabled) return !0;\n        if (!hook.supportsFiber) return console.error(\"The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools\"), !0;\n        try {\n            rendererID = hook.inject(internals), injectedHook = hook;\n        } catch (err) {\n            console.error(\"React instrumentation encountered an error: %s.\", err);\n        }\n        return hook.checkDCE ? !0 : !1;\n    }\n    function setIsStrictModeForDevtools(newIsStrictMode) {\n        \"function\" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);\n        if (injectedHook && \"function\" === typeof injectedHook.setStrictMode) try {\n            injectedHook.setStrictMode(rendererID, newIsStrictMode);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function injectProfilingHooks(profilingHooks) {\n        injectedProfilingHooks = profilingHooks;\n    }\n    function markCommitStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();\n    }\n    function markComponentRenderStarted(fiber) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);\n    }\n    function markComponentRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();\n    }\n    function markRenderStarted(lanes) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);\n    }\n    function markRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();\n    }\n    function markStateUpdateScheduled(fiber, lane) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n    }\n    function clz32Fallback(x) {\n        x >>>= 0;\n        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;\n    }\n    function getLabelForLane(lane) {\n        if (lane & 1) return \"SyncHydrationLane\";\n        if (lane & 2) return \"Sync\";\n        if (lane & 4) return \"InputContinuousHydration\";\n        if (lane & 8) return \"InputContinuous\";\n        if (lane & 16) return \"DefaultHydration\";\n        if (lane & 32) return \"Default\";\n        if (lane & 128) return \"TransitionHydration\";\n        if (lane & 4194048) return \"Transition\";\n        if (lane & 62914560) return \"Retry\";\n        if (lane & 67108864) return \"SelectiveHydration\";\n        if (lane & 134217728) return \"IdleHydration\";\n        if (lane & 268435456) return \"Idle\";\n        if (lane & 536870912) return \"Offscreen\";\n        if (lane & 1073741824) return \"Deferred\";\n    }\n    function getHighestPriorityLanes(lanes) {\n        var pendingSyncLanes = lanes & 42;\n        if (0 !== pendingSyncLanes) return pendingSyncLanes;\n        switch(lanes & -lanes){\n            case 1:\n                return 1;\n            case 2:\n                return 2;\n            case 4:\n                return 4;\n            case 8:\n                return 8;\n            case 16:\n                return 16;\n            case 32:\n                return 32;\n            case 64:\n                return 64;\n            case 128:\n                return 128;\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return lanes & 4194048;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return lanes & 62914560;\n            case 67108864:\n                return 67108864;\n            case 134217728:\n                return 134217728;\n            case 268435456:\n                return 268435456;\n            case 536870912:\n                return 536870912;\n            case 1073741824:\n                return 0;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), lanes;\n        }\n    }\n    function getNextLanes(root, wipLanes, rootHasPendingCommit) {\n        var pendingLanes = root.pendingLanes;\n        if (0 === pendingLanes) return 0;\n        var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;\n        root = root.warmLanes;\n        var nonIdlePendingLanes = pendingLanes & 134217727;\n        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));\n        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;\n    }\n    function checkIfRootIsPrerendering(root, renderLanes) {\n        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);\n    }\n    function computeExpirationTime(lane, currentTime) {\n        switch(lane){\n            case 1:\n            case 2:\n            case 4:\n            case 8:\n            case 64:\n                return currentTime + 250;\n            case 16:\n            case 32:\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return currentTime + 5e3;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return -1;\n            case 67108864:\n            case 134217728:\n            case 268435456:\n            case 536870912:\n            case 1073741824:\n                return -1;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), -1;\n        }\n    }\n    function claimNextTransitionLane() {\n        var lane = nextTransitionLane;\n        nextTransitionLane <<= 1;\n        0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);\n        return lane;\n    }\n    function claimNextRetryLane() {\n        var lane = nextRetryLane;\n        nextRetryLane <<= 1;\n        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n        return lane;\n    }\n    function createLaneMap(initial) {\n        for(var laneMap = [], i = 0; 31 > i; i++)laneMap.push(initial);\n        return laneMap;\n    }\n    function markRootUpdated$1(root, updateLane) {\n        root.pendingLanes |= updateLane;\n        268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);\n    }\n    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        var previouslyPendingLanes = root.pendingLanes;\n        root.pendingLanes = remainingLanes;\n        root.suspendedLanes = 0;\n        root.pingedLanes = 0;\n        root.warmLanes = 0;\n        root.expiredLanes &= remainingLanes;\n        root.entangledLanes &= remainingLanes;\n        root.errorRecoveryDisabledLanes &= remainingLanes;\n        root.shellSuspendCounter = 0;\n        var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;\n        for(remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;){\n            var index = 31 - clz32(remainingLanes), lane = 1 << index;\n            entanglements[index] = 0;\n            expirationTimes[index] = -1;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (null !== hiddenUpdatesForLane) for(hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++){\n                var update = hiddenUpdatesForLane[index];\n                null !== update && (update.lane &= -536870913);\n            }\n            remainingLanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n    }\n    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n        root.pendingLanes |= spawnedLane;\n        root.suspendedLanes &= ~spawnedLane;\n        var spawnedLaneIndex = 31 - clz32(spawnedLane);\n        root.entangledLanes |= spawnedLane;\n        root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;\n    }\n    function markRootEntangled(root, entangledLanes) {\n        var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n        for(root = root.entanglements; rootEntangledLanes;){\n            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;\n            lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);\n            rootEntangledLanes &= ~lane;\n        }\n    }\n    function getBumpedLaneForHydrationByLane(lane) {\n        switch(lane){\n            case 2:\n                lane = 1;\n                break;\n            case 8:\n                lane = 4;\n                break;\n            case 32:\n                lane = 16;\n                break;\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                lane = 128;\n                break;\n            case 268435456:\n                lane = 134217728;\n                break;\n            default:\n                lane = 0;\n        }\n        return lane;\n    }\n    function addFiberToLanesMap(root, fiber, lanes) {\n        if (isDevToolsPresent) for(root = root.pendingUpdatersLaneMap; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            root[index].add(fiber);\n            lanes &= ~lane;\n        }\n    }\n    function movePendingFibersToMemoized(root, lanes) {\n        if (isDevToolsPresent) for(var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;){\n            var index = 31 - clz32(lanes);\n            root = 1 << index;\n            index = pendingUpdatersLaneMap[index];\n            0 < index.size && (index.forEach(function(fiber) {\n                var alternate = fiber.alternate;\n                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);\n            }), index.clear());\n            lanes &= ~root;\n        }\n    }\n    function lanesToEventPriority(lanes) {\n        lanes &= -lanes;\n        return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;\n    }\n    function resolveUpdatePriority() {\n        var updatePriority = ReactDOMSharedInternals.p;\n        if (0 !== updatePriority) return updatePriority;\n        updatePriority = window.event;\n        return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);\n    }\n    function runWithPriority(priority, fn) {\n        var previousPriority = ReactDOMSharedInternals.p;\n        try {\n            return ReactDOMSharedInternals.p = priority, fn();\n        } finally{\n            ReactDOMSharedInternals.p = previousPriority;\n        }\n    }\n    function detachDeletedInstance(node) {\n        delete node[internalInstanceKey];\n        delete node[internalPropsKey];\n        delete node[internalEventHandlersKey];\n        delete node[internalEventHandlerListenersKey];\n        delete node[internalEventHandlesSetKey];\n    }\n    function getClosestInstanceFromNode(targetNode) {\n        var targetInst = targetNode[internalInstanceKey];\n        if (targetInst) return targetInst;\n        for(var parentNode = targetNode.parentNode; parentNode;){\n            if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {\n                parentNode = targetInst.alternate;\n                if (null !== targetInst.child || null !== parentNode && null !== parentNode.child) for(targetNode = getParentSuspenseInstance(targetNode); null !== targetNode;){\n                    if (parentNode = targetNode[internalInstanceKey]) return parentNode;\n                    targetNode = getParentSuspenseInstance(targetNode);\n                }\n                return targetInst;\n            }\n            targetNode = parentNode;\n            parentNode = targetNode.parentNode;\n        }\n        return null;\n    }\n    function getInstanceFromNode(node) {\n        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {\n            var tag = node.tag;\n            if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag) return node;\n        }\n        return null;\n    }\n    function getNodeFromInstance(inst) {\n        var tag = inst.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;\n        throw Error(\"getNodeFromInstance: Invalid argument.\");\n    }\n    function getResourcesFromRoot(root) {\n        var resources = root[internalRootNodeResourcesKey];\n        resources || (resources = root[internalRootNodeResourcesKey] = {\n            hoistableStyles: new Map(),\n            hoistableScripts: new Map()\n        });\n        return resources;\n    }\n    function markNodeAsHoistable(node) {\n        node[internalHoistableMarker] = !0;\n    }\n    function registerTwoPhaseEvent(registrationName, dependencies) {\n        registerDirectEvent(registrationName, dependencies);\n        registerDirectEvent(registrationName + \"Capture\", dependencies);\n    }\n    function registerDirectEvent(registrationName, dependencies) {\n        registrationNameDependencies[registrationName] && console.error(\"EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.\", registrationName);\n        registrationNameDependencies[registrationName] = dependencies;\n        var lowerCasedName = registrationName.toLowerCase();\n        possibleRegistrationNames[lowerCasedName] = registrationName;\n        \"onDoubleClick\" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);\n        for(registrationName = 0; registrationName < dependencies.length; registrationName++)allNativeEvents.add(dependencies[registrationName]);\n    }\n    function checkControlledValueProps(tagName, props) {\n        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || (\"select\" === tagName ? console.error(\"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.\") : console.error(\"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\"));\n        props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(\"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\");\n    }\n    function isAttributeNameSafe(attributeName) {\n        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return !0;\n        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;\n        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) return validatedAttributeNameCache[attributeName] = !0;\n        illegalAttributeNameCache[attributeName] = !0;\n        console.error(\"Invalid attribute name: `%s`\", attributeName);\n        return !1;\n    }\n    function getValueForAttributeOnCustomComponent(node, name, expected) {\n        if (isAttributeNameSafe(name)) {\n            if (!node.hasAttribute(name)) {\n                switch(typeof expected){\n                    case \"symbol\":\n                    case \"object\":\n                        return expected;\n                    case \"function\":\n                        return expected;\n                    case \"boolean\":\n                        if (!1 === expected) return expected;\n                }\n                return void 0 === expected ? void 0 : null;\n            }\n            node = node.getAttribute(name);\n            if (\"\" === node && !0 === expected) return !0;\n            checkAttributeStringCoercion(expected, name);\n            return node === \"\" + expected ? expected : node;\n        }\n    }\n    function setValueForAttribute(node, name, value) {\n        if (isAttributeNameSafe(name)) if (null === value) node.removeAttribute(name);\n        else {\n            switch(typeof value){\n                case \"undefined\":\n                case \"function\":\n                case \"symbol\":\n                    node.removeAttribute(name);\n                    return;\n                case \"boolean\":\n                    var prefix = name.toLowerCase().slice(0, 5);\n                    if (\"data-\" !== prefix && \"aria-\" !== prefix) {\n                        node.removeAttribute(name);\n                        return;\n                    }\n            }\n            checkAttributeStringCoercion(value, name);\n            node.setAttribute(name, \"\" + value);\n        }\n    }\n    function setValueForKnownAttribute(node, name, value) {\n        if (null === value) node.removeAttribute(name);\n        else {\n            switch(typeof value){\n                case \"undefined\":\n                case \"function\":\n                case \"symbol\":\n                case \"boolean\":\n                    node.removeAttribute(name);\n                    return;\n            }\n            checkAttributeStringCoercion(value, name);\n            node.setAttribute(name, \"\" + value);\n        }\n    }\n    function setValueForNamespacedAttribute(node, namespace, name, value) {\n        if (null === value) node.removeAttribute(name);\n        else {\n            switch(typeof value){\n                case \"undefined\":\n                case \"function\":\n                case \"symbol\":\n                case \"boolean\":\n                    node.removeAttribute(name);\n                    return;\n            }\n            checkAttributeStringCoercion(value, name);\n            node.setAttributeNS(namespace, name, \"\" + value);\n        }\n    }\n    function getToStringValue(value) {\n        switch(typeof value){\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n            case \"undefined\":\n                return value;\n            case \"object\":\n                return checkFormFieldValueStringCoercion(value), value;\n            default:\n                return \"\";\n        }\n    }\n    function isCheckable(elem) {\n        var type = elem.type;\n        return (elem = elem.nodeName) && \"input\" === elem.toLowerCase() && (\"checkbox\" === type || \"radio\" === type);\n    }\n    function trackValueOnNode(node) {\n        var valueField = isCheckable(node) ? \"checked\" : \"value\", descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n        checkFormFieldValueStringCoercion(node[valueField]);\n        var currentValue = \"\" + node[valueField];\n        if (!node.hasOwnProperty(valueField) && \"undefined\" !== typeof descriptor && \"function\" === typeof descriptor.get && \"function\" === typeof descriptor.set) {\n            var get = descriptor.get, set = descriptor.set;\n            Object.defineProperty(node, valueField, {\n                configurable: !0,\n                get: function() {\n                    return get.call(this);\n                },\n                set: function(value) {\n                    checkFormFieldValueStringCoercion(value);\n                    currentValue = \"\" + value;\n                    set.call(this, value);\n                }\n            });\n            Object.defineProperty(node, valueField, {\n                enumerable: descriptor.enumerable\n            });\n            return {\n                getValue: function() {\n                    return currentValue;\n                },\n                setValue: function(value) {\n                    checkFormFieldValueStringCoercion(value);\n                    currentValue = \"\" + value;\n                },\n                stopTracking: function() {\n                    node._valueTracker = null;\n                    delete node[valueField];\n                }\n            };\n        }\n    }\n    function track(node) {\n        node._valueTracker || (node._valueTracker = trackValueOnNode(node));\n    }\n    function updateValueIfChanged(node) {\n        if (!node) return !1;\n        var tracker = node._valueTracker;\n        if (!tracker) return !0;\n        var lastValue = tracker.getValue();\n        var value = \"\";\n        node && (value = isCheckable(node) ? node.checked ? \"true\" : \"false\" : node.value);\n        node = value;\n        return node !== lastValue ? (tracker.setValue(node), !0) : !1;\n    }\n    function getActiveElement(doc) {\n        doc = doc || (\"undefined\" !== typeof document ? document : void 0);\n        if (\"undefined\" === typeof doc) return null;\n        try {\n            return doc.activeElement || doc.body;\n        } catch (e) {\n            return doc.body;\n        }\n    }\n    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {\n        return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function(ch) {\n            return \"\\\\\" + ch.charCodeAt(0).toString(16) + \" \";\n        });\n    }\n    function validateInputProps(element, props) {\n        void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(\"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\", props.type), didWarnCheckedDefaultChecked = !0);\n        void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(\"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\", props.type), didWarnValueDefaultValue$1 = !0);\n    }\n    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {\n        element.name = \"\";\n        null != type && \"function\" !== typeof type && \"symbol\" !== typeof type && \"boolean\" !== typeof type ? (checkAttributeStringCoercion(type, \"type\"), element.type = type) : element.removeAttribute(\"type\");\n        if (null != value) if (\"number\" === type) {\n            if (0 === value && \"\" === element.value || element.value != value) element.value = \"\" + getToStringValue(value);\n        } else element.value !== \"\" + getToStringValue(value) && (element.value = \"\" + getToStringValue(value));\n        else \"submit\" !== type && \"reset\" !== type || element.removeAttribute(\"value\");\n        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute(\"value\");\n        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);\n        null != checked && (element.checked = checked && \"function\" !== typeof checked && \"symbol\" !== typeof checked);\n        null != name && \"function\" !== typeof name && \"symbol\" !== typeof name && \"boolean\" !== typeof name ? (checkAttributeStringCoercion(name, \"name\"), element.name = \"\" + getToStringValue(name)) : element.removeAttribute(\"name\");\n    }\n    function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating) {\n        null != type && \"function\" !== typeof type && \"symbol\" !== typeof type && \"boolean\" !== typeof type && (checkAttributeStringCoercion(type, \"type\"), element.type = type);\n        if (null != value || null != defaultValue) {\n            if (!(\"submit\" !== type && \"reset\" !== type || void 0 !== value && null !== value)) return;\n            defaultValue = null != defaultValue ? \"\" + getToStringValue(defaultValue) : \"\";\n            value = null != value ? \"\" + getToStringValue(value) : defaultValue;\n            isHydrating || value === element.value || (element.value = value);\n            element.defaultValue = value;\n        }\n        checked = null != checked ? checked : defaultChecked;\n        checked = \"function\" !== typeof checked && \"symbol\" !== typeof checked && !!checked;\n        element.checked = isHydrating ? element.checked : !!checked;\n        element.defaultChecked = !!checked;\n        null != name && \"function\" !== typeof name && \"symbol\" !== typeof name && \"boolean\" !== typeof name && (checkAttributeStringCoercion(name, \"name\"), element.name = name);\n    }\n    function setDefaultValue(node, type, value) {\n        \"number\" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === \"\" + value || (node.defaultValue = \"\" + value);\n    }\n    function validateOptionProps(element, props) {\n        null == props.value && (\"object\" === typeof props.children && null !== props.children ? React.Children.forEach(props.children, function(child) {\n            null == child || \"string\" === typeof child || \"number\" === typeof child || \"bigint\" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = !0, console.error(\"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\"));\n        }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = !0, console.error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\")));\n        null == props.selected || didWarnSelectedSetOnOption || (console.error(\"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\"), didWarnSelectedSetOnOption = !0);\n    }\n    function getDeclarationErrorAddendum() {\n        var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n        return ownerName ? \"\\n\\nCheck the render method of `\" + ownerName + \"`.\" : \"\";\n    }\n    function updateOptions(node, multiple, propValue, setDefaultSelected) {\n        node = node.options;\n        if (multiple) {\n            multiple = {};\n            for(var i = 0; i < propValue.length; i++)multiple[\"$\" + propValue[i]] = !0;\n            for(propValue = 0; propValue < node.length; propValue++)i = multiple.hasOwnProperty(\"$\" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = !0);\n        } else {\n            propValue = \"\" + getToStringValue(propValue);\n            multiple = null;\n            for(i = 0; i < node.length; i++){\n                if (node[i].value === propValue) {\n                    node[i].selected = !0;\n                    setDefaultSelected && (node[i].defaultSelected = !0);\n                    return;\n                }\n                null !== multiple || node[i].disabled || (multiple = node[i]);\n            }\n            null !== multiple && (multiple.selected = !0);\n        }\n    }\n    function validateSelectProps(element, props) {\n        for(element = 0; element < valuePropNames.length; element++){\n            var propName = valuePropNames[element];\n            if (null != props[propName]) {\n                var propNameIsArray = isArrayImpl(props[propName]);\n                props.multiple && !propNameIsArray ? console.error(\"The `%s` prop supplied to <select> must be an array if `multiple` is true.%s\", propName, getDeclarationErrorAddendum()) : !props.multiple && propNameIsArray && console.error(\"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s\", propName, getDeclarationErrorAddendum());\n            }\n        }\n        void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(\"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components\"), didWarnValueDefaultValue = !0);\n    }\n    function validateTextareaProps(element, props) {\n        void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(\"%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\"), didWarnValDefaultVal = !0);\n        null != props.children && null == props.value && console.error(\"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\");\n    }\n    function updateTextarea(element, value, defaultValue) {\n        if (null != value && (value = \"\" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {\n            element.defaultValue !== value && (element.defaultValue = value);\n            return;\n        }\n        element.defaultValue = null != defaultValue ? \"\" + getToStringValue(defaultValue) : \"\";\n    }\n    function initTextarea(element, value, defaultValue, children) {\n        if (null == value) {\n            if (null != children) {\n                if (null != defaultValue) throw Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n                if (isArrayImpl(children)) {\n                    if (1 < children.length) throw Error(\"<textarea> can only have at most one child.\");\n                    children = children[0];\n                }\n                defaultValue = children;\n            }\n            null == defaultValue && (defaultValue = \"\");\n            value = defaultValue;\n        }\n        defaultValue = getToStringValue(value);\n        element.defaultValue = defaultValue;\n        children = element.textContent;\n        children === defaultValue && \"\" !== children && null !== children && (element.value = children);\n    }\n    function findNotableNode(node, indent) {\n        return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;\n    }\n    function indentation(indent) {\n        return \"  \" + \"  \".repeat(indent);\n    }\n    function added(indent) {\n        return \"+ \" + \"  \".repeat(indent);\n    }\n    function removed(indent) {\n        return \"- \" + \"  \".repeat(indent);\n    }\n    function describeFiberType(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return fiber.type;\n            case 16:\n                return \"Lazy\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 0:\n            case 15:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            case 11:\n                return fiber = fiber.type.render, fiber.displayName || fiber.name || null;\n            case 1:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            default:\n                return null;\n        }\n    }\n    function describeTextNode(content, maxLength) {\n        return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{\"...\"}' : \"{\" + content.slice(0, maxLength - 7) + '...\"}' : \"{\" + content + \"}\") : content.length > maxLength ? 5 > maxLength ? '{\"...\"}' : content.slice(0, maxLength - 3) + \"...\" : content;\n    }\n    function describeTextDiff(clientText, serverProps, indent) {\n        var maxLength = 120 - 2 * indent;\n        if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n        if (\"string\" === typeof serverProps) {\n            for(var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);\n            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = \"...\" + clientText.slice(firstDiff - 8), serverProps = \"...\" + serverProps.slice(firstDiff - 8));\n            return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\" + removed(indent) + describeTextNode(serverProps, maxLength) + \"\\n\";\n        }\n        return indentation(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n    }\n    function objectName(object) {\n        return Object.prototype.toString.call(object).replace(/^\\[object (.*)\\]$/, function(m, p0) {\n            return p0;\n        });\n    }\n    function describeValue(value, maxLength) {\n        switch(typeof value){\n            case \"string\":\n                return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '\"...\"' : value.slice(0, maxLength - 4) + '...\"' : value;\n            case \"object\":\n                if (null === value) return \"null\";\n                if (isArrayImpl(value)) return \"[...]\";\n                if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? \"<\" + maxLength + \">\" : \"<...>\";\n                var name = objectName(value);\n                if (\"Object\" === name) {\n                    name = \"\";\n                    maxLength -= 2;\n                    for(var propName in value)if (value.hasOwnProperty(propName)) {\n                        var jsonPropName = JSON.stringify(propName);\n                        jsonPropName !== '\"' + propName + '\"' && (propName = jsonPropName);\n                        maxLength -= propName.length - 2;\n                        jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);\n                        maxLength -= jsonPropName.length;\n                        if (0 > maxLength) {\n                            name += \"\" === name ? \"...\" : \", ...\";\n                            break;\n                        }\n                        name += (\"\" === name ? \"\" : \",\") + propName + \":\" + jsonPropName;\n                    }\n                    return \"{\" + name + \"}\";\n                }\n                return name;\n            case \"function\":\n                return (maxLength = value.displayName || value.name) ? \"function \" + maxLength : \"function\";\n            default:\n                return String(value);\n        }\n    }\n    function describePropValue(value, maxLength) {\n        return \"string\" !== typeof value || needsEscaping.test(value) ? \"{\" + describeValue(value, maxLength - 2) + \"}\" : value.length > maxLength - 2 ? 5 > maxLength ? '\"...\"' : '\"' + value.slice(0, maxLength - 5) + '...\"' : '\"' + value + '\"';\n    }\n    function describeExpandedElement(type, props, rowPrefix) {\n        var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;\n        for(propName in props)if (props.hasOwnProperty(propName) && \"children\" !== propName) {\n            var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);\n            remainingRowLength -= propName.length + propValue.length + 2;\n            properties.push(propName + \"=\" + propValue);\n        }\n        return 0 === properties.length ? rowPrefix + \"<\" + type + \">\\n\" : 0 < remainingRowLength ? rowPrefix + \"<\" + type + \" \" + properties.join(\" \") + \">\\n\" : rowPrefix + \"<\" + type + \"\\n\" + rowPrefix + \"  \" + properties.join(\"\\n\" + rowPrefix + \"  \") + \"\\n\" + rowPrefix + \">\\n\";\n    }\n    function describePropertiesDiff(clientObject, serverObject, indent) {\n        var properties = \"\", remainingServerProperties = assign({}, serverObject), propName;\n        for(propName in clientObject)if (clientObject.hasOwnProperty(propName)) {\n            delete remainingServerProperties[propName];\n            var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);\n            serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\", properties += removed(indent) + propName + \": \" + maxLength + \"\\n\") : properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\";\n        }\n        for(var _propName in remainingServerProperties)remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + \": \" + clientObject + \"\\n\");\n        return properties;\n    }\n    function describeElementDiff(type, clientProps, serverProps, indent) {\n        var content = \"\", serverPropNames = new Map();\n        for(propName$jscomp$0 in serverProps)serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);\n        if (1 === serverPropNames.size && serverPropNames.has(\"children\")) content += describeExpandedElement(type, clientProps, indentation(indent));\n        else {\n            for(var _propName2 in clientProps)if (clientProps.hasOwnProperty(_propName2) && \"children\" !== _propName2) {\n                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                if (void 0 !== serverPropName) {\n                    serverPropNames.delete(_propName2.toLowerCase());\n                    var propName$jscomp$0 = clientProps[_propName2];\n                    serverPropName = serverProps[serverPropName];\n                    var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);\n                    maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);\n                    \"object\" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && \"object\" === typeof serverPropName && null !== serverPropName && \"Object\" === objectName(propName$jscomp$0) && \"Object\" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf(\"...\") || -1 < maxLength$jscomp$0.indexOf(\"...\")) ? content += indentation(indent + 1) + _propName2 + \"={{\\n\" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + \"}}\\n\" : (content += added(indent + 1) + _propName2 + \"=\" + clientPropValue + \"\\n\", content += removed(indent + 1) + _propName2 + \"=\" + maxLength$jscomp$0 + \"\\n\");\n                } else content += indentation(indent + 1) + _propName2 + \"=\" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + \"\\n\";\n            }\n            serverPropNames.forEach(function(propName) {\n                if (\"children\" !== propName) {\n                    var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;\n                    content += removed(indent + 1) + propName + \"=\" + describePropValue(serverProps[propName], maxLength) + \"\\n\";\n                }\n            });\n            content = \"\" === content ? indentation(indent) + \"<\" + type + \">\\n\" : indentation(indent) + \"<\" + type + \"\\n\" + content + indentation(indent) + \">\\n\";\n        }\n        type = serverProps.children;\n        clientProps = clientProps.children;\n        if (\"string\" === typeof type || \"number\" === typeof type || \"bigint\" === typeof type) {\n            serverPropNames = \"\";\n            if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) serverPropNames = \"\" + clientProps;\n            content += describeTextDiff(serverPropNames, \"\" + type, indent + 1);\n        } else if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) content = null == type ? content + describeTextDiff(\"\" + clientProps, null, indent + 1) : content + describeTextDiff(\"\" + clientProps, void 0, indent + 1);\n        return content;\n    }\n    function describeSiblingFiber(fiber, indent) {\n        var type = describeFiberType(fiber);\n        if (null === type) {\n            type = \"\";\n            for(fiber = fiber.child; fiber;)type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;\n            return type;\n        }\n        return indentation(indent) + \"<\" + type + \">\\n\";\n    }\n    function describeNode(node, indent) {\n        var skipToNode = findNotableNode(node, indent);\n        if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + \"...\\n\" + describeNode(skipToNode, indent + 1);\n        skipToNode = \"\";\n        var debugInfo = node.fiber._debugInfo;\n        if (debugInfo) for(var i = 0; i < debugInfo.length; i++){\n            var serverComponentName = debugInfo[i].name;\n            \"string\" === typeof serverComponentName && (skipToNode += indentation(indent) + \"<\" + serverComponentName + \">\\n\", indent++);\n        }\n        debugInfo = \"\";\n        i = node.fiber.pendingProps;\n        if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;\n        else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) if (void 0 === node.serverProps) {\n            debugInfo = indent;\n            var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = \"\";\n            for(propName in i)if (i.hasOwnProperty(propName) && \"children\" !== propName) {\n                var propValue = describePropValue(i[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (0 > maxLength) {\n                    content += \" ...\";\n                    break;\n                }\n                content += \" \" + propName + \"=\" + propValue;\n            }\n            debugInfo = indentation(debugInfo) + \"<\" + serverComponentName + content + \">\\n\";\n            indent++;\n        } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : \"string\" === typeof node.serverProps ? console.error(\"Should not have matched a non HostText fiber to a Text node. This is a bug in React.\") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);\n        var propName = \"\";\n        i = node.fiber.child;\n        for(serverComponentName = 0; i && serverComponentName < node.children.length;)maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;\n        i && 0 < node.children.length && (propName += indentation(indent) + \"...\\n\");\n        i = node.serverTail;\n        null === node.serverProps && indent--;\n        for(node = 0; node < i.length; node++)serverComponentName = i[node], propName = \"string\" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + \"\\n\") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));\n        return skipToNode + debugInfo + propName;\n    }\n    function describeDiff(rootNode) {\n        try {\n            return \"\\n\\n\" + describeNode(rootNode, 0);\n        } catch (x) {\n            return \"\";\n        }\n    }\n    function describeAncestors(ancestor, child, props) {\n        for(var fiber = child, node = null, distanceFromLeaf = 0; fiber;)fiber === ancestor && (distanceFromLeaf = 0), node = {\n            fiber: fiber,\n            children: null !== node ? [\n                node\n            ] : [],\n            serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,\n            serverTail: [],\n            distanceFromLeaf: distanceFromLeaf\n        }, distanceFromLeaf++, fiber = fiber.return;\n        return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, \">\") : \"\";\n    }\n    function updatedAncestorInfoDev(oldInfo, tag) {\n        var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev), info = {\n            tag: tag\n        };\n        -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);\n        -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);\n        -1 !== specialTags.indexOf(tag) && \"address\" !== tag && \"div\" !== tag && \"p\" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);\n        ancestorInfo.current = info;\n        \"form\" === tag && (ancestorInfo.formTag = info);\n        \"a\" === tag && (ancestorInfo.aTagInScope = info);\n        \"button\" === tag && (ancestorInfo.buttonTagInScope = info);\n        \"nobr\" === tag && (ancestorInfo.nobrTagInScope = info);\n        \"p\" === tag && (ancestorInfo.pTagInButtonScope = info);\n        \"li\" === tag && (ancestorInfo.listItemTagAutoclosing = info);\n        if (\"dd\" === tag || \"dt\" === tag) ancestorInfo.dlItemTagAutoclosing = info;\n        \"#document\" === tag || \"html\" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);\n        null !== oldInfo || \"#document\" !== tag && \"html\" !== tag && \"body\" !== tag ? !0 === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = !1) : ancestorInfo.implicitRootScope = !0;\n        return ancestorInfo;\n    }\n    function isTagValidWithParent(tag, parentTag, implicitRootScope) {\n        switch(parentTag){\n            case \"select\":\n                return \"hr\" === tag || \"option\" === tag || \"optgroup\" === tag || \"script\" === tag || \"template\" === tag || \"#text\" === tag;\n            case \"optgroup\":\n                return \"option\" === tag || \"#text\" === tag;\n            case \"option\":\n                return \"#text\" === tag;\n            case \"tr\":\n                return \"th\" === tag || \"td\" === tag || \"style\" === tag || \"script\" === tag || \"template\" === tag;\n            case \"tbody\":\n            case \"thead\":\n            case \"tfoot\":\n                return \"tr\" === tag || \"style\" === tag || \"script\" === tag || \"template\" === tag;\n            case \"colgroup\":\n                return \"col\" === tag || \"template\" === tag;\n            case \"table\":\n                return \"caption\" === tag || \"colgroup\" === tag || \"tbody\" === tag || \"tfoot\" === tag || \"thead\" === tag || \"style\" === tag || \"script\" === tag || \"template\" === tag;\n            case \"head\":\n                return \"base\" === tag || \"basefont\" === tag || \"bgsound\" === tag || \"link\" === tag || \"meta\" === tag || \"title\" === tag || \"noscript\" === tag || \"noframes\" === tag || \"style\" === tag || \"script\" === tag || \"template\" === tag;\n            case \"html\":\n                if (implicitRootScope) break;\n                return \"head\" === tag || \"body\" === tag || \"frameset\" === tag;\n            case \"frameset\":\n                return \"frame\" === tag;\n            case \"#document\":\n                if (!implicitRootScope) return \"html\" === tag;\n        }\n        switch(tag){\n            case \"h1\":\n            case \"h2\":\n            case \"h3\":\n            case \"h4\":\n            case \"h5\":\n            case \"h6\":\n                return \"h1\" !== parentTag && \"h2\" !== parentTag && \"h3\" !== parentTag && \"h4\" !== parentTag && \"h5\" !== parentTag && \"h6\" !== parentTag;\n            case \"rp\":\n            case \"rt\":\n                return -1 === impliedEndTags.indexOf(parentTag);\n            case \"caption\":\n            case \"col\":\n            case \"colgroup\":\n            case \"frameset\":\n            case \"frame\":\n            case \"tbody\":\n            case \"td\":\n            case \"tfoot\":\n            case \"th\":\n            case \"thead\":\n            case \"tr\":\n                return null == parentTag;\n            case \"head\":\n                return implicitRootScope || null === parentTag;\n            case \"html\":\n                return implicitRootScope && \"#document\" === parentTag || null === parentTag;\n            case \"body\":\n                return implicitRootScope && (\"#document\" === parentTag || \"html\" === parentTag) || null === parentTag;\n        }\n        return !0;\n    }\n    function findInvalidAncestorForTag(tag, ancestorInfo) {\n        switch(tag){\n            case \"address\":\n            case \"article\":\n            case \"aside\":\n            case \"blockquote\":\n            case \"center\":\n            case \"details\":\n            case \"dialog\":\n            case \"dir\":\n            case \"div\":\n            case \"dl\":\n            case \"fieldset\":\n            case \"figcaption\":\n            case \"figure\":\n            case \"footer\":\n            case \"header\":\n            case \"hgroup\":\n            case \"main\":\n            case \"menu\":\n            case \"nav\":\n            case \"ol\":\n            case \"p\":\n            case \"section\":\n            case \"summary\":\n            case \"ul\":\n            case \"pre\":\n            case \"listing\":\n            case \"table\":\n            case \"hr\":\n            case \"xmp\":\n            case \"h1\":\n            case \"h2\":\n            case \"h3\":\n            case \"h4\":\n            case \"h5\":\n            case \"h6\":\n                return ancestorInfo.pTagInButtonScope;\n            case \"form\":\n                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n            case \"li\":\n                return ancestorInfo.listItemTagAutoclosing;\n            case \"dd\":\n            case \"dt\":\n                return ancestorInfo.dlItemTagAutoclosing;\n            case \"button\":\n                return ancestorInfo.buttonTagInScope;\n            case \"a\":\n                return ancestorInfo.aTagInScope;\n            case \"nobr\":\n                return ancestorInfo.nobrTagInScope;\n        }\n        return null;\n    }\n    function findAncestor(parent, tagName) {\n        for(; parent;){\n            switch(parent.tag){\n                case 5:\n                case 26:\n                case 27:\n                    if (parent.type === tagName) return parent;\n            }\n            parent = parent.return;\n        }\n        return null;\n    }\n    function validateDOMNesting(childTag, ancestorInfo) {\n        ancestorInfo = ancestorInfo || emptyAncestorInfoDev;\n        var parentInfo = ancestorInfo.current;\n        ancestorInfo = (parentInfo = isTagValidWithParent(childTag, parentInfo && parentInfo.tag, ancestorInfo.implicitRootScope) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n        ancestorInfo = parentInfo || ancestorInfo;\n        if (!ancestorInfo) return !0;\n        var ancestorTag = ancestorInfo.tag;\n        ancestorInfo = String(!!parentInfo) + \"|\" + childTag + \"|\" + ancestorTag;\n        if (didWarn[ancestorInfo]) return !1;\n        didWarn[ancestorInfo] = !0;\n        var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : \"\", tagDisplayName = \"<\" + childTag + \">\";\n        parentInfo ? (parentInfo = \"\", \"table\" === ancestorTag && \"tr\" === childTag && (parentInfo += \" Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.\"), console.error(\"In HTML, %s cannot be a child of <%s>.%s\\nThis will cause a hydration error.%s\", tagDisplayName, ancestorTag, parentInfo, ancestorDescription)) : console.error(\"In HTML, %s cannot be a descendant of <%s>.\\nThis will cause a hydration error.%s\", tagDisplayName, ancestorTag, ancestorDescription);\n        ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {\n            console.error(\"<%s> cannot contain a nested %s.\\nSee this log for the ancestor stack trace.\", ancestorTag, tagDisplayName);\n        }));\n        return !1;\n    }\n    function validateTextNesting(childText, parentTag, implicitRootScope) {\n        if (implicitRootScope || isTagValidWithParent(\"#text\", parentTag, !1)) return !0;\n        implicitRootScope = \"#text|\" + parentTag;\n        if (didWarn[implicitRootScope]) return !1;\n        didWarn[implicitRootScope] = !0;\n        var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;\n        implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(ancestor, implicitRootScope, 6 !== implicitRootScope.tag ? {\n            children: null\n        } : null) : \"\";\n        /\\S/.test(childText) ? console.error(\"In HTML, text nodes cannot be a child of <%s>.\\nThis will cause a hydration error.%s\", parentTag, implicitRootScope) : console.error(\"In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\\nThis will cause a hydration error.%s\", parentTag, implicitRootScope);\n        return !1;\n    }\n    function setTextContent(node, text) {\n        if (text) {\n            var firstChild = node.firstChild;\n            if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {\n                firstChild.nodeValue = text;\n                return;\n            }\n        }\n        node.textContent = text;\n    }\n    function camelize(string) {\n        return string.replace(hyphenPattern, function(_, character) {\n            return character.toUpperCase();\n        });\n    }\n    function setValueForStyle(style, styleName, value) {\n        var isCustomProperty = 0 === styleName.indexOf(\"--\");\n        isCustomProperty || (-1 < styleName.indexOf(\"-\") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = !0, console.error(\"Unsupported style property %s. Did you mean %s?\", styleName, camelize(styleName.replace(msPattern, \"ms-\")))) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = !0, console.error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", styleName, styleName.charAt(0).toUpperCase() + styleName.slice(1))) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = !0, console.error('Style property values shouldn\\'t contain a semicolon. Try \"%s: %s\" instead.', styleName, value.replace(badStyleValueWithSemicolonPattern, \"\"))), \"number\" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = !0, console.error(\"`NaN` is an invalid value for the `%s` css style property.\", styleName)) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = !0, console.error(\"`Infinity` is an invalid value for the `%s` css style property.\", styleName))));\n        null == value || \"boolean\" === typeof value || \"\" === value ? isCustomProperty ? style.setProperty(styleName, \"\") : \"float\" === styleName ? style.cssFloat = \"\" : style[styleName] = \"\" : isCustomProperty ? style.setProperty(styleName, value) : \"number\" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? \"float\" === styleName ? style.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style[styleName] = (\"\" + value).trim()) : style[styleName] = value + \"px\";\n    }\n    function setValueForStyles(node, styles, prevStyles) {\n        if (null != styles && \"object\" !== typeof styles) throw Error(\"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\");\n        styles && Object.freeze(styles);\n        node = node.style;\n        if (null != prevStyles) {\n            if (styles) {\n                var expandedUpdates = {};\n                if (prevStyles) {\n                    for(var key in prevStyles)if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key)) for(var longhands = shorthandToLonghand[key] || [\n                        key\n                    ], i = 0; i < longhands.length; i++)expandedUpdates[longhands[i]] = key;\n                }\n                for(var _key in styles)if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key])) for(key = shorthandToLonghand[_key] || [\n                    _key\n                ], longhands = 0; longhands < key.length; longhands++)expandedUpdates[key[longhands]] = _key;\n                _key = {};\n                for(var key$jscomp$0 in styles)for(key = shorthandToLonghand[key$jscomp$0] || [\n                    key$jscomp$0\n                ], longhands = 0; longhands < key.length; longhands++)_key[key[longhands]] = key$jscomp$0;\n                key$jscomp$0 = {};\n                for(var _key2 in expandedUpdates)if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + \",\" + longhands, !key$jscomp$0[i])) {\n                    key$jscomp$0[i] = !0;\n                    i = console;\n                    var value = styles[key];\n                    i.error.call(i, \"%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.\", null == value || \"boolean\" === typeof value || \"\" === value ? \"Removing\" : \"Updating\", key, longhands);\n                }\n            }\n            for(var styleName in prevStyles)!prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf(\"--\") ? node.setProperty(styleName, \"\") : \"float\" === styleName ? node.cssFloat = \"\" : node[styleName] = \"\");\n            for(var _styleName in styles)_key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);\n        } else for(expandedUpdates in styles)styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);\n    }\n    function isCustomElement(tagName) {\n        if (-1 === tagName.indexOf(\"-\")) return !1;\n        switch(tagName){\n            case \"annotation-xml\":\n            case \"color-profile\":\n            case \"font-face\":\n            case \"font-face-src\":\n            case \"font-face-uri\":\n            case \"font-face-format\":\n            case \"font-face-name\":\n            case \"missing-glyph\":\n                return !1;\n            default:\n                return !0;\n        }\n    }\n    function getAttributeAlias(name) {\n        return aliases.get(name) || name;\n    }\n    function validateProperty$1(tagName, name) {\n        if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) return !0;\n        if (rARIACamel$1.test(name)) {\n            tagName = \"aria-\" + name.slice(4).toLowerCase();\n            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n            if (null == tagName) return console.error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name), warnedProperties$1[name] = !0;\n            if (name !== tagName) return console.error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, tagName), warnedProperties$1[name] = !0;\n        }\n        if (rARIA$1.test(name)) {\n            tagName = name.toLowerCase();\n            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;\n            if (null == tagName) return warnedProperties$1[name] = !0, !1;\n            name !== tagName && (console.error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, tagName), warnedProperties$1[name] = !0);\n        }\n        return !0;\n    }\n    function validateProperties$2(type, props) {\n        var invalidProps = [], key;\n        for(key in props)validateProperty$1(type, key) || invalidProps.push(key);\n        props = invalidProps.map(function(prop) {\n            return \"`\" + prop + \"`\";\n        }).join(\", \");\n        1 === invalidProps.length ? console.error(\"Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\", props, type) : 1 < invalidProps.length && console.error(\"Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props\", props, type);\n    }\n    function validateProperty(tagName, name, value, eventRegistry) {\n        if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) return !0;\n        var lowerCasedName = name.toLowerCase();\n        if (\"onfocusin\" === lowerCasedName || \"onfocusout\" === lowerCasedName) return console.error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\"), warnedProperties[name] = !0;\n        if (\"function\" === typeof value && (\"form\" === tagName && \"action\" === name || \"input\" === tagName && \"formAction\" === name || \"button\" === tagName && \"formAction\" === name)) return !0;\n        if (null != eventRegistry) {\n            tagName = eventRegistry.possibleRegistrationNames;\n            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name)) return !0;\n            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;\n            if (null != eventRegistry) return console.error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, eventRegistry), warnedProperties[name] = !0;\n            if (EVENT_NAME_REGEX.test(name)) return console.error(\"Unknown event handler property `%s`. It will be ignored.\", name), warnedProperties[name] = !0;\n        } else if (EVENT_NAME_REGEX.test(name)) return INVALID_EVENT_NAME_REGEX.test(name) && console.error(\"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\", name), warnedProperties[name] = !0;\n        if (rARIA.test(name) || rARIACamel.test(name)) return !0;\n        if (\"innerhtml\" === lowerCasedName) return console.error(\"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\"), warnedProperties[name] = !0;\n        if (\"aria\" === lowerCasedName) return console.error(\"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\"), warnedProperties[name] = !0;\n        if (\"is\" === lowerCasedName && null !== value && void 0 !== value && \"string\" !== typeof value) return console.error(\"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\", typeof value), warnedProperties[name] = !0;\n        if (\"number\" === typeof value && isNaN(value)) return console.error(\"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\", name), warnedProperties[name] = !0;\n        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name) return console.error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, lowerCasedName), warnedProperties[name] = !0;\n        } else if (name !== lowerCasedName) return console.error(\"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\", name, lowerCasedName), warnedProperties[name] = !0;\n        switch(name){\n            case \"dangerouslySetInnerHTML\":\n            case \"children\":\n            case \"style\":\n            case \"suppressContentEditableWarning\":\n            case \"suppressHydrationWarning\":\n            case \"defaultValue\":\n            case \"defaultChecked\":\n            case \"innerHTML\":\n            case \"ref\":\n                return !0;\n            case \"innerText\":\n            case \"textContent\":\n                return !0;\n        }\n        switch(typeof value){\n            case \"boolean\":\n                switch(name){\n                    case \"autoFocus\":\n                    case \"checked\":\n                    case \"multiple\":\n                    case \"muted\":\n                    case \"selected\":\n                    case \"contentEditable\":\n                    case \"spellCheck\":\n                    case \"draggable\":\n                    case \"value\":\n                    case \"autoReverse\":\n                    case \"externalResourcesRequired\":\n                    case \"focusable\":\n                    case \"preserveAlpha\":\n                    case \"allowFullScreen\":\n                    case \"async\":\n                    case \"autoPlay\":\n                    case \"controls\":\n                    case \"default\":\n                    case \"defer\":\n                    case \"disabled\":\n                    case \"disablePictureInPicture\":\n                    case \"disableRemotePlayback\":\n                    case \"formNoValidate\":\n                    case \"hidden\":\n                    case \"loop\":\n                    case \"noModule\":\n                    case \"noValidate\":\n                    case \"open\":\n                    case \"playsInline\":\n                    case \"readOnly\":\n                    case \"required\":\n                    case \"reversed\":\n                    case \"scoped\":\n                    case \"seamless\":\n                    case \"itemScope\":\n                    case \"capture\":\n                    case \"download\":\n                    case \"inert\":\n                        return !0;\n                    default:\n                        lowerCasedName = name.toLowerCase().slice(0, 5);\n                        if (\"data-\" === lowerCasedName || \"aria-\" === lowerCasedName) return !0;\n                        value ? console.error('Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.', value, name, name, value, name) : console.error('Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);\n                        return warnedProperties[name] = !0;\n                }\n            case \"function\":\n            case \"symbol\":\n                return warnedProperties[name] = !0, !1;\n            case \"string\":\n                if (\"false\" === value || \"true\" === value) {\n                    switch(name){\n                        case \"checked\":\n                        case \"selected\":\n                        case \"multiple\":\n                        case \"muted\":\n                        case \"allowFullScreen\":\n                        case \"async\":\n                        case \"autoPlay\":\n                        case \"controls\":\n                        case \"default\":\n                        case \"defer\":\n                        case \"disabled\":\n                        case \"disablePictureInPicture\":\n                        case \"disableRemotePlayback\":\n                        case \"formNoValidate\":\n                        case \"hidden\":\n                        case \"loop\":\n                        case \"noModule\":\n                        case \"noValidate\":\n                        case \"open\":\n                        case \"playsInline\":\n                        case \"readOnly\":\n                        case \"required\":\n                        case \"reversed\":\n                        case \"scoped\":\n                        case \"seamless\":\n                        case \"itemScope\":\n                        case \"inert\":\n                            break;\n                        default:\n                            return !0;\n                    }\n                    console.error(\"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\", value, name, \"false\" === value ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n                    warnedProperties[name] = !0;\n                }\n        }\n        return !0;\n    }\n    function warnUnknownProperties(type, props, eventRegistry) {\n        var unknownProps = [], key;\n        for(key in props)validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);\n        props = unknownProps.map(function(prop) {\n            return \"`\" + prop + \"`\";\n        }).join(\", \");\n        1 === unknownProps.length ? console.error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior \", props, type) : 1 < unknownProps.length && console.error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior \", props, type);\n    }\n    function sanitizeURL(url) {\n        return isJavaScriptProtocol.test(\"\" + url) ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\" : url;\n    }\n    function getEventTarget(nativeEvent) {\n        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;\n        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);\n        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;\n    }\n    function restoreStateOfTarget(target) {\n        var internalInstance = getInstanceFromNode(target);\n        if (internalInstance && (target = internalInstance.stateNode)) {\n            var props = target[internalPropsKey] || null;\n            a: switch(target = internalInstance.stateNode, internalInstance.type){\n                case \"input\":\n                    updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);\n                    internalInstance = props.name;\n                    if (\"radio\" === props.type && null != internalInstance) {\n                        for(props = target; props.parentNode;)props = props.parentNode;\n                        checkAttributeStringCoercion(internalInstance, \"name\");\n                        props = props.querySelectorAll('input[name=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(\"\" + internalInstance) + '\"][type=\"radio\"]');\n                        for(internalInstance = 0; internalInstance < props.length; internalInstance++){\n                            var otherNode = props[internalInstance];\n                            if (otherNode !== target && otherNode.form === target.form) {\n                                var otherProps = otherNode[internalPropsKey] || null;\n                                if (!otherProps) throw Error(\"ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.\");\n                                updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);\n                            }\n                        }\n                        for(internalInstance = 0; internalInstance < props.length; internalInstance++)otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);\n                    }\n                    break a;\n                case \"textarea\":\n                    updateTextarea(target, props.value, props.defaultValue);\n                    break a;\n                case \"select\":\n                    internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, !1);\n            }\n        }\n    }\n    function batchedUpdates$1(fn, a, b) {\n        if (isInsideEventHandler) return fn(a, b);\n        isInsideEventHandler = !0;\n        try {\n            var JSCompiler_inline_result = fn(a);\n            return JSCompiler_inline_result;\n        } finally{\n            if (isInsideEventHandler = !1, null !== restoreTarget || null !== restoreQueue) {\n                if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn)) for(a = 0; a < fn.length; a++)restoreStateOfTarget(fn[a]);\n            }\n        }\n    }\n    function getListener(inst, registrationName) {\n        var stateNode = inst.stateNode;\n        if (null === stateNode) return null;\n        var props = stateNode[internalPropsKey] || null;\n        if (null === props) return null;\n        stateNode = props[registrationName];\n        a: switch(registrationName){\n            case \"onClick\":\n            case \"onClickCapture\":\n            case \"onDoubleClick\":\n            case \"onDoubleClickCapture\":\n            case \"onMouseDown\":\n            case \"onMouseDownCapture\":\n            case \"onMouseMove\":\n            case \"onMouseMoveCapture\":\n            case \"onMouseUp\":\n            case \"onMouseUpCapture\":\n            case \"onMouseEnter\":\n                (props = !props.disabled) || (inst = inst.type, props = !(\"button\" === inst || \"input\" === inst || \"select\" === inst || \"textarea\" === inst));\n                inst = !props;\n                break a;\n            default:\n                inst = !1;\n        }\n        if (inst) return null;\n        if (stateNode && \"function\" !== typeof stateNode) throw Error(\"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof stateNode + \"` type.\");\n        return stateNode;\n    }\n    function getData() {\n        if (fallbackText) return fallbackText;\n        var start, startValue = startText, startLength = startValue.length, end, endValue = \"value\" in root ? root.value : root.textContent, endLength = endValue.length;\n        for(start = 0; start < startLength && startValue[start] === endValue[start]; start++);\n        var minEnd = startLength - start;\n        for(end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);\n        return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);\n    }\n    function getEventCharCode(nativeEvent) {\n        var keyCode = nativeEvent.keyCode;\n        \"charCode\" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;\n        10 === nativeEvent && (nativeEvent = 13);\n        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;\n    }\n    function functionThatReturnsTrue() {\n        return !0;\n    }\n    function functionThatReturnsFalse() {\n        return !1;\n    }\n    function createSyntheticEvent(Interface) {\n        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {\n            this._reactName = reactName;\n            this._targetInst = targetInst;\n            this.type = reactEventType;\n            this.nativeEvent = nativeEvent;\n            this.target = nativeEventTarget;\n            this.currentTarget = null;\n            for(var propName in Interface)Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);\n            this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : !1 === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;\n            this.isPropagationStopped = functionThatReturnsFalse;\n            return this;\n        }\n        assign(SyntheticBaseEvent.prototype, {\n            preventDefault: function() {\n                this.defaultPrevented = !0;\n                var event = this.nativeEvent;\n                event && (event.preventDefault ? event.preventDefault() : \"unknown\" !== typeof event.returnValue && (event.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue);\n            },\n            stopPropagation: function() {\n                var event = this.nativeEvent;\n                event && (event.stopPropagation ? event.stopPropagation() : \"unknown\" !== typeof event.cancelBubble && (event.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue);\n            },\n            persist: function() {},\n            isPersistent: functionThatReturnsTrue\n        });\n        return SyntheticBaseEvent;\n    }\n    function modifierStateGetter(keyArg) {\n        var nativeEvent = this.nativeEvent;\n        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : !1;\n    }\n    function getEventModifierState() {\n        return modifierStateGetter;\n    }\n    function isFallbackCompositionEnd(domEventName, nativeEvent) {\n        switch(domEventName){\n            case \"keyup\":\n                return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);\n            case \"keydown\":\n                return nativeEvent.keyCode !== START_KEYCODE;\n            case \"keypress\":\n            case \"mousedown\":\n            case \"focusout\":\n                return !0;\n            default:\n                return !1;\n        }\n    }\n    function getDataFromCustomEvent(nativeEvent) {\n        nativeEvent = nativeEvent.detail;\n        return \"object\" === typeof nativeEvent && \"data\" in nativeEvent ? nativeEvent.data : null;\n    }\n    function getNativeBeforeInputChars(domEventName, nativeEvent) {\n        switch(domEventName){\n            case \"compositionend\":\n                return getDataFromCustomEvent(nativeEvent);\n            case \"keypress\":\n                if (nativeEvent.which !== SPACEBAR_CODE) return null;\n                hasSpaceKeypress = !0;\n                return SPACEBAR_CHAR;\n            case \"textInput\":\n                return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;\n            default:\n                return null;\n        }\n    }\n    function getFallbackBeforeInputChars(domEventName, nativeEvent) {\n        if (isComposing) return \"compositionend\" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = !1, domEventName) : null;\n        switch(domEventName){\n            case \"paste\":\n                return null;\n            case \"keypress\":\n                if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {\n                    if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char;\n                    if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);\n                }\n                return null;\n            case \"compositionend\":\n                return useFallbackCompositionData && \"ko\" !== nativeEvent.locale ? null : nativeEvent.data;\n            default:\n                return null;\n        }\n    }\n    function isTextInputElement(elem) {\n        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n        return \"input\" === nodeName ? !!supportedInputTypes[elem.type] : \"textarea\" === nodeName ? !0 : !1;\n    }\n    function isEventSupported(eventNameSuffix) {\n        if (!canUseDOM) return !1;\n        eventNameSuffix = \"on\" + eventNameSuffix;\n        var isSupported = eventNameSuffix in document;\n        isSupported || (isSupported = document.createElement(\"div\"), isSupported.setAttribute(eventNameSuffix, \"return;\"), isSupported = \"function\" === typeof isSupported[eventNameSuffix]);\n        return isSupported;\n    }\n    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {\n        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [\n            target\n        ] : restoreTarget = target;\n        inst = accumulateTwoPhaseListeners(inst, \"onChange\");\n        0 < inst.length && (nativeEvent = new SyntheticEvent(\"onChange\", \"change\", null, nativeEvent, target), dispatchQueue.push({\n            event: nativeEvent,\n            listeners: inst\n        }));\n    }\n    function runEventInBatch(dispatchQueue) {\n        processDispatchQueue(dispatchQueue, 0);\n    }\n    function getInstIfValueChanged(targetInst) {\n        var targetNode = getNodeFromInstance(targetInst);\n        if (updateValueIfChanged(targetNode)) return targetInst;\n    }\n    function getTargetInstForChangeEvent(domEventName, targetInst) {\n        if (\"change\" === domEventName) return targetInst;\n    }\n    function stopWatchingForValueChange() {\n        activeElement$1 && (activeElement$1.detachEvent(\"onpropertychange\", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);\n    }\n    function handlePropertyChange(nativeEvent) {\n        if (\"value\" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {\n            var dispatchQueue = [];\n            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));\n            batchedUpdates$1(runEventInBatch, dispatchQueue);\n        }\n    }\n    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\n        \"focusin\" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent(\"onpropertychange\", handlePropertyChange)) : \"focusout\" === domEventName && stopWatchingForValueChange();\n    }\n    function getTargetInstForInputEventPolyfill(domEventName) {\n        if (\"selectionchange\" === domEventName || \"keyup\" === domEventName || \"keydown\" === domEventName) return getInstIfValueChanged(activeElementInst$1);\n    }\n    function getTargetInstForClickEvent(domEventName, targetInst) {\n        if (\"click\" === domEventName) return getInstIfValueChanged(targetInst);\n    }\n    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\n        if (\"input\" === domEventName || \"change\" === domEventName) return getInstIfValueChanged(targetInst);\n    }\n    function is(x, y) {\n        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    function shallowEqual(objA, objB) {\n        if (objectIs(objA, objB)) return !0;\n        if (\"object\" !== typeof objA || null === objA || \"object\" !== typeof objB || null === objB) return !1;\n        var keysA = Object.keys(objA), keysB = Object.keys(objB);\n        if (keysA.length !== keysB.length) return !1;\n        for(keysB = 0; keysB < keysA.length; keysB++){\n            var currentKey = keysA[keysB];\n            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;\n        }\n        return !0;\n    }\n    function getLeafNode(node) {\n        for(; node && node.firstChild;)node = node.firstChild;\n        return node;\n    }\n    function getNodeForCharacterOffset(root, offset) {\n        var node = getLeafNode(root);\n        root = 0;\n        for(var nodeEnd; node;){\n            if (3 === node.nodeType) {\n                nodeEnd = root + node.textContent.length;\n                if (root <= offset && nodeEnd >= offset) return {\n                    node: node,\n                    offset: offset - root\n                };\n                root = nodeEnd;\n            }\n            a: {\n                for(; node;){\n                    if (node.nextSibling) {\n                        node = node.nextSibling;\n                        break a;\n                    }\n                    node = node.parentNode;\n                }\n                node = void 0;\n            }\n            node = getLeafNode(node);\n        }\n    }\n    function containsNode(outerNode, innerNode) {\n        return outerNode && innerNode ? outerNode === innerNode ? !0 : outerNode && 3 === outerNode.nodeType ? !1 : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : \"contains\" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : !1 : !1;\n    }\n    function getActiveElementDeep(containerInfo) {\n        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;\n        for(var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement;){\n            try {\n                var JSCompiler_inline_result = \"string\" === typeof element.contentWindow.location.href;\n            } catch (err) {\n                JSCompiler_inline_result = !1;\n            }\n            if (JSCompiler_inline_result) containerInfo = element.contentWindow;\n            else break;\n            element = getActiveElement(containerInfo.document);\n        }\n        return element;\n    }\n    function hasSelectionCapabilities(elem) {\n        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n        return nodeName && (\"input\" === nodeName && (\"text\" === elem.type || \"search\" === elem.type || \"tel\" === elem.type || \"url\" === elem.type || \"password\" === elem.type) || \"textarea\" === nodeName || \"true\" === elem.contentEditable);\n    }\n    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\n        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;\n        mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, \"selectionStart\" in doc && hasSelectionCapabilities(doc) ? doc = {\n            start: doc.selectionStart,\n            end: doc.selectionEnd\n        } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {\n            anchorNode: doc.anchorNode,\n            anchorOffset: doc.anchorOffset,\n            focusNode: doc.focusNode,\n            focusOffset: doc.focusOffset\n        }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, \"onSelect\"), 0 < doc.length && (nativeEvent = new SyntheticEvent(\"onSelect\", \"select\", null, nativeEvent, nativeEventTarget), dispatchQueue.push({\n            event: nativeEvent,\n            listeners: doc\n        }), nativeEvent.target = activeElement)));\n    }\n    function makePrefixMap(styleProp, eventName) {\n        var prefixes = {};\n        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n        prefixes[\"Webkit\" + styleProp] = \"webkit\" + eventName;\n        prefixes[\"Moz\" + styleProp] = \"moz\" + eventName;\n        return prefixes;\n    }\n    function getVendorPrefixedEventName(eventName) {\n        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];\n        if (!vendorPrefixes[eventName]) return eventName;\n        var prefixMap = vendorPrefixes[eventName], styleProp;\n        for(styleProp in prefixMap)if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) return prefixedEventNames[eventName] = prefixMap[styleProp];\n        return eventName;\n    }\n    function registerSimpleEvent(domEventName, reactName) {\n        topLevelEventsToReactNames.set(domEventName, reactName);\n        registerTwoPhaseEvent(reactName, [\n            domEventName\n        ]);\n    }\n    function createCapturedValueAtFiber(value, source) {\n        if (\"object\" === typeof value && null !== value) {\n            var existing = CapturedStacks.get(value);\n            if (void 0 !== existing) return existing;\n            source = {\n                value: value,\n                source: source,\n                stack: getStackByFiberInDevAndProd(source)\n            };\n            CapturedStacks.set(value, source);\n            return source;\n        }\n        return {\n            value: value,\n            source: source,\n            stack: getStackByFiberInDevAndProd(source)\n        };\n    }\n    function finishQueueingConcurrentUpdates() {\n        for(var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;){\n            var fiber = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var queue = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var update = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var lane = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            if (null !== queue && null !== update) {\n                var pending = queue.pending;\n                null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n                queue.pending = update;\n            }\n            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n        }\n    }\n    function enqueueUpdate$1(fiber, queue, update, lane) {\n        concurrentQueues[concurrentQueuesIndex++] = fiber;\n        concurrentQueues[concurrentQueuesIndex++] = queue;\n        concurrentQueues[concurrentQueuesIndex++] = update;\n        concurrentQueues[concurrentQueuesIndex++] = lane;\n        concurrentlyUpdatedLanes |= lane;\n        fiber.lanes |= lane;\n        fiber = fiber.alternate;\n        null !== fiber && (fiber.lanes |= lane);\n    }\n    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n        enqueueUpdate$1(fiber, queue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function enqueueConcurrentRenderForLane(fiber, lane) {\n        enqueueUpdate$1(fiber, null, null, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n        sourceFiber.lanes |= lane;\n        var alternate = sourceFiber.alternate;\n        null !== alternate && (alternate.lanes |= lane);\n        for(var isHidden = !1, parent = sourceFiber.return; null !== parent;)parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = !0)), sourceFiber = parent, parent = parent.return;\n        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [\n            update\n        ] : alternate.push(update), update.lane = lane | 536870912), parent) : null;\n    }\n    function getRootForUpdatedFiber(sourceFiber) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(\"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\");\n        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(\"Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.\"));\n        null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        for(var node = sourceFiber, parent = node.return; null !== parent;)null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;\n        return 3 === node.tag ? node.stateNode : null;\n    }\n    function resolveFunctionForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? type : family.current;\n    }\n    function resolveForwardRefForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? null !== type && void 0 !== type && \"function\" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: family\n        }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;\n    }\n    function isCompatibleFamilyForHotReloading(fiber, element) {\n        if (null === resolveFamily) return !1;\n        var prevType = fiber.elementType;\n        element = element.type;\n        var needsCompareFamilies = !1, $$typeofNextType = \"object\" === typeof element && null !== element ? element.$$typeof : null;\n        switch(fiber.tag){\n            case 1:\n                \"function\" === typeof element && (needsCompareFamilies = !0);\n                break;\n            case 0:\n                \"function\" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 11:\n                $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 14:\n            case 15:\n                $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            default:\n                return !1;\n        }\n        return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;\n    }\n    function markFailedErrorBoundaryForHotReloading(fiber) {\n        null !== resolveFamily && \"function\" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));\n    }\n    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;\n        switch(tag){\n            case 0:\n            case 15:\n            case 1:\n                candidateType = type;\n                break;\n            case 11:\n                candidateType = type.render;\n        }\n        if (null === resolveFamily) throw Error(\"Expected resolveFamily to be set during hot reload.\");\n        var needsRender = !1;\n        type = !1;\n        null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = !0 : updatedFamilies.has(candidateType) && (1 === tag ? type = !0 : needsRender = !0)));\n        null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = !0);\n        type && (fiber._debugNeedsRemount = !0);\n        if (type || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);\n        null === child || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n        null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n    function FiberNode(tag, pendingProps, key, mode) {\n        this.tag = tag;\n        this.key = key;\n        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;\n        this.index = 0;\n        this.refCleanup = this.ref = null;\n        this.pendingProps = pendingProps;\n        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;\n        this.mode = mode;\n        this.subtreeFlags = this.flags = 0;\n        this.deletions = null;\n        this.childLanes = this.lanes = 0;\n        this.alternate = null;\n        this.actualDuration = -0;\n        this.actualStartTime = -1.1;\n        this.treeBaseDuration = this.selfBaseDuration = -0;\n        this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;\n        this._debugNeedsRemount = !1;\n        this._debugHookTypes = null;\n        hasBadMapPolyfill || \"function\" !== typeof Object.preventExtensions || Object.preventExtensions(this);\n    }\n    function shouldConstruct(Component) {\n        Component = Component.prototype;\n        return !(!Component || !Component.isReactComponent);\n    }\n    function createWorkInProgress(current, pendingProps) {\n        var workInProgress = current.alternate;\n        null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugStack = current._debugStack, workInProgress._debugTask = current._debugTask, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);\n        workInProgress.flags = current.flags & 65011712;\n        workInProgress.childLanes = current.childLanes;\n        workInProgress.lanes = current.lanes;\n        workInProgress.child = current.child;\n        workInProgress.memoizedProps = current.memoizedProps;\n        workInProgress.memoizedState = current.memoizedState;\n        workInProgress.updateQueue = current.updateQueue;\n        pendingProps = current.dependencies;\n        workInProgress.dependencies = null === pendingProps ? null : {\n            lanes: pendingProps.lanes,\n            firstContext: pendingProps.firstContext,\n            _debugThenableState: pendingProps._debugThenableState\n        };\n        workInProgress.sibling = current.sibling;\n        workInProgress.index = current.index;\n        workInProgress.ref = current.ref;\n        workInProgress.refCleanup = current.refCleanup;\n        workInProgress.selfBaseDuration = current.selfBaseDuration;\n        workInProgress.treeBaseDuration = current.treeBaseDuration;\n        workInProgress._debugInfo = current._debugInfo;\n        workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n        switch(workInProgress.tag){\n            case 0:\n            case 15:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 1:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 11:\n                workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        }\n        return workInProgress;\n    }\n    function resetWorkInProgress(workInProgress, renderLanes) {\n        workInProgress.flags &= 65011714;\n        var current = workInProgress.alternate;\n        null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {\n            lanes: renderLanes.lanes,\n            firstContext: renderLanes.firstContext,\n            _debugThenableState: renderLanes._debugThenableState\n        }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);\n        return workInProgress;\n    }\n    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n        var fiberTag = 0, resolvedType = type;\n        if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);\n        else if (\"string\" === typeof type) fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : \"html\" === type || \"head\" === type || \"body\" === type ? 27 : 5;\n        else a: switch(type){\n            case REACT_ACTIVITY_TYPE:\n                return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;\n            case REACT_FRAGMENT_TYPE:\n                return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n            case REACT_STRICT_MODE_TYPE:\n                fiberTag = 8;\n                mode |= StrictLegacyMode;\n                mode |= StrictEffectsMode;\n                break;\n            case REACT_PROFILER_TYPE:\n                return type = pendingProps, owner = mode, \"string\" !== typeof type.id && console.error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                }, key;\n            case REACT_SUSPENSE_TYPE:\n                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;\n            case REACT_SUSPENSE_LIST_TYPE:\n                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;\n            default:\n                if (\"object\" === typeof type && null !== type) switch(type.$$typeof){\n                    case REACT_PROVIDER_TYPE:\n                    case REACT_CONTEXT_TYPE:\n                        fiberTag = 10;\n                        break a;\n                    case REACT_CONSUMER_TYPE:\n                        fiberTag = 9;\n                        break a;\n                    case REACT_FORWARD_REF_TYPE:\n                        fiberTag = 11;\n                        resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                        break a;\n                    case REACT_MEMO_TYPE:\n                        fiberTag = 14;\n                        break a;\n                    case REACT_LAZY_TYPE:\n                        fiberTag = 16;\n                        resolvedType = null;\n                        break a;\n                }\n                resolvedType = \"\";\n                if (void 0 === type || \"object\" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n                null === type ? pendingProps = \"null\" : isArrayImpl(type) ? pendingProps = \"array\" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\", resolvedType = \" Did you accidentally export a JSX literal instead of a component?\") : pendingProps = typeof type;\n                (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += \"\\n\\nCheck the render method of `\" + fiberTag + \"`.\");\n                fiberTag = 29;\n                pendingProps = Error(\"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" + (pendingProps + \".\" + resolvedType));\n                resolvedType = null;\n        }\n        key = createFiber(fiberTag, pendingProps, key, mode);\n        key.elementType = type;\n        key.type = resolvedType;\n        key.lanes = lanes;\n        key._debugOwner = owner;\n        return key;\n    }\n    function createFiberFromElement(element, mode, lanes) {\n        mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);\n        mode._debugOwner = element._owner;\n        mode._debugStack = element._debugStack;\n        mode._debugTask = element._debugTask;\n        return mode;\n    }\n    function createFiberFromFragment(elements, mode, lanes, key) {\n        elements = createFiber(7, elements, key, mode);\n        elements.lanes = lanes;\n        return elements;\n    }\n    function createFiberFromText(content, mode, lanes) {\n        content = createFiber(6, content, null, mode);\n        content.lanes = lanes;\n        return content;\n    }\n    function createFiberFromPortal(portal, mode, lanes) {\n        mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);\n        mode.lanes = lanes;\n        mode.stateNode = {\n            containerInfo: portal.containerInfo,\n            pendingChildren: null,\n            implementation: portal.implementation\n        };\n        return mode;\n    }\n    function pushTreeFork(workInProgress, totalChildren) {\n        warnIfNotHydrating();\n        forkStack[forkStackIndex++] = treeForkCount;\n        forkStack[forkStackIndex++] = treeForkProvider;\n        treeForkProvider = workInProgress;\n        treeForkCount = totalChildren;\n    }\n    function pushTreeId(workInProgress, totalChildren, index) {\n        warnIfNotHydrating();\n        idStack[idStackIndex++] = treeContextId;\n        idStack[idStackIndex++] = treeContextOverflow;\n        idStack[idStackIndex++] = treeContextProvider;\n        treeContextProvider = workInProgress;\n        var baseIdWithLeadingBit = treeContextId;\n        workInProgress = treeContextOverflow;\n        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n        baseIdWithLeadingBit &= ~(1 << baseLength);\n        index += 1;\n        var length = 32 - clz32(totalChildren) + baseLength;\n        if (30 < length) {\n            var numberOfOverflowBits = baseLength - baseLength % 5;\n            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);\n            baseIdWithLeadingBit >>= numberOfOverflowBits;\n            baseLength -= numberOfOverflowBits;\n            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;\n            treeContextOverflow = length + workInProgress;\n        } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;\n    }\n    function pushMaterializedTreeId(workInProgress) {\n        warnIfNotHydrating();\n        null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n    }\n    function popTreeContext(workInProgress) {\n        for(; workInProgress === treeForkProvider;)treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;\n        for(; workInProgress === treeContextProvider;)treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;\n    }\n    function warnIfNotHydrating() {\n        isHydrating || console.error(\"Expected to be hydrating. This is a bug in React. Please file an issue.\");\n    }\n    function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n        if (null === fiber.return) {\n            if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {\n                fiber: fiber,\n                children: [],\n                serverProps: void 0,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            else {\n                if (hydrationDiffRootDEV.fiber !== fiber) throw Error(\"Saw multiple hydration diff roots in a pass. This is a bug in React.\");\n                hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);\n            }\n            return hydrationDiffRootDEV;\n        }\n        var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;\n        if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;\n        distanceFromLeaf = {\n            fiber: fiber,\n            children: [],\n            serverProps: void 0,\n            serverTail: [],\n            distanceFromLeaf: distanceFromLeaf\n        };\n        siblings.push(distanceFromLeaf);\n        return distanceFromLeaf;\n    }\n    function warnNonHydratedInstance(fiber, rejectedCandidate) {\n        didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));\n    }\n    function throwOnHydrationMismatch(fiber) {\n        var fromText = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : !1, diff = \"\", diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));\n        queueHydrationError(createCapturedValueAtFiber(Error(\"Hydration failed because the server rendered \" + (fromText ? \"text\" : \"HTML\") + \" didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\nhttps://react.dev/link/hydration-mismatch\" + diff), fiber));\n        throw HydrationMismatchException;\n    }\n    function prepareToHydrateHostInstance(fiber) {\n        var didHydrate = fiber.stateNode;\n        var type = fiber.type, props = fiber.memoizedProps;\n        didHydrate[internalInstanceKey] = fiber;\n        didHydrate[internalPropsKey] = props;\n        validatePropertiesInDevelopment(type, props);\n        switch(type){\n            case \"dialog\":\n                listenToNonDelegatedEvent(\"cancel\", didHydrate);\n                listenToNonDelegatedEvent(\"close\", didHydrate);\n                break;\n            case \"iframe\":\n            case \"object\":\n            case \"embed\":\n                listenToNonDelegatedEvent(\"load\", didHydrate);\n                break;\n            case \"video\":\n            case \"audio\":\n                for(type = 0; type < mediaEventTypes.length; type++)listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);\n                break;\n            case \"source\":\n                listenToNonDelegatedEvent(\"error\", didHydrate);\n                break;\n            case \"img\":\n            case \"image\":\n            case \"link\":\n                listenToNonDelegatedEvent(\"error\", didHydrate);\n                listenToNonDelegatedEvent(\"load\", didHydrate);\n                break;\n            case \"details\":\n                listenToNonDelegatedEvent(\"toggle\", didHydrate);\n                break;\n            case \"input\":\n                checkControlledValueProps(\"input\", props);\n                listenToNonDelegatedEvent(\"invalid\", didHydrate);\n                validateInputProps(didHydrate, props);\n                initInput(didHydrate, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, !0);\n                track(didHydrate);\n                break;\n            case \"option\":\n                validateOptionProps(didHydrate, props);\n                break;\n            case \"select\":\n                checkControlledValueProps(\"select\", props);\n                listenToNonDelegatedEvent(\"invalid\", didHydrate);\n                validateSelectProps(didHydrate, props);\n                break;\n            case \"textarea\":\n                checkControlledValueProps(\"textarea\", props), listenToNonDelegatedEvent(\"invalid\", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(didHydrate, props.value, props.defaultValue, props.children), track(didHydrate);\n        }\n        type = props.children;\n        \"string\" !== typeof type && \"number\" !== typeof type && \"bigint\" !== typeof type || didHydrate.textContent === \"\" + type || !0 === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent(\"beforetoggle\", didHydrate), listenToNonDelegatedEvent(\"toggle\", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent(\"scroll\", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent(\"scrollend\", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = !0) : didHydrate = !1;\n        didHydrate || throwOnHydrationMismatch(fiber, !0);\n    }\n    function popToNextHostParent(fiber) {\n        for(hydrationParentFiber = fiber.return; hydrationParentFiber;)switch(hydrationParentFiber.tag){\n            case 5:\n            case 13:\n                rootOrSingletonContext = !1;\n                return;\n            case 27:\n            case 3:\n                rootOrSingletonContext = !0;\n                return;\n            default:\n                hydrationParentFiber = hydrationParentFiber.return;\n        }\n    }\n    function popHydrationState(fiber) {\n        if (fiber !== hydrationParentFiber) return !1;\n        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;\n        var tag = fiber.tag, JSCompiler_temp;\n        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {\n            if (JSCompiler_temp = 5 === tag) JSCompiler_temp = fiber.type, JSCompiler_temp = !(\"form\" !== JSCompiler_temp && \"button\" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);\n            JSCompiler_temp = !JSCompiler_temp;\n        }\n        if (JSCompiler_temp && nextHydratableInstance) {\n            for(JSCompiler_temp = nextHydratableInstance; JSCompiler_temp;){\n                var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);\n                diffNode.serverTail.push(description);\n                JSCompiler_temp = \"Suspense\" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);\n            }\n            throwOnHydrationMismatch(fiber);\n        }\n        popToNextHostParent(fiber);\n        if (13 === tag) {\n            fiber = fiber.memoizedState;\n            fiber = null !== fiber ? fiber.dehydrated : null;\n            if (!fiber) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);\n        } else 27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;\n        return !0;\n    }\n    function resetHydrationState() {\n        nextHydratableInstance = hydrationParentFiber = null;\n        didSuspendOrErrorDEV = isHydrating = !1;\n    }\n    function upgradeHydrationErrorsToRecoverable() {\n        var queuedErrors = hydrationErrors;\n        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);\n        return queuedErrors;\n    }\n    function queueHydrationError(error) {\n        null === hydrationErrors ? hydrationErrors = [\n            error\n        ] : hydrationErrors.push(error);\n    }\n    function emitPendingHydrationWarnings() {\n        var diffRoot = hydrationDiffRootDEV;\n        if (null !== diffRoot) {\n            hydrationDiffRootDEV = null;\n            for(var diff = describeDiff(diffRoot); 0 < diffRoot.children.length;)diffRoot = diffRoot.children[0];\n            runWithFiberInDEV(diffRoot.fiber, function() {\n                console.error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\n%s%s\", \"https://react.dev/link/hydration-mismatch\", diff);\n            });\n        }\n    }\n    function resetContextDependencies() {\n        lastContextDependency = currentlyRenderingFiber$1 = null;\n        isDisallowedContextReadInDEV = !1;\n    }\n    function pushProvider(providerFiber, context, nextValue) {\n        push(valueCursor, context._currentValue, providerFiber);\n        context._currentValue = nextValue;\n        push(rendererCursorDEV, context._currentRenderer, providerFiber);\n        void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\");\n        context._currentRenderer = rendererSigil;\n    }\n    function popProvider(context, providerFiber) {\n        context._currentValue = valueCursor.current;\n        var currentRenderer = rendererCursorDEV.current;\n        pop(rendererCursorDEV, providerFiber);\n        context._currentRenderer = currentRenderer;\n        pop(valueCursor, providerFiber);\n    }\n    function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n        for(; null !== parent;){\n            var alternate = parent.alternate;\n            (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);\n            if (parent === propagationRoot) break;\n            parent = parent.return;\n        }\n        parent !== propagationRoot && console.error(\"Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {\n        var fiber = workInProgress.child;\n        null !== fiber && (fiber.return = workInProgress);\n        for(; null !== fiber;){\n            var list = fiber.dependencies;\n            if (null !== list) {\n                var nextFiber = fiber.child;\n                list = list.firstContext;\n                a: for(; null !== list;){\n                    var dependency = list;\n                    list = fiber;\n                    for(var i = 0; i < contexts.length; i++)if (dependency.context === contexts[i]) {\n                        list.lanes |= renderLanes;\n                        dependency = list.alternate;\n                        null !== dependency && (dependency.lanes |= renderLanes);\n                        scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);\n                        forcePropagateEntireTree || (nextFiber = null);\n                        break a;\n                    }\n                    list = dependency.next;\n                }\n            } else if (18 === fiber.tag) {\n                nextFiber = fiber.return;\n                if (null === nextFiber) throw Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n                nextFiber.lanes |= renderLanes;\n                list = nextFiber.alternate;\n                null !== list && (list.lanes |= renderLanes);\n                scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n                nextFiber = null;\n            } else nextFiber = fiber.child;\n            if (null !== nextFiber) nextFiber.return = fiber;\n            else for(nextFiber = fiber; null !== nextFiber;){\n                if (nextFiber === workInProgress) {\n                    nextFiber = null;\n                    break;\n                }\n                fiber = nextFiber.sibling;\n                if (null !== fiber) {\n                    fiber.return = nextFiber.return;\n                    nextFiber = fiber;\n                    break;\n                }\n                nextFiber = nextFiber.return;\n            }\n            fiber = nextFiber;\n        }\n    }\n    function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {\n        current = null;\n        for(var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;){\n            if (!isInsidePropagationBailout) {\n                if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n                else if (0 !== (parent.flags & 262144)) break;\n            }\n            if (10 === parent.tag) {\n                var currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent = currentParent.memoizedProps;\n                if (null !== currentParent) {\n                    var context = parent.type;\n                    objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [\n                        context\n                    ]);\n                }\n            } else if (parent === hostTransitionProviderCursor.current) {\n                currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [\n                    HostTransitionContext\n                ]);\n            }\n            parent = parent.return;\n        }\n        null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);\n        workInProgress.flags |= 262144;\n    }\n    function checkIfContextChanged(currentDependencies) {\n        for(currentDependencies = currentDependencies.firstContext; null !== currentDependencies;){\n            if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue)) return !0;\n            currentDependencies = currentDependencies.next;\n        }\n        return !1;\n    }\n    function prepareToReadContext(workInProgress) {\n        currentlyRenderingFiber$1 = workInProgress;\n        lastContextDependency = null;\n        workInProgress = workInProgress.dependencies;\n        null !== workInProgress && (workInProgress.firstContext = null);\n    }\n    function readContext(context) {\n        isDisallowedContextReadInDEV && console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n        return readContextForConsumer(currentlyRenderingFiber$1, context);\n    }\n    function readContextDuringReconciliation(consumer, context) {\n        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);\n        return readContextForConsumer(consumer, context);\n    }\n    function readContextForConsumer(consumer, context) {\n        var value = context._currentValue;\n        context = {\n            context: context,\n            memoizedValue: value,\n            next: null\n        };\n        if (null === lastContextDependency) {\n            if (null === consumer) throw Error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n            lastContextDependency = context;\n            consumer.dependencies = {\n                lanes: 0,\n                firstContext: context,\n                _debugThenableState: null\n            };\n            consumer.flags |= 524288;\n        } else lastContextDependency = lastContextDependency.next = context;\n        return value;\n    }\n    function createCache() {\n        return {\n            controller: new AbortControllerLocal(),\n            data: new Map(),\n            refCount: 0\n        };\n    }\n    function retainCache(cache) {\n        cache.controller.signal.aborted && console.warn(\"A cache instance was retained after it was already freed. This likely indicates a bug in React.\");\n        cache.refCount++;\n    }\n    function releaseCache(cache) {\n        cache.refCount--;\n        0 > cache.refCount && console.warn(\"A cache instance was released after it was already freed. This likely indicates a bug in React.\");\n        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {\n            cache.controller.abort();\n        });\n    }\n    function pushNestedEffectDurations() {\n        var prevEffectDuration = profilerEffectDuration;\n        profilerEffectDuration = 0;\n        return prevEffectDuration;\n    }\n    function popNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration = prevEffectDuration;\n        return elapsedTime;\n    }\n    function bubbleNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration += prevEffectDuration;\n        return elapsedTime;\n    }\n    function pushComponentEffectStart() {\n        var prevEffectStart = componentEffectStartTime;\n        componentEffectStartTime = -1.1;\n        return prevEffectStart;\n    }\n    function popComponentEffectStart(prevEffectStart) {\n        0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);\n    }\n    function startProfilerTimer(fiber) {\n        profilerStartTime = now();\n        0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);\n    }\n    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            fiber.selfBaseDuration = elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function recordEffectDuration() {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            profilerStartTime = -1;\n            profilerEffectDuration += elapsedTime;\n        }\n    }\n    function startEffectTimer() {\n        profilerStartTime = now();\n        0 > componentEffectStartTime && (componentEffectStartTime = profilerStartTime);\n    }\n    function transferActualDuration(fiber) {\n        for(var child = fiber.child; child;)fiber.actualDuration += child.actualDuration, child = child.sibling;\n    }\n    function entangleAsyncAction(transition, thenable) {\n        if (null === currentEntangledListeners) {\n            var entangledListeners = currentEntangledListeners = [];\n            currentEntangledPendingCount = 0;\n            currentEntangledLane = requestTransitionLane();\n            currentEntangledActionThenable = {\n                status: \"pending\",\n                value: void 0,\n                then: function(resolve) {\n                    entangledListeners.push(resolve);\n                }\n            };\n        }\n        currentEntangledPendingCount++;\n        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n        return thenable;\n    }\n    function pingEngtangledActionScope() {\n        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {\n            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = \"fulfilled\");\n            var listeners = currentEntangledListeners;\n            currentEntangledListeners = null;\n            currentEntangledLane = 0;\n            currentEntangledActionThenable = null;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])();\n        }\n    }\n    function chainThenableValue(thenable, result) {\n        var listeners = [], thenableWithOverride = {\n            status: \"pending\",\n            value: null,\n            reason: null,\n            then: function(resolve) {\n                listeners.push(resolve);\n            }\n        };\n        thenable.then(function() {\n            thenableWithOverride.status = \"fulfilled\";\n            thenableWithOverride.value = result;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])(result);\n        }, function(error) {\n            thenableWithOverride.status = \"rejected\";\n            thenableWithOverride.reason = error;\n            for(error = 0; error < listeners.length; error++)(0, listeners[error])(void 0);\n        });\n        return thenableWithOverride;\n    }\n    function peekCacheFromPool() {\n        var cacheResumedFromPreviousRender = resumedCache.current;\n        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;\n    }\n    function pushTransition(offscreenWorkInProgress, prevCachePool) {\n        null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n    }\n    function getSuspendedCache() {\n        var cacheFromPool = peekCacheFromPool();\n        return null === cacheFromPool ? null : {\n            parent: CacheContext._currentValue,\n            pool: cacheFromPool\n        };\n    }\n    function createThenableState() {\n        return {\n            didWarnAboutUncachedPromise: !1,\n            thenables: []\n        };\n    }\n    function isThenableResolved(thenable) {\n        thenable = thenable.status;\n        return \"fulfilled\" === thenable || \"rejected\" === thenable;\n    }\n    function noop$3() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n        null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);\n        var trackedThenables = thenableState.thenables;\n        index = trackedThenables[index];\n        void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error(\"A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.\")), thenable.then(noop$3, noop$3), thenable = index);\n        switch(thenable.status){\n            case \"fulfilled\":\n                return thenable.value;\n            case \"rejected\":\n                throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n            default:\n                if (\"string\" === typeof thenable.status) thenable.then(noop$3, noop$3);\n                else {\n                    thenableState = workInProgressRoot;\n                    if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(\"An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n                    thenableState = thenable;\n                    thenableState.status = \"pending\";\n                    thenableState.then(function(fulfilledValue) {\n                        if (\"pending\" === thenable.status) {\n                            var fulfilledThenable = thenable;\n                            fulfilledThenable.status = \"fulfilled\";\n                            fulfilledThenable.value = fulfilledValue;\n                        }\n                    }, function(error) {\n                        if (\"pending\" === thenable.status) {\n                            var rejectedThenable = thenable;\n                            rejectedThenable.status = \"rejected\";\n                            rejectedThenable.reason = error;\n                        }\n                    });\n                }\n                switch(thenable.status){\n                    case \"fulfilled\":\n                        return thenable.value;\n                    case \"rejected\":\n                        throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n                }\n                suspendedThenable = thenable;\n                needsToResetSuspendedThenableDEV = !0;\n                throw SuspenseException;\n        }\n    }\n    function getSuspendedThenable() {\n        if (null === suspendedThenable) throw Error(\"Expected a suspended thenable. This is a bug in React. Please file an issue.\");\n        var thenable = suspendedThenable;\n        suspendedThenable = null;\n        needsToResetSuspendedThenableDEV = !1;\n        return thenable;\n    }\n    function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException) throw Error(\"Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n    }\n    function pushDebugInfo(debugInfo) {\n        var previousDebugInfo = currentDebugInfo;\n        null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));\n        return previousDebugInfo;\n    }\n    function validateFragmentProps(element, fiber, returnFiber) {\n        for(var keys = Object.keys(element.props), i = 0; i < keys.length; i++){\n            var key = keys[i];\n            if (\"children\" !== key && \"key\" !== key) {\n                null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);\n                runWithFiberInDEV(fiber, function(erroredKey) {\n                    console.error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", erroredKey);\n                }, key);\n                break;\n            }\n        }\n    }\n    function unwrapThenable(thenable) {\n        var index = thenableIndexCounter$1;\n        thenableIndexCounter$1 += 1;\n        null === thenableState$1 && (thenableState$1 = createThenableState());\n        return trackUsedThenable(thenableState$1, thenable, index);\n    }\n    function coerceRef(workInProgress, element) {\n        element = element.props.ref;\n        workInProgress.ref = void 0 !== element ? element : null;\n    }\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\\n- Multiple copies of the \"react\" package is used.\\n- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n- A compiler tries to \"inline\" JSX instead of using the runtime.');\n        returnFiber = Object.prototype.toString.call(newChild);\n        throw Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === returnFiber ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : returnFiber) + \"). If you meant to render a collection of children, use an array instead.\");\n    }\n    function warnOnFunctionType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || \"Component\", 3 === returnFiber.tag ? console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  root.render(%s)\", invalidChild, invalidChild, invalidChild) : console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  <%s>{%s}</%s>\", invalidChild, invalidChild, parentName, invalidChild, parentName));\n    }\n    function warnOnSymbolType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(\"Symbols are not valid as a React child.\\n  root.render(%s)\", invalidChild) : console.error(\"Symbols are not valid as a React child.\\n  <%s>%s</%s>\", parentName, invalidChild, parentName));\n    }\n    function createChildReconciler(shouldTrackSideEffects) {\n        function deleteChild(returnFiber, childToDelete) {\n            if (shouldTrackSideEffects) {\n                var deletions = returnFiber.deletions;\n                null === deletions ? (returnFiber.deletions = [\n                    childToDelete\n                ], returnFiber.flags |= 16) : deletions.push(childToDelete);\n            }\n        }\n        function deleteRemainingChildren(returnFiber, currentFirstChild) {\n            if (!shouldTrackSideEffects) return null;\n            for(; null !== currentFirstChild;)deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return null;\n        }\n        function mapRemainingChildren(currentFirstChild) {\n            for(var existingChildren = new Map(); null !== currentFirstChild;)null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return existingChildren;\n        }\n        function useFiber(fiber, pendingProps) {\n            fiber = createWorkInProgress(fiber, pendingProps);\n            fiber.index = 0;\n            fiber.sibling = null;\n            return fiber;\n        }\n        function placeChild(newFiber, lastPlacedIndex, newIndex) {\n            newFiber.index = newIndex;\n            if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;\n            newIndex = newFiber.alternate;\n            if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;\n            newFiber.flags |= 67108866;\n            return lastPlacedIndex;\n        }\n        function placeSingleChild(newFiber) {\n            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);\n            return newFiber;\n        }\n        function updateTextNode(returnFiber, current, textContent, lanes) {\n            if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugTask = returnFiber._debugTask, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, textContent);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateElement(returnFiber, current, element, lanes) {\n            var elementType = element.type;\n            if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;\n            if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || \"object\" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;\n            current = createFiberFromElement(element, returnFiber.mode, lanes);\n            coerceRef(current, element);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updatePortal(returnFiber, current, portal, lanes) {\n            if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, portal.children || []);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateFragment(returnFiber, current, fragment, lanes, key) {\n            if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugTask = returnFiber._debugTask, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, fragment);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function createChild(returnFiber, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return newChild = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                    case REACT_PORTAL_TYPE:\n                        return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = createChild(returnFiber, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n            var key = null !== oldFiber ? oldFiber.key : null;\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;\n                    case REACT_PORTAL_TYPE:\n                        return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;\n                    case REACT_LAZY_TYPE:\n                        return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) {\n                    if (null !== key) return null;\n                    key = pushDebugInfo(newChild._debugInfo);\n                    returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n                    currentDebugInfo = key;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo7;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {\n            if (\"object\" !== typeof child || null === child) return knownKeys;\n            switch(child.$$typeof){\n                case REACT_ELEMENT_TYPE:\n                case REACT_PORTAL_TYPE:\n                    warnForMissingKey(returnFiber, workInProgress, child);\n                    var key = child.key;\n                    if (\"string\" !== typeof key) break;\n                    if (null === knownKeys) {\n                        knownKeys = new Set();\n                        knownKeys.add(key);\n                        break;\n                    }\n                    if (!knownKeys.has(key)) {\n                        knownKeys.add(key);\n                        break;\n                    }\n                    runWithFiberInDEV(workInProgress, function() {\n                        console.error(\"Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \\u2014 the behavior is unsupported and could change in a future version.\", key);\n                    });\n                    break;\n                case REACT_LAZY_TYPE:\n                    child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);\n            }\n            return knownKeys;\n        }\n        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n            for(var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; newIdx < newChildren.length; newIdx++)oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {\n            if (null == newChildren) throw Error(\"An iterable object provided no iterator.\");\n            for(var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; !step.done; newIdx++, step = newChildren.next())oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {\n            \"object\" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        var prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        a: {\n                            for(var key = newChild.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === key) {\n                                    key = newChild.type;\n                                    if (key === REACT_FRAGMENT_TYPE) {\n                                        if (7 === currentFirstChild.tag) {\n                                            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                            lanes = useFiber(currentFirstChild, newChild.props.children);\n                                            lanes.return = returnFiber;\n                                            lanes._debugOwner = newChild._owner;\n                                            lanes._debugInfo = currentDebugInfo;\n                                            validateFragmentProps(newChild, lanes, returnFiber);\n                                            returnFiber = lanes;\n                                            break a;\n                                        }\n                                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || \"object\" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {\n                                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                        lanes = useFiber(currentFirstChild, newChild.props);\n                                        coerceRef(lanes, newChild);\n                                        lanes.return = returnFiber;\n                                        lanes._debugOwner = newChild._owner;\n                                        lanes._debugInfo = currentDebugInfo;\n                                        returnFiber = lanes;\n                                        break a;\n                                    }\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                } else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);\n                        }\n                        returnFiber = placeSingleChild(returnFiber);\n                        currentDebugInfo = prevDebugInfo;\n                        return returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        a: {\n                            prevDebugInfo = newChild;\n                            for(newChild = prevDebugInfo.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === newChild) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                    lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);\n                                    lanes.return = returnFiber;\n                                    returnFiber = lanes;\n                                    break a;\n                                } else {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                }\n                                else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);\n                            lanes.return = returnFiber;\n                            returnFiber = lanes;\n                        }\n                        return placeSingleChild(returnFiber);\n                    case REACT_LAZY_TYPE:\n                        return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                }\n                if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (getIteratorFn(newChild)) {\n                    prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                    key = getIteratorFn(newChild);\n                    if (\"function\" !== typeof key) throw Error(\"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.\");\n                    var newChildren = key.call(newChild);\n                    if (newChildren === newChild) {\n                        if (0 !== returnFiber.tag || \"[object GeneratorFunction]\" !== Object.prototype.toString.call(returnFiber.type) || \"[object Generator]\" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error(\"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"), didWarnAboutGenerators = !0;\n                    } else newChild.entries !== key || didWarnAboutMaps || (console.error(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"), didWarnAboutMaps = !0);\n                    returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);\n                    currentDebugInfo = prevDebugInfo;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return prevDebugInfo = \"\" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return deleteRemainingChildren(returnFiber, currentFirstChild);\n        }\n        return function(returnFiber, currentFirstChild, newChild, lanes) {\n            var prevDebugInfo = currentDebugInfo;\n            currentDebugInfo = null;\n            try {\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);\n                thenableState$1 = null;\n                return firstChildFiber;\n            } catch (x) {\n                if (x === SuspenseException || x === SuspenseActionException) throw x;\n                var fiber = createFiber(29, x, null, returnFiber.mode);\n                fiber.lanes = lanes;\n                fiber.return = returnFiber;\n                var debugInfo = fiber._debugInfo = currentDebugInfo;\n                fiber._debugOwner = returnFiber._debugOwner;\n                fiber._debugTask = returnFiber._debugTask;\n                if (null != debugInfo) {\n                    for(var i = debugInfo.length - 1; 0 <= i; i--)if (\"string\" === typeof debugInfo[i].stack) {\n                        fiber._debugOwner = debugInfo[i];\n                        fiber._debugTask = debugInfo[i].debugTask;\n                        break;\n                    }\n                }\n                return fiber;\n            } finally{\n                currentDebugInfo = prevDebugInfo;\n            }\n        };\n    }\n    function initializeUpdateQueue(fiber) {\n        fiber.updateQueue = {\n            baseState: fiber.memoizedState,\n            firstBaseUpdate: null,\n            lastBaseUpdate: null,\n            shared: {\n                pending: null,\n                lanes: 0,\n                hiddenCallbacks: null\n            },\n            callbacks: null\n        };\n    }\n    function cloneUpdateQueue(current, workInProgress) {\n        current = current.updateQueue;\n        workInProgress.updateQueue === current && (workInProgress.updateQueue = {\n            baseState: current.baseState,\n            firstBaseUpdate: current.firstBaseUpdate,\n            lastBaseUpdate: current.lastBaseUpdate,\n            shared: current.shared,\n            callbacks: null\n        });\n    }\n    function createUpdate(lane) {\n        return {\n            lane: lane,\n            tag: UpdateState,\n            payload: null,\n            callback: null,\n            next: null\n        };\n    }\n    function enqueueUpdate(fiber, update, lane) {\n        var updateQueue = fiber.updateQueue;\n        if (null === updateQueue) return null;\n        updateQueue = updateQueue.shared;\n        if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {\n            var componentName = getComponentNameFromFiber(fiber);\n            console.error(\"An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\\n\\nPlease update the following component: %s\", componentName);\n            didWarnUpdateInsideUpdate = !0;\n        }\n        if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;\n        enqueueUpdate$1(fiber, updateQueue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function entangleTransitions(root, fiber, lane) {\n        fiber = fiber.updateQueue;\n        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {\n            var queueLanes = fiber.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            fiber.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n        var queue = workInProgress.updateQueue, current = workInProgress.alternate;\n        if (null !== current && (current = current.updateQueue, queue === current)) {\n            var newFirst = null, newLast = null;\n            queue = queue.firstBaseUpdate;\n            if (null !== queue) {\n                do {\n                    var clone = {\n                        lane: queue.lane,\n                        tag: queue.tag,\n                        payload: queue.payload,\n                        callback: null,\n                        next: null\n                    };\n                    null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;\n                    queue = queue.next;\n                }while (null !== queue);\n                null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;\n            } else newFirst = newLast = capturedUpdate;\n            queue = {\n                baseState: current.baseState,\n                firstBaseUpdate: newFirst,\n                lastBaseUpdate: newLast,\n                shared: current.shared,\n                callbacks: current.callbacks\n            };\n            workInProgress.updateQueue = queue;\n            return;\n        }\n        workInProgress = queue.lastBaseUpdate;\n        null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;\n        queue.lastBaseUpdate = capturedUpdate;\n    }\n    function suspendIfUpdateReadFromEntangledAsyncAction() {\n        if (didReadFromEntangledAsyncAction) {\n            var entangledActionThenable = currentEntangledActionThenable;\n            if (null !== entangledActionThenable) throw entangledActionThenable;\n        }\n    }\n    function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {\n        didReadFromEntangledAsyncAction = !1;\n        var queue = workInProgress.updateQueue;\n        hasForceUpdate = !1;\n        currentlyProcessingQueue = queue.shared;\n        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;\n        if (null !== pendingQueue) {\n            queue.shared.pending = null;\n            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;\n            lastPendingUpdate.next = null;\n            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;\n            lastBaseUpdate = lastPendingUpdate;\n            var current = workInProgress.alternate;\n            null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));\n        }\n        if (null !== firstBaseUpdate) {\n            var newState = queue.baseState;\n            lastBaseUpdate = 0;\n            current = firstPendingUpdate = lastPendingUpdate = null;\n            pendingQueue = firstBaseUpdate;\n            do {\n                var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;\n                if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    null !== current && (current = current.next = {\n                        lane: 0,\n                        tag: pendingQueue.tag,\n                        payload: pendingQueue.payload,\n                        callback: null,\n                        next: null\n                    });\n                    a: {\n                        updateLane = workInProgress;\n                        var partialState = pendingQueue;\n                        var nextProps = props, instance = instance$jscomp$0;\n                        switch(partialState.tag){\n                            case ReplaceState:\n                                partialState = partialState.payload;\n                                if (\"function\" === typeof partialState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    var nextState = partialState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & StrictLegacyMode) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            partialState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                    newState = nextState;\n                                    break a;\n                                }\n                                newState = partialState;\n                                break a;\n                            case CaptureUpdate:\n                                updateLane.flags = updateLane.flags & -65537 | 128;\n                            case UpdateState:\n                                nextState = partialState.payload;\n                                if (\"function\" === typeof nextState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    partialState = nextState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & StrictLegacyMode) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            nextState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                } else partialState = nextState;\n                                if (null === partialState || void 0 === partialState) break a;\n                                newState = assign({}, newState, partialState);\n                                break a;\n                            case ForceUpdate:\n                                hasForceUpdate = !0;\n                        }\n                    }\n                    updateLane = pendingQueue.callback;\n                    null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [\n                        updateLane\n                    ] : isHiddenUpdate.push(updateLane));\n                } else isHiddenUpdate = {\n                    lane: updateLane,\n                    tag: pendingQueue.tag,\n                    payload: pendingQueue.payload,\n                    callback: pendingQueue.callback,\n                    next: null\n                }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;\n                pendingQueue = pendingQueue.next;\n                if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;\n                else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;\n            }while (1);\n            null === current && (lastPendingUpdate = newState);\n            queue.baseState = lastPendingUpdate;\n            queue.firstBaseUpdate = firstPendingUpdate;\n            queue.lastBaseUpdate = current;\n            null === firstBaseUpdate && (queue.shared.lanes = 0);\n            workInProgressRootSkippedLanes |= lastBaseUpdate;\n            workInProgress.lanes = lastBaseUpdate;\n            workInProgress.memoizedState = newState;\n        }\n        currentlyProcessingQueue = null;\n    }\n    function callCallback(callback, context) {\n        if (\"function\" !== typeof callback) throw Error(\"Invalid argument passed as callback. Expected a function. Instead received: \" + callback);\n        callback.call(context);\n    }\n    function commitHiddenCallbacks(updateQueue, context) {\n        var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n        if (null !== hiddenCallbacks) for(updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)callCallback(hiddenCallbacks[updateQueue], context);\n    }\n    function commitCallbacks(updateQueue, context) {\n        var callbacks = updateQueue.callbacks;\n        if (null !== callbacks) for(updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)callCallback(callbacks[updateQueue], context);\n    }\n    function pushHiddenContext(fiber, context) {\n        var prevEntangledRenderLanes = entangledRenderLanes;\n        push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, context, fiber);\n        entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;\n    }\n    function reuseHiddenContextOnStack(fiber) {\n        push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n    }\n    function popHiddenContext(fiber) {\n        entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n        pop(currentTreeHiddenStackCursor, fiber);\n        pop(prevEntangledRenderLanesCursor, fiber);\n    }\n    function pushPrimaryTreeSuspenseHandler(handler) {\n        var current = handler.alternate;\n        push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);\n        push(suspenseHandlerStackCursor, handler, handler);\n        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));\n    }\n    function pushOffscreenSuspenseHandler(fiber) {\n        if (22 === fiber.tag) {\n            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {\n                var current = fiber.alternate;\n                null !== current && null !== current.memoizedState && (shellBoundary = fiber);\n            }\n        } else reuseSuspenseHandlerOnStack(fiber);\n    }\n    function reuseSuspenseHandlerOnStack(fiber) {\n        push(suspenseStackCursor, suspenseStackCursor.current, fiber);\n        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);\n    }\n    function popSuspenseHandler(fiber) {\n        pop(suspenseHandlerStackCursor, fiber);\n        shellBoundary === fiber && (shellBoundary = null);\n        pop(suspenseStackCursor, fiber);\n    }\n    function findFirstSuspended(row) {\n        for(var node = row; null !== node;){\n            if (13 === node.tag) {\n                var state = node.memoizedState;\n                if (null !== state && (state = state.dehydrated, null === state || state.data === SUSPENSE_PENDING_START_DATA || isSuspenseInstanceFallback(state))) return node;\n            } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\n                if (0 !== (node.flags & 128)) return node;\n            } else if (null !== node.child) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n            }\n            if (node === row) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === row) return null;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function mountHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        null === hookTypesDev ? hookTypesDev = [\n            hookName\n        ] : hookTypesDev.push(hookName);\n    }\n    function updateHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {\n            var componentName = getComponentNameFromFiber(currentlyRenderingFiber);\n            if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {\n                for(var table = \"\", i = 0; i <= hookTypesUpdateIndexDev; i++){\n                    var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;\n                    for(oldHookName = i + 1 + \". \" + oldHookName; 30 > oldHookName.length;)oldHookName += \" \";\n                    oldHookName += newHookName + \"\\n\";\n                    table += oldHookName;\n                }\n                console.error(\"React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n   Previous render            Next render\\n   ------------------------------------------------------\\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n            }\n        }\n    }\n    function checkDepsAreArrayDev(deps) {\n        void 0 === deps || null === deps || isArrayImpl(deps) || console.error(\"%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n    }\n    function warnOnUseFormStateInDev() {\n        var componentName = getComponentNameFromFiber(currentlyRenderingFiber);\n        didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error(\"ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.\", componentName));\n    }\n    function throwInvalidHookError() {\n        throw Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n    }\n    function areHookInputsEqual(nextDeps, prevDeps) {\n        if (ignorePreviousDependencies) return !1;\n        if (null === prevDeps) return console.error(\"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\", currentHookNameInDev), !1;\n        nextDeps.length !== prevDeps.length && console.error(\"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++)if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n        return !0;\n    }\n    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n        renderLanes = nextRenderLanes;\n        currentlyRenderingFiber = workInProgress;\n        hookTypesDev = null !== current ? current._debugHookTypes : null;\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        if (\"[object AsyncFunction]\" === Object.prototype.toString.call(Component) || \"[object AsyncGeneratorFunction]\" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(\"%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\", null === nextRenderLanes ? \"An unknown Component\" : \"<\" + nextRenderLanes + \">\"));\n        workInProgress.memoizedState = null;\n        workInProgress.updateQueue = null;\n        workInProgress.lanes = 0;\n        ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;\n        shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & StrictLegacyMode) !== NoMode;\n        var children = callComponentInDEV(Component, props, secondArg);\n        shouldDoubleInvokeUserFnsInHooksDEV = !1;\n        didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));\n        if (nextRenderLanes) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        finishRenderingHooks(current, workInProgress);\n        return children;\n    }\n    function finishRenderingHooks(current, workInProgress) {\n        workInProgress._debugHookTypes = hookTypesDev;\n        null === workInProgress.dependencies ? null !== thenableState && (workInProgress.dependencies = {\n            lanes: 0,\n            firstContext: null,\n            _debugThenableState: thenableState\n        }) : workInProgress.dependencies._debugThenableState = thenableState;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n        renderLanes = 0;\n        hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;\n        hookTypesUpdateIndexDev = -1;\n        null !== current && (current.flags & 65011712) !== (workInProgress.flags & 65011712) && console.error(\"Internal React error: Expected static flag was missing. Please notify the React team.\");\n        didScheduleRenderPhaseUpdate = !1;\n        thenableIndexCounter = 0;\n        thenableState = null;\n        if (didRenderTooFewHooks) throw Error(\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\");\n        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));\n        needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;\n        current && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Unknown\", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error(\"`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.\")));\n    }\n    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n        currentlyRenderingFiber = workInProgress;\n        var numberOfReRenders = 0;\n        do {\n            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);\n            thenableIndexCounter = 0;\n            didScheduleRenderPhaseUpdateDuringThisPass = !1;\n            if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error(\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\");\n            numberOfReRenders += 1;\n            ignorePreviousDependencies = !1;\n            workInProgressHook = currentHook = null;\n            if (null != workInProgress.updateQueue) {\n                var children = workInProgress.updateQueue;\n                children.lastEffect = null;\n                children.events = null;\n                children.stores = null;\n                null != children.memoCache && (children.memoCache.index = 0);\n            }\n            hookTypesUpdateIndexDev = -1;\n            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n            children = callComponentInDEV(Component, props, secondArg);\n        }while (didScheduleRenderPhaseUpdateDuringThisPass);\n        return children;\n    }\n    function TransitionAwareHostComponent() {\n        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];\n        maybeThenable = \"function\" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;\n        dispatcher = dispatcher.useState()[0];\n        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);\n        return maybeThenable;\n    }\n    function checkDidRenderIdHook() {\n        var didRenderIdHook = 0 !== localIdCounter;\n        localIdCounter = 0;\n        return didRenderIdHook;\n    }\n    function bailoutHooks(current, workInProgress, lanes) {\n        workInProgress.updateQueue = current.updateQueue;\n        workInProgress.flags = (workInProgress.mode & StrictEffectsMode) !== NoMode ? workInProgress.flags & -402655237 : workInProgress.flags & -2053;\n        current.lanes &= ~lanes;\n    }\n    function resetHooksOnUnwind(workInProgress) {\n        if (didScheduleRenderPhaseUpdate) {\n            for(workInProgress = workInProgress.memoizedState; null !== workInProgress;){\n                var queue = workInProgress.queue;\n                null !== queue && (queue.pending = null);\n                workInProgress = workInProgress.next;\n            }\n            didScheduleRenderPhaseUpdate = !1;\n        }\n        renderLanes = 0;\n        hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;\n        hookTypesUpdateIndexDev = -1;\n        currentHookNameInDev = null;\n        didScheduleRenderPhaseUpdateDuringThisPass = !1;\n        thenableIndexCounter = localIdCounter = 0;\n        thenableState = null;\n    }\n    function mountWorkInProgressHook() {\n        var hook = {\n            memoizedState: null,\n            baseState: null,\n            baseQueue: null,\n            queue: null,\n            next: null\n        };\n        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;\n        return workInProgressHook;\n    }\n    function updateWorkInProgressHook() {\n        if (null === currentHook) {\n            var nextCurrentHook = currentlyRenderingFiber.alternate;\n            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n        } else nextCurrentHook = currentHook.next;\n        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;\n        if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;\n        else {\n            if (null === nextCurrentHook) {\n                if (null === currentlyRenderingFiber.alternate) throw Error(\"Update hook called on initial render. This is likely a bug in React. Please file an issue.\");\n                throw Error(\"Rendered more hooks than during the previous render.\");\n            }\n            currentHook = nextCurrentHook;\n            nextCurrentHook = {\n                memoizedState: currentHook.memoizedState,\n                baseState: currentHook.baseState,\n                baseQueue: currentHook.baseQueue,\n                queue: currentHook.queue,\n                next: null\n            };\n            null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;\n        }\n        return workInProgressHook;\n    }\n    function createFunctionComponentUpdateQueue() {\n        return {\n            lastEffect: null,\n            events: null,\n            stores: null,\n            memoCache: null\n        };\n    }\n    function useThenable(thenable) {\n        var index = thenableIndexCounter;\n        thenableIndexCounter += 1;\n        null === thenableState && (thenableState = createThenableState());\n        thenable = trackUsedThenable(thenableState, thenable, index);\n        index = currentlyRenderingFiber;\n        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);\n        return thenable;\n    }\n    function use(usable) {\n        if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then) return useThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n        }\n        throw Error(\"An unsupported type was passed to use(): \" + String(usable));\n    }\n    function useMemoCache(size) {\n        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;\n        null !== updateQueue && (memoCache = updateQueue.memoCache);\n        if (null == memoCache) {\n            var current = currentlyRenderingFiber.alternate;\n            null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {\n                data: current.data.map(function(array) {\n                    return array.slice();\n                }),\n                index: 0\n            })));\n        }\n        null == memoCache && (memoCache = {\n            data: [],\n            index: 0\n        });\n        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);\n        updateQueue.memoCache = memoCache;\n        updateQueue = memoCache.data[memoCache.index];\n        if (void 0 === updateQueue || ignorePreviousDependencies) for(updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n        else updateQueue.length !== size && console.error(\"Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.\", updateQueue.length, size);\n        memoCache.index++;\n        return updateQueue;\n    }\n    function basicStateReducer(state, action) {\n        return \"function\" === typeof action ? action(state) : action;\n    }\n    function mountReducer(reducer, initialArg, init) {\n        var hook = mountWorkInProgressHook();\n        if (void 0 !== init) {\n            var initialState = init(initialArg);\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    init(initialArg);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        } else initialState = initialArg;\n        hook.memoizedState = hook.baseState = initialState;\n        reducer = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: reducer,\n            lastRenderedState: initialState\n        };\n        hook.queue = reducer;\n        reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);\n        return [\n            hook.memoizedState,\n            reducer\n        ];\n    }\n    function updateReducer(reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateReducerImpl(hook, currentHook, reducer);\n    }\n    function updateReducerImpl(hook, current, reducer) {\n        var queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;\n        if (null !== pendingQueue) {\n            if (null !== baseQueue) {\n                var baseFirst = baseQueue.next;\n                baseQueue.next = pendingQueue.next;\n                pendingQueue.next = baseFirst;\n            }\n            current.baseQueue !== baseQueue && console.error(\"Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.\");\n            current.baseQueue = baseQueue = pendingQueue;\n            queue.pending = null;\n        }\n        pendingQueue = hook.baseState;\n        if (null === baseQueue) hook.memoizedState = pendingQueue;\n        else {\n            current = baseQueue.next;\n            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction = !1;\n            do {\n                var updateLane = update.lane & -536870913;\n                if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    var revertLane = update.revertLane;\n                    if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {\n                        lane: 0,\n                        revertLane: 0,\n                        gesture: null,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    else if ((renderLanes & revertLane) === revertLane) {\n                        update = update.next;\n                        revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                        continue;\n                    } else updateLane = {\n                        lane: 0,\n                        revertLane: update.revertLane,\n                        gesture: null,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;\n                    updateLane = update.action;\n                    shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);\n                    pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);\n                } else revertLane = {\n                    lane: updateLane,\n                    revertLane: update.revertLane,\n                    gesture: update.gesture,\n                    action: update.action,\n                    hasEagerState: update.hasEagerState,\n                    eagerState: update.eagerState,\n                    next: null\n                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;\n                update = update.next;\n            }while (null !== update && update !== current);\n            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;\n            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;\n            hook.memoizedState = pendingQueue;\n            hook.baseState = baseFirst;\n            hook.baseQueue = newBaseQueueLast;\n            queue.lastRenderedState = pendingQueue;\n        }\n        null === baseQueue && (queue.lanes = 0);\n        return [\n            hook.memoizedState,\n            queue.dispatch\n        ];\n    }\n    function rerenderReducer(reducer) {\n        var hook = updateWorkInProgressHook(), queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;\n        if (null !== lastRenderPhaseUpdate) {\n            queue.pending = null;\n            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n            do newState = reducer(newState, update.action), update = update.next;\n            while (update !== lastRenderPhaseUpdate);\n            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n            hook.memoizedState = newState;\n            null === hook.baseQueue && (hook.baseState = newState);\n            queue.lastRenderedState = newState;\n        }\n        return [\n            newState,\n            dispatch\n        ];\n    }\n    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();\n        if (isHydrating) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            var nextSnapshot = getServerSnapshot();\n            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        } else {\n            nextSnapshot = getSnapshot();\n            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0));\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n        }\n        hook.memoizedState = nextSnapshot;\n        getServerSnapshot = {\n            value: nextSnapshot,\n            getSnapshot: getSnapshot\n        };\n        hook.queue = getServerSnapshot;\n        mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [\n            subscribe\n        ]);\n        fiber.flags |= 2048;\n        pushSimpleEffect(HasEffect | Passive, {\n            destroy: void 0\n        }, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), null);\n        return nextSnapshot;\n    }\n    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;\n        if (isHydrating$jscomp$0) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            getServerSnapshot = getServerSnapshot();\n        } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {\n            var cachedSnapshot = getSnapshot();\n            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        }\n        if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;\n        hook = hook.queue;\n        var create = subscribeToStore.bind(null, fiber, hook, subscribe);\n        updateEffectImpl(2048, Passive, create, [\n            subscribe\n        ]);\n        if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {\n            fiber.flags |= 2048;\n            pushSimpleEffect(HasEffect | Passive, {\n                destroy: void 0\n            }, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n        }\n        return getServerSnapshot;\n    }\n    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n        fiber.flags |= 16384;\n        fiber = {\n            getSnapshot: getSnapshot,\n            value: renderedSnapshot\n        };\n        getSnapshot = currentlyRenderingFiber.updateQueue;\n        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [\n            fiber\n        ]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [\n            fiber\n        ] : renderedSnapshot.push(fiber));\n    }\n    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n        inst.value = nextSnapshot;\n        inst.getSnapshot = getSnapshot;\n        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n    }\n    function subscribeToStore(fiber, inst, subscribe) {\n        return subscribe(function() {\n            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n        });\n    }\n    function checkIfSnapshotChanged(inst) {\n        var latestGetSnapshot = inst.getSnapshot;\n        inst = inst.value;\n        try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(inst, nextValue);\n        } catch (error) {\n            return !0;\n        }\n    }\n    function forceStoreRerender(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    }\n    function mountStateImpl(initialState) {\n        var hook = mountWorkInProgressHook();\n        if (\"function\" === typeof initialState) {\n            var initialStateInitializer = initialState;\n            initialState = initialStateInitializer();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    initialStateInitializer();\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        }\n        hook.memoizedState = hook.baseState = initialState;\n        hook.queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: basicStateReducer,\n            lastRenderedState: initialState\n        };\n        return hook;\n    }\n    function mountState(initialState) {\n        initialState = mountStateImpl(initialState);\n        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);\n        queue.dispatch = dispatch;\n        return [\n            initialState.memoizedState,\n            dispatch\n        ];\n    }\n    function mountOptimistic(passthrough) {\n        var hook = mountWorkInProgressHook();\n        hook.memoizedState = hook.baseState = passthrough;\n        var queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: null,\n            lastRenderedState: null\n        };\n        hook.queue = queue;\n        hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !0, queue);\n        queue.dispatch = hook;\n        return [\n            passthrough,\n            hook\n        ];\n    }\n    function updateOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n    }\n    function updateOptimisticImpl(hook, current, passthrough, reducer) {\n        hook.baseState = passthrough;\n        return updateReducerImpl(hook, currentHook, \"function\" === typeof reducer ? reducer : basicStateReducer);\n    }\n    function rerenderOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        hook.baseState = passthrough;\n        return [\n            passthrough,\n            hook.queue.dispatch\n        ];\n    }\n    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n        if (isRenderPhaseUpdate(fiber)) throw Error(\"Cannot update form state while rendering.\");\n        fiber = actionQueue.action;\n        if (null !== fiber) {\n            var actionNode = {\n                payload: payload,\n                action: fiber,\n                next: null,\n                isTransition: !0,\n                status: \"pending\",\n                value: null,\n                reason: null,\n                listeners: [],\n                then: function(listener) {\n                    actionNode.listeners.push(listener);\n                }\n            };\n            null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;\n            setState(actionNode);\n            setPendingState = actionQueue.pending;\n            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);\n        }\n    }\n    function runActionStateAction(actionQueue, node) {\n        var action = node.action, payload = node.payload, prevState = actionQueue.state;\n        if (node.isTransition) {\n            var prevTransition = ReactSharedInternals.T, currentTransition = {};\n            currentTransition._updatedFibers = new Set();\n            ReactSharedInternals.T = currentTransition;\n            try {\n                var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;\n                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n                handleActionReturnValue(actionQueue, node, returnValue);\n            } catch (error) {\n                onActionError(actionQueue, node, error);\n            } finally{\n                null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(\"We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React.\"), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n            }\n        } else try {\n            currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);\n        } catch (error$4) {\n            onActionError(actionQueue, node, error$4);\n        }\n    }\n    function handleActionReturnValue(actionQueue, node, returnValue) {\n        null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then ? (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(function(nextState) {\n            onActionSuccess(actionQueue, node, nextState);\n        }, function(error) {\n            return onActionError(actionQueue, node, error);\n        }), node.isTransition || console.error(\"An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop.\")) : onActionSuccess(actionQueue, node, returnValue);\n    }\n    function onActionSuccess(actionQueue, actionNode, nextState) {\n        actionNode.status = \"fulfilled\";\n        actionNode.value = nextState;\n        notifyActionListeners(actionNode);\n        actionQueue.state = nextState;\n        actionNode = actionQueue.pending;\n        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));\n    }\n    function onActionError(actionQueue, actionNode, error) {\n        var last = actionQueue.pending;\n        actionQueue.pending = null;\n        if (null !== last) {\n            last = last.next;\n            do actionNode.status = \"rejected\", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;\n            while (actionNode !== last);\n        }\n        actionQueue.action = null;\n    }\n    function notifyActionListeners(actionNode) {\n        actionNode = actionNode.listeners;\n        for(var i = 0; i < actionNode.length; i++)(0, actionNode[i])();\n    }\n    function actionStateReducer(oldState, newState) {\n        return newState;\n    }\n    function mountActionState(action, initialStateProp) {\n        if (isHydrating) {\n            var ssrFormState = workInProgressRoot.formState;\n            if (null !== ssrFormState) {\n                a: {\n                    var isMatching = currentlyRenderingFiber;\n                    if (isHydrating) {\n                        if (nextHydratableInstance) {\n                            b: {\n                                var markerInstance = nextHydratableInstance;\n                                for(var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType;){\n                                    if (!inRootOrSingleton) {\n                                        markerInstance = null;\n                                        break b;\n                                    }\n                                    markerInstance = getNextHydratable(markerInstance.nextSibling);\n                                    if (null === markerInstance) {\n                                        markerInstance = null;\n                                        break b;\n                                    }\n                                }\n                                inRootOrSingleton = markerInstance.data;\n                                markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;\n                            }\n                            if (markerInstance) {\n                                nextHydratableInstance = getNextHydratable(markerInstance.nextSibling);\n                                isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;\n                                break a;\n                            }\n                        }\n                        throwOnHydrationMismatch(isMatching);\n                    }\n                    isMatching = !1;\n                }\n                isMatching && (initialStateProp = ssrFormState[0]);\n            }\n        }\n        ssrFormState = mountWorkInProgressHook();\n        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n        isMatching = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: actionStateReducer,\n            lastRenderedState: initialStateProp\n        };\n        ssrFormState.queue = isMatching;\n        ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, isMatching);\n        isMatching.dispatch = ssrFormState;\n        isMatching = mountStateImpl(!1);\n        inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !1, isMatching.queue);\n        isMatching = mountWorkInProgressHook();\n        markerInstance = {\n            state: initialStateProp,\n            dispatch: null,\n            action: action,\n            pending: null\n        };\n        isMatching.queue = markerInstance;\n        ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, markerInstance, inRootOrSingleton, ssrFormState);\n        markerInstance.dispatch = ssrFormState;\n        isMatching.memoizedState = action;\n        return [\n            initialStateProp,\n            ssrFormState,\n            !1\n        ];\n    }\n    function updateActionState(action) {\n        var stateHook = updateWorkInProgressHook();\n        return updateActionStateImpl(stateHook, currentHook, action);\n    }\n    function updateActionStateImpl(stateHook, currentStateHook, action) {\n        currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];\n        stateHook = updateReducer(basicStateReducer)[0];\n        if (\"object\" === typeof currentStateHook && null !== currentStateHook && \"function\" === typeof currentStateHook.then) try {\n            var state = useThenable(currentStateHook);\n        } catch (x) {\n            if (x === SuspenseException) throw SuspenseActionException;\n            throw x;\n        }\n        else state = currentStateHook;\n        currentStateHook = updateWorkInProgressHook();\n        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;\n        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(HasEffect | Passive, {\n            destroy: void 0\n        }, actionStateActionEffect.bind(null, actionQueue, action), null));\n        return [\n            state,\n            dispatch,\n            stateHook\n        ];\n    }\n    function actionStateActionEffect(actionQueue, action) {\n        actionQueue.action = action;\n    }\n    function rerenderActionState(action) {\n        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;\n        if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);\n        updateWorkInProgressHook();\n        stateHook = stateHook.memoizedState;\n        currentStateHook = updateWorkInProgressHook();\n        var dispatch = currentStateHook.queue.dispatch;\n        currentStateHook.memoizedState = action;\n        return [\n            stateHook,\n            dispatch,\n            !1\n        ];\n    }\n    function pushSimpleEffect(tag, inst, create, deps) {\n        tag = {\n            tag: tag,\n            create: create,\n            deps: deps,\n            inst: inst,\n            next: null\n        };\n        inst = currentlyRenderingFiber.updateQueue;\n        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);\n        create = inst.lastEffect;\n        null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);\n        return tag;\n    }\n    function mountRef(initialValue) {\n        var hook = mountWorkInProgressHook();\n        initialValue = {\n            current: initialValue\n        };\n        return hook.memoizedState = initialValue;\n    }\n    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = mountWorkInProgressHook();\n        currentlyRenderingFiber.flags |= fiberFlags;\n        hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, {\n            destroy: void 0\n        }, create, void 0 === deps ? null : deps);\n    }\n    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var inst = hook.memoizedState.inst;\n        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, inst, create, deps));\n    }\n    function mountEffect(create, deps) {\n        (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(276826112, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);\n    }\n    function mountLayoutEffect(create, deps) {\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);\n        return mountEffectImpl(fiberFlags, Layout, create, deps);\n    }\n    function imperativeHandleEffect(create, ref) {\n        if (\"function\" === typeof ref) {\n            create = create();\n            var refCleanup = ref(create);\n            return function() {\n                \"function\" === typeof refCleanup ? refCleanup() : ref(null);\n            };\n        }\n        if (null !== ref && void 0 !== ref) return ref.hasOwnProperty(\"current\") || console.error(\"Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(ref).join(\", \") + \"}\"), create = create(), ref.current = create, function() {\n            ref.current = null;\n        };\n    }\n    function mountImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);\n        mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function updateImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function mountCallback(callback, deps) {\n        mountWorkInProgressHook().memoizedState = [\n            callback,\n            void 0 === deps ? null : deps\n        ];\n        return callback;\n    }\n    function updateCallback(callback, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        hook.memoizedState = [\n            callback,\n            deps\n        ];\n        return callback;\n    }\n    function mountMemo(nextCreate, deps) {\n        var hook = mountWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var nextValue = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            nextValue,\n            deps\n        ];\n        return nextValue;\n    }\n    function updateMemo(nextCreate, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        prevState = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            prevState,\n            deps\n        ];\n        return prevState;\n    }\n    function mountDeferredValue(value, initialValue) {\n        var hook = mountWorkInProgressHook();\n        return mountDeferredValueImpl(hook, value, initialValue);\n    }\n    function updateDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function rerenderDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function mountDeferredValueImpl(hook, value, initialValue) {\n        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;\n        hook.memoizedState = initialValue;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return initialValue;\n    }\n    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n        if (objectIs(value, prevValue)) return value;\n        if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;\n        if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824)) return didReceiveUpdate = !0, hook.memoizedState = value;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return prevValue;\n    }\n    function releaseAsyncTransition() {\n        ReactSharedInternals.asyncTransitions--;\n    }\n    function startTransition(fiber, queue, pendingState, finishedState, callback) {\n        var previousPriority = ReactDOMSharedInternals.p;\n        ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;\n        var prevTransition = ReactSharedInternals.T, currentTransition = {};\n        currentTransition._updatedFibers = new Set();\n        ReactSharedInternals.T = currentTransition;\n        dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n        try {\n            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;\n            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n            if (null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then) {\n                ReactSharedInternals.asyncTransitions++;\n                returnValue.then(releaseAsyncTransition, releaseAsyncTransition);\n                var thenableForFinishedState = chainThenableValue(returnValue, finishedState);\n                dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));\n            } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));\n        } catch (error) {\n            dispatchSetStateInternal(fiber, queue, {\n                then: function() {},\n                status: \"rejected\",\n                reason: error\n            }, requestUpdateLane(fiber));\n        } finally{\n            ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(\"We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React.\"), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n        }\n    }\n    function startHostTransition(formFiber, pendingState, action, formData) {\n        if (5 !== formFiber.tag) throw Error(\"Expected the form instance to be a HostComponent. This is a bug in React.\");\n        var queue = ensureFormComponentIsStateful(formFiber).queue;\n        startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop$2 : function() {\n            requestFormReset$1(formFiber);\n            return action(formData);\n        });\n    }\n    function ensureFormComponentIsStateful(formFiber) {\n        var existingStateHook = formFiber.memoizedState;\n        if (null !== existingStateHook) return existingStateHook;\n        existingStateHook = {\n            memoizedState: NotPendingTransition,\n            baseState: NotPendingTransition,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            },\n            next: null\n        };\n        var initialResetState = {};\n        existingStateHook.next = {\n            memoizedState: initialResetState,\n            baseState: initialResetState,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            },\n            next: null\n        };\n        formFiber.memoizedState = existingStateHook;\n        formFiber = formFiber.alternate;\n        null !== formFiber && (formFiber.memoizedState = existingStateHook);\n        return existingStateHook;\n    }\n    function requestFormReset$1(formFiber) {\n        null === ReactSharedInternals.T && console.error(\"requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.\");\n        var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\n        dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));\n    }\n    function mountTransition() {\n        var stateHook = mountStateImpl(!1);\n        stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, !0, !1);\n        mountWorkInProgressHook().memoizedState = stateHook;\n        return [\n            !1,\n            stateHook\n        ];\n    }\n    function updateTransition() {\n        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function rerenderTransition() {\n        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function useHostTransitionStatus() {\n        return readContext(HostTransitionContext);\n    }\n    function mountId() {\n        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;\n        if (isHydrating) {\n            var treeId = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;\n            identifierPrefix = \"\\u00ab\" + identifierPrefix + \"R\" + treeId;\n            treeId = localIdCounter++;\n            0 < treeId && (identifierPrefix += \"H\" + treeId.toString(32));\n            identifierPrefix += \"\\u00bb\";\n        } else treeId = globalClientIdCounter++, identifierPrefix = \"\\u00ab\" + identifierPrefix + \"r\" + treeId.toString(32) + \"\\u00bb\";\n        return hook.memoizedState = identifierPrefix;\n    }\n    function mountRefresh() {\n        return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber);\n    }\n    function refreshCache(fiber, seedKey) {\n        for(var provider = fiber.return; null !== provider;){\n            switch(provider.tag){\n                case 24:\n                case 3:\n                    var lane = requestUpdateLane(provider);\n                    fiber = createUpdate(lane);\n                    var root = enqueueUpdate(provider, fiber, lane);\n                    null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));\n                    provider = createCache();\n                    null !== seedKey && void 0 !== seedKey && null !== root && console.error(\"The seed argument is not enabled outside experimental channels.\");\n                    fiber.payload = {\n                        cache: provider\n                    };\n                    return;\n            }\n            provider = provider.return;\n        }\n    }\n    function dispatchReducerAction(fiber, queue, action) {\n        var args = arguments;\n        \"function\" === typeof args[3] && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        args = requestUpdateLane(fiber);\n        var update = {\n            lane: args,\n            revertLane: 0,\n            gesture: null,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));\n        markStateUpdateScheduled(fiber, args);\n    }\n    function dispatchSetState(fiber, queue, action) {\n        var args = arguments;\n        \"function\" === typeof args[3] && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        args = requestUpdateLane(fiber);\n        dispatchSetStateInternal(fiber, queue, action, args);\n        markStateUpdateScheduled(fiber, args);\n    }\n    function dispatchSetStateInternal(fiber, queue, action, lane) {\n        var update = {\n            lane: lane,\n            revertLane: 0,\n            gesture: null,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n        else {\n            var alternate = fiber.alternate;\n            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {\n                var prevDispatcher = ReactSharedInternals.H;\n                ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                try {\n                    var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);\n                    update.hasEagerState = !0;\n                    update.eagerState = eagerState;\n                    if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;\n                } catch (error) {} finally{\n                    ReactSharedInternals.H = prevDispatcher;\n                }\n            }\n            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;\n        }\n        return !1;\n    }\n    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n        null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(\"An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.\");\n        action = {\n            lane: 2,\n            revertLane: requestTransitionLane(),\n            gesture: null,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) {\n            if (throwIfDuringRender) throw Error(\"Cannot update optimistic state while rendering.\");\n            console.error(\"Cannot call startTransition while rendering.\");\n        } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\n        markStateUpdateScheduled(fiber, 2);\n    }\n    function isRenderPhaseUpdate(fiber) {\n        var alternate = fiber.alternate;\n        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;\n    }\n    function enqueueRenderPhaseUpdate(queue, update) {\n        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;\n        var pending = queue.pending;\n        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n        queue.pending = update;\n    }\n    function entangleTransitionUpdate(root, queue, lane) {\n        if (0 !== (lane & 4194048)) {\n            var queueLanes = queue.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            queue.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function warnOnInvalidCallback(callback) {\n        if (null !== callback && \"function\" !== typeof callback) {\n            var key = String(callback);\n            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback));\n        }\n    }\n    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n        var prevState = workInProgress.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);\n        if (workInProgress.mode & StrictLegacyMode) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                partialState = getDerivedStateFromProps(nextProps, prevState);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        void 0 === partialState && (ctor = getComponentNameFromType(ctor) || \"Component\", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\", ctor)));\n        prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);\n        workInProgress.memoizedState = prevState;\n        0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);\n    }\n    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n        var instance = workInProgress.stateNode;\n        if (\"function\" === typeof instance.shouldComponentUpdate) {\n            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n            if (workInProgress.mode & StrictLegacyMode) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            void 0 === oldProps && console.error(\"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n            return oldProps;\n        }\n        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;\n    }\n    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n        var oldState = instance.state;\n        \"function\" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);\n        \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n        instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Component\", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error(\"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));\n    }\n    function resolveClassComponentProps(Component, baseProps) {\n        var newProps = baseProps;\n        if (\"ref\" in baseProps) {\n            newProps = {};\n            for(var propName in baseProps)\"ref\" !== propName && (newProps[propName] = baseProps[propName]);\n        }\n        if (Component = Component.defaultProps) {\n            newProps === baseProps && (newProps = assign({}, newProps));\n            for(var _propName in Component)void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);\n        }\n        return newProps;\n    }\n    function defaultOnUncaughtError(error) {\n        reportGlobalError(error);\n        console.warn(\"%s\\n\\n%s\\n\", componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : \"An error occurred in one of your React components.\", \"Consider adding an error boundary to your tree to customize error handling behavior.\\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.\");\n    }\n    function defaultOnCaughtError(error) {\n        var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : \"The above error occurred in one of your React components.\", recreateMessage = \"React will try to recreate this component tree from scratch using the error boundary you provided, \" + ((errorBoundaryName || \"Anonymous\") + \".\");\n        if (\"object\" === typeof error && null !== error && \"string\" === typeof error.environmentName) {\n            var JSCompiler_inline_result = error.environmentName;\n            error = [\n                \"%o\\n\\n%s\\n\\n%s\\n\",\n                error,\n                componentNameMessage,\n                recreateMessage\n            ].slice(0);\n            \"string\" === typeof error[0] ? error.splice(0, 1, badgeFormat + error[0], badgeStyle, pad + JSCompiler_inline_result + pad, resetStyle) : error.splice(0, 0, badgeFormat, badgeStyle, pad + JSCompiler_inline_result + pad, resetStyle);\n            error.unshift(console);\n            JSCompiler_inline_result = bind.apply(console.error, error);\n            JSCompiler_inline_result();\n        } else console.error(\"%o\\n\\n%s\\n\\n%s\\n\", error, componentNameMessage, recreateMessage);\n    }\n    function defaultOnRecoverableError(error) {\n        reportGlobalError(error);\n    }\n    function logUncaughtError(root, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = null;\n            var error = errorInfo.value;\n            if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);\n            else {\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            }\n        } catch (e$5) {\n            setTimeout(function() {\n                throw e$5;\n            });\n        }\n    }\n    function logCaughtError(root, boundary, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = getComponentNameFromFiber(boundary);\n            var onCaughtError = root.onCaughtError;\n            onCaughtError(errorInfo.value, {\n                componentStack: errorInfo.stack,\n                errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n            });\n        } catch (e$6) {\n            setTimeout(function() {\n                throw e$6;\n            });\n        }\n    }\n    function createRootErrorUpdate(root, errorInfo, lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        lane.payload = {\n            element: null\n        };\n        lane.callback = function() {\n            runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);\n        };\n        return lane;\n    }\n    function createClassErrorUpdate(lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        return lane;\n    }\n    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n        if (\"function\" === typeof getDerivedStateFromError) {\n            var error = errorInfo.value;\n            update.payload = function() {\n                return getDerivedStateFromError(error);\n            };\n            update.callback = function() {\n                markFailedErrorBoundaryForHotReloading(fiber);\n                runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            };\n        }\n        var inst = fiber.stateNode;\n        null !== inst && \"function\" === typeof inst.componentDidCatch && (update.callback = function() {\n            markFailedErrorBoundaryForHotReloading(fiber);\n            runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            \"function\" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([\n                this\n            ]) : legacyErrorBoundariesThatAlreadyFailed.add(this));\n            callComponentDidCatchInDEV(this, errorInfo);\n            \"function\" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(\"%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n        });\n    }\n    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n        sourceFiber.flags |= 32768;\n        isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);\n        if (null !== value && \"object\" === typeof value && \"function\" === typeof value.then) {\n            returnFiber = sourceFiber.alternate;\n            null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);\n            isHydrating && (didSuspendOrErrorDEV = !0);\n            sourceFiber = suspenseHandlerStackCursor.current;\n            if (null !== sourceFiber) {\n                switch(sourceFiber.tag){\n                    case 13:\n                        return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([\n                            value\n                        ]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;\n                    case 22:\n                        return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {\n                            transitions: null,\n                            markerInstances: null,\n                            retryQueue: new Set([\n                                value\n                            ])\n                        }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([\n                            value\n                        ]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;\n                }\n                throw Error(\"Unexpected Suspense handler tag (\" + sourceFiber.tag + \"). This is a bug in React.\");\n            }\n            attachPingListener(root, value, rootRenderLanes);\n            renderDidSuspendDelayIfPossible();\n            return !1;\n        }\n        if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.\", {\n            cause: value\n        }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering the entire root.\", {\n            cause: value\n        }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;\n        var error = createCapturedValueAtFiber(Error(\"There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.\", {\n            cause: value\n        }), sourceFiber);\n        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [\n            error\n        ] : workInProgressRootConcurrentErrors.push(error);\n        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);\n        if (null === returnFiber) return !0;\n        value = createCapturedValueAtFiber(value, sourceFiber);\n        sourceFiber = returnFiber;\n        do {\n            switch(sourceFiber.tag){\n                case 3:\n                    return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;\n                case 1:\n                    if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && (\"function\" === typeof returnFiber.getDerivedStateFromError || null !== error && \"function\" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;\n            }\n            sourceFiber = sourceFiber.return;\n        }while (null !== sourceFiber);\n        return !1;\n    }\n    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n        workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n    }\n    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n        Component = Component.render;\n        var ref = workInProgress.ref;\n        if (\"ref\" in nextProps) {\n            var propsWithoutRef = {};\n            for(var key in nextProps)\"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\n        } else propsWithoutRef = nextProps;\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);\n        key = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && key && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null === current) {\n            var type = Component.type;\n            if (\"function\" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);\n            current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n            current.ref = workInProgress.ref;\n            current.return = workInProgress;\n            return workInProgress.child = current;\n        }\n        type = current.child;\n        if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n            var prevProps = type.memoizedProps;\n            Component = Component.compare;\n            Component = null !== Component ? Component : shallowEqual;\n            if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        workInProgress.flags |= 1;\n        current = createWorkInProgress(type, nextProps);\n        current.ref = workInProgress.ref;\n        current.return = workInProgress;\n        return workInProgress.child = current;\n    }\n    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null !== current) {\n            var prevProps = current.memoizedProps;\n            if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n            else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n    }\n    function updateOffscreenComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;\n        if (\"hidden\" === nextProps.mode) {\n            if (0 !== (workInProgress.flags & 128)) {\n                nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n                if (null !== current) {\n                    nextChildren = workInProgress.child = current.child;\n                    for(prevState = 0; null !== nextChildren;)prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;\n                    workInProgress.childLanes = prevState & ~nextProps;\n                } else workInProgress.childLanes = 0, workInProgress.child = null;\n                return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);\n            }\n            if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {\n                baseLanes: 0,\n                cachePool: null\n            }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);\n            else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);\n        } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n        var JSCompiler_inline_result = peekCacheFromPool();\n        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {\n            parent: CacheContext._currentValue,\n            pool: JSCompiler_inline_result\n        };\n        workInProgress.memoizedState = {\n            baseLanes: nextBaseLanes,\n            cachePool: JSCompiler_inline_result\n        };\n        null !== current && pushTransition(workInProgress, null);\n        reuseHiddenContextOnStack(workInProgress);\n        pushOffscreenSuspenseHandler(workInProgress);\n        null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n        return null;\n    }\n    function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n        if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 4194816);\n        else {\n            if (\"function\" !== typeof ref && \"object\" !== typeof ref) throw Error(\"Expected ref to be a function, an object returned by React.createRef(), or undefined/null.\");\n            if (null === current || current.ref !== ref) workInProgress.flags |= 4194816;\n        }\n    }\n    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (Component.prototype && \"function\" === typeof Component.prototype.render) {\n            var componentName = getComponentNameFromType(Component) || \"Unknown\";\n            didWarnAboutBadClass[componentName] || (console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName), didWarnAboutBadClass[componentName] = !0);\n        }\n        workInProgress.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n        null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\", componentName))));\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);\n        nextProps = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, Component, renderLanes);\n        return workInProgress.child;\n    }\n    function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        workInProgress.updateQueue = null;\n        nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);\n        finishRenderingHooks(current, workInProgress);\n        Component = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && Component && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        switch(shouldErrorImpl(workInProgress)){\n            case !1:\n                var _instance = workInProgress.stateNode, state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;\n                _instance.updater.enqueueSetState(_instance, state, null);\n                break;\n            case !0:\n                workInProgress.flags |= 128;\n                workInProgress.flags |= 65536;\n                _instance = Error(\"Simulated error coming from DevTools\");\n                var lane = renderLanes & -renderLanes;\n                workInProgress.lanes |= lane;\n                state = workInProgressRoot;\n                if (null === state) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                lane = createClassErrorUpdate(lane);\n                initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));\n                enqueueCapturedUpdate(workInProgress, lane);\n        }\n        prepareToReadContext(workInProgress);\n        if (null === workInProgress.stateNode) {\n            state = emptyContextObject;\n            _instance = Component.contextType;\n            \"contextType\" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\" : \"object\" !== typeof _instance ? \" However, it is set to a \" + typeof _instance + \".\" : _instance.$$typeof === REACT_CONSUMER_TYPE ? \" Did you accidentally pass the Context.Consumer instead?\" : \" However, it is set to an object with keys {\" + Object.keys(_instance).join(\", \") + \"}.\", console.error(\"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(Component) || \"Component\", lane));\n            \"object\" === typeof _instance && null !== _instance && (state = readContext(_instance));\n            _instance = new Component(nextProps, state);\n            if (workInProgress.mode & StrictLegacyMode) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    _instance = new Component(nextProps, state);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;\n            _instance.updater = classComponentUpdater;\n            workInProgress.stateNode = _instance;\n            _instance._reactInternals = workInProgress;\n            _instance._reactInternalInstance = fakeInternalInstance;\n            \"function\" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(\"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", state, null === _instance.state ? \"null\" : \"undefined\", state)));\n            if (\"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) {\n                var foundWillUpdateName = lane = state = null;\n                \"function\" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = \"componentWillMount\" : \"function\" === typeof _instance.UNSAFE_componentWillMount && (state = \"UNSAFE_componentWillMount\");\n                \"function\" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = \"componentWillReceiveProps\" : \"function\" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = \"UNSAFE_componentWillReceiveProps\");\n                \"function\" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = \"componentWillUpdate\" : \"function\" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n                if (null !== state || null !== lane || null !== foundWillUpdateName) {\n                    _instance = getComponentNameFromType(Component) || \"Component\";\n                    var newApiName = \"function\" === typeof Component.getDerivedStateFromProps ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                    didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\", _instance, newApiName, null !== state ? \"\\n  \" + state : \"\", null !== lane ? \"\\n  \" + lane : \"\", null !== foundWillUpdateName ? \"\\n  \" + foundWillUpdateName : \"\"));\n                }\n            }\n            _instance = workInProgress.stateNode;\n            state = getComponentNameFromType(Component) || \"Component\";\n            _instance.render || (Component.prototype && \"function\" === typeof Component.prototype.render ? console.error(\"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\", state) : console.error(\"No `render` method found on the %s instance: you may have forgotten to define `render`.\", state));\n            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(\"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\", state);\n            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(\"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\", state);\n            _instance.contextType && console.error(\"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\", state);\n            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(\"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\", state));\n            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\", state));\n            \"function\" === typeof _instance.componentShouldUpdate && console.error(\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\", state);\n            Component.prototype && Component.prototype.isPureReactComponent && \"undefined\" !== typeof _instance.shouldComponentUpdate && console.error(\"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(Component) || \"A pure component\");\n            \"function\" === typeof _instance.componentDidUnmount && console.error(\"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\", state);\n            \"function\" === typeof _instance.componentDidReceiveProps && console.error(\"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", state);\n            \"function\" === typeof _instance.componentWillRecieveProps && console.error(\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", state);\n            \"function\" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(\"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", state);\n            lane = _instance.props !== nextProps;\n            void 0 !== _instance.props && lane && console.error(\"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\", state);\n            _instance.defaultProps && console.error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\", state, state);\n            \"function\" !== typeof _instance.getSnapshotBeforeUpdate || \"function\" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(Component)));\n            \"function\" === typeof _instance.getDerivedStateFromProps && console.error(\"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof _instance.getDerivedStateFromError && console.error(\"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof Component.getSnapshotBeforeUpdate && console.error(\"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\", state);\n            (lane = _instance.state) && (\"object\" !== typeof lane || isArrayImpl(lane)) && console.error(\"%s.state: must be set to an object or null\", state);\n            \"function\" === typeof _instance.getChildContext && \"object\" !== typeof Component.childContextTypes && console.error(\"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\", state);\n            _instance = workInProgress.stateNode;\n            _instance.props = nextProps;\n            _instance.state = workInProgress.memoizedState;\n            _instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            state = Component.contextType;\n            _instance.context = \"object\" === typeof state && null !== state ? readContext(state) : emptyContextObject;\n            _instance.state === nextProps && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(\"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\", state)));\n            workInProgress.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);\n            _instance.state = workInProgress.memoizedState;\n            state = Component.getDerivedStateFromProps;\n            \"function\" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (state = _instance.state, \"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(\"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress) || \"Component\"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);\n            (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 134217728);\n            _instance = !0;\n        } else if (null === current) {\n            _instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            lane = resolveClassComponentProps(Component, unresolvedOldProps);\n            _instance.props = lane;\n            var oldContext = _instance.context;\n            foundWillUpdateName = Component.contextType;\n            state = emptyContextObject;\n            \"object\" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));\n            newApiName = Component.getDerivedStateFromProps;\n            foundWillUpdateName = \"function\" === typeof newApiName || \"function\" === typeof _instance.getSnapshotBeforeUpdate;\n            unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n            foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);\n            hasForceUpdate = !1;\n            var oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            oldContext = workInProgress.memoizedState;\n            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (\"function\" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (\"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 134217728)) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 134217728), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 134217728), _instance = !1);\n        } else {\n            _instance = workInProgress.stateNode;\n            cloneUpdateQueue(current, workInProgress);\n            state = workInProgress.memoizedProps;\n            foundWillUpdateName = resolveClassComponentProps(Component, state);\n            _instance.props = foundWillUpdateName;\n            newApiName = workInProgress.pendingProps;\n            oldState = _instance.context;\n            oldContext = Component.contextType;\n            lane = emptyContextObject;\n            \"object\" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));\n            unresolvedOldProps = Component.getDerivedStateFromProps;\n            (oldContext = \"function\" === typeof unresolvedOldProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);\n            hasForceUpdate = !1;\n            oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            var newState = workInProgress.memoizedState;\n            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? (\"function\" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || \"function\" !== typeof _instance.UNSAFE_componentWillUpdate && \"function\" !== typeof _instance.componentWillUpdate || (\"function\" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), \"function\" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), \"function\" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), \"function\" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : (\"function\" !== typeof _instance.componentDidUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (\"function\" !== typeof _instance.componentDidUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), _instance = !1);\n        }\n        lane = _instance;\n        markRef(current, workInProgress);\n        state = 0 !== (workInProgress.flags & 128);\n        if (lane || state) {\n            lane = workInProgress.stateNode;\n            setCurrentFiber(workInProgress);\n            if (state && \"function\" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;\n            else {\n                markComponentRenderStarted(workInProgress);\n                Component = callRenderInDEV(lane);\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(!0);\n                    try {\n                        callRenderInDEV(lane);\n                    } finally{\n                        setIsStrictModeForDevtools(!1);\n                    }\n                }\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= 1;\n            null !== current && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current, workInProgress, Component, renderLanes);\n            workInProgress.memoizedState = lane.state;\n            current = workInProgress.child;\n        } else current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        renderLanes = workInProgress.stateNode;\n        _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error(\"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress) || \"a component\"), didWarnAboutReassigningProps = !0);\n        return current;\n    }\n    function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n        resetHydrationState();\n        workInProgress.flags |= 256;\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function validateFunctionComponentInDev(workInProgress, Component) {\n        Component && Component.childContextTypes && console.error(\"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\", Component.displayName || Component.name || \"Component\");\n        \"function\" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error(\"%s: Function components do not support getDerivedStateFromProps.\", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));\n        \"object\" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(\"%s: Function components do not support contextType.\", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));\n    }\n    function mountSuspenseOffscreenState(renderLanes) {\n        return {\n            baseLanes: renderLanes,\n            cachePool: getSuspendedCache()\n        };\n    }\n    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n        current = null !== current ? current.childLanes & ~renderLanes : 0;\n        primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n        return current;\n    }\n    function updateSuspenseComponent(current, workInProgress, renderLanes) {\n        var JSCompiler_object_inline_digest_2446;\n        var JSCompiler_object_inline_stack_2447 = workInProgress.pendingProps;\n        shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);\n        var JSCompiler_object_inline_componentStack_2448 = !1;\n        var didSuspend = 0 !== (workInProgress.flags & 128);\n        (JSCompiler_object_inline_digest_2446 = didSuspend) || (JSCompiler_object_inline_digest_2446 = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));\n        JSCompiler_object_inline_digest_2446 && (JSCompiler_object_inline_componentStack_2448 = !0, workInProgress.flags &= -129);\n        JSCompiler_object_inline_digest_2446 = 0 !== (workInProgress.flags & 32);\n        workInProgress.flags &= -33;\n        if (null === current) {\n            if (isHydrating) {\n                JSCompiler_object_inline_componentStack_2448 ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);\n                if (isHydrating) {\n                    var JSCompiler_object_inline_message_2445 = nextHydratableInstance;\n                    var JSCompiler_temp;\n                    if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2445)) {\n                        c: {\n                            var instance = JSCompiler_object_inline_message_2445;\n                            for(JSCompiler_temp = rootOrSingletonContext; 8 !== instance.nodeType;){\n                                if (!JSCompiler_temp) {\n                                    JSCompiler_temp = null;\n                                    break c;\n                                }\n                                instance = getNextHydratable(instance.nextSibling);\n                                if (null === instance) {\n                                    JSCompiler_temp = null;\n                                    break c;\n                                }\n                            }\n                            JSCompiler_temp = instance;\n                        }\n                        null !== JSCompiler_temp ? (warnIfNotHydrating(), workInProgress.memoizedState = {\n                            dehydrated: JSCompiler_temp,\n                            treeContext: null !== treeContextProvider ? {\n                                id: treeContextId,\n                                overflow: treeContextOverflow\n                            } : null,\n                            retryLane: 536870912,\n                            hydrationErrors: null\n                        }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress, workInProgress.child = instance, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp = !0) : JSCompiler_temp = !1;\n                        JSCompiler_temp = !JSCompiler_temp;\n                    }\n                    JSCompiler_temp && (warnNonHydratedInstance(workInProgress, JSCompiler_object_inline_message_2445), throwOnHydrationMismatch(workInProgress));\n                }\n                JSCompiler_object_inline_message_2445 = workInProgress.memoizedState;\n                if (null !== JSCompiler_object_inline_message_2445 && (JSCompiler_object_inline_message_2445 = JSCompiler_object_inline_message_2445.dehydrated, null !== JSCompiler_object_inline_message_2445)) return isSuspenseInstanceFallback(JSCompiler_object_inline_message_2445) ? workInProgress.lanes = 32 : workInProgress.lanes = 536870912, null;\n                popSuspenseHandler(workInProgress);\n            }\n            JSCompiler_object_inline_message_2445 = JSCompiler_object_inline_stack_2447.children;\n            JSCompiler_object_inline_stack_2447 = JSCompiler_object_inline_stack_2447.fallback;\n            if (JSCompiler_object_inline_componentStack_2448) return reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2448 = workInProgress.mode, JSCompiler_object_inline_message_2445 = mountWorkInProgressOffscreenFiber({\n                mode: \"hidden\",\n                children: JSCompiler_object_inline_message_2445\n            }, JSCompiler_object_inline_componentStack_2448), JSCompiler_object_inline_stack_2447 = createFiberFromFragment(JSCompiler_object_inline_stack_2447, JSCompiler_object_inline_componentStack_2448, renderLanes, null), JSCompiler_object_inline_message_2445.return = workInProgress, JSCompiler_object_inline_stack_2447.return = workInProgress, JSCompiler_object_inline_message_2445.sibling = JSCompiler_object_inline_stack_2447, workInProgress.child = JSCompiler_object_inline_message_2445, JSCompiler_object_inline_componentStack_2448 = workInProgress.child, JSCompiler_object_inline_componentStack_2448.memoizedState = mountSuspenseOffscreenState(renderLanes), JSCompiler_object_inline_componentStack_2448.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2446, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2447;\n            pushPrimaryTreeSuspenseHandler(workInProgress);\n            return mountSuspensePrimaryChildren(workInProgress, JSCompiler_object_inline_message_2445);\n        }\n        var prevState = current.memoizedState;\n        if (null !== prevState && (JSCompiler_object_inline_message_2445 = prevState.dehydrated, null !== JSCompiler_object_inline_message_2445)) {\n            if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2448 = JSCompiler_object_inline_stack_2447.fallback, JSCompiler_object_inline_message_2445 = workInProgress.mode, JSCompiler_object_inline_stack_2447 = mountWorkInProgressOffscreenFiber({\n                mode: \"visible\",\n                children: JSCompiler_object_inline_stack_2447.children\n            }, JSCompiler_object_inline_message_2445), JSCompiler_object_inline_componentStack_2448 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2448, JSCompiler_object_inline_message_2445, renderLanes, null), JSCompiler_object_inline_componentStack_2448.flags |= 2, JSCompiler_object_inline_stack_2447.return = workInProgress, JSCompiler_object_inline_componentStack_2448.return = workInProgress, JSCompiler_object_inline_stack_2447.sibling = JSCompiler_object_inline_componentStack_2448, workInProgress.child = JSCompiler_object_inline_stack_2447, reconcileChildFibers(workInProgress, current.child, null, renderLanes), JSCompiler_object_inline_stack_2447 = workInProgress.child, JSCompiler_object_inline_stack_2447.memoizedState = mountSuspenseOffscreenState(renderLanes), JSCompiler_object_inline_stack_2447.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2446, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = JSCompiler_object_inline_componentStack_2448);\n            else if (pushPrimaryTreeSuspenseHandler(workInProgress), isHydrating && console.error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\"), isSuspenseInstanceFallback(JSCompiler_object_inline_message_2445)) {\n                JSCompiler_object_inline_digest_2446 = JSCompiler_object_inline_message_2445.nextSibling && JSCompiler_object_inline_message_2445.nextSibling.dataset;\n                if (JSCompiler_object_inline_digest_2446) {\n                    JSCompiler_temp = JSCompiler_object_inline_digest_2446.dgst;\n                    var message = JSCompiler_object_inline_digest_2446.msg;\n                    instance = JSCompiler_object_inline_digest_2446.stck;\n                    var componentStack = JSCompiler_object_inline_digest_2446.cstck;\n                }\n                JSCompiler_object_inline_message_2445 = message;\n                JSCompiler_object_inline_digest_2446 = JSCompiler_temp;\n                JSCompiler_object_inline_stack_2447 = instance;\n                JSCompiler_temp = JSCompiler_object_inline_componentStack_2448 = componentStack;\n                JSCompiler_object_inline_componentStack_2448 = JSCompiler_object_inline_message_2445 ? Error(JSCompiler_object_inline_message_2445) : Error(\"The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.\");\n                JSCompiler_object_inline_componentStack_2448.stack = JSCompiler_object_inline_stack_2447 || \"\";\n                JSCompiler_object_inline_componentStack_2448.digest = JSCompiler_object_inline_digest_2446;\n                JSCompiler_object_inline_digest_2446 = void 0 === JSCompiler_temp ? null : JSCompiler_temp;\n                JSCompiler_object_inline_stack_2447 = {\n                    value: JSCompiler_object_inline_componentStack_2448,\n                    source: null,\n                    stack: JSCompiler_object_inline_digest_2446\n                };\n                \"string\" === typeof JSCompiler_object_inline_digest_2446 && CapturedStacks.set(JSCompiler_object_inline_componentStack_2448, JSCompiler_object_inline_stack_2447);\n                queueHydrationError(JSCompiler_object_inline_stack_2447);\n                workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_object_inline_digest_2446 = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2446) {\n                JSCompiler_object_inline_digest_2446 = workInProgressRoot;\n                if (null !== JSCompiler_object_inline_digest_2446 && (JSCompiler_object_inline_stack_2447 = renderLanes & -renderLanes, JSCompiler_object_inline_stack_2447 = 0 !== (JSCompiler_object_inline_stack_2447 & 42) ? 1 : getBumpedLaneForHydrationByLane(JSCompiler_object_inline_stack_2447), JSCompiler_object_inline_stack_2447 = 0 !== (JSCompiler_object_inline_stack_2447 & (JSCompiler_object_inline_digest_2446.suspendedLanes | renderLanes)) ? 0 : JSCompiler_object_inline_stack_2447, 0 !== JSCompiler_object_inline_stack_2447 && JSCompiler_object_inline_stack_2447 !== prevState.retryLane)) throw prevState.retryLane = JSCompiler_object_inline_stack_2447, enqueueConcurrentRenderForLane(current, JSCompiler_object_inline_stack_2447), scheduleUpdateOnFiber(JSCompiler_object_inline_digest_2446, current, JSCompiler_object_inline_stack_2447), SelectiveHydrationException;\n                JSCompiler_object_inline_message_2445.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();\n                workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            } else JSCompiler_object_inline_message_2445.data === SUSPENSE_PENDING_START_DATA ? (workInProgress.flags |= 192, workInProgress.child = current.child, workInProgress = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(JSCompiler_object_inline_message_2445.nextSibling), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress), workInProgress = mountSuspensePrimaryChildren(workInProgress, JSCompiler_object_inline_stack_2447.children), workInProgress.flags |= 4096);\n            return workInProgress;\n        }\n        if (JSCompiler_object_inline_componentStack_2448) return reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2448 = JSCompiler_object_inline_stack_2447.fallback, JSCompiler_object_inline_message_2445 = workInProgress.mode, JSCompiler_temp = current.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2447 = createWorkInProgress(JSCompiler_temp, {\n            mode: \"hidden\",\n            children: JSCompiler_object_inline_stack_2447.children\n        }), JSCompiler_object_inline_stack_2447.subtreeFlags = JSCompiler_temp.subtreeFlags & 65011712, null !== instance ? JSCompiler_object_inline_componentStack_2448 = createWorkInProgress(instance, JSCompiler_object_inline_componentStack_2448) : (JSCompiler_object_inline_componentStack_2448 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2448, JSCompiler_object_inline_message_2445, renderLanes, null), JSCompiler_object_inline_componentStack_2448.flags |= 2), JSCompiler_object_inline_componentStack_2448.return = workInProgress, JSCompiler_object_inline_stack_2447.return = workInProgress, JSCompiler_object_inline_stack_2447.sibling = JSCompiler_object_inline_componentStack_2448, workInProgress.child = JSCompiler_object_inline_stack_2447, JSCompiler_object_inline_stack_2447 = JSCompiler_object_inline_componentStack_2448, JSCompiler_object_inline_componentStack_2448 = workInProgress.child, JSCompiler_object_inline_message_2445 = current.child.memoizedState, null === JSCompiler_object_inline_message_2445 ? JSCompiler_object_inline_message_2445 = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp = JSCompiler_object_inline_message_2445.cachePool, null !== JSCompiler_temp ? (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent !== instance ? {\n            parent: instance,\n            pool: instance\n        } : JSCompiler_temp) : JSCompiler_temp = getSuspendedCache(), JSCompiler_object_inline_message_2445 = {\n            baseLanes: JSCompiler_object_inline_message_2445.baseLanes | renderLanes,\n            cachePool: JSCompiler_temp\n        }), JSCompiler_object_inline_componentStack_2448.memoizedState = JSCompiler_object_inline_message_2445, JSCompiler_object_inline_componentStack_2448.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2446, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2447;\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        renderLanes = current.child;\n        current = renderLanes.sibling;\n        renderLanes = createWorkInProgress(renderLanes, {\n            mode: \"visible\",\n            children: JSCompiler_object_inline_stack_2447.children\n        });\n        renderLanes.return = workInProgress;\n        renderLanes.sibling = null;\n        null !== current && (JSCompiler_object_inline_digest_2446 = workInProgress.deletions, null === JSCompiler_object_inline_digest_2446 ? (workInProgress.deletions = [\n            current\n        ], workInProgress.flags |= 16) : JSCompiler_object_inline_digest_2446.push(current));\n        workInProgress.child = renderLanes;\n        workInProgress.memoizedState = null;\n        return renderLanes;\n    }\n    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n        primaryChildren = mountWorkInProgressOffscreenFiber({\n            mode: \"visible\",\n            children: primaryChildren\n        }, workInProgress.mode);\n        primaryChildren.return = workInProgress;\n        return workInProgress.child = primaryChildren;\n    }\n    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n        offscreenProps = createFiber(22, offscreenProps, null, mode);\n        offscreenProps.lanes = 0;\n        offscreenProps.stateNode = {\n            _visibility: OffscreenVisible,\n            _pendingMarkers: null,\n            _retryCache: null,\n            _transitions: null\n        };\n        return offscreenProps;\n    }\n    function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n        reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n        current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);\n        current.flags |= 2;\n        workInProgress.memoizedState = null;\n        return current;\n    }\n    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n        fiber.lanes |= renderLanes;\n        var alternate = fiber.alternate;\n        null !== alternate && (alternate.lanes |= renderLanes);\n        scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n    }\n    function validateSuspenseListNestedChild(childSlot, index) {\n        var isAnArray = isArrayImpl(childSlot);\n        childSlot = !isAnArray && \"function\" === typeof getIteratorFn(childSlot);\n        return isAnArray || childSlot ? (isAnArray = isAnArray ? \"array\" : \"iterable\", console.error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>\", isAnArray, index, isAnArray), !1) : !0;\n    }\n    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n        var renderState = workInProgress.memoizedState;\n        null === renderState ? workInProgress.memoizedState = {\n            isBackwards: isBackwards,\n            rendering: null,\n            renderingStartTime: 0,\n            last: lastContentRow,\n            tail: tail,\n            tailMode: tailMode\n        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);\n    }\n    function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;\n        nextProps = nextProps.children;\n        if (void 0 !== revealOrder && \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && \"together\" !== revealOrder && !didWarnAboutRevealOrder[revealOrder]) if (didWarnAboutRevealOrder[revealOrder] = !0, \"string\" === typeof revealOrder) switch(revealOrder.toLowerCase()){\n            case \"together\":\n            case \"forwards\":\n            case \"backwards\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            case \"forward\":\n            case \"backward\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            default:\n                console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        }\n        else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        void 0 === tailMode || didWarnAboutTailOptions[tailMode] || (\"collapsed\" !== tailMode && \"hidden\" !== tailMode ? (didWarnAboutTailOptions[tailMode] = !0, console.error('\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"collapsed\" or \"hidden\"?', tailMode)) : \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && (didWarnAboutTailOptions[tailMode] = !0, console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?', tailMode)));\n        a: if ((\"forwards\" === revealOrder || \"backwards\" === revealOrder) && void 0 !== nextProps && null !== nextProps && !1 !== nextProps) if (isArrayImpl(nextProps)) for(var i = 0; i < nextProps.length; i++){\n            if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;\n        }\n        else if (i = getIteratorFn(nextProps), \"function\" === typeof i) {\n            if (i = i.call(nextProps)) for(var step = i.next(), _i = 0; !step.done; step = i.next()){\n                if (!validateSuspenseListNestedChild(step.value, _i)) break a;\n                _i++;\n            }\n        } else console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        nextProps = suspenseStackCursor.current;\n        if (0 !== (nextProps & ForceSuspenseFallback)) nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128;\n        else {\n            if (null !== current && 0 !== (current.flags & 128)) a: for(current = workInProgress.child; null !== current;){\n                if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (null !== current.child) {\n                    current.child.return = current;\n                    current = current.child;\n                    continue;\n                }\n                if (current === workInProgress) break a;\n                for(; null === current.sibling;){\n                    if (null === current.return || current.return === workInProgress) break a;\n                    current = current.return;\n                }\n                current.sibling.return = current.return;\n                current = current.sibling;\n            }\n            nextProps &= SubtreeSuspenseContextMask;\n        }\n        push(suspenseStackCursor, nextProps, workInProgress);\n        switch(revealOrder){\n            case \"forwards\":\n                renderLanes = workInProgress.child;\n                for(revealOrder = null; null !== renderLanes;)current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;\n                renderLanes = revealOrder;\n                null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);\n                initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);\n                break;\n            case \"backwards\":\n                renderLanes = null;\n                revealOrder = workInProgress.child;\n                for(workInProgress.child = null; null !== revealOrder;){\n                    current = revealOrder.alternate;\n                    if (null !== current && null === findFirstSuspended(current)) {\n                        workInProgress.child = revealOrder;\n                        break;\n                    }\n                    current = revealOrder.sibling;\n                    revealOrder.sibling = renderLanes;\n                    renderLanes = revealOrder;\n                    revealOrder = current;\n                }\n                initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);\n                break;\n            case \"together\":\n                initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\n                break;\n            default:\n                workInProgress.memoizedState = null;\n        }\n        return workInProgress.child;\n    }\n    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n        null !== current && (workInProgress.dependencies = current.dependencies);\n        profilerStartTime = -1;\n        workInProgressRootSkippedLanes |= workInProgress.lanes;\n        if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {\n            if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;\n        } else return null;\n        if (null !== current && workInProgress.child !== current.child) throw Error(\"Resuming work not yet implemented.\");\n        if (null !== workInProgress.child) {\n            current = workInProgress.child;\n            renderLanes = createWorkInProgress(current, current.pendingProps);\n            workInProgress.child = renderLanes;\n            for(renderLanes.return = workInProgress; null !== current.sibling;)current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;\n            renderLanes.sibling = null;\n        }\n        return workInProgress.child;\n    }\n    function checkScheduledUpdateOrContext(current, renderLanes) {\n        if (0 !== (current.lanes & renderLanes)) return !0;\n        current = current.dependencies;\n        return null !== current && checkIfContextChanged(current) ? !0 : !1;\n    }\n    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n        switch(workInProgress.tag){\n            case 3:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n                resetHydrationState();\n                break;\n            case 27:\n            case 5:\n                pushHostContext(workInProgress);\n                break;\n            case 4:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                break;\n            case 10:\n                pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);\n                break;\n            case 12:\n                0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);\n                workInProgress.flags |= 2048;\n                var stateNode = workInProgress.stateNode;\n                stateNode.effectDuration = -0;\n                stateNode.passiveEffectDuration = -0;\n                break;\n            case 13:\n                stateNode = workInProgress.memoizedState;\n                if (null !== stateNode) {\n                    if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;\n                    if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    return null !== current ? current.sibling : null;\n                }\n                pushPrimaryTreeSuspenseHandler(workInProgress);\n                break;\n            case 19:\n                var didSuspendBefore = 0 !== (current.flags & 128);\n                stateNode = 0 !== (renderLanes & workInProgress.childLanes);\n                stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));\n                if (didSuspendBefore) {\n                    if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    workInProgress.flags |= 128;\n                }\n                didSuspendBefore = workInProgress.memoizedState;\n                null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);\n                push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);\n                if (stateNode) break;\n                else return null;\n            case 22:\n            case 23:\n                return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n        }\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n    function beginWork(current, workInProgress, renderLanes) {\n        if (workInProgress._debugNeedsRemount && null !== current) {\n            renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);\n            renderLanes._debugStack = workInProgress._debugStack;\n            renderLanes._debugTask = workInProgress._debugTask;\n            var returnFiber = workInProgress.return;\n            if (null === returnFiber) throw Error(\"Cannot swap the root fiber.\");\n            current.alternate = null;\n            workInProgress.alternate = null;\n            renderLanes.index = workInProgress.index;\n            renderLanes.sibling = workInProgress.sibling;\n            renderLanes.return = workInProgress.return;\n            renderLanes.ref = workInProgress.ref;\n            renderLanes._debugInfo = workInProgress._debugInfo;\n            if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;\n            else {\n                var prevSibling = returnFiber.child;\n                if (null === prevSibling) throw Error(\"Expected parent to have a child.\");\n                for(; prevSibling.sibling !== workInProgress;)if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error(\"Expected to find the previous sibling.\");\n                prevSibling.sibling = renderLanes;\n            }\n            workInProgress = returnFiber.deletions;\n            null === workInProgress ? (returnFiber.deletions = [\n                current\n            ], returnFiber.flags |= 16) : workInProgress.push(current);\n            renderLanes.flags |= 2;\n            return renderLanes;\n        }\n        if (null !== current) if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;\n        else {\n            if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n            didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n        }\n        else {\n            didReceiveUpdate = !1;\n            if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);\n            returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));\n        }\n        workInProgress.lanes = 0;\n        switch(workInProgress.tag){\n            case 16:\n                a: if (returnFiber = workInProgress.pendingProps, current = callLazyInitInDEV(workInProgress.elementType), workInProgress.type = current, \"function\" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));\n                else {\n                    if (void 0 !== current && null !== current) {\n                        if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {\n                            workInProgress.tag = 11;\n                            workInProgress.type = current = resolveForwardRefForHotReloading(current);\n                            workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        } else if (prevSibling === REACT_MEMO_TYPE) {\n                            workInProgress.tag = 14;\n                            workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        }\n                    }\n                    workInProgress = \"\";\n                    null !== current && \"object\" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = \" Did you wrap a component in React.lazy() more than once?\");\n                    current = getComponentNameFromType(current) || current;\n                    throw Error(\"Element type is invalid. Received a promise that resolves to: \" + current + \". Lazy element type must resolve to a class or function.\" + workInProgress);\n                }\n                return workInProgress;\n            case 0:\n                return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 1:\n                return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);\n            case 3:\n                a: {\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    if (null === current) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                    returnFiber = workInProgress.pendingProps;\n                    var prevState = workInProgress.memoizedState;\n                    prevSibling = prevState.element;\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, returnFiber, null, renderLanes);\n                    var nextState = workInProgress.memoizedState;\n                    returnFiber = nextState.cache;\n                    pushProvider(workInProgress, CacheContext, returnFiber);\n                    returnFiber !== prevState.cache && propagateContextChanges(workInProgress, [\n                        CacheContext\n                    ], renderLanes, !0);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                    returnFiber = nextState.element;\n                    if (prevState.isDehydrated) if (prevState = {\n                        element: returnFiber,\n                        isDehydrated: !1,\n                        cache: nextState.cache\n                    }, workInProgress.updateQueue.baseState = prevState, workInProgress.memoizedState = prevState, workInProgress.flags & 256) {\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, returnFiber, renderLanes);\n                        break a;\n                    } else if (returnFiber !== prevSibling) {\n                        prevSibling = createCapturedValueAtFiber(Error(\"This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.\"), workInProgress);\n                        queueHydrationError(prevSibling);\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, returnFiber, renderLanes);\n                        break a;\n                    } else {\n                        current = workInProgress.stateNode.containerInfo;\n                        switch(current.nodeType){\n                            case 9:\n                                current = current.body;\n                                break;\n                            default:\n                                current = \"HTML\" === current.nodeName ? current.ownerDocument.body : current;\n                        }\n                        nextHydratableInstance = getNextHydratable(current.firstChild);\n                        hydrationParentFiber = workInProgress;\n                        isHydrating = !0;\n                        hydrationErrors = null;\n                        didSuspendOrErrorDEV = !1;\n                        hydrationDiffRootDEV = null;\n                        rootOrSingletonContext = !0;\n                        current = mountChildFibers(workInProgress, null, returnFiber, renderLanes);\n                        for(workInProgress.child = current; current;)current.flags = current.flags & -3 | 4096, current = current.sibling;\n                    }\n                    else {\n                        resetHydrationState();\n                        if (returnFiber === prevSibling) {\n                            workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                            break a;\n                        }\n                        reconcileChildren(current, workInProgress, returnFiber, renderLanes);\n                    }\n                    workInProgress = workInProgress.child;\n                }\n                return workInProgress;\n            case 26:\n                return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (current = workInProgress.type, renderLanes = workInProgress.pendingProps, returnFiber = requiredContext(rootInstanceStackCursor.current), returnFiber = getOwnerDocumentFromRootContainer(returnFiber).createElement(current), returnFiber[internalInstanceKey] = workInProgress, returnFiber[internalPropsKey] = renderLanes, setInitialProperties(returnFiber, current, renderLanes), markNodeAsHoistable(returnFiber), workInProgress.stateNode = returnFiber) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;\n            case 27:\n                return pushHostContext(workInProgress), null === current && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, returnFiber, prevSibling, !1), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(returnFiber, workInProgress.type, workInProgress.pendingProps, prevSibling), null !== prevSibling && (buildHydrationDiffNode(workInProgress, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(returnFiber.firstChild)) : nextHydratableInstance = prevSibling), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), markRef(current, workInProgress), null === current && (workInProgress.flags |= 4194304), workInProgress.child;\n            case 5:\n                return null === current && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(workInProgress.type, prevState.ancestorInfo), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(nextState, workInProgress.type, workInProgress.pendingProps, prevState), null !== prevState && (buildHydrationDiffNode(workInProgress, 0).serverProps = prevState)), hydrationParentFiber = workInProgress, nextHydratableInstance = getNextHydratable(nextState.firstChild), rootOrSingletonContext = !1, prevState = !0) : prevState = !1, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, prevState = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), HostTransitionContext._currentValue = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 6:\n                return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext(), returnFiber = renderLanes.ancestorInfo.current, current = null != returnFiber ? validateTextNesting(current, returnFiber.tag, renderLanes.ancestorInfo.implicitRootScope) : !0, renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;\n            case 13:\n                return updateSuspenseComponent(current, workInProgress, renderLanes);\n            case 4:\n                return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 11:\n                return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 7:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;\n            case 8:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 12:\n                return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 10:\n                return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, prevState = prevSibling.value, \"value\" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\")), pushProvider(workInProgress, returnFiber, prevState), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;\n            case 9:\n                return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, \"function\" !== typeof returnFiber && console.error(\"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), markComponentRenderStopped(), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 14:\n                return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 15:\n                return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 19:\n                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n            case 31:\n                return returnFiber = workInProgress.pendingProps, renderLanes = workInProgress.mode, returnFiber = {\n                    mode: returnFiber.mode,\n                    children: returnFiber.children\n                }, null === current ? (current = mountWorkInProgressOffscreenFiber(returnFiber, renderLanes), current.ref = workInProgress.ref, workInProgress.child = current, current.return = workInProgress, workInProgress = current) : (current = createWorkInProgress(current.child, returnFiber), current.ref = workInProgress.ref, workInProgress.child = current, current.return = workInProgress, workInProgress = current), workInProgress;\n            case 22:\n                return updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = prevState), workInProgress.memoizedState = {\n                    parent: returnFiber,\n                    cache: prevSibling\n                }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, prevState = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {\n                    parent: returnFiber,\n                    cache: returnFiber\n                }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                    CacheContext\n                ], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 29:\n                throw workInProgress.pendingProps;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function markUpdate(workInProgress) {\n        workInProgress.flags |= 4;\n    }\n    function preloadInstanceAndSuspendIfNeeded(workInProgress, type, oldProps, newProps, renderLanes) {\n        if (type = (workInProgress.mode & SuspenseyImagesMode) !== NoMode) type = !1;\n        if (type) {\n            if (workInProgress.flags |= 16777216, (renderLanes & 335544128) === renderLanes) if (workInProgress.stateNode.complete) workInProgress.flags |= 8192;\n            else if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n        if (\"stylesheet\" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded) workInProgress.flags &= -16777217;\n        else if (workInProgress.flags |= 16777216, !preloadResource(resource)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n        else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n    }\n    function scheduleRetryEffect(workInProgress, retryQueue) {\n        null !== retryQueue && (workInProgress.flags |= 4);\n        workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);\n    }\n    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n        if (!isHydrating) switch(renderState.tailMode){\n            case \"hidden\":\n                hasRenderedATailFallback = renderState.tail;\n                for(var lastTailNode = null; null !== hasRenderedATailFallback;)null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;\n                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;\n                break;\n            case \"collapsed\":\n                lastTailNode = renderState.tail;\n                for(var _lastTailNode = null; null !== lastTailNode;)null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;\n                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;\n        }\n    }\n    function bubbleProperties(completedWork) {\n        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;\n        if (didBailout) if ((completedWork.mode & ProfileMode) !== NoMode) {\n            for(var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;)newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;\n            completedWork.treeBaseDuration = _treeBaseDuration;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        else if ((completedWork.mode & ProfileMode) !== NoMode) {\n            _treeBaseDuration = completedWork.actualDuration;\n            _child2 = completedWork.selfBaseDuration;\n            for(var child = completedWork.child; null !== child;)newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;\n            completedWork.actualDuration = _treeBaseDuration;\n            completedWork.treeBaseDuration = _child2;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        completedWork.subtreeFlags |= subtreeFlags;\n        completedWork.childLanes = newChildLanes;\n        return didBailout;\n    }\n    function completeWork(current, workInProgress, renderLanes) {\n        var newProps = workInProgress.pendingProps;\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 31:\n            case 16:\n            case 15:\n            case 0:\n            case 11:\n            case 7:\n            case 8:\n            case 12:\n            case 9:\n            case 14:\n                return bubbleProperties(workInProgress), null;\n            case 1:\n                return bubbleProperties(workInProgress), null;\n            case 3:\n                renderLanes = workInProgress.stateNode;\n                newProps = null;\n                null !== current && (newProps = current.memoizedState.cache);\n                workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);\n                popProvider(CacheContext, workInProgress);\n                popHostContainer(workInProgress);\n                renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);\n                if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, upgradeHydrationErrorsToRecoverable());\n                bubbleProperties(workInProgress);\n                return null;\n            case 26:\n                var type = workInProgress.type, nextResource = workInProgress.memoizedState;\n                null === current ? (markUpdate(workInProgress), null !== nextResource ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, type, null, newProps, renderLanes))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress), bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, type, current, newProps, renderLanes));\n                return null;\n            case 27:\n                popHostContext(workInProgress);\n                renderLanes = requiredContext(rootInstanceStackCursor.current);\n                type = workInProgress.type;\n                if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);\n                else {\n                    if (!newProps) {\n                        if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                    current = getHostContext();\n                    popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(type, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));\n                }\n                bubbleProperties(workInProgress);\n                return null;\n            case 5:\n                popHostContext(workInProgress);\n                type = workInProgress.type;\n                if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);\n                else {\n                    if (!newProps) {\n                        if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                    var _currentHostContext = getHostContext();\n                    if (popHydrationState(workInProgress)) prepareToHydrateHostInstance(workInProgress, _currentHostContext);\n                    else {\n                        nextResource = requiredContext(rootInstanceStackCursor.current);\n                        validateDOMNesting(type, _currentHostContext.ancestorInfo);\n                        _currentHostContext = _currentHostContext.context;\n                        nextResource = getOwnerDocumentFromRootContainer(nextResource);\n                        switch(_currentHostContext){\n                            case HostContextNamespaceSvg:\n                                nextResource = nextResource.createElementNS(SVG_NAMESPACE, type);\n                                break;\n                            case HostContextNamespaceMath:\n                                nextResource = nextResource.createElementNS(MATH_NAMESPACE, type);\n                                break;\n                            default:\n                                switch(type){\n                                    case \"svg\":\n                                        nextResource = nextResource.createElementNS(SVG_NAMESPACE, type);\n                                        break;\n                                    case \"math\":\n                                        nextResource = nextResource.createElementNS(MATH_NAMESPACE, type);\n                                        break;\n                                    case \"script\":\n                                        nextResource = nextResource.createElement(\"div\");\n                                        nextResource.innerHTML = \"<script>\\x3c/script>\";\n                                        nextResource = nextResource.removeChild(nextResource.firstChild);\n                                        break;\n                                    case \"select\":\n                                        nextResource = \"string\" === typeof newProps.is ? nextResource.createElement(\"select\", {\n                                            is: newProps.is\n                                        }) : nextResource.createElement(\"select\");\n                                        newProps.multiple ? nextResource.multiple = !0 : newProps.size && (nextResource.size = newProps.size);\n                                        break;\n                                    default:\n                                        nextResource = \"string\" === typeof newProps.is ? nextResource.createElement(type, {\n                                            is: newProps.is\n                                        }) : nextResource.createElement(type), -1 === type.indexOf(\"-\") && (type !== type.toLowerCase() && console.error(\"<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\", type), \"[object HTMLUnknownElement]\" !== Object.prototype.toString.call(nextResource) || hasOwnProperty.call(warnedUnknownTags, type) || (warnedUnknownTags[type] = !0, console.error(\"The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.\", type)));\n                                }\n                        }\n                        nextResource[internalInstanceKey] = workInProgress;\n                        nextResource[internalPropsKey] = newProps;\n                        a: for(_currentHostContext = workInProgress.child; null !== _currentHostContext;){\n                            if (5 === _currentHostContext.tag || 6 === _currentHostContext.tag) nextResource.appendChild(_currentHostContext.stateNode);\n                            else if (4 !== _currentHostContext.tag && 27 !== _currentHostContext.tag && null !== _currentHostContext.child) {\n                                _currentHostContext.child.return = _currentHostContext;\n                                _currentHostContext = _currentHostContext.child;\n                                continue;\n                            }\n                            if (_currentHostContext === workInProgress) break a;\n                            for(; null === _currentHostContext.sibling;){\n                                if (null === _currentHostContext.return || _currentHostContext.return === workInProgress) break a;\n                                _currentHostContext = _currentHostContext.return;\n                            }\n                            _currentHostContext.sibling.return = _currentHostContext.return;\n                            _currentHostContext = _currentHostContext.sibling;\n                        }\n                        workInProgress.stateNode = nextResource;\n                        a: switch(setInitialProperties(nextResource, type, newProps), type){\n                            case \"button\":\n                            case \"input\":\n                            case \"select\":\n                            case \"textarea\":\n                                newProps = !!newProps.autoFocus;\n                                break a;\n                            case \"img\":\n                                newProps = !0;\n                                break a;\n                            default:\n                                newProps = !1;\n                        }\n                        newProps && markUpdate(workInProgress);\n                    }\n                }\n                bubbleProperties(workInProgress);\n                preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, null === current ? null : current.memoizedProps, workInProgress.pendingProps, renderLanes);\n                return null;\n            case 6:\n                if (current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);\n                else {\n                    if (\"string\" !== typeof newProps && null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                    current = requiredContext(rootInstanceStackCursor.current);\n                    renderLanes = getHostContext();\n                    if (popHydrationState(workInProgress)) {\n                        current = workInProgress.stateNode;\n                        renderLanes = workInProgress.memoizedProps;\n                        type = !didSuspendOrErrorDEV;\n                        newProps = null;\n                        nextResource = hydrationParentFiber;\n                        if (null !== nextResource) switch(nextResource.tag){\n                            case 3:\n                                type && (type = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== type && (buildHydrationDiffNode(workInProgress, 0).serverProps = type));\n                                break;\n                            case 27:\n                            case 5:\n                                newProps = nextResource.memoizedProps, type && (type = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== type && (buildHydrationDiffNode(workInProgress, 0).serverProps = type));\n                        }\n                        current[internalInstanceKey] = workInProgress;\n                        current = current.nodeValue === renderLanes || null !== newProps && !0 === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes) ? !0 : !1;\n                        current || throwOnHydrationMismatch(workInProgress, !0);\n                    } else type = renderLanes.ancestorInfo.current, null != type && validateTextNesting(newProps, type.tag, renderLanes.ancestorInfo.implicitRootScope), current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps), current[internalInstanceKey] = workInProgress, workInProgress.stateNode = current;\n                }\n                bubbleProperties(workInProgress);\n                return null;\n            case 13:\n                newProps = workInProgress.memoizedState;\n                if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {\n                    type = popHydrationState(workInProgress);\n                    if (null !== newProps && null !== newProps.dehydrated) {\n                        if (null === current) {\n                            if (!type) throw Error(\"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.\");\n                            type = workInProgress.memoizedState;\n                            type = null !== type ? type.dehydrated : null;\n                            if (!type) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n                            type[internalInstanceKey] = workInProgress;\n                            bubbleProperties(workInProgress);\n                            (workInProgress.mode & ProfileMode) !== NoMode && null !== newProps && (type = workInProgress.child, null !== type && (workInProgress.treeBaseDuration -= type.treeBaseDuration));\n                        } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & ProfileMode) !== NoMode && null !== newProps && (type = workInProgress.child, null !== type && (workInProgress.treeBaseDuration -= type.treeBaseDuration));\n                        type = !1;\n                    } else type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = !0;\n                    if (!type) {\n                        if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;\n                        popSuspenseHandler(workInProgress);\n                        return null;\n                    }\n                }\n                popSuspenseHandler(workInProgress);\n                if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress;\n                renderLanes = null !== newProps;\n                current = null !== current && null !== current.memoizedState;\n                renderLanes && (newProps = workInProgress.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));\n                renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);\n                scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n                bubbleProperties(workInProgress);\n                (workInProgress.mode & ProfileMode) !== NoMode && renderLanes && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));\n                return null;\n            case 4:\n                return popHostContainer(workInProgress), null === current && listenToAllSupportedEvents(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;\n            case 19:\n                pop(suspenseStackCursor, workInProgress);\n                type = workInProgress.memoizedState;\n                if (null === type) return bubbleProperties(workInProgress), null;\n                newProps = 0 !== (workInProgress.flags & 128);\n                nextResource = type.rendering;\n                if (null === nextResource) if (newProps) cutOffTailIfNeeded(type, !1);\n                else {\n                    if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for(current = workInProgress.child; null !== current;){\n                        nextResource = findFirstSuspended(current);\n                        if (null !== nextResource) {\n                            workInProgress.flags |= 128;\n                            cutOffTailIfNeeded(type, !1);\n                            current = nextResource.updateQueue;\n                            workInProgress.updateQueue = current;\n                            scheduleRetryEffect(workInProgress, current);\n                            workInProgress.subtreeFlags = 0;\n                            current = renderLanes;\n                            for(renderLanes = workInProgress.child; null !== renderLanes;)resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;\n                            push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);\n                            return workInProgress.child;\n                        }\n                        current = current.sibling;\n                    }\n                    null !== type.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(type, !1), workInProgress.lanes = 4194304);\n                }\n                else {\n                    if (!newProps) if (current = findFirstSuspended(nextResource), null !== current) {\n                        if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(type, !0), null === type.tail && \"hidden\" === type.tailMode && !nextResource.alternate && !isHydrating) return bubbleProperties(workInProgress), null;\n                    } else 2 * now$1() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(type, !1), workInProgress.lanes = 4194304);\n                    type.isBackwards ? (nextResource.sibling = workInProgress.child, workInProgress.child = nextResource) : (current = type.last, null !== current ? current.sibling = nextResource : workInProgress.child = nextResource, type.last = nextResource);\n                }\n                if (null !== type.tail) return current = type.tail, type.rendering = current, type.tail = current.sibling, type.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = newProps ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), current;\n                bubbleProperties(workInProgress);\n                return null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;\n            case 24:\n                return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;\n            case 25:\n                return null;\n            case 30:\n                return null;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function unwindWork(current, workInProgress) {\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 1:\n                return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 3:\n                return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;\n            case 26:\n            case 27:\n            case 5:\n                return popHostContext(workInProgress), null;\n            case 13:\n                popSuspenseHandler(workInProgress);\n                current = workInProgress.memoizedState;\n                if (null !== current && null !== current.dehydrated) {\n                    if (null === workInProgress.alternate) throw Error(\"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.\");\n                    resetHydrationState();\n                }\n                current = workInProgress.flags;\n                return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 19:\n                return pop(suspenseStackCursor, workInProgress), null;\n            case 4:\n                return popHostContainer(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 24:\n                return popProvider(CacheContext, workInProgress), null;\n            case 25:\n                return null;\n            default:\n                return null;\n        }\n    }\n    function unwindInterruptedWork(current, interruptedWork) {\n        popTreeContext(interruptedWork);\n        switch(interruptedWork.tag){\n            case 3:\n                popProvider(CacheContext, interruptedWork);\n                popHostContainer(interruptedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                popHostContext(interruptedWork);\n                break;\n            case 4:\n                popHostContainer(interruptedWork);\n                break;\n            case 13:\n                popSuspenseHandler(interruptedWork);\n                break;\n            case 19:\n                pop(suspenseStackCursor, interruptedWork);\n                break;\n            case 10:\n                popProvider(interruptedWork.type, interruptedWork);\n                break;\n            case 22:\n            case 23:\n                popSuspenseHandler(interruptedWork);\n                popHiddenContext(interruptedWork);\n                null !== current && pop(resumedCache, interruptedWork);\n                break;\n            case 24:\n                popProvider(CacheContext, interruptedWork);\n        }\n    }\n    function shouldProfile(current) {\n        return (current.mode & ProfileMode) !== NoMode;\n    }\n    function commitHookLayoutEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitHookEffectListMount(flags, finishedWork) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && \"function\" !== typeof lastEffect)) {\n                        var hookName = void 0;\n                        hookName = 0 !== (updateQueue.tag & Layout) ? \"useLayoutEffect\" : 0 !== (updateQueue.tag & Insertion) ? \"useInsertionEffect\" : \"useEffect\";\n                        var addendum = void 0;\n                        addendum = null === lastEffect ? \" You returned null. If your effect does not require clean up, return undefined (or nothing).\" : \"function\" === typeof lastEffect.then ? \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\\n\\n\" + hookName + \"(() => {\\n  async function fetchData() {\\n    // You can await here\\n    const response = await MyAPI.getData(someId);\\n    // ...\\n  }\\n  fetchData();\\n}, [someId]); // Or [] if effect doesn't need props or state\\n\\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching\" : \" You returned: \" + lastEffect;\n                        runWithFiberInDEV(finishedWork, function(n, a) {\n                            console.error(\"%s must not return anything besides a function, which is used for clean-up.%s\", n, a);\n                        }, hookName, addendum);\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags) {\n                        var inst = updateQueue.inst, destroy = inst.destroy;\n                        void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = finishedWork, runWithFiberInDEV(lastEffect, callDestroyInDEV, lastEffect, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitClassCallbacks(finishedWork) {\n        var updateQueue = finishedWork.updateQueue;\n        if (null !== updateQueue) {\n            var instance = finishedWork.stateNode;\n            finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), instance.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n            try {\n                runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }\n    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {\n        return instance.getSnapshotBeforeUpdate(prevProps, prevState);\n    }\n    function commitClassSnapshot(finishedWork, current) {\n        var prevProps = current.memoizedProps, prevState = current.memoizedState;\n        current = finishedWork.stateNode;\n        finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), current.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n        try {\n            var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);\n            var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);\n            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;\n            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {\n                console.error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n            }));\n            current.__reactInternalSnapshotBeforeUpdate = snapshot;\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n        instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n        instance.state = current.memoizedState;\n        shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);\n    }\n    function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n        if (null !== ref) {\n            switch(finishedWork.tag){\n                case 26:\n                case 27:\n                case 5:\n                    var instanceToUse = finishedWork.stateNode;\n                    break;\n                case 30:\n                    instanceToUse = finishedWork.stateNode;\n                    break;\n                default:\n                    instanceToUse = finishedWork.stateNode;\n            }\n            if (\"function\" === typeof ref) if (shouldProfile(finishedWork)) try {\n                startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);\n            } finally{\n                recordEffectDuration();\n            }\n            else finishedWork.refCleanup = ref(instanceToUse);\n            else \"string\" === typeof ref ? console.error(\"String refs are no longer supported.\") : ref.hasOwnProperty(\"current\") || console.error(\"Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork)), ref.current = instanceToUse;\n        }\n    }\n    function safelyAttachRef(current, nearestMountedAncestor) {\n        try {\n            runWithFiberInDEV(current, commitAttachRef, current);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        }\n    }\n    function safelyDetachRef(current, nearestMountedAncestor) {\n        var ref = current.ref, refCleanup = current.refCleanup;\n        if (null !== ref) if (\"function\" === typeof refCleanup) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, refCleanup);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, refCleanup);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        } finally{\n            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);\n        }\n        else if (\"function\" === typeof ref) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, ref, null);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, ref, null);\n        } catch (error$7) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error$7);\n        }\n        else ref.current = null;\n    }\n    function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {\n        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;\n        _finishedWork$memoize = _finishedWork$memoize.onRender;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);\n        \"function\" === typeof onCommit && onCommit(finishedWork.memoizedProps.id, current, effectDuration, commitStartTime);\n    }\n    function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {\n        var _finishedWork$memoize2 = finishedWork.memoizedProps;\n        finishedWork = _finishedWork$memoize2.id;\n        _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);\n    }\n    function commitHostMount(finishedWork) {\n        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;\n        try {\n            runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHostUpdate(finishedWork, newProps, oldProps) {\n        try {\n            runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function isHostParent(fiber) {\n        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;\n    }\n    function getHostSibling(fiber) {\n        a: for(;;){\n            for(; null === fiber.sibling;){\n                if (null === fiber.return || isHostParent(fiber.return)) return null;\n                fiber = fiber.return;\n            }\n            fiber.sibling.return = fiber.return;\n            for(fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;){\n                if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;\n                if (fiber.flags & 2) continue a;\n                if (null === fiber.child || 4 === fiber.tag) continue a;\n                else fiber.child.return = fiber, fiber = fiber.child;\n            }\n            if (!(fiber.flags & 2)) return fiber.stateNode;\n        }\n    }\n    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? (warnForReactChildrenConflict(parent), (9 === parent.nodeType ? parent.body : \"HTML\" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before)) : (warnForReactChildrenConflict(parent), before = 9 === parent.nodeType ? parent.body : \"HTML\" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));\n        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node)) for(insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;\n    }\n    function insertOrAppendPlacementNode(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);\n        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node)) for(insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n    }\n    function commitPlacement(finishedWork) {\n        for(var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber;){\n            if (isHostParent(parentFiber)) {\n                hostParentFiber = parentFiber;\n                break;\n            }\n            parentFiber = parentFiber.return;\n        }\n        if (null == hostParentFiber) throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n        switch(hostParentFiber.tag){\n            case 27:\n                hostParentFiber = hostParentFiber.stateNode;\n                parentFiber = getHostSibling(finishedWork);\n                insertOrAppendPlacementNode(finishedWork, parentFiber, hostParentFiber);\n                break;\n            case 5:\n                parentFiber = hostParentFiber.stateNode;\n                hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);\n                hostParentFiber = getHostSibling(finishedWork);\n                insertOrAppendPlacementNode(finishedWork, hostParentFiber, parentFiber);\n                break;\n            case 3:\n            case 4:\n                hostParentFiber = hostParentFiber.stateNode.containerInfo;\n                parentFiber = getHostSibling(finishedWork);\n                insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, hostParentFiber);\n                break;\n            default:\n                throw Error(\"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n    }\n    function commitHostSingletonAcquisition(finishedWork) {\n        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;\n        try {\n            runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, singleton, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitBeforeMutationEffects(root, firstChild) {\n        root = root.containerInfo;\n        eventsEnabled = _enabled;\n        root = getActiveElementDeep(root);\n        if (hasSelectionCapabilities(root)) {\n            if (\"selectionStart\" in root) var JSCompiler_temp = {\n                start: root.selectionStart,\n                end: root.selectionEnd\n            };\n            else a: {\n                JSCompiler_temp = (JSCompiler_temp = root.ownerDocument) && JSCompiler_temp.defaultView || window;\n                var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();\n                if (selection && 0 !== selection.rangeCount) {\n                    JSCompiler_temp = selection.anchorNode;\n                    var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;\n                    selection = selection.focusOffset;\n                    try {\n                        JSCompiler_temp.nodeType, focusNode.nodeType;\n                    } catch (e$2) {\n                        JSCompiler_temp = null;\n                        break a;\n                    }\n                    var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root, parentNode = null;\n                    b: for(;;){\n                        for(var next;;){\n                            node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);\n                            node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);\n                            3 === node.nodeType && (length += node.nodeValue.length);\n                            if (null === (next = node.firstChild)) break;\n                            parentNode = node;\n                            node = next;\n                        }\n                        for(;;){\n                            if (node === root) break b;\n                            parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);\n                            parentNode === focusNode && ++indexWithinFocus === selection && (end = length);\n                            if (null !== (next = node.nextSibling)) break;\n                            node = parentNode;\n                            parentNode = node.parentNode;\n                        }\n                        node = next;\n                    }\n                    JSCompiler_temp = -1 === start || -1 === end ? null : {\n                        start: start,\n                        end: end\n                    };\n                } else JSCompiler_temp = null;\n            }\n            JSCompiler_temp = JSCompiler_temp || {\n                start: 0,\n                end: 0\n            };\n        } else JSCompiler_temp = null;\n        selectionInformation = {\n            focusedElem: root,\n            selectionRange: JSCompiler_temp\n        };\n        _enabled = !1;\n        for(nextEffect = firstChild; null !== nextEffect;)if (firstChild = nextEffect, root = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root) root.return = firstChild, nextEffect = root;\n        else for(; null !== nextEffect;){\n            root = firstChild = nextEffect;\n            JSCompiler_temp = root.alternate;\n            anchorOffset = root.flags;\n            switch(root.tag){\n                case 0:\n                    break;\n                case 11:\n                case 15:\n                    break;\n                case 1:\n                    0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root, JSCompiler_temp);\n                    break;\n                case 3:\n                    if (0 !== (anchorOffset & 1024)) {\n                        if (root = root.stateNode.containerInfo, JSCompiler_temp = root.nodeType, 9 === JSCompiler_temp) clearContainerSparingly(root);\n                        else if (1 === JSCompiler_temp) switch(root.nodeName){\n                            case \"HEAD\":\n                            case \"HTML\":\n                            case \"BODY\":\n                                clearContainerSparingly(root);\n                                break;\n                            default:\n                                root.textContent = \"\";\n                        }\n                    }\n                    break;\n                case 5:\n                case 26:\n                case 27:\n                case 6:\n                case 4:\n                case 17:\n                    break;\n                default:\n                    if (0 !== (anchorOffset & 1024)) throw Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            root = firstChild.sibling;\n            if (null !== root) {\n                root.return = firstChild.return;\n                nextEffect = root;\n                break;\n            }\n            nextEffect = firstChild.return;\n        }\n    }\n    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n        var prevEffectStart = pushComponentEffectStart(), flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                break;\n            case 1:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);\n                else {\n                    var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                    current = current.memoizedState;\n                    finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n                    shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);\n                }\n                flags & 64 && commitClassCallbacks(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 3:\n                current = pushNestedEffectDurations();\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {\n                    prevProps = null;\n                    if (null !== finishedWork.child) switch(finishedWork.child.tag){\n                        case 27:\n                        case 5:\n                            prevProps = finishedWork.child.stateNode;\n                            break;\n                        case 1:\n                            prevProps = finishedWork.child.stateNode;\n                    }\n                    try {\n                        runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                finishedRoot.effectDuration += popNestedEffectDurations(current);\n                break;\n            case 27:\n                null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);\n            case 26:\n            case 5:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                null === current && flags & 4 && commitHostMount(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                break;\n            case 13:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(null, finishedWork), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));\n                break;\n            case 22:\n                flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n                if (!flags) {\n                    current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;\n                    prevProps = offscreenSubtreeIsHidden;\n                    var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                    offscreenSubtreeIsHidden = flags;\n                    (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    offscreenSubtreeIsHidden = prevProps;\n                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                }\n                break;\n            case 30:\n                break;\n            default:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        }\n        popComponentEffectStart(prevEffectStart);\n    }\n    function detachFiberAfterEffects(fiber) {\n        var alternate = fiber.alternate;\n        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));\n        fiber.child = null;\n        fiber.deletions = null;\n        fiber.sibling = null;\n        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));\n        fiber.stateNode = null;\n        fiber._debugOwner = null;\n        fiber.return = null;\n        fiber.dependencies = null;\n        fiber.memoizedProps = null;\n        fiber.memoizedState = null;\n        fiber.pendingProps = null;\n        fiber.stateNode = null;\n        fiber.updateQueue = null;\n    }\n    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n        for(parent = parent.child; null !== parent;)commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;\n    }\n    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount) try {\n            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        var prevEffectStart = pushComponentEffectStart();\n        switch(deletedFiber.tag){\n            case 26:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));\n                break;\n            case 27:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;\n                isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = !1);\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                runWithFiberInDEV(deletedFiber, releaseSingletonInstance, deletedFiber.stateNode);\n                hostParent = prevHostParent;\n                hostParentIsContainer = prevHostParentIsContainer;\n                break;\n            case 5:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n            case 6:\n                prevHostParent = hostParent;\n                prevHostParentIsContainer = hostParentIsContainer;\n                hostParent = null;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                hostParent = prevHostParent;\n                hostParentIsContainer = prevHostParentIsContainer;\n                if (null !== hostParent) if (hostParentIsContainer) try {\n                    runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);\n                } catch (error) {\n                    captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                }\n                else try {\n                    runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);\n                } catch (error) {\n                    captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                }\n                break;\n            case 18:\n                null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(9 === finishedRoot.nodeType ? finishedRoot.body : \"HTML\" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot, deletedFiber.stateNode), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n                break;\n            case 4:\n                prevHostParent = hostParent;\n                prevHostParentIsContainer = hostParentIsContainer;\n                hostParent = deletedFiber.stateNode.containerInfo;\n                hostParentIsContainer = !0;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                hostParent = prevHostParent;\n                hostParentIsContainer = prevHostParentIsContainer;\n                break;\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 1:\n                offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, \"function\" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 21:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 22:\n                offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                offscreenSubtreeWasHidden = prevHostParent;\n                break;\n            default:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n        popComponentEffectStart(prevEffectStart);\n    }\n    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {\n            runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function getRetryCache(finishedWork) {\n        switch(finishedWork.tag){\n            case 13:\n            case 19:\n                var retryCache = finishedWork.stateNode;\n                null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n                return retryCache;\n            case 22:\n                return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;\n            default:\n                throw Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a bug in React.\");\n        }\n    }\n    function attachSuspenseRetryListeners(finishedWork, wakeables) {\n        var retryCache = getRetryCache(finishedWork);\n        wakeables.forEach(function(wakeable) {\n            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n            if (!retryCache.has(wakeable)) {\n                retryCache.add(wakeable);\n                if (isDevToolsPresent) if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                else throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                wakeable.then(retry, retry);\n            }\n        });\n    }\n    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n            var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], prevEffectStart = pushComponentEffectStart(), parent = returnFiber;\n            a: for(; null !== parent;){\n                switch(parent.tag){\n                    case 27:\n                        if (isSingletonScope(parent.type)) {\n                            hostParent = parent.stateNode;\n                            hostParentIsContainer = !1;\n                            break a;\n                        }\n                        break;\n                    case 5:\n                        hostParent = parent.stateNode;\n                        hostParentIsContainer = !1;\n                        break a;\n                    case 3:\n                    case 4:\n                        hostParent = parent.stateNode.containerInfo;\n                        hostParentIsContainer = !0;\n                        break a;\n                }\n                parent = parent.return;\n            }\n            if (null === hostParent) throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n            commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            hostParent = null;\n            hostParentIsContainer = !1;\n            popComponentEffectStart(prevEffectStart);\n            root = deletedFiber;\n            returnFiber = root.alternate;\n            null !== returnFiber && (returnFiber.return = null);\n            root.return = null;\n        }\n        if (parentFiber.subtreeFlags & 13878) for(parentFiber = parentFiber.child; null !== parentFiber;)commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;\n    }\n    function commitMutationEffectsOnFiber(finishedWork, root) {\n        var prevEffectStart = pushComponentEffectStart(), current = finishedWork.alternate, flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));\n                break;\n            case 1:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));\n                break;\n            case 26:\n                var hoistableRoot = currentHoistableRoot;\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                if (flags & 4) if (root = null !== current ? current.memoizedState : null, flags = finishedWork.memoizedState, null === current) if (null === flags) if (null === finishedWork.stateNode) {\n                    a: {\n                        flags = finishedWork.type;\n                        current = finishedWork.memoizedProps;\n                        root = hoistableRoot.ownerDocument || hoistableRoot;\n                        b: switch(flags){\n                            case \"title\":\n                                hoistableRoot = root.getElementsByTagName(\"title\")[0];\n                                if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute(\"itemprop\")) hoistableRoot = root.createElement(flags), root.head.insertBefore(hoistableRoot, root.querySelector(\"head > title\"));\n                                setInitialProperties(hoistableRoot, flags, current);\n                                hoistableRoot[internalInstanceKey] = finishedWork;\n                                markNodeAsHoistable(hoistableRoot);\n                                flags = hoistableRoot;\n                                break a;\n                            case \"link\":\n                                var maybeNodes = getHydratableHoistableCache(\"link\", \"href\", root).get(flags + (current.href || \"\"));\n                                if (maybeNodes) {\n                                    for(var i = 0; i < maybeNodes.length; i++)if (hoistableRoot = maybeNodes[i], hoistableRoot.getAttribute(\"href\") === (null == current.href || \"\" === current.href ? null : current.href) && hoistableRoot.getAttribute(\"rel\") === (null == current.rel ? null : current.rel) && hoistableRoot.getAttribute(\"title\") === (null == current.title ? null : current.title) && hoistableRoot.getAttribute(\"crossorigin\") === (null == current.crossOrigin ? null : current.crossOrigin)) {\n                                        maybeNodes.splice(i, 1);\n                                        break b;\n                                    }\n                                }\n                                hoistableRoot = root.createElement(flags);\n                                setInitialProperties(hoistableRoot, flags, current);\n                                root.head.appendChild(hoistableRoot);\n                                break;\n                            case \"meta\":\n                                if (maybeNodes = getHydratableHoistableCache(\"meta\", \"content\", root).get(flags + (current.content || \"\"))) {\n                                    for(i = 0; i < maybeNodes.length; i++)if (hoistableRoot = maybeNodes[i], checkAttributeStringCoercion(current.content, \"content\"), hoistableRoot.getAttribute(\"content\") === (null == current.content ? null : \"\" + current.content) && hoistableRoot.getAttribute(\"name\") === (null == current.name ? null : current.name) && hoistableRoot.getAttribute(\"property\") === (null == current.property ? null : current.property) && hoistableRoot.getAttribute(\"http-equiv\") === (null == current.httpEquiv ? null : current.httpEquiv) && hoistableRoot.getAttribute(\"charset\") === (null == current.charSet ? null : current.charSet)) {\n                                        maybeNodes.splice(i, 1);\n                                        break b;\n                                    }\n                                }\n                                hoistableRoot = root.createElement(flags);\n                                setInitialProperties(hoistableRoot, flags, current);\n                                root.head.appendChild(hoistableRoot);\n                                break;\n                            default:\n                                throw Error('getNodesForType encountered a type it did not expect: \"' + flags + '\". This is a bug in React.');\n                        }\n                        hoistableRoot[internalInstanceKey] = finishedWork;\n                        markNodeAsHoistable(hoistableRoot);\n                        flags = hoistableRoot;\n                    }\n                    finishedWork.stateNode = flags;\n                } else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);\n                else finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);\n                else root !== flags ? (null === root ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : root.count--, null === flags ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);\n                break;\n            case 27:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                null !== current && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);\n                break;\n            case 5:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                if (finishedWork.flags & 32) {\n                    root = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, resetTextContent, root);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));\n                flags & 1024 && (needsFormReset = !0, \"form\" !== finishedWork.type && console.error(\"Unexpected host component type. Expected a form. This is a bug in React.\"));\n                break;\n            case 6:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4) {\n                    if (null === finishedWork.stateNode) throw Error(\"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.\");\n                    flags = finishedWork.memoizedProps;\n                    current = null !== current ? current.memoizedProps : flags;\n                    root = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                break;\n            case 3:\n                hoistableRoot = pushNestedEffectDurations();\n                tagCaches = null;\n                maybeNodes = currentHoistableRoot;\n                currentHoistableRoot = getHoistableRoot(root.containerInfo);\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                currentHoistableRoot = maybeNodes;\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4 && null !== current && current.memoizedState.isDehydrated) try {\n                    runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n                needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));\n                root.effectDuration += popNestedEffectDurations(hoistableRoot);\n                break;\n            case 4:\n                flags = currentHoistableRoot;\n                currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                currentHoistableRoot = flags;\n                break;\n            case 12:\n                flags = pushNestedEffectDurations();\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);\n                break;\n            case 13:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 22:\n                hoistableRoot = null !== finishedWork.memoizedState;\n                var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                commitReconciliationEffects(finishedWork);\n                if (flags & 8192) a: for(root = finishedWork.stateNode, root._visibility = hoistableRoot ? root._visibility & ~OffscreenVisible : root._visibility | OffscreenVisible, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root = finishedWork;;){\n                    if (5 === root.tag || 26 === root.tag) {\n                        if (null === current) {\n                            wasHidden = current = root;\n                            try {\n                                maybeNodes = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, maybeNodes) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);\n                            } catch (error) {\n                                captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                            }\n                        }\n                    } else if (6 === root.tag) {\n                        if (null === current) {\n                            wasHidden = root;\n                            try {\n                                i = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, i) : runWithFiberInDEV(wasHidden, unhideTextInstance, i, wasHidden.memoizedProps);\n                            } catch (error) {\n                                captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                            }\n                        }\n                    } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {\n                        root.child.return = root;\n                        root = root.child;\n                        continue;\n                    }\n                    if (root === finishedWork) break a;\n                    for(; null === root.sibling;){\n                        if (null === root.return || root.return === finishedWork) break a;\n                        current === root && (current = null);\n                        root = root.return;\n                    }\n                    current === root && (current = null);\n                    root.sibling.return = root.return;\n                    root = root.sibling;\n                }\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));\n                break;\n            case 19:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 30:\n                break;\n            case 21:\n                break;\n            default:\n                recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);\n        }\n        popComponentEffectStart(prevEffectStart);\n    }\n    function commitReconciliationEffects(finishedWork) {\n        var flags = finishedWork.flags;\n        if (flags & 2) {\n            try {\n                runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n            finishedWork.flags &= -3;\n        }\n        flags & 4096 && (finishedWork.flags &= -4097);\n    }\n    function recursivelyResetForms(parentFiber) {\n        if (parentFiber.subtreeFlags & 1024) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var fiber = parentFiber;\n            recursivelyResetForms(fiber);\n            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function recursivelyTraverseLayoutEffects(root, parentFiber) {\n        if (parentFiber.subtreeFlags & 8772) for(parentFiber = parentFiber.child; null !== parentFiber;)commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disappearLayoutEffects(finishedWork) {\n        var prevEffectStart = pushComponentEffectStart();\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 1:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                var instance = finishedWork.stateNode;\n                \"function\" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 27:\n                runWithFiberInDEV(finishedWork, releaseSingletonInstance, finishedWork.stateNode);\n            case 26:\n            case 5:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 22:\n                null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 30:\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        }\n        popComponentEffectStart(prevEffectStart);\n    }\n    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {\n        var prevEffectStart = pushComponentEffectStart(), flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                commitHookLayoutEffects(finishedWork, Layout);\n                break;\n            case 1:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                current = finishedWork.stateNode;\n                \"function\" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);\n                current = finishedWork.updateQueue;\n                if (null !== current) {\n                    finishedRoot = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 27:\n                commitHostSingletonAcquisition(finishedWork);\n            case 26:\n            case 5:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (includeWorkInProgressEffects && flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                    includeWorkInProgressEffects = finishedWork.stateNode;\n                    includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                break;\n            case 13:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 30:\n                break;\n            default:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n        }\n        popComponentEffectStart(prevEffectStart);\n    }\n    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function commitOffscreenPassiveMountEffects(current, finishedWork) {\n        var previousCache = null;\n        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);\n        current = null;\n        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);\n        current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));\n    }\n    function commitCachePassiveMountEffect(current, finishedWork) {\n        current = null;\n        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);\n        finishedWork = finishedWork.memoizedState.cache;\n        finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));\n    }\n    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n        var prevEffectStart = pushComponentEffectStart(), flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                break;\n            case 1:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                break;\n            case 3:\n                var prevProfilerEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));\n                finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);\n                break;\n            case 12:\n                if (flags & 2048) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                break;\n            case 13:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                break;\n            case 23:\n                break;\n            case 22:\n                prevProfilerEffectDuration = finishedWork.stateNode;\n                var _current = finishedWork.alternate;\n                null !== finishedWork.memoizedState ? prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (prevProfilerEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));\n                flags & 2048 && commitOffscreenPassiveMountEffects(_current, finishedWork);\n                break;\n            case 24:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n        }\n        popComponentEffectStart(prevEffectStart);\n    }\n    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        var prevEffectStart = pushComponentEffectStart(), flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                commitHookPassiveMountEffects(finishedWork, Passive);\n                break;\n            case 23:\n                break;\n            case 22:\n                var _instance2 = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));\n                includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n        }\n        popComponentEffectStart(prevEffectStart);\n    }\n    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case 22:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                    break;\n                case 24:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                    break;\n                default:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n            }\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function recursivelyAccumulateSuspenseyCommit(parentFiber) {\n        if (parentFiber.subtreeFlags & suspenseyCommitFlag) for(parentFiber = parentFiber.child; null !== parentFiber;)accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function accumulateSuspenseyCommitOnFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);\n                break;\n            case 5:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                break;\n            case 3:\n            case 4:\n                var previousHoistableRoot = currentHoistableRoot;\n                currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                currentHoistableRoot = previousHoistableRoot;\n                break;\n            case 22:\n                null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));\n                break;\n            default:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n        }\n    }\n    function detachAlternateSiblings(parentFiber) {\n        var previousFiber = parentFiber.alternate;\n        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {\n            previousFiber.child = null;\n            do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;\n            while (null !== parentFiber);\n        }\n    }\n    function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                popComponentEffectStart(prevEffectStart);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveUnmountOnFiber(finishedWork) {\n        var prevEffectStart = pushComponentEffectStart();\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                break;\n            case 3:\n                var prevProfilerEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);\n                break;\n            case 12:\n                prevProfilerEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevProfilerEffectDuration);\n                break;\n            case 22:\n                prevProfilerEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState && prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevProfilerEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n        }\n        popComponentEffectStart(prevEffectStart);\n    }\n    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                popComponentEffectStart(prevEffectStart);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disconnectPassiveEffect(finishedWork) {\n        var prevEffectStart = pushComponentEffectStart();\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                break;\n            case 22:\n                var instance = finishedWork.stateNode;\n                instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));\n                break;\n            default:\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        }\n        popComponentEffectStart(prevEffectStart);\n    }\n    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor$jscomp$0) {\n        for(; null !== nextEffect;){\n            var fiber = nextEffect, current = fiber, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, prevEffectStart = pushComponentEffectStart();\n            switch(current.tag){\n                case 0:\n                case 11:\n                case 15:\n                    commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                    break;\n                case 23:\n                case 22:\n                    null !== current.memoizedState && null !== current.memoizedState.cachePool && (current = current.memoizedState.cachePool.pool, null != current && retainCache(current));\n                    break;\n                case 24:\n                    releaseCache(current.memoizedState.cache);\n            }\n            popComponentEffectStart(prevEffectStart);\n            prevEffectStart = fiber.child;\n            if (null !== prevEffectStart) prevEffectStart.return = fiber, nextEffect = prevEffectStart;\n            else a: for(fiber = deletedSubtreeRoot; null !== nextEffect;){\n                prevEffectStart = nextEffect;\n                current = prevEffectStart.sibling;\n                nearestMountedAncestor = prevEffectStart.return;\n                detachFiberAfterEffects(prevEffectStart);\n                if (prevEffectStart === fiber) {\n                    nextEffect = null;\n                    break a;\n                }\n                if (null !== current) {\n                    current.return = nearestMountedAncestor;\n                    nextEffect = current;\n                    break a;\n                }\n                nextEffect = nearestMountedAncestor;\n            }\n        }\n    }\n    function onCommitRoot() {\n        commitHooks.forEach(function(commitHook) {\n            return commitHook();\n        });\n    }\n    function isConcurrentActEnvironment() {\n        var isReactActEnvironmentGlobal = \"undefined\" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;\n        isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(\"The current testing environment is not configured to support act(...)\");\n        return isReactActEnvironmentGlobal;\n    }\n    function requestUpdateLane(fiber) {\n        if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n        var transition = ReactSharedInternals.T;\n        return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();\n    }\n    function requestDeferredLane() {\n        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);\n        var suspenseHandler = suspenseHandlerStackCursor.current;\n        null !== suspenseHandler && (suspenseHandler.flags |= 32);\n        return workInProgressDeferredLane;\n    }\n    function scheduleUpdateOnFiber(root, fiber, lane) {\n        isRunningInsertionEffect && console.error(\"useInsertionEffect must not schedule updates.\");\n        isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);\n        if (root === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n        markRootUpdated$1(root, lane);\n        if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {\n            if (isRendering) switch(fiber.tag){\n                case 0:\n                case 11:\n                case 15:\n                    root = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                    didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || \"Unknown\", console.error(\"Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render\", fiber, root, root));\n                    break;\n                case 1:\n                    didWarnAboutUpdateInRender || (console.error(\"Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.\"), didWarnAboutUpdateInRender = !0);\n            }\n        } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);\n    }\n    function performWorkOnRoot(root, lanes, forceSync) {\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0), renderWasConcurrent = shouldTimeSlice;\n        do {\n            if (exitStatus === RootInProgress) {\n                workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, !1);\n                break;\n            } else {\n                forceSync = root.current.alternate;\n                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {\n                    exitStatus = renderRootSync(root, lanes, !1);\n                    renderWasConcurrent = !1;\n                    continue;\n                }\n                if (exitStatus === RootErrored) {\n                    renderWasConcurrent = lanes;\n                    if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;\n                    else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;\n                    if (0 !== errorRetryLanes) {\n                        lanes = errorRetryLanes;\n                        a: {\n                            exitStatus = root;\n                            var errorRetryLanes$jscomp$0 = errorRetryLanes;\n                            errorRetryLanes = workInProgressRootConcurrentErrors;\n                            var wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;\n                            wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);\n                            errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, !1);\n                            if (errorRetryLanes$jscomp$0 !== RootErrored) {\n                                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                                    exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;\n                                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;\n                                    exitStatus = RootSuspendedWithDelay;\n                                    break a;\n                                }\n                                exitStatus = workInProgressRootRecoverableErrors;\n                                workInProgressRootRecoverableErrors = errorRetryLanes;\n                                null !== exitStatus && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = exitStatus : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, exitStatus));\n                            }\n                            exitStatus = errorRetryLanes$jscomp$0;\n                        }\n                        renderWasConcurrent = !1;\n                        if (exitStatus !== RootErrored) continue;\n                    }\n                }\n                if (exitStatus === RootFatalErrored) {\n                    prepareFreshStack(root, 0);\n                    markRootSuspended(root, lanes, 0, !0);\n                    break;\n                }\n                a: {\n                    shouldTimeSlice = root;\n                    switch(exitStatus){\n                        case RootInProgress:\n                        case RootFatalErrored:\n                            throw Error(\"Root did not complete. This is a bug in React.\");\n                        case RootSuspendedWithDelay:\n                            if ((lanes & 4194048) !== lanes) break;\n                        case RootSuspendedAtTheShell:\n                            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                            break a;\n                        case RootErrored:\n                            workInProgressRootRecoverableErrors = null;\n                            break;\n                        case RootSuspended:\n                        case RootCompleted:\n                            break;\n                        default:\n                            throw Error(\"Unknown root exit status.\");\n                    }\n                    if (null !== ReactSharedInternals.actQueue) commitRoot(shouldTimeSlice, forceSync, lanes, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes);\n                    else {\n                        if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {\n                            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                            if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;\n                            shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, exitStatus, THROTTLED_COMMIT, renderStartTime, 0), renderWasConcurrent);\n                            break a;\n                        }\n                        commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, exitStatus, IMMEDIATE_COMMIT, renderStartTime, 0);\n                    }\n                }\n            }\n            break;\n        }while (1);\n        ensureRootIsScheduled(root);\n    }\n    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        root.timeoutHandle = noTimeout;\n        suspendedCommitReason = finishedWork.subtreeFlags;\n        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {\n            if (suspendedState = {\n                stylesheets: null,\n                count: 0,\n                unsuspend: noop\n            }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {\n                root.cancelPendingCommit = suspendedCommitReason(commitRoot.bind(null, root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));\n                markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n                return;\n            }\n        }\n        commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);\n    }\n    function isRenderConsistentWithExternalStores(finishedWork) {\n        for(var node = finishedWork;;){\n            var tag = node.tag;\n            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for(var i = 0; i < tag.length; i++){\n                var check = tag[i], getSnapshot = check.getSnapshot;\n                check = check.value;\n                try {\n                    if (!objectIs(getSnapshot(), check)) return !1;\n                } catch (error) {\n                    return !1;\n                }\n            }\n            tag = node.child;\n            if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;\n            else {\n                if (node === finishedWork) break;\n                for(; null === node.sibling;){\n                    if (null === node.return || node.return === finishedWork) return !0;\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        return !0;\n    }\n    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {\n        suspendedLanes &= ~workInProgressRootPingedLanes;\n        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n        root.suspendedLanes |= suspendedLanes;\n        root.pingedLanes &= ~suspendedLanes;\n        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n        didAttemptEntireTree = root.expirationTimes;\n        for(var lanes = suspendedLanes; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            didAttemptEntireTree[index] = -1;\n            lanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n    }\n    function flushSyncWork$1() {\n        return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;\n    }\n    function resetWorkInProgressStack() {\n        if (null !== workInProgress) {\n            if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;\n            else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;\n            for(; null !== interruptedWork;)unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;\n            workInProgress = null;\n        }\n    }\n    function prepareFreshStack(root, lanes) {\n        var timeoutHandle = root.timeoutHandle;\n        timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));\n        timeoutHandle = root.cancelPendingCommit;\n        null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());\n        resetWorkInProgressStack();\n        workInProgressRoot = root;\n        workInProgress = timeoutHandle = createWorkInProgress(root.current, null);\n        workInProgressRootRenderLanes = lanes;\n        workInProgressSuspendedReason = NotSuspended;\n        workInProgressThrownValue = null;\n        workInProgressRootDidSkipSuspendedSiblings = !1;\n        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        workInProgressRootDidAttachPingListener = !1;\n        workInProgressRootExitStatus = RootInProgress;\n        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;\n        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;\n        workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n        0 !== (lanes & 8) && (lanes |= lanes & 32);\n        var allEntangledLanes = root.entangledLanes;\n        if (0 !== allEntangledLanes) for(root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;){\n            var index = 31 - clz32(allEntangledLanes), lane = 1 << index;\n            lanes |= root[index];\n            allEntangledLanes &= ~lane;\n        }\n        entangledRenderLanes = lanes;\n        finishQueueingConcurrentUpdates();\n        lanes = getCurrentTime();\n        1e3 < lanes - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = lanes);\n        ReactStrictModeWarnings.discardPendingWarnings();\n        return timeoutHandle;\n    }\n    function handleThrow(root, thrownValue) {\n        currentlyRenderingFiber = null;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        ReactSharedInternals.getCurrentStack = null;\n        isRendering = !1;\n        current = null;\n        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && \"object\" === typeof thrownValue && \"function\" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;\n        workInProgressThrownValue = thrownValue;\n        var erroredWork = workInProgress;\n        if (null === erroredWork) workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n        else switch(erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason){\n            case SuspendedOnError:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                break;\n            case SuspendedOnData:\n            case SuspendedOnAction:\n            case SuspendedOnImmediate:\n            case SuspendedOnDeprecatedThrowPromise:\n            case SuspendedAndReadyToContinue:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n    }\n    function shouldRemainOnPreviousScreen() {\n        var handler = suspenseHandlerStackCursor.current;\n        return null === handler ? !0 : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? !0 : !1 : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : !1;\n    }\n    function pushDispatcher() {\n        var prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n    }\n    function pushAsyncDispatcher() {\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        return prevAsyncDispatcher;\n    }\n    function renderDidSuspendDelayIfPossible() {\n        workInProgressRootExitStatus = RootSuspendedWithDelay;\n        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);\n        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n    }\n    function renderRootSync(root, lanes, shouldYieldForPrerendering) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            prepareFreshStack(root, lanes);\n        }\n        markRenderStarted(lanes);\n        lanes = !1;\n        memoizedUpdaters = workInProgressRootExitStatus;\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {\n                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnHydration:\n                        resetWorkInProgressStack();\n                        memoizedUpdaters = RootSuspendedAtTheShell;\n                        break a;\n                    case SuspendedOnImmediate:\n                    case SuspendedOnData:\n                    case SuspendedOnAction:\n                    case SuspendedOnDeprecatedThrowPromise:\n                        null === suspenseHandlerStackCursor.current && (lanes = !0);\n                        var reason = workInProgressSuspendedReason;\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                        if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {\n                            memoizedUpdaters = RootInProgress;\n                            break a;\n                        }\n                        break;\n                    default:\n                        reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                }\n            }\n            workLoopSync();\n            memoizedUpdaters = workInProgressRootExitStatus;\n            break;\n        } catch (thrownValue$8) {\n            handleThrow(root, thrownValue$8);\n        }\n        while (1);\n        lanes && root.shellSuspendCounter++;\n        resetContextDependencies();\n        executionContext = prevExecutionContext;\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        markRenderStopped();\n        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());\n        return memoizedUpdaters;\n    }\n    function workLoopSync() {\n        for(; null !== workInProgress;)performUnitOfWork(workInProgress);\n    }\n    function renderRootConcurrent(root, lanes) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n            prepareFreshStack(root, lanes);\n        } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        markRenderStarted(lanes);\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch(lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason){\n                case SuspendedOnError:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);\n                    break;\n                case SuspendedOnData:\n                case SuspendedOnAction:\n                    if (isThenableResolved(memoizedUpdaters)) {\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        replaySuspendedUnitOfWork(lanes);\n                        break;\n                    }\n                    lanes = function() {\n                        workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);\n                        ensureRootIsScheduled(root);\n                    };\n                    memoizedUpdaters.then(lanes, lanes);\n                    break a;\n                case SuspendedOnImmediate:\n                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                    break a;\n                case SuspendedOnInstance:\n                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                    break a;\n                case SuspendedAndReadyToContinue:\n                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));\n                    break;\n                case SuspendedOnInstanceAndReadyToContinue:\n                    var resource = null;\n                    switch(workInProgress.tag){\n                        case 26:\n                            resource = workInProgress.memoizedState;\n                        case 5:\n                        case 27:\n                            var hostFiber = workInProgress;\n                            if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {\n                                workInProgressSuspendedReason = NotSuspended;\n                                workInProgressThrownValue = null;\n                                var sibling = hostFiber.sibling;\n                                if (null !== sibling) workInProgress = sibling;\n                                else {\n                                    var returnFiber = hostFiber.return;\n                                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;\n                                }\n                                break b;\n                            }\n                            break;\n                        default:\n                            console.error(\"Unexpected type of fiber triggered a suspensey commit. This is a bug in React.\");\n                    }\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);\n                    break;\n                case SuspendedOnDeprecatedThrowPromise:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);\n                    break;\n                case SuspendedOnHydration:\n                    resetWorkInProgressStack();\n                    workInProgressRootExitStatus = RootSuspendedAtTheShell;\n                    break a;\n                default:\n                    throw Error(\"Unexpected SuspendedReason. This is a bug in React.\");\n            }\n            null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();\n            break;\n        } catch (thrownValue$9) {\n            handleThrow(root, thrownValue$9);\n        }\n        while (1);\n        resetContextDependencies();\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        executionContext = prevExecutionContext;\n        if (null !== workInProgress) return null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;\n        markRenderStopped();\n        workInProgressRoot = null;\n        workInProgressRootRenderLanes = 0;\n        finishQueueingConcurrentUpdates();\n        return workInProgressRootExitStatus;\n    }\n    function workLoopConcurrentByScheduler() {\n        for(; null !== workInProgress && !shouldYield();)performUnitOfWork(workInProgress);\n    }\n    function performUnitOfWork(unitOfWork) {\n        var current = unitOfWork.alternate;\n        (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;\n    }\n    function replaySuspendedUnitOfWork(unitOfWork) {\n        var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;\n    }\n    function replayBeginWork(unitOfWork) {\n        var current = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;\n        isProfilingMode && startProfilerTimer(unitOfWork);\n        switch(unitOfWork.tag){\n            case 15:\n            case 0:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);\n                break;\n            case 11:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);\n                break;\n            case 5:\n                resetHooksOnUnwind(unitOfWork);\n            default:\n                unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);\n        }\n        isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);\n        return current;\n    }\n    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {\n        resetContextDependencies();\n        resetHooksOnUnwind(unitOfWork);\n        thenableState$1 = null;\n        thenableIndexCounter$1 = 0;\n        var returnFiber = unitOfWork.return;\n        try {\n            if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                workInProgress = null;\n                return;\n            }\n        } catch (error) {\n            if (null !== returnFiber) throw workInProgress = returnFiber, error;\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n            workInProgress = null;\n            return;\n        }\n        if (unitOfWork.flags & 32768) {\n            if (isHydrating || suspendedReason === SuspendedOnError) root = !0;\n            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;\n            else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);\n            unwindUnitOfWork(unitOfWork, root);\n        } else completeUnitOfWork(unitOfWork);\n    }\n    function completeUnitOfWork(unitOfWork) {\n        var completedWork = unitOfWork;\n        do {\n            if (0 !== (completedWork.flags & 32768)) {\n                unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);\n                return;\n            }\n            var current = completedWork.alternate;\n            unitOfWork = completedWork.return;\n            startProfilerTimer(completedWork);\n            current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);\n            (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);\n            if (null !== current) {\n                workInProgress = current;\n                return;\n            }\n            completedWork = completedWork.sibling;\n            if (null !== completedWork) {\n                workInProgress = completedWork;\n                return;\n            }\n            workInProgress = completedWork = unitOfWork;\n        }while (null !== completedWork);\n        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);\n    }\n    function unwindUnitOfWork(unitOfWork, skipSiblings) {\n        do {\n            var next = unwindWork(unitOfWork.alternate, unitOfWork);\n            if (null !== next) {\n                next.flags &= 32767;\n                workInProgress = next;\n                return;\n            }\n            if ((unitOfWork.mode & ProfileMode) !== NoMode) {\n                stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);\n                next = unitOfWork.actualDuration;\n                for(var child = unitOfWork.child; null !== child;)next += child.actualDuration, child = child.sibling;\n                unitOfWork.actualDuration = next;\n            }\n            next = unitOfWork.return;\n            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);\n            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {\n                workInProgress = unitOfWork;\n                return;\n            }\n            workInProgress = unitOfWork = next;\n        }while (null !== unitOfWork);\n        workInProgressRootExitStatus = RootSuspendedAtTheShell;\n        workInProgress = null;\n    }\n    function commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        root.cancelPendingCommit = null;\n        do flushPendingEffects();\n        while (pendingEffectsStatus !== NO_PENDING_EFFECTS);\n        ReactStrictModeWarnings.flushLegacyContextWarning();\n        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(lanes);\n        if (null === finishedWork) markCommitStopped();\n        else {\n            0 === lanes && console.error(\"finishedLanes should not be empty during a commit. This is a bug in React.\");\n            if (finishedWork === root.current) throw Error(\"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.\");\n            didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;\n            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;\n            markRootFinished(root, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);\n            root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);\n            pendingFinishedWork = finishedWork;\n            pendingEffectsRoot = root;\n            pendingEffectsLanes = lanes;\n            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;\n            pendingPassiveTransitions = transitions;\n            pendingRecoverableErrors = recoverableErrors;\n            0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root.callbackNode = null, root.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {\n                flushPassiveEffects(!0);\n                return null;\n            })) : (root.callbackNode = null, root.callbackPriority = 0);\n            commitStartTime = now();\n            recoverableErrors = 0 !== (finishedWork.flags & 13878);\n            if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {\n                recoverableErrors = ReactSharedInternals.T;\n                ReactSharedInternals.T = null;\n                transitions = ReactDOMSharedInternals.p;\n                ReactDOMSharedInternals.p = DiscreteEventPriority;\n                spawnedLane = executionContext;\n                executionContext |= CommitContext;\n                try {\n                    commitBeforeMutationEffects(root, finishedWork, lanes);\n                } finally{\n                    executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;\n                }\n            }\n            pendingEffectsStatus = PENDING_MUTATION_PHASE;\n            flushMutationEffects();\n            flushLayoutEffects();\n            flushSpawnedWork();\n        }\n    }\n    function flushMutationEffects() {\n        if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {\n            pendingEffectsStatus = NO_PENDING_EFFECTS;\n            var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);\n            if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {\n                rootMutationHasEffect = ReactSharedInternals.T;\n                ReactSharedInternals.T = null;\n                var previousPriority = ReactDOMSharedInternals.p;\n                ReactDOMSharedInternals.p = DiscreteEventPriority;\n                var prevExecutionContext = executionContext;\n                executionContext |= CommitContext;\n                try {\n                    inProgressLanes = lanes;\n                    inProgressRoot = root;\n                    componentEffectStartTime = -1.1;\n                    commitMutationEffectsOnFiber(finishedWork, root);\n                    inProgressRoot = inProgressLanes = null;\n                    lanes = selectionInformation;\n                    var curFocusedElem = getActiveElementDeep(root.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;\n                    if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(priorFocusedElem.ownerDocument.documentElement, priorFocusedElem)) {\n                        if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {\n                            var start = priorSelectionRange.start, end = priorSelectionRange.end;\n                            void 0 === end && (end = start);\n                            if (\"selectionStart\" in priorFocusedElem) priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(end, priorFocusedElem.value.length);\n                            else {\n                                var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;\n                                if (win.getSelection) {\n                                    var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);\n                                    !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);\n                                    var startMarker = getNodeForCharacterOffset(priorFocusedElem, start$jscomp$0), endMarker = getNodeForCharacterOffset(priorFocusedElem, end$jscomp$0);\n                                    if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {\n                                        var range = doc.createRange();\n                                        range.setStart(startMarker.node, startMarker.offset);\n                                        selection.removeAllRanges();\n                                        start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));\n                                    }\n                                }\n                            }\n                        }\n                        doc = [];\n                        for(selection = priorFocusedElem; selection = selection.parentNode;)1 === selection.nodeType && doc.push({\n                            element: selection,\n                            left: selection.scrollLeft,\n                            top: selection.scrollTop\n                        });\n                        \"function\" === typeof priorFocusedElem.focus && priorFocusedElem.focus();\n                        for(priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++){\n                            var info = doc[priorFocusedElem];\n                            info.element.scrollLeft = info.left;\n                            info.element.scrollTop = info.top;\n                        }\n                    }\n                    _enabled = !!eventsEnabled;\n                    selectionInformation = eventsEnabled = null;\n                } finally{\n                    executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;\n                }\n            }\n            root.current = finishedWork;\n            pendingEffectsStatus = PENDING_LAYOUT_PHASE;\n        }\n    }\n    function flushLayoutEffects() {\n        if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {\n            pendingEffectsStatus = NO_PENDING_EFFECTS;\n            var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);\n            if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {\n                rootHasLayoutEffect = ReactSharedInternals.T;\n                ReactSharedInternals.T = null;\n                var previousPriority = ReactDOMSharedInternals.p;\n                ReactDOMSharedInternals.p = DiscreteEventPriority;\n                var prevExecutionContext = executionContext;\n                executionContext |= CommitContext;\n                try {\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(lanes), inProgressLanes = lanes, inProgressRoot = root, componentEffectStartTime = -1.1, commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork), inProgressRoot = inProgressLanes = null, null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped();\n                } finally{\n                    executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;\n                }\n            }\n            pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;\n        }\n    }\n    function flushSpawnedWork() {\n        if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {\n            pendingEffectsStatus = NO_PENDING_EFFECTS;\n            requestPaint();\n            var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors, rootDidHavePassiveEffects = 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);\n            rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root, root.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);\n            var remainingLanes = root.pendingLanes;\n            0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);\n            rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root);\n            rootDidHavePassiveEffects = lanesToEventPriority(lanes);\n            finishedWork = finishedWork.stateNode;\n            if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberRoot) try {\n                var didError = 128 === (finishedWork.current.flags & 128);\n                switch(rootDidHavePassiveEffects){\n                    case DiscreteEventPriority:\n                        var schedulerPriority = ImmediatePriority;\n                        break;\n                    case ContinuousEventPriority:\n                        schedulerPriority = UserBlockingPriority;\n                        break;\n                    case DefaultEventPriority:\n                        schedulerPriority = NormalPriority$1;\n                        break;\n                    case IdleEventPriority:\n                        schedulerPriority = IdlePriority;\n                        break;\n                    default:\n                        schedulerPriority = NormalPriority$1;\n                }\n                injectedHook.onCommitFiberRoot(rendererID, finishedWork, schedulerPriority, didError);\n            } catch (err) {\n                hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n            }\n            isDevToolsPresent && root.memoizedUpdaters.clear();\n            onCommitRoot();\n            if (null !== recoverableErrors) {\n                didError = ReactSharedInternals.T;\n                schedulerPriority = ReactDOMSharedInternals.p;\n                ReactDOMSharedInternals.p = DiscreteEventPriority;\n                ReactSharedInternals.T = null;\n                try {\n                    var onRecoverableError = root.onRecoverableError;\n                    for(finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++){\n                        var recoverableError = recoverableErrors[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);\n                        runWithFiberInDEV(recoverableError.source, onRecoverableError, recoverableError.value, errorInfo);\n                    }\n                } finally{\n                    ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;\n                }\n            }\n            0 !== (pendingEffectsLanes & 3) && flushPendingEffects();\n            ensureRootIsScheduled(root);\n            remainingLanes = root.pendingLanes;\n            0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;\n            flushSyncWorkAcrossRoots_impl(0, !1);\n            markCommitStopped();\n        }\n    }\n    function makeErrorInfo(componentStack) {\n        componentStack = {\n            componentStack: componentStack\n        };\n        Object.defineProperty(componentStack, \"digest\", {\n            get: function() {\n                console.error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');\n            }\n        });\n        return componentStack;\n    }\n    function releaseRootPooledCache(root, remainingLanes) {\n        0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));\n    }\n    function flushPendingEffects(wasDelayedCommit) {\n        flushMutationEffects();\n        flushLayoutEffects();\n        flushSpawnedWork();\n        return flushPassiveEffects(wasDelayedCommit);\n    }\n    function flushPassiveEffects() {\n        if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return !1;\n        var root = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;\n        pendingEffectsRemainingLanes = 0;\n        var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;\n        renderPriority = ReactSharedInternals.T;\n        var previousPriority = ReactDOMSharedInternals.p;\n        try {\n            ReactDOMSharedInternals.p = priority;\n            ReactSharedInternals.T = null;\n            priority = pendingPassiveTransitions;\n            pendingPassiveTransitions = null;\n            var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;\n            pendingEffectsStatus = NO_PENDING_EFFECTS;\n            pendingFinishedWork = pendingEffectsRoot = null;\n            pendingEffectsLanes = 0;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Cannot flush passive effects while already rendering.\");\n            isFlushingPassiveEffects = !0;\n            didScheduleUpdateDuringPassiveEffects = !1;\n            null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n            var prevExecutionContext = executionContext;\n            executionContext |= CommitContext;\n            var finishedWork = root$jscomp$0.current;\n            componentEffectStartTime = -1.1;\n            commitPassiveUnmountOnFiber(finishedWork);\n            var finishedWork$jscomp$0 = root$jscomp$0.current;\n            componentEffectStartTime = -1.1;\n            commitPassiveMountOnFiber(root$jscomp$0, finishedWork$jscomp$0, lanes, priority);\n            null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();\n            commitDoubleInvokeEffectsInDEV(root$jscomp$0);\n            executionContext = prevExecutionContext;\n            flushSyncWorkAcrossRoots_impl(0, !1);\n            didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;\n            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;\n            if (injectedHook && \"function\" === typeof injectedHook.onPostCommitFiberRoot) try {\n                injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);\n            } catch (err) {\n                hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n            }\n            var stateNode = root$jscomp$0.current.stateNode;\n            stateNode.effectDuration = 0;\n            stateNode.passiveEffectDuration = 0;\n            return !0;\n        } finally{\n            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);\n        }\n    }\n    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);\n        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);\n        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));\n    }\n    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n        isRunningInsertionEffect = !1;\n        if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n        else {\n            for(; null !== nearestMountedAncestor;){\n                if (3 === nearestMountedAncestor.tag) {\n                    captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);\n                    return;\n                }\n                if (1 === nearestMountedAncestor.tag) {\n                    var instance = nearestMountedAncestor.stateNode;\n                    if (\"function\" === typeof nearestMountedAncestor.type.getDerivedStateFromError || \"function\" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {\n                        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n                        error = createClassErrorUpdate(2);\n                        instance = enqueueUpdate(nearestMountedAncestor, error, 2);\n                        null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));\n                        return;\n                    }\n                }\n                nearestMountedAncestor = nearestMountedAncestor.return;\n            }\n            console.error(\"Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\\n\\nError message:\\n\\n%s\", error);\n        }\n    }\n    function attachPingListener(root, wakeable, lanes) {\n        var pingCache = root.pingCache;\n        if (null === pingCache) {\n            pingCache = root.pingCache = new PossiblyWeakMap();\n            var threadIDs = new Set();\n            pingCache.set(wakeable, threadIDs);\n        } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));\n        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));\n    }\n    function pingSuspendedRoot(root, wakeable, pingedLanes) {\n        var pingCache = root.pingCache;\n        null !== pingCache && pingCache.delete(wakeable);\n        root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        root.warmLanes &= ~pingedLanes;\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(\"A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\\n\\nWhen testing, code that resolves suspended data should be wrapped into act(...):\\n\\nact(() => {\\n  /* finish loading suspended data */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\");\n        workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));\n        ensureRootIsScheduled(root);\n    }\n    function retryTimedOutBoundary(boundaryFiber, retryLane) {\n        0 === retryLane && (retryLane = claimNextRetryLane());\n        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));\n    }\n    function retryDehydratedSuspenseBoundary(boundaryFiber) {\n        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;\n        null !== suspenseState && (retryLane = suspenseState.retryLane);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function resolveRetryWakeable(boundaryFiber, wakeable) {\n        var retryLane = 0;\n        switch(boundaryFiber.tag){\n            case 13:\n                var retryCache = boundaryFiber.stateNode;\n                var suspenseState = boundaryFiber.memoizedState;\n                null !== suspenseState && (retryLane = suspenseState.retryLane);\n                break;\n            case 19:\n                retryCache = boundaryFiber.stateNode;\n                break;\n            case 22:\n                retryCache = boundaryFiber.stateNode._retryCache;\n                break;\n            default:\n                throw Error(\"Pinged unknown suspense boundary type. This is probably a bug in React.\");\n        }\n        null !== retryCache && retryCache.delete(wakeable);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {\n        if (0 !== (parentFiber.subtreeFlags & 67117056)) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            isStrictModeFiber = isInStrictMode || isStrictModeFiber;\n            22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & NoStrictPassiveEffectsMode) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function doubleInvokeEffectsOnFiber(root, fiber) {\n        var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;\n        setIsStrictModeForDevtools(!0);\n        try {\n            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, !1, 0);\n        } finally{\n            setIsStrictModeForDevtools(!1);\n        }\n    }\n    function commitDoubleInvokeEffectsInDEV(root) {\n        var doubleInvokeEffects = !0;\n        root.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = !1);\n        recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n    }\n    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n        if ((executionContext & RenderContext) === NoContext) {\n            var tag = fiber.tag;\n            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {\n                tag = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n                if (null !== didWarnStateUpdateForNotYetMountedComponent) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;\n                    didWarnStateUpdateForNotYetMountedComponent.add(tag);\n                } else didWarnStateUpdateForNotYetMountedComponent = new Set([\n                    tag\n                ]);\n                runWithFiberInDEV(fiber, function() {\n                    console.error(\"Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.\");\n                });\n            }\n        }\n    }\n    function restorePendingUpdaters(root, lanes) {\n        isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {\n            addFiberToLanesMap(root, schedulingFiber, lanes);\n        });\n    }\n    function scheduleCallback$1(priorityLevel, callback) {\n        var actQueue = ReactSharedInternals.actQueue;\n        return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);\n    }\n    function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {\n            console.error(\"An update to %s inside a test was not wrapped in act(...).\\n\\nWhen testing, code that causes React state updates should be wrapped into act(...):\\n\\nact(() => {\\n  /* fire events that update state */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n        });\n    }\n    function ensureRootIsScheduled(root) {\n        root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);\n        mightHavePendingSyncWork = !0;\n        null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateRootScheduleTask());\n    }\n    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {\n        if (!isFlushingWork && mightHavePendingSyncWork) {\n            isFlushingWork = !0;\n            do {\n                var didPerformSomeWork = !1;\n                for(var root = firstScheduledRoot; null !== root;){\n                    if (!onlyLegacy) if (0 !== syncTransitionLanes) {\n                        var pendingLanes = root.pendingLanes;\n                        if (0 === pendingLanes) var nextLanes = 0;\n                        else {\n                            var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;\n                            nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;\n                            nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);\n                            nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;\n                        }\n                        0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = !1;\n        }\n    }\n    function processRootScheduleInImmediateTask() {\n        processRootScheduleInMicrotask();\n    }\n    function processRootScheduleInMicrotask() {\n        mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;\n        var syncTransitionLanes = 0;\n        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);\n        for(var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;){\n            var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n            if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);\n            else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;\n            root = next;\n        }\n        pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);\n    }\n    function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n        for(var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];\n            if (-1 === expirationTime) {\n                if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);\n            } else expirationTime <= currentTime && (root.expiredLanes |= lane);\n            lanes &= ~lane;\n        }\n        currentTime = workInProgressRoot;\n        suspendedLanes = workInProgressRootRenderLanes;\n        suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout);\n        pingedLanes = root.callbackNode;\n        if (0 === suspendedLanes || root === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;\n        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {\n            currentTime = suspendedLanes & -suspendedLanes;\n            if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode) cancelCallback(pingedLanes);\n            else return currentTime;\n            switch(lanesToEventPriority(suspendedLanes)){\n                case DiscreteEventPriority:\n                case ContinuousEventPriority:\n                    suspendedLanes = UserBlockingPriority;\n                    break;\n                case DefaultEventPriority:\n                    suspendedLanes = NormalPriority$1;\n                    break;\n                case IdleEventPriority:\n                    suspendedLanes = IdlePriority;\n                    break;\n                default:\n                    suspendedLanes = NormalPriority$1;\n            }\n            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);\n            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);\n            root.callbackPriority = currentTime;\n            root.callbackNode = suspendedLanes;\n            return currentTime;\n        }\n        null !== pingedLanes && cancelCallback(pingedLanes);\n        root.callbackPriority = 2;\n        root.callbackNode = null;\n        return 2;\n    }\n    function performWorkOnRootViaSchedulerTask(root, didTimeout) {\n        nestedUpdateScheduled = currentUpdateIsNested = !1;\n        if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return root.callbackNode = null, root.callbackPriority = 0, null;\n        var originalCallbackNode = root.callbackNode;\n        if (flushPendingEffects(!0) && root.callbackNode !== originalCallbackNode) return null;\n        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;\n        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout);\n        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;\n        performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);\n        scheduleTaskForRootDuringMicrotask(root, now$1());\n        return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;\n    }\n    function performSyncWorkOnRoot(root, lanes) {\n        if (flushPendingEffects()) return null;\n        currentUpdateIsNested = nestedUpdateScheduled;\n        nestedUpdateScheduled = !1;\n        performWorkOnRoot(root, lanes, !0);\n    }\n    function cancelCallback(callbackNode) {\n        callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);\n    }\n    function scheduleImmediateRootScheduleTask() {\n        null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {\n            processRootScheduleInMicrotask();\n            return null;\n        });\n        scheduleMicrotask(function() {\n            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();\n        });\n    }\n    function requestTransitionLane() {\n        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());\n        return currentEventTransitionLane;\n    }\n    function coerceFormActionProp(actionProp) {\n        if (null == actionProp || \"symbol\" === typeof actionProp || \"boolean\" === typeof actionProp) return null;\n        if (\"function\" === typeof actionProp) return actionProp;\n        checkAttributeStringCoercion(actionProp, \"action\");\n        return sanitizeURL(\"\" + actionProp);\n    }\n    function createFormDataWithSubmitter(form, submitter) {\n        var temp = submitter.ownerDocument.createElement(\"input\");\n        temp.name = submitter.name;\n        temp.value = submitter.value;\n        form.id && temp.setAttribute(\"form\", form.id);\n        submitter.parentNode.insertBefore(temp, submitter);\n        form = new FormData(form);\n        temp.parentNode.removeChild(temp);\n        return form;\n    }\n    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {\n        if (\"submit\" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {\n            var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action), submitter = nativeEvent.submitter;\n            submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute(\"formAction\"), null !== domEventName && (action = domEventName, submitter = null));\n            var event = new SyntheticEvent(\"action\", \"action\", null, nativeEvent, nativeEventTarget);\n            dispatchQueue.push({\n                event: event,\n                listeners: [\n                    {\n                        instance: null,\n                        listener: function() {\n                            if (nativeEvent.defaultPrevented) {\n                                if (0 !== currentEventTransitionLane) {\n                                    var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), pendingState = {\n                                        pending: !0,\n                                        data: formData,\n                                        method: nativeEventTarget.method,\n                                        action: action\n                                    };\n                                    Object.freeze(pendingState);\n                                    startHostTransition(maybeTargetInst, pendingState, null, formData);\n                                }\n                            } else \"function\" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), pendingState = {\n                                pending: !0,\n                                data: formData,\n                                method: nativeEventTarget.method,\n                                action: action\n                            }, Object.freeze(pendingState), startHostTransition(maybeTargetInst, pendingState, action, formData));\n                        },\n                        currentTarget: nativeEventTarget\n                    }\n                ]\n            });\n        }\n    }\n    function executeDispatch(event, listener, currentTarget) {\n        event.currentTarget = currentTarget;\n        try {\n            listener(event);\n        } catch (error) {\n            reportGlobalError(error);\n        }\n        event.currentTarget = null;\n    }\n    function processDispatchQueue(dispatchQueue, eventSystemFlags) {\n        eventSystemFlags = 0 !== (eventSystemFlags & 4);\n        for(var i = 0; i < dispatchQueue.length; i++){\n            var _dispatchQueue$i = dispatchQueue[i];\n            a: {\n                var previousInstance = void 0, event = _dispatchQueue$i.event;\n                _dispatchQueue$i = _dispatchQueue$i.listeners;\n                if (eventSystemFlags) for(var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--){\n                    var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;\n                    _dispatchListeners$i = _dispatchListeners$i.listener;\n                    if (instance !== previousInstance && event.isPropagationStopped()) break a;\n                    null !== instance ? runWithFiberInDEV(instance, executeDispatch, event, _dispatchListeners$i, currentTarget) : executeDispatch(event, _dispatchListeners$i, currentTarget);\n                    previousInstance = instance;\n                }\n                else for(i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++){\n                    _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];\n                    instance = _dispatchListeners$i.instance;\n                    currentTarget = _dispatchListeners$i.currentTarget;\n                    _dispatchListeners$i = _dispatchListeners$i.listener;\n                    if (instance !== previousInstance && event.isPropagationStopped()) break a;\n                    null !== instance ? runWithFiberInDEV(instance, executeDispatch, event, _dispatchListeners$i, currentTarget) : executeDispatch(event, _dispatchListeners$i, currentTarget);\n                    previousInstance = instance;\n                }\n            }\n        }\n    }\n    function listenToNonDelegatedEvent(domEventName, targetElement) {\n        nonDelegatedEvents.has(domEventName) || console.error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". This is a bug in React. Please file an issue.', domEventName);\n        var listenerSet = targetElement[internalEventHandlersKey];\n        void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = new Set());\n        var listenerSetKey = domEventName + \"__bubble\";\n        listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, !1), listenerSet.add(listenerSetKey));\n    }\n    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {\n        nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);\n        var eventSystemFlags = 0;\n        isCapturePhaseListener && (eventSystemFlags |= 4);\n        addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);\n    }\n    function listenToAllSupportedEvents(rootContainerElement) {\n        if (!rootContainerElement[listeningMarker]) {\n            rootContainerElement[listeningMarker] = !0;\n            allNativeEvents.forEach(function(domEventName) {\n                \"selectionchange\" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, !1, rootContainerElement), listenToNativeEvent(domEventName, !0, rootContainerElement));\n            });\n            var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;\n            null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = !0, listenToNativeEvent(\"selectionchange\", !1, ownerDocument));\n        }\n    }\n    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {\n        switch(getEventPriority(domEventName)){\n            case DiscreteEventPriority:\n                var listenerWrapper = dispatchDiscreteEvent;\n                break;\n            case ContinuousEventPriority:\n                listenerWrapper = dispatchContinuousEvent;\n                break;\n            default:\n                listenerWrapper = dispatchEvent;\n        }\n        eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);\n        listenerWrapper = void 0;\n        !passiveBrowserEventsSupported || \"touchstart\" !== domEventName && \"touchmove\" !== domEventName && \"wheel\" !== domEventName || (listenerWrapper = !0);\n        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {\n            capture: !0,\n            passive: listenerWrapper\n        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !0) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {\n            passive: listenerWrapper\n        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);\n    }\n    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {\n        var ancestorInst = targetInst$jscomp$0;\n        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0) a: for(;;){\n            if (null === targetInst$jscomp$0) return;\n            var nodeTag = targetInst$jscomp$0.tag;\n            if (3 === nodeTag || 4 === nodeTag) {\n                var container = targetInst$jscomp$0.stateNode.containerInfo;\n                if (container === targetContainer) break;\n                if (4 === nodeTag) for(nodeTag = targetInst$jscomp$0.return; null !== nodeTag;){\n                    var grandTag = nodeTag.tag;\n                    if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer) return;\n                    nodeTag = nodeTag.return;\n                }\n                for(; null !== container;){\n                    nodeTag = getClosestInstanceFromNode(container);\n                    if (null === nodeTag) return;\n                    grandTag = nodeTag.tag;\n                    if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {\n                        targetInst$jscomp$0 = ancestorInst = nodeTag;\n                        continue a;\n                    }\n                    container = container.parentNode;\n                }\n            }\n            targetInst$jscomp$0 = targetInst$jscomp$0.return;\n        }\n        batchedUpdates$1(function() {\n            var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];\n            a: {\n                var reactName = topLevelEventsToReactNames.get(domEventName);\n                if (void 0 !== reactName) {\n                    var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;\n                    switch(domEventName){\n                        case \"keypress\":\n                            if (0 === getEventCharCode(nativeEvent)) break a;\n                        case \"keydown\":\n                        case \"keyup\":\n                            SyntheticEventCtor = SyntheticKeyboardEvent;\n                            break;\n                        case \"focusin\":\n                            reactEventType = \"focus\";\n                            SyntheticEventCtor = SyntheticFocusEvent;\n                            break;\n                        case \"focusout\":\n                            reactEventType = \"blur\";\n                            SyntheticEventCtor = SyntheticFocusEvent;\n                            break;\n                        case \"beforeblur\":\n                        case \"afterblur\":\n                            SyntheticEventCtor = SyntheticFocusEvent;\n                            break;\n                        case \"click\":\n                            if (2 === nativeEvent.button) break a;\n                        case \"auxclick\":\n                        case \"dblclick\":\n                        case \"mousedown\":\n                        case \"mousemove\":\n                        case \"mouseup\":\n                        case \"mouseout\":\n                        case \"mouseover\":\n                        case \"contextmenu\":\n                            SyntheticEventCtor = SyntheticMouseEvent;\n                            break;\n                        case \"drag\":\n                        case \"dragend\":\n                        case \"dragenter\":\n                        case \"dragexit\":\n                        case \"dragleave\":\n                        case \"dragover\":\n                        case \"dragstart\":\n                        case \"drop\":\n                            SyntheticEventCtor = SyntheticDragEvent;\n                            break;\n                        case \"touchcancel\":\n                        case \"touchend\":\n                        case \"touchmove\":\n                        case \"touchstart\":\n                            SyntheticEventCtor = SyntheticTouchEvent;\n                            break;\n                        case ANIMATION_END:\n                        case ANIMATION_ITERATION:\n                        case ANIMATION_START:\n                            SyntheticEventCtor = SyntheticAnimationEvent;\n                            break;\n                        case TRANSITION_END:\n                            SyntheticEventCtor = SyntheticTransitionEvent;\n                            break;\n                        case \"scroll\":\n                        case \"scrollend\":\n                            SyntheticEventCtor = SyntheticUIEvent;\n                            break;\n                        case \"wheel\":\n                            SyntheticEventCtor = SyntheticWheelEvent;\n                            break;\n                        case \"copy\":\n                        case \"cut\":\n                        case \"paste\":\n                            SyntheticEventCtor = SyntheticClipboardEvent;\n                            break;\n                        case \"gotpointercapture\":\n                        case \"lostpointercapture\":\n                        case \"pointercancel\":\n                        case \"pointerdown\":\n                        case \"pointermove\":\n                        case \"pointerout\":\n                        case \"pointerover\":\n                        case \"pointerup\":\n                            SyntheticEventCtor = SyntheticPointerEvent;\n                            break;\n                        case \"toggle\":\n                        case \"beforetoggle\":\n                            SyntheticEventCtor = SyntheticToggleEvent;\n                    }\n                    var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && (\"scroll\" === domEventName || \"scrollend\" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + \"Capture\" : null : reactName;\n                    inCapturePhase = [];\n                    for(var instance = targetInst, lastHostComponent; null !== instance;){\n                        var _instance2 = instance;\n                        lastHostComponent = _instance2.stateNode;\n                        _instance2 = _instance2.tag;\n                        5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(createDispatchListener(instance, _instance2, lastHostComponent)));\n                        if (accumulateTargetOnly) break;\n                        instance = instance.return;\n                    }\n                    0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({\n                        event: reactName,\n                        listeners: inCapturePhase\n                    }));\n                }\n            }\n            if (0 === (eventSystemFlags & 7)) {\n                a: {\n                    reactName = \"mouseover\" === domEventName || \"pointerover\" === domEventName;\n                    SyntheticEventCtor = \"mouseout\" === domEventName || \"pointerout\" === domEventName;\n                    if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey])) break a;\n                    if (SyntheticEventCtor || reactName) {\n                        reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;\n                        if (SyntheticEventCtor) {\n                            if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase)) reactEventType = null;\n                        } else SyntheticEventCtor = null, reactEventType = targetInst;\n                        if (SyntheticEventCtor !== reactEventType) {\n                            inCapturePhase = SyntheticMouseEvent;\n                            _instance2 = \"onMouseLeave\";\n                            reactEventName = \"onMouseEnter\";\n                            instance = \"mouse\";\n                            if (\"pointerout\" === domEventName || \"pointerover\" === domEventName) inCapturePhase = SyntheticPointerEvent, _instance2 = \"onPointerLeave\", reactEventName = \"onPointerEnter\", instance = \"pointer\";\n                            accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);\n                            lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);\n                            reactName = new inCapturePhase(_instance2, instance + \"leave\", SyntheticEventCtor, nativeEvent, nativeEventTarget);\n                            reactName.target = accumulateTargetOnly;\n                            reactName.relatedTarget = lastHostComponent;\n                            _instance2 = null;\n                            getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + \"enter\", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);\n                            accumulateTargetOnly = _instance2;\n                            if (SyntheticEventCtor && reactEventType) b: {\n                                inCapturePhase = SyntheticEventCtor;\n                                reactEventName = reactEventType;\n                                instance = 0;\n                                for(lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))instance++;\n                                lastHostComponent = 0;\n                                for(_instance2 = reactEventName; _instance2; _instance2 = getParent(_instance2))lastHostComponent++;\n                                for(; 0 < instance - lastHostComponent;)inCapturePhase = getParent(inCapturePhase), instance--;\n                                for(; 0 < lastHostComponent - instance;)reactEventName = getParent(reactEventName), lastHostComponent--;\n                                for(; instance--;){\n                                    if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate) break b;\n                                    inCapturePhase = getParent(inCapturePhase);\n                                    reactEventName = getParent(reactEventName);\n                                }\n                                inCapturePhase = null;\n                            }\n                            else inCapturePhase = null;\n                            null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, !1);\n                            null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, !0);\n                        }\n                    }\n                }\n                a: {\n                    reactName = targetInst ? getNodeFromInstance(targetInst) : window;\n                    SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();\n                    if (\"select\" === SyntheticEventCtor || \"input\" === SyntheticEventCtor && \"file\" === reactName.type) var getTargetInstFunc = getTargetInstForChangeEvent;\n                    else if (isTextInputElement(reactName)) if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n                    else {\n                        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n                        var handleEventFunc = handleEventsForInputEventPolyfill;\n                    }\n                    else SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || \"input\" !== SyntheticEventCtor.toLowerCase() || \"checkbox\" !== reactName.type && \"radio\" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;\n                    if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {\n                        createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);\n                        break a;\n                    }\n                    handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);\n                    \"focusout\" === domEventName && targetInst && \"number\" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, \"number\", reactName.value);\n                }\n                handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;\n                switch(domEventName){\n                    case \"focusin\":\n                        if (isTextInputElement(handleEventFunc) || \"true\" === handleEventFunc.contentEditable) activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;\n                        break;\n                    case \"focusout\":\n                        lastSelection = activeElementInst = activeElement = null;\n                        break;\n                    case \"mousedown\":\n                        mouseDown = !0;\n                        break;\n                    case \"contextmenu\":\n                    case \"mouseup\":\n                    case \"dragend\":\n                        mouseDown = !1;\n                        constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n                        break;\n                    case \"selectionchange\":\n                        if (skipSelectionChangeEvent) break;\n                    case \"keydown\":\n                    case \"keyup\":\n                        constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n                }\n                var fallbackData;\n                if (canUseCompositionEvent) b: {\n                    switch(domEventName){\n                        case \"compositionstart\":\n                            var eventType = \"onCompositionStart\";\n                            break b;\n                        case \"compositionend\":\n                            eventType = \"onCompositionEnd\";\n                            break b;\n                        case \"compositionupdate\":\n                            eventType = \"onCompositionUpdate\";\n                            break b;\n                    }\n                    eventType = void 0;\n                }\n                else isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = \"onCompositionEnd\") : \"keydown\" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = \"onCompositionStart\");\n                eventType && (useFallbackCompositionData && \"ko\" !== nativeEvent.locale && (isComposing || \"onCompositionStart\" !== eventType ? \"onCompositionEnd\" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = \"value\" in root ? root.value : root.textContent, isComposing = !0)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({\n                    event: eventType,\n                    listeners: handleEventFunc\n                }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));\n                if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent)) eventType = accumulateTwoPhaseListeners(targetInst, \"onBeforeInput\"), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(\"onBeforeInput\", \"beforeinput\", null, nativeEvent, nativeEventTarget), dispatchQueue.push({\n                    event: handleEventFunc,\n                    listeners: eventType\n                }), handleEventFunc.data = fallbackData);\n                extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n            }\n            processDispatchQueue(dispatchQueue, eventSystemFlags);\n        });\n    }\n    function createDispatchListener(instance, listener, currentTarget) {\n        return {\n            instance: instance,\n            listener: listener,\n            currentTarget: currentTarget\n        };\n    }\n    function accumulateTwoPhaseListeners(targetFiber, reactName) {\n        for(var captureName = reactName + \"Capture\", listeners = []; null !== targetFiber;){\n            var _instance3 = targetFiber, stateNode = _instance3.stateNode;\n            _instance3 = _instance3.tag;\n            5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(createDispatchListener(targetFiber, _instance3, stateNode)), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(createDispatchListener(targetFiber, _instance3, stateNode)));\n            if (3 === targetFiber.tag) return listeners;\n            targetFiber = targetFiber.return;\n        }\n        return [];\n    }\n    function getParent(inst) {\n        if (null === inst) return null;\n        do inst = inst.return;\n        while (inst && 5 !== inst.tag && 27 !== inst.tag);\n        return inst ? inst : null;\n    }\n    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {\n        for(var registrationName = event._reactName, listeners = []; null !== target && target !== common;){\n            var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;\n            _instance4 = _instance4.tag;\n            if (null !== alternate && alternate === common) break;\n            5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(createDispatchListener(target, stateNode, alternate))));\n            target = target.return;\n        }\n        0 !== listeners.length && dispatchQueue.push({\n            event: event,\n            listeners: listeners\n        });\n    }\n    function validatePropertiesInDevelopment(type, props) {\n        validateProperties$2(type, props);\n        \"input\" !== type && \"textarea\" !== type && \"select\" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = !0, \"select\" === type && props.multiple ? console.error(\"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\", type) : console.error(\"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\", type));\n        var eventRegistry = {\n            registrationNameDependencies: registrationNameDependencies,\n            possibleRegistrationNames: possibleRegistrationNames\n        };\n        isCustomElement(type) || \"string\" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);\n        props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(\"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\");\n    }\n    function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {\n        serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));\n    }\n    function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {\n        attributeNames.forEach(function(attributeName) {\n            serverDifferences[getPropNameFromAttributeName(attributeName)] = \"style\" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);\n        });\n    }\n    function warnForInvalidEventListener(registrationName, listener) {\n        !1 === listener ? console.error(\"Expected `%s` listener to be a function, instead got `false`.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.\", registrationName, registrationName, registrationName) : console.error(\"Expected `%s` listener to be a function, instead got a value of `%s` type.\", registrationName, typeof listener);\n    }\n    function normalizeHTML(parent, html) {\n        parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName) : parent.ownerDocument.createElement(parent.tagName);\n        parent.innerHTML = html;\n        return parent.innerHTML;\n    }\n    function normalizeMarkupForTextOrAttribute(markup) {\n        willCoercionThrow(markup) && (console.error(\"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.\", typeName(markup)), testStringCoercion(markup));\n        return (\"string\" === typeof markup ? markup : \"\" + markup).replace(NORMALIZE_NEWLINES_REGEX, \"\\n\").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, \"\");\n    }\n    function checkForUnmatchedText(serverText, clientText) {\n        clientText = normalizeMarkupForTextOrAttribute(clientText);\n        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;\n    }\n    function noop$1() {}\n    function setProp(domElement, tag, key, value, props, prevValue) {\n        switch(key){\n            case \"children\":\n                if (\"string\" === typeof value) validateTextNesting(value, tag, !1), \"body\" === tag || \"textarea\" === tag && \"\" === value || setTextContent(domElement, value);\n                else if (\"number\" === typeof value || \"bigint\" === typeof value) validateTextNesting(\"\" + value, tag, !1), \"body\" !== tag && setTextContent(domElement, \"\" + value);\n                break;\n            case \"className\":\n                setValueForKnownAttribute(domElement, \"class\", value);\n                break;\n            case \"tabIndex\":\n                setValueForKnownAttribute(domElement, \"tabindex\", value);\n                break;\n            case \"dir\":\n            case \"role\":\n            case \"viewBox\":\n            case \"width\":\n            case \"height\":\n                setValueForKnownAttribute(domElement, key, value);\n                break;\n            case \"style\":\n                setValueForStyles(domElement, value, prevValue);\n                break;\n            case \"data\":\n                if (\"object\" !== tag) {\n                    setValueForKnownAttribute(domElement, \"data\", value);\n                    break;\n                }\n            case \"src\":\n            case \"href\":\n                if (\"\" === value && (\"a\" !== tag || \"href\" !== key)) {\n                    \"src\" === key ? console.error('An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key) : console.error('An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key);\n                    domElement.removeAttribute(key);\n                    break;\n                }\n                if (null == value || \"function\" === typeof value || \"symbol\" === typeof value || \"boolean\" === typeof value) {\n                    domElement.removeAttribute(key);\n                    break;\n                }\n                checkAttributeStringCoercion(value, key);\n                value = sanitizeURL(\"\" + value);\n                domElement.setAttribute(key, value);\n                break;\n            case \"action\":\n            case \"formAction\":\n                null != value && (\"form\" === tag ? \"formAction\" === key ? console.error(\"You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>.\") : \"function\" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error(\"Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.\")), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error(\"Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window.\"))) : \"input\" === tag || \"button\" === tag ? \"action\" === key ? console.error(\"You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>.\") : \"input\" !== tag || \"submit\" === props.type || \"image\" === props.type || didWarnFormActionType ? \"button\" !== tag || null == props.type || \"submit\" === props.type || didWarnFormActionType ? \"function\" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = !0, console.error('Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.')), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error(\"Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.\")), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error(\"Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window.\"))) : (didWarnFormActionType = !0, console.error('A button can only specify a formAction along with type=\"submit\" or no type.')) : (didWarnFormActionType = !0, console.error('An input can only specify a formAction along with type=\"submit\" or type=\"image\".')) : \"action\" === key ? console.error(\"You can only pass the action prop to <form>.\") : console.error(\"You can only pass the formAction prop to <input> or <button>.\"));\n                if (\"function\" === typeof value) {\n                    domElement.setAttribute(key, \"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')\");\n                    break;\n                } else \"function\" === typeof prevValue && (\"formAction\" === key ? (\"input\" !== tag && setProp(domElement, tag, \"name\", props.name, props, null), setProp(domElement, tag, \"formEncType\", props.formEncType, props, null), setProp(domElement, tag, \"formMethod\", props.formMethod, props, null), setProp(domElement, tag, \"formTarget\", props.formTarget, props, null)) : (setProp(domElement, tag, \"encType\", props.encType, props, null), setProp(domElement, tag, \"method\", props.method, props, null), setProp(domElement, tag, \"target\", props.target, props, null)));\n                if (null == value || \"symbol\" === typeof value || \"boolean\" === typeof value) {\n                    domElement.removeAttribute(key);\n                    break;\n                }\n                checkAttributeStringCoercion(value, key);\n                value = sanitizeURL(\"\" + value);\n                domElement.setAttribute(key, value);\n                break;\n            case \"onClick\":\n                null != value && (\"function\" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);\n                break;\n            case \"onScroll\":\n                null != value && (\"function\" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent(\"scroll\", domElement));\n                break;\n            case \"onScrollEnd\":\n                null != value && (\"function\" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent(\"scrollend\", domElement));\n                break;\n            case \"dangerouslySetInnerHTML\":\n                if (null != value) {\n                    if (\"object\" !== typeof value || !(\"__html\" in value)) throw Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\");\n                    key = value.__html;\n                    if (null != key) {\n                        if (null != props.children) throw Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                        domElement.innerHTML = key;\n                    }\n                }\n                break;\n            case \"multiple\":\n                domElement.multiple = value && \"function\" !== typeof value && \"symbol\" !== typeof value;\n                break;\n            case \"muted\":\n                domElement.muted = value && \"function\" !== typeof value && \"symbol\" !== typeof value;\n                break;\n            case \"suppressContentEditableWarning\":\n            case \"suppressHydrationWarning\":\n            case \"defaultValue\":\n            case \"defaultChecked\":\n            case \"innerHTML\":\n            case \"ref\":\n                break;\n            case \"autoFocus\":\n                break;\n            case \"xlinkHref\":\n                if (null == value || \"function\" === typeof value || \"boolean\" === typeof value || \"symbol\" === typeof value) {\n                    domElement.removeAttribute(\"xlink:href\");\n                    break;\n                }\n                checkAttributeStringCoercion(value, key);\n                key = sanitizeURL(\"\" + value);\n                domElement.setAttributeNS(xlinkNamespace, \"xlink:href\", key);\n                break;\n            case \"contentEditable\":\n            case \"spellCheck\":\n            case \"draggable\":\n            case \"value\":\n            case \"autoReverse\":\n            case \"externalResourcesRequired\":\n            case \"focusable\":\n            case \"preserveAlpha\":\n                null != value && \"function\" !== typeof value && \"symbol\" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, \"\" + value)) : domElement.removeAttribute(key);\n                break;\n            case \"inert\":\n                \"\" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = !0, console.error(\"Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.\", key));\n            case \"allowFullScreen\":\n            case \"async\":\n            case \"autoPlay\":\n            case \"controls\":\n            case \"default\":\n            case \"defer\":\n            case \"disabled\":\n            case \"disablePictureInPicture\":\n            case \"disableRemotePlayback\":\n            case \"formNoValidate\":\n            case \"hidden\":\n            case \"loop\":\n            case \"noModule\":\n            case \"noValidate\":\n            case \"open\":\n            case \"playsInline\":\n            case \"readOnly\":\n            case \"required\":\n            case \"reversed\":\n            case \"scoped\":\n            case \"seamless\":\n            case \"itemScope\":\n                value && \"function\" !== typeof value && \"symbol\" !== typeof value ? domElement.setAttribute(key, \"\") : domElement.removeAttribute(key);\n                break;\n            case \"capture\":\n            case \"download\":\n                !0 === value ? domElement.setAttribute(key, \"\") : !1 !== value && null != value && \"function\" !== typeof value && \"symbol\" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);\n                break;\n            case \"cols\":\n            case \"rows\":\n            case \"size\":\n            case \"span\":\n                null != value && \"function\" !== typeof value && \"symbol\" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);\n                break;\n            case \"rowSpan\":\n            case \"start\":\n                null == value || \"function\" === typeof value || \"symbol\" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));\n                break;\n            case \"popover\":\n                listenToNonDelegatedEvent(\"beforetoggle\", domElement);\n                listenToNonDelegatedEvent(\"toggle\", domElement);\n                setValueForAttribute(domElement, \"popover\", value);\n                break;\n            case \"xlinkActuate\":\n                setValueForNamespacedAttribute(domElement, xlinkNamespace, \"xlink:actuate\", value);\n                break;\n            case \"xlinkArcrole\":\n                setValueForNamespacedAttribute(domElement, xlinkNamespace, \"xlink:arcrole\", value);\n                break;\n            case \"xlinkRole\":\n                setValueForNamespacedAttribute(domElement, xlinkNamespace, \"xlink:role\", value);\n                break;\n            case \"xlinkShow\":\n                setValueForNamespacedAttribute(domElement, xlinkNamespace, \"xlink:show\", value);\n                break;\n            case \"xlinkTitle\":\n                setValueForNamespacedAttribute(domElement, xlinkNamespace, \"xlink:title\", value);\n                break;\n            case \"xlinkType\":\n                setValueForNamespacedAttribute(domElement, xlinkNamespace, \"xlink:type\", value);\n                break;\n            case \"xmlBase\":\n                setValueForNamespacedAttribute(domElement, xmlNamespace, \"xml:base\", value);\n                break;\n            case \"xmlLang\":\n                setValueForNamespacedAttribute(domElement, xmlNamespace, \"xml:lang\", value);\n                break;\n            case \"xmlSpace\":\n                setValueForNamespacedAttribute(domElement, xmlNamespace, \"xml:space\", value);\n                break;\n            case \"is\":\n                null != prevValue && console.error('Cannot update the \"is\" prop after it has been initialized.');\n                setValueForAttribute(domElement, \"is\", value);\n                break;\n            case \"innerText\":\n            case \"textContent\":\n                break;\n            case \"popoverTarget\":\n                didWarnPopoverTargetObject || null == value || \"object\" !== typeof value || (didWarnPopoverTargetObject = !0, console.error(\"The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.\", value));\n            default:\n                !(2 < key.length) || \"o\" !== key[0] && \"O\" !== key[0] || \"n\" !== key[1] && \"N\" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && \"function\" !== typeof value && warnForInvalidEventListener(key, value);\n        }\n    }\n    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {\n        switch(key){\n            case \"style\":\n                setValueForStyles(domElement, value, prevValue);\n                break;\n            case \"dangerouslySetInnerHTML\":\n                if (null != value) {\n                    if (\"object\" !== typeof value || !(\"__html\" in value)) throw Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\");\n                    key = value.__html;\n                    if (null != key) {\n                        if (null != props.children) throw Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                        domElement.innerHTML = key;\n                    }\n                }\n                break;\n            case \"children\":\n                \"string\" === typeof value ? setTextContent(domElement, value) : (\"number\" === typeof value || \"bigint\" === typeof value) && setTextContent(domElement, \"\" + value);\n                break;\n            case \"onScroll\":\n                null != value && (\"function\" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent(\"scroll\", domElement));\n                break;\n            case \"onScrollEnd\":\n                null != value && (\"function\" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent(\"scrollend\", domElement));\n                break;\n            case \"onClick\":\n                null != value && (\"function\" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);\n                break;\n            case \"suppressContentEditableWarning\":\n            case \"suppressHydrationWarning\":\n            case \"innerHTML\":\n            case \"ref\":\n                break;\n            case \"innerText\":\n            case \"textContent\":\n                break;\n            default:\n                if (registrationNameDependencies.hasOwnProperty(key)) null != value && \"function\" !== typeof value && warnForInvalidEventListener(key, value);\n                else a: {\n                    if (\"o\" === key[0] && \"n\" === key[1] && (props = key.endsWith(\"Capture\"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, \"function\" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), \"function\" === typeof value)) {\n                        \"function\" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));\n                        domElement.addEventListener(tag, value, props);\n                        break a;\n                    }\n                    key in domElement ? domElement[key] = value : !0 === value ? domElement.setAttribute(key, \"\") : setValueForAttribute(domElement, key, value);\n                }\n        }\n    }\n    function setInitialProperties(domElement, tag, props) {\n        validatePropertiesInDevelopment(tag, props);\n        switch(tag){\n            case \"div\":\n            case \"span\":\n            case \"svg\":\n            case \"path\":\n            case \"a\":\n            case \"g\":\n            case \"p\":\n            case \"li\":\n                break;\n            case \"img\":\n                listenToNonDelegatedEvent(\"error\", domElement);\n                listenToNonDelegatedEvent(\"load\", domElement);\n                var hasSrc = !1, hasSrcSet = !1, propKey;\n                for(propKey in props)if (props.hasOwnProperty(propKey)) {\n                    var propValue = props[propKey];\n                    if (null != propValue) switch(propKey){\n                        case \"src\":\n                            hasSrc = !0;\n                            break;\n                        case \"srcSet\":\n                            hasSrcSet = !0;\n                            break;\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw Error(tag + \" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\");\n                        default:\n                            setProp(domElement, tag, propKey, propValue, props, null);\n                    }\n                }\n                hasSrcSet && setProp(domElement, tag, \"srcSet\", props.srcSet, props, null);\n                hasSrc && setProp(domElement, tag, \"src\", props.src, props, null);\n                return;\n            case \"input\":\n                checkControlledValueProps(\"input\", props);\n                listenToNonDelegatedEvent(\"invalid\", domElement);\n                var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;\n                for(hasSrc in props)if (props.hasOwnProperty(hasSrc)) {\n                    var _propValue = props[hasSrc];\n                    if (null != _propValue) switch(hasSrc){\n                        case \"name\":\n                            hasSrcSet = _propValue;\n                            break;\n                        case \"type\":\n                            propValue = _propValue;\n                            break;\n                        case \"checked\":\n                            checked = _propValue;\n                            break;\n                        case \"defaultChecked\":\n                            defaultChecked = _propValue;\n                            break;\n                        case \"value\":\n                            propKey = _propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = _propValue;\n                            break;\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            if (null != _propValue) throw Error(tag + \" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\");\n                            break;\n                        default:\n                            setProp(domElement, tag, hasSrc, _propValue, props, null);\n                    }\n                }\n                validateInputProps(domElement, props);\n                initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, !1);\n                track(domElement);\n                return;\n            case \"select\":\n                checkControlledValueProps(\"select\", props);\n                listenToNonDelegatedEvent(\"invalid\", domElement);\n                hasSrc = propValue = propKey = null;\n                for(hasSrcSet in props)if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue)) switch(hasSrcSet){\n                    case \"value\":\n                        propKey = defaultValue;\n                        break;\n                    case \"defaultValue\":\n                        propValue = defaultValue;\n                        break;\n                    case \"multiple\":\n                        hasSrc = defaultValue;\n                    default:\n                        setProp(domElement, tag, hasSrcSet, defaultValue, props, null);\n                }\n                validateSelectProps(domElement, props);\n                tag = propKey;\n                props = propValue;\n                domElement.multiple = !!hasSrc;\n                null != tag ? updateOptions(domElement, !!hasSrc, tag, !1) : null != props && updateOptions(domElement, !!hasSrc, props, !0);\n                return;\n            case \"textarea\":\n                checkControlledValueProps(\"textarea\", props);\n                listenToNonDelegatedEvent(\"invalid\", domElement);\n                propKey = hasSrcSet = hasSrc = null;\n                for(propValue in props)if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue)) switch(propValue){\n                    case \"value\":\n                        hasSrc = defaultValue;\n                        break;\n                    case \"defaultValue\":\n                        hasSrcSet = defaultValue;\n                        break;\n                    case \"children\":\n                        propKey = defaultValue;\n                        break;\n                    case \"dangerouslySetInnerHTML\":\n                        if (null != defaultValue) throw Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n                        break;\n                    default:\n                        setProp(domElement, tag, propValue, defaultValue, props, null);\n                }\n                validateTextareaProps(domElement, props);\n                initTextarea(domElement, hasSrc, hasSrcSet, propKey);\n                track(domElement);\n                return;\n            case \"option\":\n                validateOptionProps(domElement, props);\n                for(checked in props)if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc)) switch(checked){\n                    case \"selected\":\n                        domElement.selected = hasSrc && \"function\" !== typeof hasSrc && \"symbol\" !== typeof hasSrc;\n                        break;\n                    default:\n                        setProp(domElement, tag, checked, hasSrc, props, null);\n                }\n                return;\n            case \"dialog\":\n                listenToNonDelegatedEvent(\"beforetoggle\", domElement);\n                listenToNonDelegatedEvent(\"toggle\", domElement);\n                listenToNonDelegatedEvent(\"cancel\", domElement);\n                listenToNonDelegatedEvent(\"close\", domElement);\n                break;\n            case \"iframe\":\n            case \"object\":\n                listenToNonDelegatedEvent(\"load\", domElement);\n                break;\n            case \"video\":\n            case \"audio\":\n                for(hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);\n                break;\n            case \"image\":\n                listenToNonDelegatedEvent(\"error\", domElement);\n                listenToNonDelegatedEvent(\"load\", domElement);\n                break;\n            case \"details\":\n                listenToNonDelegatedEvent(\"toggle\", domElement);\n                break;\n            case \"embed\":\n            case \"source\":\n            case \"link\":\n                listenToNonDelegatedEvent(\"error\", domElement), listenToNonDelegatedEvent(\"load\", domElement);\n            case \"area\":\n            case \"base\":\n            case \"br\":\n            case \"col\":\n            case \"hr\":\n            case \"keygen\":\n            case \"meta\":\n            case \"param\":\n            case \"track\":\n            case \"wbr\":\n            case \"menuitem\":\n                for(defaultChecked in props)if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc)) switch(defaultChecked){\n                    case \"children\":\n                    case \"dangerouslySetInnerHTML\":\n                        throw Error(tag + \" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\");\n                    default:\n                        setProp(domElement, tag, defaultChecked, hasSrc, props, null);\n                }\n                return;\n            default:\n                if (isCustomElement(tag)) {\n                    for(_propValue in props)props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(domElement, tag, _propValue, hasSrc, props, void 0));\n                    return;\n                }\n        }\n        for(defaultValue in props)props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));\n    }\n    function updateProperties(domElement, tag, lastProps, nextProps) {\n        validatePropertiesInDevelopment(tag, nextProps);\n        switch(tag){\n            case \"div\":\n            case \"span\":\n            case \"svg\":\n            case \"path\":\n            case \"a\":\n            case \"g\":\n            case \"p\":\n            case \"li\":\n                break;\n            case \"input\":\n                var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;\n                for(propKey in lastProps){\n                    var lastProp = lastProps[propKey];\n                    if (lastProps.hasOwnProperty(propKey) && null != lastProp) switch(propKey){\n                        case \"checked\":\n                            break;\n                        case \"value\":\n                            break;\n                        case \"defaultValue\":\n                            lastDefaultValue = lastProp;\n                        default:\n                            nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);\n                    }\n                }\n                for(var _propKey8 in nextProps){\n                    var propKey = nextProps[_propKey8];\n                    lastProp = lastProps[_propKey8];\n                    if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp)) switch(_propKey8){\n                        case \"type\":\n                            type = propKey;\n                            break;\n                        case \"name\":\n                            name = propKey;\n                            break;\n                        case \"checked\":\n                            checked = propKey;\n                            break;\n                        case \"defaultChecked\":\n                            defaultChecked = propKey;\n                            break;\n                        case \"value\":\n                            value = propKey;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propKey;\n                            break;\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            if (null != propKey) throw Error(tag + \" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\");\n                            break;\n                        default:\n                            propKey !== lastProp && setProp(domElement, tag, _propKey8, propKey, nextProps, lastProp);\n                    }\n                }\n                tag = \"checkbox\" === lastProps.type || \"radio\" === lastProps.type ? null != lastProps.checked : null != lastProps.value;\n                nextProps = \"checkbox\" === nextProps.type || \"radio\" === nextProps.type ? null != nextProps.checked : null != nextProps.value;\n                tag || !nextProps || didWarnUncontrolledToControlled || (console.error(\"A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components\"), didWarnUncontrolledToControlled = !0);\n                !tag || nextProps || didWarnControlledToUncontrolled || (console.error(\"A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components\"), didWarnControlledToUncontrolled = !0);\n                updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);\n                return;\n            case \"select\":\n                propKey = value = defaultValue = _propKey8 = null;\n                for(type in lastProps)if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue) switch(type){\n                    case \"value\":\n                        break;\n                    case \"multiple\":\n                        propKey = lastDefaultValue;\n                    default:\n                        nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);\n                }\n                for(name in nextProps)if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue)) switch(name){\n                    case \"value\":\n                        _propKey8 = type;\n                        break;\n                    case \"defaultValue\":\n                        defaultValue = type;\n                        break;\n                    case \"multiple\":\n                        value = type;\n                    default:\n                        type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);\n                }\n                nextProps = defaultValue;\n                tag = value;\n                lastProps = propKey;\n                null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, !1) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, !0) : updateOptions(domElement, !!tag, tag ? [] : \"\", !1));\n                return;\n            case \"textarea\":\n                propKey = _propKey8 = null;\n                for(defaultValue in lastProps)if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue)) switch(defaultValue){\n                    case \"value\":\n                        break;\n                    case \"children\":\n                        break;\n                    default:\n                        setProp(domElement, tag, defaultValue, null, nextProps, name);\n                }\n                for(value in nextProps)if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type)) switch(value){\n                    case \"value\":\n                        _propKey8 = name;\n                        break;\n                    case \"defaultValue\":\n                        propKey = name;\n                        break;\n                    case \"children\":\n                        break;\n                    case \"dangerouslySetInnerHTML\":\n                        if (null != name) throw Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n                        break;\n                    default:\n                        name !== type && setProp(domElement, tag, value, name, nextProps, type);\n                }\n                updateTextarea(domElement, _propKey8, propKey);\n                return;\n            case \"option\":\n                for(var _propKey13 in lastProps)if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13)) switch(_propKey13){\n                    case \"selected\":\n                        domElement.selected = !1;\n                        break;\n                    default:\n                        setProp(domElement, tag, _propKey13, null, nextProps, _propKey8);\n                }\n                for(lastDefaultValue in nextProps)if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey)) switch(lastDefaultValue){\n                    case \"selected\":\n                        domElement.selected = _propKey8 && \"function\" !== typeof _propKey8 && \"symbol\" !== typeof _propKey8;\n                        break;\n                    default:\n                        setProp(domElement, tag, lastDefaultValue, _propKey8, nextProps, propKey);\n                }\n                return;\n            case \"img\":\n            case \"link\":\n            case \"area\":\n            case \"base\":\n            case \"br\":\n            case \"col\":\n            case \"embed\":\n            case \"hr\":\n            case \"keygen\":\n            case \"meta\":\n            case \"param\":\n            case \"source\":\n            case \"track\":\n            case \"wbr\":\n            case \"menuitem\":\n                for(var _propKey15 in lastProps)_propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(domElement, tag, _propKey15, null, nextProps, _propKey8);\n                for(checked in nextProps)if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey)) switch(checked){\n                    case \"children\":\n                    case \"dangerouslySetInnerHTML\":\n                        if (null != _propKey8) throw Error(tag + \" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\");\n                        break;\n                    default:\n                        setProp(domElement, tag, checked, _propKey8, nextProps, propKey);\n                }\n                return;\n            default:\n                if (isCustomElement(tag)) {\n                    for(var _propKey17 in lastProps)_propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(domElement, tag, _propKey17, void 0, nextProps, _propKey8);\n                    for(defaultChecked in nextProps)_propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(domElement, tag, defaultChecked, _propKey8, nextProps, propKey);\n                    return;\n                }\n        }\n        for(var _propKey19 in lastProps)_propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);\n        for(lastProp in nextProps)_propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);\n    }\n    function getPropNameFromAttributeName(attrName) {\n        switch(attrName){\n            case \"class\":\n                return \"className\";\n            case \"for\":\n                return \"htmlFor\";\n            default:\n                return attrName;\n        }\n    }\n    function getStylesObjectFromElement(domElement) {\n        var serverValueInObjectForm = {};\n        domElement = domElement.style;\n        for(var i = 0; i < domElement.length; i++){\n            var styleName = domElement[i];\n            serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);\n        }\n        return serverValueInObjectForm;\n    }\n    function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {\n        if (null != value$jscomp$0 && \"object\" !== typeof value$jscomp$0) console.error(\"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\");\n        else {\n            var clientValue;\n            var delimiter = clientValue = \"\", styleName;\n            for(styleName in value$jscomp$0)if (value$jscomp$0.hasOwnProperty(styleName)) {\n                var value = value$jscomp$0[styleName];\n                null != value && \"boolean\" !== typeof value && \"\" !== value && (0 === styleName.indexOf(\"--\") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + \":\" + (\"\" + value).trim()) : \"number\" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern$1, \"-ms-\") + \":\" + (\"\" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern$1, \"-ms-\") + \":\" + value + \"px\", delimiter = \";\");\n            }\n            clientValue = clientValue || null;\n            value$jscomp$0 = domElement.getAttribute(\"style\");\n            value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));\n        }\n    }\n    function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {\n        extraAttributes.delete(attributeName);\n        domElement = domElement.getAttribute(attributeName);\n        if (null === domElement) switch(typeof value){\n            case \"undefined\":\n            case \"function\":\n            case \"symbol\":\n            case \"boolean\":\n                return;\n        }\n        else if (null != value) switch(typeof value){\n            case \"function\":\n            case \"symbol\":\n            case \"boolean\":\n                break;\n            default:\n                if (checkAttributeStringCoercion(value, propKey), domElement === \"\" + value) return;\n        }\n        warnForPropDifference(propKey, domElement, value, serverDifferences);\n    }\n    function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {\n        extraAttributes.delete(attributeName);\n        domElement = domElement.getAttribute(attributeName);\n        if (null === domElement) {\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            if (!value) return;\n        } else switch(typeof value){\n            case \"function\":\n            case \"symbol\":\n                break;\n            default:\n                if (value) return;\n        }\n        warnForPropDifference(propKey, domElement, value, serverDifferences);\n    }\n    function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {\n        extraAttributes.delete(attributeName);\n        domElement = domElement.getAttribute(attributeName);\n        if (null === domElement) switch(typeof value){\n            case \"undefined\":\n            case \"function\":\n            case \"symbol\":\n                return;\n        }\n        else if (null != value) switch(typeof value){\n            case \"function\":\n            case \"symbol\":\n                break;\n            default:\n                if (checkAttributeStringCoercion(value, attributeName), domElement === \"\" + value) return;\n        }\n        warnForPropDifference(propKey, domElement, value, serverDifferences);\n    }\n    function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {\n        extraAttributes.delete(attributeName);\n        domElement = domElement.getAttribute(attributeName);\n        if (null === domElement) switch(typeof value){\n            case \"undefined\":\n            case \"function\":\n            case \"symbol\":\n            case \"boolean\":\n                return;\n            default:\n                if (isNaN(value)) return;\n        }\n        else if (null != value) switch(typeof value){\n            case \"function\":\n            case \"symbol\":\n            case \"boolean\":\n                break;\n            default:\n                if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === \"\" + value)) return;\n        }\n        warnForPropDifference(propKey, domElement, value, serverDifferences);\n    }\n    function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {\n        extraAttributes.delete(attributeName);\n        domElement = domElement.getAttribute(attributeName);\n        if (null === domElement) switch(typeof value){\n            case \"undefined\":\n            case \"function\":\n            case \"symbol\":\n            case \"boolean\":\n                return;\n        }\n        else if (null != value) switch(typeof value){\n            case \"function\":\n            case \"symbol\":\n            case \"boolean\":\n                break;\n            default:\n                if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL(\"\" + value), domElement === attributeName) return;\n        }\n        warnForPropDifference(propKey, domElement, value, serverDifferences);\n    }\n    function diffHydratedProperties(domElement, tag, props, hostContext) {\n        for(var serverDifferences = {}, extraAttributes = new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++)switch(attributes[i].name.toLowerCase()){\n            case \"value\":\n                break;\n            case \"checked\":\n                break;\n            case \"selected\":\n                break;\n            default:\n                extraAttributes.add(attributes[i].name);\n        }\n        if (isCustomElement(tag)) for(var propKey in props){\n            if (props.hasOwnProperty(propKey)) {\n                var value = props[propKey];\n                if (null != value) {\n                    if (registrationNameDependencies.hasOwnProperty(propKey)) \"function\" !== typeof value && warnForInvalidEventListener(propKey, value);\n                    else if (!0 !== props.suppressHydrationWarning) switch(propKey){\n                        case \"children\":\n                            \"string\" !== typeof value && \"number\" !== typeof value || warnForPropDifference(\"children\", domElement.textContent, value, serverDifferences);\n                            continue;\n                        case \"suppressContentEditableWarning\":\n                        case \"suppressHydrationWarning\":\n                        case \"defaultValue\":\n                        case \"defaultChecked\":\n                        case \"innerHTML\":\n                        case \"ref\":\n                            continue;\n                        case \"dangerouslySetInnerHTML\":\n                            attributes = domElement.innerHTML;\n                            value = value ? value.__html : void 0;\n                            null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(propKey, attributes, value, serverDifferences));\n                            continue;\n                        case \"style\":\n                            extraAttributes.delete(propKey);\n                            diffHydratedStyles(domElement, value, serverDifferences);\n                            continue;\n                        case \"offsetParent\":\n                        case \"offsetTop\":\n                        case \"offsetLeft\":\n                        case \"offsetWidth\":\n                        case \"offsetHeight\":\n                        case \"isContentEditable\":\n                        case \"outerText\":\n                        case \"outerHTML\":\n                            extraAttributes.delete(propKey.toLowerCase());\n                            console.error(\"Assignment to read-only property will result in a no-op: `%s`\", propKey);\n                            continue;\n                        case \"className\":\n                            extraAttributes.delete(\"class\");\n                            attributes = getValueForAttributeOnCustomComponent(domElement, \"class\", value);\n                            warnForPropDifference(\"className\", attributes, value, serverDifferences);\n                            continue;\n                        default:\n                            hostContext.context === HostContextNamespaceNone && \"svg\" !== tag && \"math\" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(domElement, propKey, value), warnForPropDifference(propKey, attributes, value, serverDifferences);\n                    }\n                }\n            }\n        }\n        else for(value in props)if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {\n            if (registrationNameDependencies.hasOwnProperty(value)) \"function\" !== typeof propKey && warnForInvalidEventListener(value, propKey);\n            else if (!0 !== props.suppressHydrationWarning) switch(value){\n                case \"children\":\n                    \"string\" !== typeof propKey && \"number\" !== typeof propKey || warnForPropDifference(\"children\", domElement.textContent, propKey, serverDifferences);\n                    continue;\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"value\":\n                case \"checked\":\n                case \"selected\":\n                case \"defaultValue\":\n                case \"defaultChecked\":\n                case \"innerHTML\":\n                case \"ref\":\n                    continue;\n                case \"dangerouslySetInnerHTML\":\n                    attributes = domElement.innerHTML;\n                    propKey = propKey ? propKey.__html : void 0;\n                    null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = {\n                        __html: attributes\n                    }));\n                    continue;\n                case \"className\":\n                    hydrateAttribute(domElement, value, \"class\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"tabIndex\":\n                    hydrateAttribute(domElement, value, \"tabindex\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"style\":\n                    extraAttributes.delete(value);\n                    diffHydratedStyles(domElement, propKey, serverDifferences);\n                    continue;\n                case \"multiple\":\n                    extraAttributes.delete(value);\n                    warnForPropDifference(value, domElement.multiple, propKey, serverDifferences);\n                    continue;\n                case \"muted\":\n                    extraAttributes.delete(value);\n                    warnForPropDifference(value, domElement.muted, propKey, serverDifferences);\n                    continue;\n                case \"autoFocus\":\n                    extraAttributes.delete(\"autofocus\");\n                    warnForPropDifference(value, domElement.autofocus, propKey, serverDifferences);\n                    continue;\n                case \"data\":\n                    if (\"object\" !== tag) {\n                        extraAttributes.delete(value);\n                        attributes = domElement.getAttribute(\"data\");\n                        warnForPropDifference(value, attributes, propKey, serverDifferences);\n                        continue;\n                    }\n                case \"src\":\n                case \"href\":\n                    if (!(\"\" !== propKey || \"a\" === tag && \"href\" === value || \"object\" === tag && \"data\" === value)) {\n                        \"src\" === value ? console.error('An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value) : console.error('An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value);\n                        continue;\n                    }\n                    hydrateSanitizedAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"action\":\n                case \"formAction\":\n                    attributes = domElement.getAttribute(value);\n                    if (\"function\" === typeof propKey) {\n                        extraAttributes.delete(value.toLowerCase());\n                        \"formAction\" === value ? (extraAttributes.delete(\"name\"), extraAttributes.delete(\"formenctype\"), extraAttributes.delete(\"formmethod\"), extraAttributes.delete(\"formtarget\")) : (extraAttributes.delete(\"enctype\"), extraAttributes.delete(\"method\"), extraAttributes.delete(\"target\"));\n                        continue;\n                    } else if (attributes === EXPECTED_FORM_ACTION_URL) {\n                        extraAttributes.delete(value.toLowerCase());\n                        warnForPropDifference(value, \"function\", propKey, serverDifferences);\n                        continue;\n                    }\n                    hydrateSanitizedAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"xlinkHref\":\n                    hydrateSanitizedAttribute(domElement, value, \"xlink:href\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"contentEditable\":\n                    hydrateBooleanishAttribute(domElement, value, \"contenteditable\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"spellCheck\":\n                    hydrateBooleanishAttribute(domElement, value, \"spellcheck\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"draggable\":\n                case \"autoReverse\":\n                case \"externalResourcesRequired\":\n                case \"focusable\":\n                case \"preserveAlpha\":\n                    hydrateBooleanishAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"allowFullScreen\":\n                case \"async\":\n                case \"autoPlay\":\n                case \"controls\":\n                case \"default\":\n                case \"defer\":\n                case \"disabled\":\n                case \"disablePictureInPicture\":\n                case \"disableRemotePlayback\":\n                case \"formNoValidate\":\n                case \"hidden\":\n                case \"loop\":\n                case \"noModule\":\n                case \"noValidate\":\n                case \"open\":\n                case \"playsInline\":\n                case \"readOnly\":\n                case \"required\":\n                case \"reversed\":\n                case \"scoped\":\n                case \"seamless\":\n                case \"itemScope\":\n                    hydrateBooleanAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"capture\":\n                case \"download\":\n                    a: {\n                        i = domElement;\n                        var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;\n                        extraAttributes.delete(attributeName);\n                        i = i.getAttribute(attributeName);\n                        if (null === i) switch(typeof propKey){\n                            case \"undefined\":\n                            case \"function\":\n                            case \"symbol\":\n                                break a;\n                            default:\n                                if (!1 === propKey) break a;\n                        }\n                        else if (null != propKey) switch(typeof propKey){\n                            case \"function\":\n                            case \"symbol\":\n                                break;\n                            case \"boolean\":\n                                if (!0 === propKey && \"\" === i) break a;\n                                break;\n                            default:\n                                if (checkAttributeStringCoercion(propKey, attributes), i === \"\" + propKey) break a;\n                        }\n                        warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);\n                    }\n                    continue;\n                case \"cols\":\n                case \"rows\":\n                case \"size\":\n                case \"span\":\n                    a: {\n                        i = domElement;\n                        attributeName = attributes = value;\n                        serverDifferences$jscomp$0 = serverDifferences;\n                        extraAttributes.delete(attributeName);\n                        i = i.getAttribute(attributeName);\n                        if (null === i) switch(typeof propKey){\n                            case \"undefined\":\n                            case \"function\":\n                            case \"symbol\":\n                            case \"boolean\":\n                                break a;\n                            default:\n                                if (isNaN(propKey) || 1 > propKey) break a;\n                        }\n                        else if (null != propKey) switch(typeof propKey){\n                            case \"function\":\n                            case \"symbol\":\n                            case \"boolean\":\n                                break;\n                            default:\n                                if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === \"\" + propKey)) break a;\n                        }\n                        warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);\n                    }\n                    continue;\n                case \"rowSpan\":\n                    hydrateNumericAttribute(domElement, value, \"rowspan\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"start\":\n                    hydrateNumericAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"xHeight\":\n                    hydrateAttribute(domElement, value, \"x-height\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"xlinkActuate\":\n                    hydrateAttribute(domElement, value, \"xlink:actuate\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"xlinkArcrole\":\n                    hydrateAttribute(domElement, value, \"xlink:arcrole\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"xlinkRole\":\n                    hydrateAttribute(domElement, value, \"xlink:role\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"xlinkShow\":\n                    hydrateAttribute(domElement, value, \"xlink:show\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"xlinkTitle\":\n                    hydrateAttribute(domElement, value, \"xlink:title\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"xlinkType\":\n                    hydrateAttribute(domElement, value, \"xlink:type\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"xmlBase\":\n                    hydrateAttribute(domElement, value, \"xml:base\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"xmlLang\":\n                    hydrateAttribute(domElement, value, \"xml:lang\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"xmlSpace\":\n                    hydrateAttribute(domElement, value, \"xml:space\", propKey, extraAttributes, serverDifferences);\n                    continue;\n                case \"inert\":\n                    \"\" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = !0, console.error(\"Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.\", value));\n                    hydrateBooleanAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);\n                    continue;\n                default:\n                    if (!(2 < value.length) || \"o\" !== value[0] && \"O\" !== value[0] || \"n\" !== value[1] && \"N\" !== value[1]) {\n                        i = getAttributeAlias(value);\n                        attributes = !1;\n                        hostContext.context === HostContextNamespaceNone && \"svg\" !== tag && \"math\" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(attributeName) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = !0, extraAttributes.delete(attributeName)), extraAttributes.delete(i));\n                        a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0)) if (attributeName.hasAttribute(serverDifferences$jscomp$0)) attributeName = attributeName.getAttribute(serverDifferences$jscomp$0), checkAttributeStringCoercion(i, serverDifferences$jscomp$0), i = attributeName === \"\" + i ? i : attributeName;\n                        else {\n                            switch(typeof i){\n                                case \"function\":\n                                case \"symbol\":\n                                    break a;\n                                case \"boolean\":\n                                    if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), \"data-\" !== attributeName && \"aria-\" !== attributeName) break a;\n                            }\n                            i = void 0 === i ? void 0 : null;\n                        }\n                        else i = void 0;\n                        attributes || warnForPropDifference(value, i, propKey, serverDifferences);\n                    }\n            }\n        }\n        0 < extraAttributes.size && !0 !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);\n        return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;\n    }\n    function propNamesListJoin(list, combinator) {\n        switch(list.length){\n            case 0:\n                return \"\";\n            case 1:\n                return list[0];\n            case 2:\n                return list[0] + \" \" + combinator + \" \" + list[1];\n            default:\n                return list.slice(0, -1).join(\", \") + \", \" + combinator + \" \" + list[list.length - 1];\n        }\n    }\n    function getOwnerDocumentFromRootContainer(rootContainerElement) {\n        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;\n    }\n    function getOwnHostContext(namespaceURI) {\n        switch(namespaceURI){\n            case SVG_NAMESPACE:\n                return HostContextNamespaceSvg;\n            case MATH_NAMESPACE:\n                return HostContextNamespaceMath;\n            default:\n                return HostContextNamespaceNone;\n        }\n    }\n    function getChildHostContextProd(parentNamespace, type) {\n        if (parentNamespace === HostContextNamespaceNone) switch(type){\n            case \"svg\":\n                return HostContextNamespaceSvg;\n            case \"math\":\n                return HostContextNamespaceMath;\n            default:\n                return HostContextNamespaceNone;\n        }\n        return parentNamespace === HostContextNamespaceSvg && \"foreignObject\" === type ? HostContextNamespaceNone : parentNamespace;\n    }\n    function shouldSetTextContent(type, props) {\n        return \"textarea\" === type || \"noscript\" === type || \"string\" === typeof props.children || \"number\" === typeof props.children || \"bigint\" === typeof props.children || \"object\" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;\n    }\n    function shouldAttemptEagerTransition() {\n        var event = window.event;\n        if (event && \"popstate\" === event.type) {\n            if (event === currentPopstateTransitionEvent) return !1;\n            currentPopstateTransitionEvent = event;\n            return !0;\n        }\n        currentPopstateTransitionEvent = null;\n        return !1;\n    }\n    function handleErrorInNextTick(error) {\n        setTimeout(function() {\n            throw error;\n        });\n    }\n    function commitMount(domElement, type, newProps) {\n        switch(type){\n            case \"button\":\n            case \"input\":\n            case \"select\":\n            case \"textarea\":\n                newProps.autoFocus && domElement.focus();\n                break;\n            case \"img\":\n                newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);\n        }\n    }\n    function commitUpdate(domElement, type, oldProps, newProps) {\n        updateProperties(domElement, type, oldProps, newProps);\n        domElement[internalPropsKey] = newProps;\n    }\n    function resetTextContent(domElement) {\n        setTextContent(domElement, \"\");\n    }\n    function commitTextUpdate(textInstance, oldText, newText) {\n        textInstance.nodeValue = newText;\n    }\n    function warnForReactChildrenConflict(container) {\n        if (!container.__reactWarnedAboutChildrenConflict) {\n            var props = container[internalPropsKey] || null;\n            if (null !== props) {\n                var fiber = getInstanceFromNode(container);\n                null !== fiber && (\"string\" === typeof props.children || \"number\" === typeof props.children ? (container.__reactWarnedAboutChildrenConflict = !0, runWithFiberInDEV(fiber, function() {\n                    console.error('Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets \"children\" text content using React. It should be a leaf with no children. Otherwise it\\'s ambiguous which children should be used.');\n                })) : null != props.dangerouslySetInnerHTML && (container.__reactWarnedAboutChildrenConflict = !0, runWithFiberInDEV(fiber, function() {\n                    console.error('Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets \"dangerouslySetInnerHTML\" using React. It should be a leaf with no children. Otherwise it\\'s ambiguous which children should be used.');\n                })));\n            }\n        }\n    }\n    function isSingletonScope(type) {\n        return \"head\" === type;\n    }\n    function removeChild(parentInstance, child) {\n        parentInstance.removeChild(child);\n    }\n    function removeChildFromContainer(container, child) {\n        (9 === container.nodeType ? container.body : \"HTML\" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);\n    }\n    function clearSuspenseBoundary(parentInstance, suspenseInstance) {\n        var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;\n        do {\n            var nextNode = node.nextSibling;\n            parentInstance.removeChild(node);\n            if (nextNode && 8 === nextNode.nodeType) if (node = nextNode.data, node === SUSPENSE_END_DATA) {\n                if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {\n                    node = possiblePreambleContribution;\n                    var ownerDocument = parentInstance.ownerDocument;\n                    node & PREAMBLE_CONTRIBUTION_HTML && releaseSingletonInstance(ownerDocument.documentElement);\n                    node & PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(ownerDocument.body);\n                    if (node & PREAMBLE_CONTRIBUTION_HEAD) for(node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument;){\n                        var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;\n                        ownerDocument[internalHoistableMarker] || \"SCRIPT\" === nodeName || \"STYLE\" === nodeName || \"LINK\" === nodeName && \"stylesheet\" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);\n                        ownerDocument = nextNode$jscomp$0;\n                    }\n                }\n                if (0 === depth) {\n                    parentInstance.removeChild(nextNode);\n                    retryIfBlockedOn(suspenseInstance);\n                    return;\n                }\n                depth--;\n            } else node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_FALLBACK_START_DATA ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;\n            else possiblePreambleContribution = 0;\n            node = nextNode;\n        }while (node);\n        retryIfBlockedOn(suspenseInstance);\n    }\n    function hideInstance(instance) {\n        instance = instance.style;\n        \"function\" === typeof instance.setProperty ? instance.setProperty(\"display\", \"none\", \"important\") : instance.display = \"none\";\n    }\n    function hideTextInstance(textInstance) {\n        textInstance.nodeValue = \"\";\n    }\n    function unhideInstance(instance, props) {\n        props = props[STYLE];\n        props = void 0 !== props && null !== props && props.hasOwnProperty(\"display\") ? props.display : null;\n        instance.style.display = null == props || \"boolean\" === typeof props ? \"\" : (\"\" + props).trim();\n    }\n    function unhideTextInstance(textInstance, text) {\n        textInstance.nodeValue = text;\n    }\n    function clearContainerSparingly(container) {\n        var nextNode = container.firstChild;\n        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);\n        for(; nextNode;){\n            var node = nextNode;\n            nextNode = nextNode.nextSibling;\n            switch(node.nodeName){\n                case \"HTML\":\n                case \"HEAD\":\n                case \"BODY\":\n                    clearContainerSparingly(node);\n                    detachDeletedInstance(node);\n                    continue;\n                case \"SCRIPT\":\n                case \"STYLE\":\n                    continue;\n                case \"LINK\":\n                    if (\"stylesheet\" === node.rel.toLowerCase()) continue;\n            }\n            container.removeChild(node);\n        }\n    }\n    function canHydrateInstance(instance, type, props, inRootOrSingleton) {\n        for(; 1 === instance.nodeType;){\n            var anyProps = props;\n            if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {\n                if (!inRootOrSingleton && (\"INPUT\" !== instance.nodeName || \"hidden\" !== instance.type)) break;\n            } else if (!inRootOrSingleton) if (\"input\" === type && \"hidden\" === instance.type) {\n                checkAttributeStringCoercion(anyProps.name, \"name\");\n                var name = null == anyProps.name ? null : \"\" + anyProps.name;\n                if (\"hidden\" === anyProps.type && instance.getAttribute(\"name\") === name) return instance;\n            } else return instance;\n            else if (!instance[internalHoistableMarker]) switch(type){\n                case \"meta\":\n                    if (!instance.hasAttribute(\"itemprop\")) break;\n                    return instance;\n                case \"link\":\n                    name = instance.getAttribute(\"rel\");\n                    if (\"stylesheet\" === name && instance.hasAttribute(\"data-precedence\")) break;\n                    else if (name !== anyProps.rel || instance.getAttribute(\"href\") !== (null == anyProps.href || \"\" === anyProps.href ? null : anyProps.href) || instance.getAttribute(\"crossorigin\") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute(\"title\") !== (null == anyProps.title ? null : anyProps.title)) break;\n                    return instance;\n                case \"style\":\n                    if (instance.hasAttribute(\"data-precedence\")) break;\n                    return instance;\n                case \"script\":\n                    name = instance.getAttribute(\"src\");\n                    if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute(\"type\") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute(\"crossorigin\") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute(\"async\") && !instance.hasAttribute(\"itemprop\")) break;\n                    return instance;\n                default:\n                    return instance;\n            }\n            instance = getNextHydratable(instance.nextSibling);\n            if (null === instance) break;\n        }\n        return null;\n    }\n    function canHydrateTextInstance(instance, text, inRootOrSingleton) {\n        if (\"\" === text) return null;\n        for(; 3 !== instance.nodeType;){\n            if ((1 !== instance.nodeType || \"INPUT\" !== instance.nodeName || \"hidden\" !== instance.type) && !inRootOrSingleton) return null;\n            instance = getNextHydratable(instance.nextSibling);\n            if (null === instance) return null;\n        }\n        return instance;\n    }\n    function isSuspenseInstanceFallback(instance) {\n        return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE;\n    }\n    function registerSuspenseInstanceRetry(instance, callback) {\n        var ownerDocument = instance.ownerDocument;\n        if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE) callback();\n        else {\n            var listener = function() {\n                callback();\n                ownerDocument.removeEventListener(\"DOMContentLoaded\", listener);\n            };\n            ownerDocument.addEventListener(\"DOMContentLoaded\", listener);\n            instance._reactRetry = listener;\n        }\n    }\n    function getNextHydratable(node) {\n        for(; null != node; node = node.nextSibling){\n            var nodeType = node.nodeType;\n            if (1 === nodeType || 3 === nodeType) break;\n            if (8 === nodeType) {\n                nodeType = node.data;\n                if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING) break;\n                if (nodeType === SUSPENSE_END_DATA) return null;\n            }\n        }\n        return node;\n    }\n    function describeHydratableInstanceForDevWarnings(instance) {\n        if (1 === instance.nodeType) {\n            for(var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++){\n                var attr = attributes[i];\n                serverDifferences[getPropNameFromAttributeName(attr.name)] = \"style\" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;\n            }\n            return {\n                type: JSCompiler_temp_const,\n                props: serverDifferences\n            };\n        }\n        return 8 === instance.nodeType ? {\n            type: \"Suspense\",\n            props: {}\n        } : instance.nodeValue;\n    }\n    function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {\n        return null === parentProps || !0 !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;\n    }\n    function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {\n        suspenseInstance = suspenseInstance.nextSibling;\n        for(var depth = 0; suspenseInstance;){\n            if (8 === suspenseInstance.nodeType) {\n                var data = suspenseInstance.data;\n                if (data === SUSPENSE_END_DATA) {\n                    if (0 === depth) return getNextHydratable(suspenseInstance.nextSibling);\n                    depth--;\n                } else data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA || depth++;\n            }\n            suspenseInstance = suspenseInstance.nextSibling;\n        }\n        return null;\n    }\n    function getParentSuspenseInstance(targetInstance) {\n        targetInstance = targetInstance.previousSibling;\n        for(var depth = 0; targetInstance;){\n            if (8 === targetInstance.nodeType) {\n                var data = targetInstance.data;\n                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n                    if (0 === depth) return targetInstance;\n                    depth--;\n                } else data === SUSPENSE_END_DATA && depth++;\n            }\n            targetInstance = targetInstance.previousSibling;\n        }\n        return null;\n    }\n    function commitHydratedContainer(container) {\n        retryIfBlockedOn(container);\n    }\n    function commitHydratedSuspenseInstance(suspenseInstance) {\n        retryIfBlockedOn(suspenseInstance);\n    }\n    function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {\n        validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);\n        props = getOwnerDocumentFromRootContainer(rootContainerInstance);\n        switch(type){\n            case \"html\":\n                type = props.documentElement;\n                if (!type) throw Error(\"React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page.\");\n                return type;\n            case \"head\":\n                type = props.head;\n                if (!type) throw Error(\"React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page.\");\n                return type;\n            case \"body\":\n                type = props.body;\n                if (!type) throw Error(\"React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page.\");\n                return type;\n            default:\n                throw Error(\"resolveSingletonInstance was called with an element type that is not supported. This is a bug in React.\");\n        }\n    }\n    function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {\n        if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {\n            var tagName = instance.tagName.toLowerCase();\n            console.error(\"You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.\", tagName, tagName, tagName);\n        }\n        switch(type){\n            case \"html\":\n            case \"head\":\n            case \"body\":\n                break;\n            default:\n                console.error(\"acquireSingletonInstance was called with an element type that is not supported. This is a bug in React.\");\n        }\n        for(tagName = instance.attributes; tagName.length;)instance.removeAttributeNode(tagName[0]);\n        setInitialProperties(instance, type, props);\n        instance[internalInstanceKey] = internalInstanceHandle;\n        instance[internalPropsKey] = props;\n    }\n    function releaseSingletonInstance(instance) {\n        for(var attributes = instance.attributes; attributes.length;)instance.removeAttributeNode(attributes[0]);\n        detachDeletedInstance(instance);\n    }\n    function getHoistableRoot(container) {\n        return \"function\" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;\n    }\n    function preconnectAs(rel, href, crossOrigin) {\n        var ownerDocument = globalDocument;\n        if (ownerDocument && \"string\" === typeof href && href) {\n            var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);\n            limitedEscapedHref = 'link[rel=\"' + rel + '\"][href=\"' + limitedEscapedHref + '\"]';\n            \"string\" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin=\"' + crossOrigin + '\"]');\n            preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = {\n                rel: rel,\n                crossOrigin: crossOrigin,\n                href: href\n            }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement(\"link\"), setInitialProperties(href, \"link\", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));\n        }\n    }\n    function getResource(type, currentProps, pendingProps, currentResource) {\n        var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;\n        if (!resourceRoot) throw Error('\"resourceRoot\" was expected to exist. This is a bug in React.');\n        switch(type){\n            case \"meta\":\n            case \"title\":\n                return null;\n            case \"style\":\n                return \"string\" === typeof pendingProps.precedence && \"string\" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {\n                    type: \"style\",\n                    instance: null,\n                    count: 0,\n                    state: null\n                }, currentProps.set(pendingProps, currentResource)), currentResource) : {\n                    type: \"void\",\n                    instance: null,\n                    count: 0,\n                    state: null\n                };\n            case \"link\":\n                if (\"stylesheet\" === pendingProps.rel && \"string\" === typeof pendingProps.href && \"string\" === typeof pendingProps.precedence) {\n                    type = getStyleKey(pendingProps.href);\n                    var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);\n                    if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {\n                        type: \"stylesheet\",\n                        instance: null,\n                        count: 0,\n                        state: {\n                            loading: NotLoaded,\n                            preload: null\n                        }\n                    }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(getStylesheetSelectorFromKey(type))) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {\n                        var preloadProps = {\n                            rel: \"preload\",\n                            as: \"style\",\n                            href: pendingProps.href,\n                            crossOrigin: pendingProps.crossOrigin,\n                            integrity: pendingProps.integrity,\n                            media: pendingProps.media,\n                            hrefLang: pendingProps.hrefLang,\n                            referrerPolicy: pendingProps.referrerPolicy\n                        };\n                        preloadPropsMap.set(type, preloadProps);\n                        _styles || preloadStylesheet(resourceRoot, type, preloadProps, _resource.state);\n                    }\n                    if (currentProps && null === currentResource) throw pendingProps = \"\\n\\n  - \" + describeLinkForResourceErrorDEV(currentProps) + \"\\n  + \" + describeLinkForResourceErrorDEV(pendingProps), Error(\"Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key.\" + pendingProps);\n                    return _resource;\n                }\n                if (currentProps && null !== currentResource) throw pendingProps = \"\\n\\n  - \" + describeLinkForResourceErrorDEV(currentProps) + \"\\n  + \" + describeLinkForResourceErrorDEV(pendingProps), Error(\"Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key.\" + pendingProps);\n                return null;\n            case \"script\":\n                return currentProps = pendingProps.async, pendingProps = pendingProps.src, \"string\" === typeof pendingProps && currentProps && \"function\" !== typeof currentProps && \"symbol\" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {\n                    type: \"script\",\n                    instance: null,\n                    count: 0,\n                    state: null\n                }, currentProps.set(pendingProps, currentResource)), currentResource) : {\n                    type: \"void\",\n                    instance: null,\n                    count: 0,\n                    state: null\n                };\n            default:\n                throw Error('getResource encountered a type it did not expect: \"' + type + '\". this is a bug in React.');\n        }\n    }\n    function describeLinkForResourceErrorDEV(props) {\n        var describedProps = 0, description = \"<link\";\n        \"string\" === typeof props.rel ? (describedProps++, description += ' rel=\"' + props.rel + '\"') : hasOwnProperty.call(props, \"rel\") && (describedProps++, description += ' rel=\"' + (null === props.rel ? \"null\" : \"invalid type \" + typeof props.rel) + '\"');\n        \"string\" === typeof props.href ? (describedProps++, description += ' href=\"' + props.href + '\"') : hasOwnProperty.call(props, \"href\") && (describedProps++, description += ' href=\"' + (null === props.href ? \"null\" : \"invalid type \" + typeof props.href) + '\"');\n        \"string\" === typeof props.precedence ? (describedProps++, description += ' precedence=\"' + props.precedence + '\"') : hasOwnProperty.call(props, \"precedence\") && (describedProps++, description += \" precedence={\" + (null === props.precedence ? \"null\" : \"invalid type \" + typeof props.precedence) + \"}\");\n        Object.getOwnPropertyNames(props).length > describedProps && (description += \" ...\");\n        return description + \" />\";\n    }\n    function getStyleKey(href) {\n        return 'href=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '\"';\n    }\n    function getStylesheetSelectorFromKey(key) {\n        return 'link[rel=\"stylesheet\"][' + key + \"]\";\n    }\n    function stylesheetPropsFromRawProps(rawProps) {\n        return assign({}, rawProps, {\n            \"data-precedence\": rawProps.precedence,\n            precedence: null\n        });\n    }\n    function preloadStylesheet(ownerDocument, key, preloadProps, state) {\n        ownerDocument.querySelector('link[rel=\"preload\"][as=\"style\"][' + key + \"]\") ? state.loading = Loaded : (key = ownerDocument.createElement(\"link\"), state.preload = key, key.addEventListener(\"load\", function() {\n            return state.loading |= Loaded;\n        }), key.addEventListener(\"error\", function() {\n            return state.loading |= Errored;\n        }), setInitialProperties(key, \"link\", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));\n    }\n    function getScriptKey(src) {\n        return '[src=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '\"]';\n    }\n    function getScriptSelectorFromKey(key) {\n        return \"script[async]\" + key;\n    }\n    function acquireResource(hoistableRoot, resource, props) {\n        resource.count++;\n        if (null === resource.instance) switch(resource.type){\n            case \"style\":\n                var instance = hoistableRoot.querySelector('style[data-href~=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '\"]');\n                if (instance) return resource.instance = instance, markNodeAsHoistable(instance), instance;\n                var styleProps = assign({}, props, {\n                    \"data-href\": props.href,\n                    \"data-precedence\": props.precedence,\n                    href: null,\n                    precedence: null\n                });\n                instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(\"style\");\n                markNodeAsHoistable(instance);\n                setInitialProperties(instance, \"style\", styleProps);\n                insertStylesheet(instance, props.precedence, hoistableRoot);\n                return resource.instance = instance;\n            case \"stylesheet\":\n                styleProps = getStyleKey(props.href);\n                var _instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));\n                if (_instance) return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;\n                instance = stylesheetPropsFromRawProps(props);\n                (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);\n                _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(\"link\");\n                markNodeAsHoistable(_instance);\n                var linkInstance = _instance;\n                linkInstance._p = new Promise(function(resolve, reject) {\n                    linkInstance.onload = resolve;\n                    linkInstance.onerror = reject;\n                });\n                setInitialProperties(_instance, \"link\", instance);\n                resource.state.loading |= Inserted;\n                insertStylesheet(_instance, props.precedence, hoistableRoot);\n                return resource.instance = _instance;\n            case \"script\":\n                _instance = getScriptKey(props.src);\n                if (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(_instance))) return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;\n                instance = props;\n                if (styleProps = preloadPropsMap.get(_instance)) instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);\n                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n                styleProps = hoistableRoot.createElement(\"script\");\n                markNodeAsHoistable(styleProps);\n                setInitialProperties(styleProps, \"link\", instance);\n                hoistableRoot.head.appendChild(styleProps);\n                return resource.instance = styleProps;\n            case \"void\":\n                return null;\n            default:\n                throw Error('acquireResource encountered a resource type it did not expect: \"' + resource.type + '\". this is a bug in React.');\n        }\n        else \"stylesheet\" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));\n        return resource.instance;\n    }\n    function insertStylesheet(instance, precedence, root) {\n        for(var nodes = root.querySelectorAll('link[rel=\"stylesheet\"][data-precedence],style[data-precedence]'), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++){\n            var node = nodes[i];\n            if (node.dataset.precedence === precedence) prior = node;\n            else if (prior !== last) break;\n        }\n        prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root.nodeType ? root.head : root, precedence.insertBefore(instance, precedence.firstChild));\n    }\n    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {\n        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);\n        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);\n        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);\n    }\n    function adoptPreloadPropsForScript(scriptProps, preloadProps) {\n        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);\n        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);\n        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);\n    }\n    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {\n        if (null === tagCaches) {\n            var cache = new Map();\n            var caches = tagCaches = new Map();\n            caches.set(ownerDocument, cache);\n        } else caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = new Map(), caches.set(ownerDocument, cache));\n        if (cache.has(type)) return cache;\n        cache.set(type, null);\n        ownerDocument = ownerDocument.getElementsByTagName(type);\n        for(caches = 0; caches < ownerDocument.length; caches++){\n            var node = ownerDocument[caches];\n            if (!(node[internalHoistableMarker] || node[internalInstanceKey] || \"link\" === type && \"stylesheet\" === node.getAttribute(\"rel\")) && node.namespaceURI !== SVG_NAMESPACE) {\n                var nodeKey = node.getAttribute(keyAttribute) || \"\";\n                nodeKey = type + nodeKey;\n                var existing = cache.get(nodeKey);\n                existing ? existing.push(node) : cache.set(nodeKey, [\n                    node\n                ]);\n            }\n        }\n        return cache;\n    }\n    function mountHoistable(hoistableRoot, type, instance) {\n        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n        hoistableRoot.head.insertBefore(instance, \"title\" === type ? hoistableRoot.querySelector(\"head > title\") : null);\n    }\n    function isHostHoistableType(type, props, hostContext) {\n        var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;\n        if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp) return !outsideHostContainerContext || null == props.itemProp || \"meta\" !== type && \"title\" !== type && \"style\" !== type && \"link\" !== type && \"script\" !== type || console.error(\"Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.\", type, type), !1;\n        switch(type){\n            case \"meta\":\n            case \"title\":\n                return !0;\n            case \"style\":\n                if (\"string\" !== typeof props.precedence || \"string\" !== typeof props.href || \"\" === props.href) {\n                    outsideHostContainerContext && console.error('Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel=\"stylesheet\" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence=\"default\"` and `href=\"some unique resource identifier\"`.');\n                    break;\n                }\n                return !0;\n            case \"link\":\n                if (\"string\" !== typeof props.rel || \"string\" !== typeof props.href || \"\" === props.href || props.onLoad || props.onError) {\n                    if (\"stylesheet\" === props.rel && \"string\" === typeof props.precedence) {\n                        type = props.href;\n                        var onError = props.onError, disabled = props.disabled;\n                        hostContext = [];\n                        props.onLoad && hostContext.push(\"`onLoad`\");\n                        onError && hostContext.push(\"`onError`\");\n                        null != disabled && hostContext.push(\"`disabled`\");\n                        onError = propNamesListJoin(hostContext, \"and\");\n                        onError += 1 === hostContext.length ? \" prop\" : \" props\";\n                        disabled = 1 === hostContext.length ? \"an \" + onError : \"the \" + onError;\n                        hostContext.length && console.error('React encountered a <link rel=\"stylesheet\" href=\"%s\" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', type, disabled, onError);\n                    }\n                    outsideHostContainerContext && (\"string\" !== typeof props.rel || \"string\" !== typeof props.href || \"\" === props.href ? console.error(\"Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag\") : (props.onError || props.onLoad) && console.error(\"Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>.\"));\n                    break;\n                }\n                switch(props.rel){\n                    case \"stylesheet\":\n                        return type = props.precedence, props = props.disabled, \"string\" !== typeof type && outsideHostContainerContext && console.error('Cannot render a <link rel=\"stylesheet\" /> outside the main document without knowing its precedence. Consider adding precedence=\"default\" or moving it into the root <head> tag.'), \"string\" === typeof type && null == props;\n                    default:\n                        return !0;\n                }\n            case \"script\":\n                type = props.async && \"function\" !== typeof props.async && \"symbol\" !== typeof props.async;\n                if (!type || props.onLoad || props.onError || !props.src || \"string\" !== typeof props.src) {\n                    outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error(\"Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>.\") : console.error(\"Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>.\") : console.error('Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async=\"\" or moving it into the root <head> tag.'));\n                    break;\n                }\n                return !0;\n            case \"noscript\":\n            case \"template\":\n                outsideHostContainerContext && console.error(\"Cannot render <%s> outside the main document. Try moving it into the root <head> tag.\", type);\n        }\n        return !1;\n    }\n    function preloadResource(resource) {\n        return \"stylesheet\" === resource.type && (resource.state.loading & Settled) === NotLoaded ? !1 : !0;\n    }\n    function noop() {}\n    function suspendResource(hoistableRoot, resource, props) {\n        if (null === suspendedState) throw Error(\"Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.\");\n        var state = suspendedState;\n        if (\"stylesheet\" === resource.type && (\"string\" !== typeof props.media || !1 !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {\n            if (null === resource.instance) {\n                var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));\n                if (instance) {\n                    hoistableRoot = instance._p;\n                    null !== hoistableRoot && \"object\" === typeof hoistableRoot && \"function\" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));\n                    resource.state.loading |= Inserted;\n                    resource.instance = instance;\n                    markNodeAsHoistable(instance);\n                    return;\n                }\n                instance = hoistableRoot.ownerDocument || hoistableRoot;\n                props = stylesheetPropsFromRawProps(props);\n                (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);\n                instance = instance.createElement(\"link\");\n                markNodeAsHoistable(instance);\n                var linkInstance = instance;\n                linkInstance._p = new Promise(function(resolve, reject) {\n                    linkInstance.onload = resolve;\n                    linkInstance.onerror = reject;\n                });\n                setInitialProperties(instance, \"link\", props);\n                resource.instance = instance;\n            }\n            null === state.stylesheets && (state.stylesheets = new Map());\n            state.stylesheets.set(resource, hoistableRoot);\n            (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener(\"load\", resource), hoistableRoot.addEventListener(\"error\", resource));\n        }\n    }\n    function waitForCommitToBeReady() {\n        if (null === suspendedState) throw Error(\"Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.\");\n        var state = suspendedState;\n        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);\n        return 0 < state.count ? function(commit) {\n            var stylesheetTimer = setTimeout(function() {\n                state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);\n                if (state.unsuspend) {\n                    var unsuspend = state.unsuspend;\n                    state.unsuspend = null;\n                    unsuspend();\n                }\n            }, 6e4);\n            state.unsuspend = commit;\n            return function() {\n                state.unsuspend = null;\n                clearTimeout(stylesheetTimer);\n            };\n        } : null;\n    }\n    function onUnsuspend() {\n        this.count--;\n        if (0 === this.count) {\n            if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);\n            else if (this.unsuspend) {\n                var unsuspend = this.unsuspend;\n                this.unsuspend = null;\n                unsuspend();\n            }\n        }\n    }\n    function insertSuspendedStylesheets(state, resources) {\n        state.stylesheets = null;\n        null !== state.unsuspend && (state.count++, precedencesByRoot = new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));\n    }\n    function insertStylesheetIntoRoot(root, resource) {\n        if (!(resource.state.loading & Inserted)) {\n            var precedences = precedencesByRoot.get(root);\n            if (precedences) var last = precedences.get(LAST_PRECEDENCE);\n            else {\n                precedences = new Map();\n                precedencesByRoot.set(root, precedences);\n                for(var nodes = root.querySelectorAll(\"link[data-precedence],style[data-precedence]\"), i = 0; i < nodes.length; i++){\n                    var node = nodes[i];\n                    if (\"LINK\" === node.nodeName || \"not all\" !== node.getAttribute(\"media\")) precedences.set(node.dataset.precedence, node), last = node;\n                }\n                last && precedences.set(LAST_PRECEDENCE, last);\n            }\n            nodes = resource.instance;\n            node = nodes.getAttribute(\"data-precedence\");\n            i = precedences.get(node) || last;\n            i === last && precedences.set(LAST_PRECEDENCE, nodes);\n            precedences.set(node, nodes);\n            this.count++;\n            last = onUnsuspend.bind(this);\n            nodes.addEventListener(\"load\", last);\n            nodes.addEventListener(\"error\", last);\n            i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root = 9 === root.nodeType ? root.head : root, root.insertBefore(nodes, root.firstChild));\n            resource.state.loading |= Inserted;\n        }\n    }\n    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {\n        this.tag = 1;\n        this.containerInfo = containerInfo;\n        this.pingCache = this.current = this.pendingChildren = null;\n        this.timeoutHandle = noTimeout;\n        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;\n        this.callbackPriority = 0;\n        this.expirationTimes = createLaneMap(-1);\n        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;\n        this.entanglements = createLaneMap(0);\n        this.hiddenUpdates = createLaneMap(null);\n        this.identifierPrefix = identifierPrefix;\n        this.onUncaughtError = onUncaughtError;\n        this.onCaughtError = onCaughtError;\n        this.onRecoverableError = onRecoverableError;\n        this.pooledCache = null;\n        this.pooledCacheLanes = 0;\n        this.formState = formState;\n        this.incompleteTransitions = new Map();\n        this.passiveEffectDuration = this.effectDuration = -0;\n        this.memoizedUpdaters = new Set();\n        containerInfo = this.pendingUpdatersLaneMap = [];\n        for(tag = 0; 31 > tag; tag++)containerInfo.push(new Set());\n        this._debugRootType = hydrate ? \"hydrateRoot()\" : \"createRoot()\";\n    }\n    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);\n        tag = ConcurrentMode;\n        !0 === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);\n        isDevToolsPresent && (tag |= ProfileMode);\n        isStrictMode = createFiber(3, null, null, tag);\n        containerInfo.current = isStrictMode;\n        isStrictMode.stateNode = containerInfo;\n        tag = createCache();\n        retainCache(tag);\n        containerInfo.pooledCache = tag;\n        retainCache(tag);\n        isStrictMode.memoizedState = {\n            element: initialChildren,\n            isDehydrated: hydrate,\n            cache: tag\n        };\n        initializeUpdateQueue(isStrictMode);\n        return containerInfo;\n    }\n    function getContextForSubtree(parentComponent) {\n        if (!parentComponent) return emptyContextObject;\n        parentComponent = emptyContextObject;\n        return parentComponent;\n    }\n    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n        if (injectedHook && \"function\" === typeof injectedHook.onScheduleFiberRoot) try {\n            injectedHook.onScheduleFiberRoot(rendererID, container, element);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);\n        parentComponent = getContextForSubtree(parentComponent);\n        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;\n        isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error(\"Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\\n\\nCheck the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\"));\n        container = createUpdate(lane);\n        container.payload = {\n            element: element\n        };\n        callback = void 0 === callback ? null : callback;\n        null !== callback && (\"function\" !== typeof callback && console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback), container.callback = callback);\n        element = enqueueUpdate(rootFiber, container, lane);\n        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));\n    }\n    function markRetryLaneImpl(fiber, retryLane) {\n        fiber = fiber.memoizedState;\n        if (null !== fiber && null !== fiber.dehydrated) {\n            var a = fiber.retryLane;\n            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;\n        }\n    }\n    function markRetryLaneIfNotHydrated(fiber, retryLane) {\n        markRetryLaneImpl(fiber, retryLane);\n        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);\n    }\n    function attemptContinuousHydration(fiber) {\n        if (13 === fiber.tag) {\n            var root = enqueueConcurrentRenderForLane(fiber, 67108864);\n            null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);\n            markRetryLaneIfNotHydrated(fiber, 67108864);\n        }\n    }\n    function getCurrentFiberForDevTools() {\n        return current;\n    }\n    function getLaneLabelMap() {\n        for(var map = new Map(), lane = 1, index = 0; 31 > index; index++){\n            var label = getLabelForLane(lane);\n            map.set(lane, label);\n            lane *= 2;\n        }\n        return map;\n    }\n    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n        var prevTransition = ReactSharedInternals.T;\n        ReactSharedInternals.T = null;\n        var previousPriority = ReactDOMSharedInternals.p;\n        try {\n            ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n        } finally{\n            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;\n        }\n    }\n    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n        var prevTransition = ReactSharedInternals.T;\n        ReactSharedInternals.T = null;\n        var previousPriority = ReactDOMSharedInternals.p;\n        try {\n            ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n        } finally{\n            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;\n        }\n    }\n    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n        if (_enabled) {\n            var blockedOn = findInstanceBlockingEvent(nativeEvent);\n            if (null === blockedOn) dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);\n            else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) nativeEvent.stopPropagation();\n            else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {\n                for(; null !== blockedOn;){\n                    var fiber = getInstanceFromNode(blockedOn);\n                    if (null !== fiber) switch(fiber.tag){\n                        case 3:\n                            fiber = fiber.stateNode;\n                            if (fiber.current.memoizedState.isDehydrated) {\n                                var lanes = getHighestPriorityLanes(fiber.pendingLanes);\n                                if (0 !== lanes) {\n                                    var root = fiber;\n                                    root.pendingLanes |= 2;\n                                    for(root.entangledLanes |= 2; lanes;){\n                                        var lane = 1 << 31 - clz32(lanes);\n                                        root.entanglements[1] |= lane;\n                                        lanes &= ~lane;\n                                    }\n                                    ensureRootIsScheduled(fiber);\n                                    (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));\n                                }\n                            }\n                            break;\n                        case 13:\n                            root = enqueueConcurrentRenderForLane(fiber, 2), null !== root && scheduleUpdateOnFiber(root, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);\n                    }\n                    fiber = findInstanceBlockingEvent(nativeEvent);\n                    null === fiber && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n                    if (fiber === blockedOn) break;\n                    blockedOn = fiber;\n                }\n                null !== blockedOn && nativeEvent.stopPropagation();\n            } else dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);\n        }\n    }\n    function findInstanceBlockingEvent(nativeEvent) {\n        nativeEvent = getEventTarget(nativeEvent);\n        return findInstanceBlockingTarget(nativeEvent);\n    }\n    function findInstanceBlockingTarget(targetNode) {\n        return_targetInst = null;\n        targetNode = getClosestInstanceFromNode(targetNode);\n        if (null !== targetNode) {\n            var nearestMounted = getNearestMountedFiber(targetNode);\n            if (null === nearestMounted) targetNode = null;\n            else {\n                var tag = nearestMounted.tag;\n                if (13 === tag) {\n                    targetNode = getSuspenseInstanceFromFiber(nearestMounted);\n                    if (null !== targetNode) return targetNode;\n                    targetNode = null;\n                } else if (3 === tag) {\n                    if (nearestMounted.stateNode.current.memoizedState.isDehydrated) return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;\n                    targetNode = null;\n                } else nearestMounted !== targetNode && (targetNode = null);\n            }\n        }\n        return_targetInst = targetNode;\n        return null;\n    }\n    function getEventPriority(domEventName) {\n        switch(domEventName){\n            case \"beforetoggle\":\n            case \"cancel\":\n            case \"click\":\n            case \"close\":\n            case \"contextmenu\":\n            case \"copy\":\n            case \"cut\":\n            case \"auxclick\":\n            case \"dblclick\":\n            case \"dragend\":\n            case \"dragstart\":\n            case \"drop\":\n            case \"focusin\":\n            case \"focusout\":\n            case \"input\":\n            case \"invalid\":\n            case \"keydown\":\n            case \"keypress\":\n            case \"keyup\":\n            case \"mousedown\":\n            case \"mouseup\":\n            case \"paste\":\n            case \"pause\":\n            case \"play\":\n            case \"pointercancel\":\n            case \"pointerdown\":\n            case \"pointerup\":\n            case \"ratechange\":\n            case \"reset\":\n            case \"resize\":\n            case \"seeked\":\n            case \"submit\":\n            case \"toggle\":\n            case \"touchcancel\":\n            case \"touchend\":\n            case \"touchstart\":\n            case \"volumechange\":\n            case \"change\":\n            case \"selectionchange\":\n            case \"textInput\":\n            case \"compositionstart\":\n            case \"compositionend\":\n            case \"compositionupdate\":\n            case \"beforeblur\":\n            case \"afterblur\":\n            case \"beforeinput\":\n            case \"blur\":\n            case \"fullscreenchange\":\n            case \"focus\":\n            case \"hashchange\":\n            case \"popstate\":\n            case \"select\":\n            case \"selectstart\":\n                return DiscreteEventPriority;\n            case \"drag\":\n            case \"dragenter\":\n            case \"dragexit\":\n            case \"dragleave\":\n            case \"dragover\":\n            case \"mousemove\":\n            case \"mouseout\":\n            case \"mouseover\":\n            case \"pointermove\":\n            case \"pointerout\":\n            case \"pointerover\":\n            case \"scroll\":\n            case \"touchmove\":\n            case \"wheel\":\n            case \"mouseenter\":\n            case \"mouseleave\":\n            case \"pointerenter\":\n            case \"pointerleave\":\n                return ContinuousEventPriority;\n            case \"message\":\n                switch(getCurrentPriorityLevel()){\n                    case ImmediatePriority:\n                        return DiscreteEventPriority;\n                    case UserBlockingPriority:\n                        return ContinuousEventPriority;\n                    case NormalPriority$1:\n                    case LowPriority:\n                        return DefaultEventPriority;\n                    case IdlePriority:\n                        return IdleEventPriority;\n                    default:\n                        return DefaultEventPriority;\n                }\n            default:\n                return DefaultEventPriority;\n        }\n    }\n    function clearIfContinuousEvent(domEventName, nativeEvent) {\n        switch(domEventName){\n            case \"focusin\":\n            case \"focusout\":\n                queuedFocus = null;\n                break;\n            case \"dragenter\":\n            case \"dragleave\":\n                queuedDrag = null;\n                break;\n            case \"mouseover\":\n            case \"mouseout\":\n                queuedMouse = null;\n                break;\n            case \"pointerover\":\n            case \"pointerout\":\n                queuedPointers.delete(nativeEvent.pointerId);\n                break;\n            case \"gotpointercapture\":\n            case \"lostpointercapture\":\n                queuedPointerCaptures.delete(nativeEvent.pointerId);\n        }\n    }\n    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent) return existingQueuedEvent = {\n            blockedOn: blockedOn,\n            domEventName: domEventName,\n            eventSystemFlags: eventSystemFlags,\n            nativeEvent: nativeEvent,\n            targetContainers: [\n                targetContainer\n            ]\n        }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;\n        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n        blockedOn = existingQueuedEvent.targetContainers;\n        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);\n        return existingQueuedEvent;\n    }\n    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n        switch(domEventName){\n            case \"focusin\":\n                return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;\n            case \"dragenter\":\n                return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;\n            case \"mouseover\":\n                return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;\n            case \"pointerover\":\n                var pointerId = nativeEvent.pointerId;\n                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));\n                return !0;\n            case \"gotpointercapture\":\n                return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), !0;\n        }\n        return !1;\n    }\n    function attemptExplicitHydrationTarget(queuedTarget) {\n        var targetInst = getClosestInstanceFromNode(queuedTarget.target);\n        if (null !== targetInst) {\n            var nearestMounted = getNearestMountedFiber(targetInst);\n            if (null !== nearestMounted) {\n                if (targetInst = nearestMounted.tag, 13 === targetInst) {\n                    if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {\n                        queuedTarget.blockedOn = targetInst;\n                        runWithPriority(queuedTarget.priority, function() {\n                            if (13 === nearestMounted.tag) {\n                                var lane = requestUpdateLane(nearestMounted);\n                                lane = getBumpedLaneForHydrationByLane(lane);\n                                var root = enqueueConcurrentRenderForLane(nearestMounted, lane);\n                                null !== root && scheduleUpdateOnFiber(root, nearestMounted, lane);\n                                markRetryLaneIfNotHydrated(nearestMounted, lane);\n                            }\n                        });\n                        return;\n                    }\n                } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {\n                    queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;\n                    return;\n                }\n            }\n        }\n        queuedTarget.blockedOn = null;\n    }\n    function attemptReplayContinuousQueuedEvent(queuedEvent) {\n        if (null !== queuedEvent.blockedOn) return !1;\n        for(var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length;){\n            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);\n            if (null === nextBlockedOn) {\n                nextBlockedOn = queuedEvent.nativeEvent;\n                var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn), event = nativeEventClone;\n                null !== currentReplayingEvent && console.error(\"Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.\");\n                currentReplayingEvent = event;\n                nextBlockedOn.target.dispatchEvent(nativeEventClone);\n                null === currentReplayingEvent && console.error(\"Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.\");\n                currentReplayingEvent = null;\n            } else return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, !1;\n            targetContainers.shift();\n        }\n        return !0;\n    }\n    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);\n    }\n    function replayUnblockedEvents() {\n        hasScheduledReplayAttempt = !1;\n        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);\n        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);\n        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);\n        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n    }\n    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = !0, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));\n    }\n    function scheduleReplayQueueIfNeeded(formReplayingQueue) {\n        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function() {\n            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);\n            for(var i = 0; i < formReplayingQueue.length; i += 3){\n                var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];\n                if (\"function\" !== typeof submitterOrAction) if (null === findInstanceBlockingTarget(submitterOrAction || form)) continue;\n                else break;\n                var formInst = getInstanceFromNode(form);\n                null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {\n                    pending: !0,\n                    data: formData,\n                    method: form.method,\n                    action: submitterOrAction\n                }, Object.freeze(form), startHostTransition(formInst, form, submitterOrAction, formData));\n            }\n        }));\n    }\n    function retryIfBlockedOn(unblocked) {\n        function unblock(queuedEvent) {\n            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n        }\n        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n        queuedPointers.forEach(unblock);\n        queuedPointerCaptures.forEach(unblock);\n        for(var i = 0; i < queuedExplicitHydrationTargets.length; i++){\n            var queuedTarget = queuedExplicitHydrationTargets[i];\n            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);\n        }\n        for(; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn);)attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();\n        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;\n        if (null != i) for(queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3){\n            var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;\n            if (\"function\" === typeof submitterOrAction) formProps || scheduleReplayQueueIfNeeded(i);\n            else if (formProps) {\n                var action = null;\n                if (submitterOrAction && submitterOrAction.hasAttribute(\"formAction\")) if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null) action = formProps.formAction;\n                else {\n                    if (null !== findInstanceBlockingTarget(form)) continue;\n                }\n                else action = formProps.action;\n                \"function\" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);\n                scheduleReplayQueueIfNeeded(i);\n            }\n        }\n    }\n    function ReactDOMRoot(internalRoot) {\n        this._internalRoot = internalRoot;\n    }\n    function ReactDOMHydrationRoot(internalRoot) {\n        this._internalRoot = internalRoot;\n    }\n    function warnIfReactDOMContainerInDEV(container) {\n        container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(\"You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.\") : console.error(\"You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.\"));\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && \"function\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var Scheduler = __webpack_require__(/*! next/dist/compiled/scheduler */ \"(ssr)/./node_modules/next/dist/compiled/scheduler/index.js\"), React = __webpack_require__(/*! next/dist/compiled/react */ \"(ssr)/./node_modules/next/dist/compiled/react/index.js\"), ReactDOM = __webpack_require__(/*! next/dist/compiled/react-dom */ \"(ssr)/./node_modules/next/dist/compiled/react-dom/index.js\"), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"), REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"), REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"), REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n    Symbol.for(\"react.scope\");\n    var REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\");\n    Symbol.for(\"react.legacy_hidden\");\n    Symbol.for(\"react.tracing_marker\");\n    var REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\");\n    Symbol.for(\"react.view_transition\");\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"), isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({\n        pending: !1,\n        data: null,\n        method: null,\n        action: null\n    }), valueStack = [];\n    var fiberStack = [];\n    var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix, suffix, reentry = !1;\n    var componentFrameCache = new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n    var current = null, isRendering = !1, hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = !1, isDevToolsPresent = \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionLane = 256, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = \"__reactFiber$\" + randomKey, internalPropsKey = \"__reactProps$\" + randomKey, internalContainerInstanceKey = \"__reactContainer$\" + randomKey, internalEventHandlersKey = \"__reactEvents$\" + randomKey, internalEventHandlerListenersKey = \"__reactListeners$\" + randomKey, internalEventHandlesSetKey = \"__reactHandles$\" + randomKey, internalRootNodeResourcesKey = \"__reactResources$\" + randomKey, internalHoistableMarker = \"__reactMarker$\" + randomKey, allNativeEvents = new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {\n        button: !0,\n        checkbox: !0,\n        image: !0,\n        hidden: !0,\n        radio: !0,\n        reset: !0,\n        submit: !0\n    }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(\"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\\n\"\\\\]/g, didWarnValueDefaultValue$1 = !1, didWarnCheckedDefaultChecked = !1, didWarnSelectedSetOnOption = !1, didWarnInvalidChild = !1, didWarnInvalidInnerHTML = !1;\n    var didWarnValueDefaultValue = !1;\n    var valuePropNames = [\n        \"value\",\n        \"defaultValue\"\n    ], didWarnValDefaultVal = !1, needsEscaping = /[\"'&<>\\n\\t]|^\\s|\\s$/, specialTags = \"address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp\".split(\" \"), inScopeTags = \"applet caption html table td th marquee object template foreignObject desc title\".split(\" \"), buttonScopeTags = inScopeTags.concat([\n        \"button\"\n    ]), impliedEndTags = \"dd dt li option optgroup p rp rt\".split(\" \"), emptyAncestorInfoDev = {\n        current: null,\n        formTag: null,\n        aTagInScope: null,\n        buttonTagInScope: null,\n        nobrTagInScope: null,\n        pTagInButtonScope: null,\n        listItemTagAutoclosing: null,\n        dlItemTagAutoclosing: null,\n        containerTagInScope: null,\n        implicitRootScope: !1\n    }, didWarn = {}, shorthandToLonghand = {\n        animation: \"animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction\".split(\" \"),\n        background: \"backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize\".split(\" \"),\n        backgroundPosition: [\n            \"backgroundPositionX\",\n            \"backgroundPositionY\"\n        ],\n        border: \"borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth\".split(\" \"),\n        borderBlockEnd: [\n            \"borderBlockEndColor\",\n            \"borderBlockEndStyle\",\n            \"borderBlockEndWidth\"\n        ],\n        borderBlockStart: [\n            \"borderBlockStartColor\",\n            \"borderBlockStartStyle\",\n            \"borderBlockStartWidth\"\n        ],\n        borderBottom: [\n            \"borderBottomColor\",\n            \"borderBottomStyle\",\n            \"borderBottomWidth\"\n        ],\n        borderColor: [\n            \"borderBottomColor\",\n            \"borderLeftColor\",\n            \"borderRightColor\",\n            \"borderTopColor\"\n        ],\n        borderImage: [\n            \"borderImageOutset\",\n            \"borderImageRepeat\",\n            \"borderImageSlice\",\n            \"borderImageSource\",\n            \"borderImageWidth\"\n        ],\n        borderInlineEnd: [\n            \"borderInlineEndColor\",\n            \"borderInlineEndStyle\",\n            \"borderInlineEndWidth\"\n        ],\n        borderInlineStart: [\n            \"borderInlineStartColor\",\n            \"borderInlineStartStyle\",\n            \"borderInlineStartWidth\"\n        ],\n        borderLeft: [\n            \"borderLeftColor\",\n            \"borderLeftStyle\",\n            \"borderLeftWidth\"\n        ],\n        borderRadius: [\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\"\n        ],\n        borderRight: [\n            \"borderRightColor\",\n            \"borderRightStyle\",\n            \"borderRightWidth\"\n        ],\n        borderStyle: [\n            \"borderBottomStyle\",\n            \"borderLeftStyle\",\n            \"borderRightStyle\",\n            \"borderTopStyle\"\n        ],\n        borderTop: [\n            \"borderTopColor\",\n            \"borderTopStyle\",\n            \"borderTopWidth\"\n        ],\n        borderWidth: [\n            \"borderBottomWidth\",\n            \"borderLeftWidth\",\n            \"borderRightWidth\",\n            \"borderTopWidth\"\n        ],\n        columnRule: [\n            \"columnRuleColor\",\n            \"columnRuleStyle\",\n            \"columnRuleWidth\"\n        ],\n        columns: [\n            \"columnCount\",\n            \"columnWidth\"\n        ],\n        flex: [\n            \"flexBasis\",\n            \"flexGrow\",\n            \"flexShrink\"\n        ],\n        flexFlow: [\n            \"flexDirection\",\n            \"flexWrap\"\n        ],\n        font: \"fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight\".split(\" \"),\n        fontVariant: \"fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition\".split(\" \"),\n        gap: [\n            \"columnGap\",\n            \"rowGap\"\n        ],\n        grid: \"gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows\".split(\" \"),\n        gridArea: [\n            \"gridColumnEnd\",\n            \"gridColumnStart\",\n            \"gridRowEnd\",\n            \"gridRowStart\"\n        ],\n        gridColumn: [\n            \"gridColumnEnd\",\n            \"gridColumnStart\"\n        ],\n        gridColumnGap: [\n            \"columnGap\"\n        ],\n        gridGap: [\n            \"columnGap\",\n            \"rowGap\"\n        ],\n        gridRow: [\n            \"gridRowEnd\",\n            \"gridRowStart\"\n        ],\n        gridRowGap: [\n            \"rowGap\"\n        ],\n        gridTemplate: [\n            \"gridTemplateAreas\",\n            \"gridTemplateColumns\",\n            \"gridTemplateRows\"\n        ],\n        listStyle: [\n            \"listStyleImage\",\n            \"listStylePosition\",\n            \"listStyleType\"\n        ],\n        margin: [\n            \"marginBottom\",\n            \"marginLeft\",\n            \"marginRight\",\n            \"marginTop\"\n        ],\n        marker: [\n            \"markerEnd\",\n            \"markerMid\",\n            \"markerStart\"\n        ],\n        mask: \"maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize\".split(\" \"),\n        maskPosition: [\n            \"maskPositionX\",\n            \"maskPositionY\"\n        ],\n        outline: [\n            \"outlineColor\",\n            \"outlineStyle\",\n            \"outlineWidth\"\n        ],\n        overflow: [\n            \"overflowX\",\n            \"overflowY\"\n        ],\n        padding: [\n            \"paddingBottom\",\n            \"paddingLeft\",\n            \"paddingRight\",\n            \"paddingTop\"\n        ],\n        placeContent: [\n            \"alignContent\",\n            \"justifyContent\"\n        ],\n        placeItems: [\n            \"alignItems\",\n            \"justifyItems\"\n        ],\n        placeSelf: [\n            \"alignSelf\",\n            \"justifySelf\"\n        ],\n        textDecoration: [\n            \"textDecorationColor\",\n            \"textDecorationLine\",\n            \"textDecorationStyle\"\n        ],\n        textEmphasis: [\n            \"textEmphasisColor\",\n            \"textEmphasisStyle\"\n        ],\n        transition: [\n            \"transitionDelay\",\n            \"transitionDuration\",\n            \"transitionProperty\",\n            \"transitionTimingFunction\"\n        ],\n        wordWrap: [\n            \"overflowWrap\"\n        ]\n    }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = !1, warnedForInfinityValue = !1, unitlessNumbers = new Set(\"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\" \")), MATH_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\", SVG_NAMESPACE = \"http://www.w3.org/2000/svg\", aliases = new Map([\n        [\n            \"acceptCharset\",\n            \"accept-charset\"\n        ],\n        [\n            \"htmlFor\",\n            \"for\"\n        ],\n        [\n            \"httpEquiv\",\n            \"http-equiv\"\n        ],\n        [\n            \"crossOrigin\",\n            \"crossorigin\"\n        ],\n        [\n            \"accentHeight\",\n            \"accent-height\"\n        ],\n        [\n            \"alignmentBaseline\",\n            \"alignment-baseline\"\n        ],\n        [\n            \"arabicForm\",\n            \"arabic-form\"\n        ],\n        [\n            \"baselineShift\",\n            \"baseline-shift\"\n        ],\n        [\n            \"capHeight\",\n            \"cap-height\"\n        ],\n        [\n            \"clipPath\",\n            \"clip-path\"\n        ],\n        [\n            \"clipRule\",\n            \"clip-rule\"\n        ],\n        [\n            \"colorInterpolation\",\n            \"color-interpolation\"\n        ],\n        [\n            \"colorInterpolationFilters\",\n            \"color-interpolation-filters\"\n        ],\n        [\n            \"colorProfile\",\n            \"color-profile\"\n        ],\n        [\n            \"colorRendering\",\n            \"color-rendering\"\n        ],\n        [\n            \"dominantBaseline\",\n            \"dominant-baseline\"\n        ],\n        [\n            \"enableBackground\",\n            \"enable-background\"\n        ],\n        [\n            \"fillOpacity\",\n            \"fill-opacity\"\n        ],\n        [\n            \"fillRule\",\n            \"fill-rule\"\n        ],\n        [\n            \"floodColor\",\n            \"flood-color\"\n        ],\n        [\n            \"floodOpacity\",\n            \"flood-opacity\"\n        ],\n        [\n            \"fontFamily\",\n            \"font-family\"\n        ],\n        [\n            \"fontSize\",\n            \"font-size\"\n        ],\n        [\n            \"fontSizeAdjust\",\n            \"font-size-adjust\"\n        ],\n        [\n            \"fontStretch\",\n            \"font-stretch\"\n        ],\n        [\n            \"fontStyle\",\n            \"font-style\"\n        ],\n        [\n            \"fontVariant\",\n            \"font-variant\"\n        ],\n        [\n            \"fontWeight\",\n            \"font-weight\"\n        ],\n        [\n            \"glyphName\",\n            \"glyph-name\"\n        ],\n        [\n            \"glyphOrientationHorizontal\",\n            \"glyph-orientation-horizontal\"\n        ],\n        [\n            \"glyphOrientationVertical\",\n            \"glyph-orientation-vertical\"\n        ],\n        [\n            \"horizAdvX\",\n            \"horiz-adv-x\"\n        ],\n        [\n            \"horizOriginX\",\n            \"horiz-origin-x\"\n        ],\n        [\n            \"imageRendering\",\n            \"image-rendering\"\n        ],\n        [\n            \"letterSpacing\",\n            \"letter-spacing\"\n        ],\n        [\n            \"lightingColor\",\n            \"lighting-color\"\n        ],\n        [\n            \"markerEnd\",\n            \"marker-end\"\n        ],\n        [\n            \"markerMid\",\n            \"marker-mid\"\n        ],\n        [\n            \"markerStart\",\n            \"marker-start\"\n        ],\n        [\n            \"overlinePosition\",\n            \"overline-position\"\n        ],\n        [\n            \"overlineThickness\",\n            \"overline-thickness\"\n        ],\n        [\n            \"paintOrder\",\n            \"paint-order\"\n        ],\n        [\n            \"panose-1\",\n            \"panose-1\"\n        ],\n        [\n            \"pointerEvents\",\n            \"pointer-events\"\n        ],\n        [\n            \"renderingIntent\",\n            \"rendering-intent\"\n        ],\n        [\n            \"shapeRendering\",\n            \"shape-rendering\"\n        ],\n        [\n            \"stopColor\",\n            \"stop-color\"\n        ],\n        [\n            \"stopOpacity\",\n            \"stop-opacity\"\n        ],\n        [\n            \"strikethroughPosition\",\n            \"strikethrough-position\"\n        ],\n        [\n            \"strikethroughThickness\",\n            \"strikethrough-thickness\"\n        ],\n        [\n            \"strokeDasharray\",\n            \"stroke-dasharray\"\n        ],\n        [\n            \"strokeDashoffset\",\n            \"stroke-dashoffset\"\n        ],\n        [\n            \"strokeLinecap\",\n            \"stroke-linecap\"\n        ],\n        [\n            \"strokeLinejoin\",\n            \"stroke-linejoin\"\n        ],\n        [\n            \"strokeMiterlimit\",\n            \"stroke-miterlimit\"\n        ],\n        [\n            \"strokeOpacity\",\n            \"stroke-opacity\"\n        ],\n        [\n            \"strokeWidth\",\n            \"stroke-width\"\n        ],\n        [\n            \"textAnchor\",\n            \"text-anchor\"\n        ],\n        [\n            \"textDecoration\",\n            \"text-decoration\"\n        ],\n        [\n            \"textRendering\",\n            \"text-rendering\"\n        ],\n        [\n            \"transformOrigin\",\n            \"transform-origin\"\n        ],\n        [\n            \"underlinePosition\",\n            \"underline-position\"\n        ],\n        [\n            \"underlineThickness\",\n            \"underline-thickness\"\n        ],\n        [\n            \"unicodeBidi\",\n            \"unicode-bidi\"\n        ],\n        [\n            \"unicodeRange\",\n            \"unicode-range\"\n        ],\n        [\n            \"unitsPerEm\",\n            \"units-per-em\"\n        ],\n        [\n            \"vAlphabetic\",\n            \"v-alphabetic\"\n        ],\n        [\n            \"vHanging\",\n            \"v-hanging\"\n        ],\n        [\n            \"vIdeographic\",\n            \"v-ideographic\"\n        ],\n        [\n            \"vMathematical\",\n            \"v-mathematical\"\n        ],\n        [\n            \"vectorEffect\",\n            \"vector-effect\"\n        ],\n        [\n            \"vertAdvY\",\n            \"vert-adv-y\"\n        ],\n        [\n            \"vertOriginX\",\n            \"vert-origin-x\"\n        ],\n        [\n            \"vertOriginY\",\n            \"vert-origin-y\"\n        ],\n        [\n            \"wordSpacing\",\n            \"word-spacing\"\n        ],\n        [\n            \"writingMode\",\n            \"writing-mode\"\n        ],\n        [\n            \"xmlnsXlink\",\n            \"xmlns:xlink\"\n        ],\n        [\n            \"xHeight\",\n            \"x-height\"\n        ]\n    ]), possibleStandardNames = {\n        accept: \"accept\",\n        acceptcharset: \"acceptCharset\",\n        \"accept-charset\": \"acceptCharset\",\n        accesskey: \"accessKey\",\n        action: \"action\",\n        allowfullscreen: \"allowFullScreen\",\n        alt: \"alt\",\n        as: \"as\",\n        async: \"async\",\n        autocapitalize: \"autoCapitalize\",\n        autocomplete: \"autoComplete\",\n        autocorrect: \"autoCorrect\",\n        autofocus: \"autoFocus\",\n        autoplay: \"autoPlay\",\n        autosave: \"autoSave\",\n        capture: \"capture\",\n        cellpadding: \"cellPadding\",\n        cellspacing: \"cellSpacing\",\n        challenge: \"challenge\",\n        charset: \"charSet\",\n        checked: \"checked\",\n        children: \"children\",\n        cite: \"cite\",\n        class: \"className\",\n        classid: \"classID\",\n        classname: \"className\",\n        cols: \"cols\",\n        colspan: \"colSpan\",\n        content: \"content\",\n        contenteditable: \"contentEditable\",\n        contextmenu: \"contextMenu\",\n        controls: \"controls\",\n        controlslist: \"controlsList\",\n        coords: \"coords\",\n        crossorigin: \"crossOrigin\",\n        dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n        data: \"data\",\n        datetime: \"dateTime\",\n        default: \"default\",\n        defaultchecked: \"defaultChecked\",\n        defaultvalue: \"defaultValue\",\n        defer: \"defer\",\n        dir: \"dir\",\n        disabled: \"disabled\",\n        disablepictureinpicture: \"disablePictureInPicture\",\n        disableremoteplayback: \"disableRemotePlayback\",\n        download: \"download\",\n        draggable: \"draggable\",\n        enctype: \"encType\",\n        enterkeyhint: \"enterKeyHint\",\n        fetchpriority: \"fetchPriority\",\n        for: \"htmlFor\",\n        form: \"form\",\n        formmethod: \"formMethod\",\n        formaction: \"formAction\",\n        formenctype: \"formEncType\",\n        formnovalidate: \"formNoValidate\",\n        formtarget: \"formTarget\",\n        frameborder: \"frameBorder\",\n        headers: \"headers\",\n        height: \"height\",\n        hidden: \"hidden\",\n        high: \"high\",\n        href: \"href\",\n        hreflang: \"hrefLang\",\n        htmlfor: \"htmlFor\",\n        httpequiv: \"httpEquiv\",\n        \"http-equiv\": \"httpEquiv\",\n        icon: \"icon\",\n        id: \"id\",\n        imagesizes: \"imageSizes\",\n        imagesrcset: \"imageSrcSet\",\n        inert: \"inert\",\n        innerhtml: \"innerHTML\",\n        inputmode: \"inputMode\",\n        integrity: \"integrity\",\n        is: \"is\",\n        itemid: \"itemID\",\n        itemprop: \"itemProp\",\n        itemref: \"itemRef\",\n        itemscope: \"itemScope\",\n        itemtype: \"itemType\",\n        keyparams: \"keyParams\",\n        keytype: \"keyType\",\n        kind: \"kind\",\n        label: \"label\",\n        lang: \"lang\",\n        list: \"list\",\n        loop: \"loop\",\n        low: \"low\",\n        manifest: \"manifest\",\n        marginwidth: \"marginWidth\",\n        marginheight: \"marginHeight\",\n        max: \"max\",\n        maxlength: \"maxLength\",\n        media: \"media\",\n        mediagroup: \"mediaGroup\",\n        method: \"method\",\n        min: \"min\",\n        minlength: \"minLength\",\n        multiple: \"multiple\",\n        muted: \"muted\",\n        name: \"name\",\n        nomodule: \"noModule\",\n        nonce: \"nonce\",\n        novalidate: \"noValidate\",\n        open: \"open\",\n        optimum: \"optimum\",\n        pattern: \"pattern\",\n        placeholder: \"placeholder\",\n        playsinline: \"playsInline\",\n        poster: \"poster\",\n        preload: \"preload\",\n        profile: \"profile\",\n        radiogroup: \"radioGroup\",\n        readonly: \"readOnly\",\n        referrerpolicy: \"referrerPolicy\",\n        rel: \"rel\",\n        required: \"required\",\n        reversed: \"reversed\",\n        role: \"role\",\n        rows: \"rows\",\n        rowspan: \"rowSpan\",\n        sandbox: \"sandbox\",\n        scope: \"scope\",\n        scoped: \"scoped\",\n        scrolling: \"scrolling\",\n        seamless: \"seamless\",\n        selected: \"selected\",\n        shape: \"shape\",\n        size: \"size\",\n        sizes: \"sizes\",\n        span: \"span\",\n        spellcheck: \"spellCheck\",\n        src: \"src\",\n        srcdoc: \"srcDoc\",\n        srclang: \"srcLang\",\n        srcset: \"srcSet\",\n        start: \"start\",\n        step: \"step\",\n        style: \"style\",\n        summary: \"summary\",\n        tabindex: \"tabIndex\",\n        target: \"target\",\n        title: \"title\",\n        type: \"type\",\n        usemap: \"useMap\",\n        value: \"value\",\n        width: \"width\",\n        wmode: \"wmode\",\n        wrap: \"wrap\",\n        about: \"about\",\n        accentheight: \"accentHeight\",\n        \"accent-height\": \"accentHeight\",\n        accumulate: \"accumulate\",\n        additive: \"additive\",\n        alignmentbaseline: \"alignmentBaseline\",\n        \"alignment-baseline\": \"alignmentBaseline\",\n        allowreorder: \"allowReorder\",\n        alphabetic: \"alphabetic\",\n        amplitude: \"amplitude\",\n        arabicform: \"arabicForm\",\n        \"arabic-form\": \"arabicForm\",\n        ascent: \"ascent\",\n        attributename: \"attributeName\",\n        attributetype: \"attributeType\",\n        autoreverse: \"autoReverse\",\n        azimuth: \"azimuth\",\n        basefrequency: \"baseFrequency\",\n        baselineshift: \"baselineShift\",\n        \"baseline-shift\": \"baselineShift\",\n        baseprofile: \"baseProfile\",\n        bbox: \"bbox\",\n        begin: \"begin\",\n        bias: \"bias\",\n        by: \"by\",\n        calcmode: \"calcMode\",\n        capheight: \"capHeight\",\n        \"cap-height\": \"capHeight\",\n        clip: \"clip\",\n        clippath: \"clipPath\",\n        \"clip-path\": \"clipPath\",\n        clippathunits: \"clipPathUnits\",\n        cliprule: \"clipRule\",\n        \"clip-rule\": \"clipRule\",\n        color: \"color\",\n        colorinterpolation: \"colorInterpolation\",\n        \"color-interpolation\": \"colorInterpolation\",\n        colorinterpolationfilters: \"colorInterpolationFilters\",\n        \"color-interpolation-filters\": \"colorInterpolationFilters\",\n        colorprofile: \"colorProfile\",\n        \"color-profile\": \"colorProfile\",\n        colorrendering: \"colorRendering\",\n        \"color-rendering\": \"colorRendering\",\n        contentscripttype: \"contentScriptType\",\n        contentstyletype: \"contentStyleType\",\n        cursor: \"cursor\",\n        cx: \"cx\",\n        cy: \"cy\",\n        d: \"d\",\n        datatype: \"datatype\",\n        decelerate: \"decelerate\",\n        descent: \"descent\",\n        diffuseconstant: \"diffuseConstant\",\n        direction: \"direction\",\n        display: \"display\",\n        divisor: \"divisor\",\n        dominantbaseline: \"dominantBaseline\",\n        \"dominant-baseline\": \"dominantBaseline\",\n        dur: \"dur\",\n        dx: \"dx\",\n        dy: \"dy\",\n        edgemode: \"edgeMode\",\n        elevation: \"elevation\",\n        enablebackground: \"enableBackground\",\n        \"enable-background\": \"enableBackground\",\n        end: \"end\",\n        exponent: \"exponent\",\n        externalresourcesrequired: \"externalResourcesRequired\",\n        fill: \"fill\",\n        fillopacity: \"fillOpacity\",\n        \"fill-opacity\": \"fillOpacity\",\n        fillrule: \"fillRule\",\n        \"fill-rule\": \"fillRule\",\n        filter: \"filter\",\n        filterres: \"filterRes\",\n        filterunits: \"filterUnits\",\n        floodopacity: \"floodOpacity\",\n        \"flood-opacity\": \"floodOpacity\",\n        floodcolor: \"floodColor\",\n        \"flood-color\": \"floodColor\",\n        focusable: \"focusable\",\n        fontfamily: \"fontFamily\",\n        \"font-family\": \"fontFamily\",\n        fontsize: \"fontSize\",\n        \"font-size\": \"fontSize\",\n        fontsizeadjust: \"fontSizeAdjust\",\n        \"font-size-adjust\": \"fontSizeAdjust\",\n        fontstretch: \"fontStretch\",\n        \"font-stretch\": \"fontStretch\",\n        fontstyle: \"fontStyle\",\n        \"font-style\": \"fontStyle\",\n        fontvariant: \"fontVariant\",\n        \"font-variant\": \"fontVariant\",\n        fontweight: \"fontWeight\",\n        \"font-weight\": \"fontWeight\",\n        format: \"format\",\n        from: \"from\",\n        fx: \"fx\",\n        fy: \"fy\",\n        g1: \"g1\",\n        g2: \"g2\",\n        glyphname: \"glyphName\",\n        \"glyph-name\": \"glyphName\",\n        glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n        \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n        glyphorientationvertical: \"glyphOrientationVertical\",\n        \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n        glyphref: \"glyphRef\",\n        gradienttransform: \"gradientTransform\",\n        gradientunits: \"gradientUnits\",\n        hanging: \"hanging\",\n        horizadvx: \"horizAdvX\",\n        \"horiz-adv-x\": \"horizAdvX\",\n        horizoriginx: \"horizOriginX\",\n        \"horiz-origin-x\": \"horizOriginX\",\n        ideographic: \"ideographic\",\n        imagerendering: \"imageRendering\",\n        \"image-rendering\": \"imageRendering\",\n        in2: \"in2\",\n        in: \"in\",\n        inlist: \"inlist\",\n        intercept: \"intercept\",\n        k1: \"k1\",\n        k2: \"k2\",\n        k3: \"k3\",\n        k4: \"k4\",\n        k: \"k\",\n        kernelmatrix: \"kernelMatrix\",\n        kernelunitlength: \"kernelUnitLength\",\n        kerning: \"kerning\",\n        keypoints: \"keyPoints\",\n        keysplines: \"keySplines\",\n        keytimes: \"keyTimes\",\n        lengthadjust: \"lengthAdjust\",\n        letterspacing: \"letterSpacing\",\n        \"letter-spacing\": \"letterSpacing\",\n        lightingcolor: \"lightingColor\",\n        \"lighting-color\": \"lightingColor\",\n        limitingconeangle: \"limitingConeAngle\",\n        local: \"local\",\n        markerend: \"markerEnd\",\n        \"marker-end\": \"markerEnd\",\n        markerheight: \"markerHeight\",\n        markermid: \"markerMid\",\n        \"marker-mid\": \"markerMid\",\n        markerstart: \"markerStart\",\n        \"marker-start\": \"markerStart\",\n        markerunits: \"markerUnits\",\n        markerwidth: \"markerWidth\",\n        mask: \"mask\",\n        maskcontentunits: \"maskContentUnits\",\n        maskunits: \"maskUnits\",\n        mathematical: \"mathematical\",\n        mode: \"mode\",\n        numoctaves: \"numOctaves\",\n        offset: \"offset\",\n        opacity: \"opacity\",\n        operator: \"operator\",\n        order: \"order\",\n        orient: \"orient\",\n        orientation: \"orientation\",\n        origin: \"origin\",\n        overflow: \"overflow\",\n        overlineposition: \"overlinePosition\",\n        \"overline-position\": \"overlinePosition\",\n        overlinethickness: \"overlineThickness\",\n        \"overline-thickness\": \"overlineThickness\",\n        paintorder: \"paintOrder\",\n        \"paint-order\": \"paintOrder\",\n        panose1: \"panose1\",\n        \"panose-1\": \"panose1\",\n        pathlength: \"pathLength\",\n        patterncontentunits: \"patternContentUnits\",\n        patterntransform: \"patternTransform\",\n        patternunits: \"patternUnits\",\n        pointerevents: \"pointerEvents\",\n        \"pointer-events\": \"pointerEvents\",\n        points: \"points\",\n        pointsatx: \"pointsAtX\",\n        pointsaty: \"pointsAtY\",\n        pointsatz: \"pointsAtZ\",\n        popover: \"popover\",\n        popovertarget: \"popoverTarget\",\n        popovertargetaction: \"popoverTargetAction\",\n        prefix: \"prefix\",\n        preservealpha: \"preserveAlpha\",\n        preserveaspectratio: \"preserveAspectRatio\",\n        primitiveunits: \"primitiveUnits\",\n        property: \"property\",\n        r: \"r\",\n        radius: \"radius\",\n        refx: \"refX\",\n        refy: \"refY\",\n        renderingintent: \"renderingIntent\",\n        \"rendering-intent\": \"renderingIntent\",\n        repeatcount: \"repeatCount\",\n        repeatdur: \"repeatDur\",\n        requiredextensions: \"requiredExtensions\",\n        requiredfeatures: \"requiredFeatures\",\n        resource: \"resource\",\n        restart: \"restart\",\n        result: \"result\",\n        results: \"results\",\n        rotate: \"rotate\",\n        rx: \"rx\",\n        ry: \"ry\",\n        scale: \"scale\",\n        security: \"security\",\n        seed: \"seed\",\n        shaperendering: \"shapeRendering\",\n        \"shape-rendering\": \"shapeRendering\",\n        slope: \"slope\",\n        spacing: \"spacing\",\n        specularconstant: \"specularConstant\",\n        specularexponent: \"specularExponent\",\n        speed: \"speed\",\n        spreadmethod: \"spreadMethod\",\n        startoffset: \"startOffset\",\n        stddeviation: \"stdDeviation\",\n        stemh: \"stemh\",\n        stemv: \"stemv\",\n        stitchtiles: \"stitchTiles\",\n        stopcolor: \"stopColor\",\n        \"stop-color\": \"stopColor\",\n        stopopacity: \"stopOpacity\",\n        \"stop-opacity\": \"stopOpacity\",\n        strikethroughposition: \"strikethroughPosition\",\n        \"strikethrough-position\": \"strikethroughPosition\",\n        strikethroughthickness: \"strikethroughThickness\",\n        \"strikethrough-thickness\": \"strikethroughThickness\",\n        string: \"string\",\n        stroke: \"stroke\",\n        strokedasharray: \"strokeDasharray\",\n        \"stroke-dasharray\": \"strokeDasharray\",\n        strokedashoffset: \"strokeDashoffset\",\n        \"stroke-dashoffset\": \"strokeDashoffset\",\n        strokelinecap: \"strokeLinecap\",\n        \"stroke-linecap\": \"strokeLinecap\",\n        strokelinejoin: \"strokeLinejoin\",\n        \"stroke-linejoin\": \"strokeLinejoin\",\n        strokemiterlimit: \"strokeMiterlimit\",\n        \"stroke-miterlimit\": \"strokeMiterlimit\",\n        strokewidth: \"strokeWidth\",\n        \"stroke-width\": \"strokeWidth\",\n        strokeopacity: \"strokeOpacity\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n        suppresshydrationwarning: \"suppressHydrationWarning\",\n        surfacescale: \"surfaceScale\",\n        systemlanguage: \"systemLanguage\",\n        tablevalues: \"tableValues\",\n        targetx: \"targetX\",\n        targety: \"targetY\",\n        textanchor: \"textAnchor\",\n        \"text-anchor\": \"textAnchor\",\n        textdecoration: \"textDecoration\",\n        \"text-decoration\": \"textDecoration\",\n        textlength: \"textLength\",\n        textrendering: \"textRendering\",\n        \"text-rendering\": \"textRendering\",\n        to: \"to\",\n        transform: \"transform\",\n        transformorigin: \"transformOrigin\",\n        \"transform-origin\": \"transformOrigin\",\n        typeof: \"typeof\",\n        u1: \"u1\",\n        u2: \"u2\",\n        underlineposition: \"underlinePosition\",\n        \"underline-position\": \"underlinePosition\",\n        underlinethickness: \"underlineThickness\",\n        \"underline-thickness\": \"underlineThickness\",\n        unicode: \"unicode\",\n        unicodebidi: \"unicodeBidi\",\n        \"unicode-bidi\": \"unicodeBidi\",\n        unicoderange: \"unicodeRange\",\n        \"unicode-range\": \"unicodeRange\",\n        unitsperem: \"unitsPerEm\",\n        \"units-per-em\": \"unitsPerEm\",\n        unselectable: \"unselectable\",\n        valphabetic: \"vAlphabetic\",\n        \"v-alphabetic\": \"vAlphabetic\",\n        values: \"values\",\n        vectoreffect: \"vectorEffect\",\n        \"vector-effect\": \"vectorEffect\",\n        version: \"version\",\n        vertadvy: \"vertAdvY\",\n        \"vert-adv-y\": \"vertAdvY\",\n        vertoriginx: \"vertOriginX\",\n        \"vert-origin-x\": \"vertOriginX\",\n        vertoriginy: \"vertOriginY\",\n        \"vert-origin-y\": \"vertOriginY\",\n        vhanging: \"vHanging\",\n        \"v-hanging\": \"vHanging\",\n        videographic: \"vIdeographic\",\n        \"v-ideographic\": \"vIdeographic\",\n        viewbox: \"viewBox\",\n        viewtarget: \"viewTarget\",\n        visibility: \"visibility\",\n        vmathematical: \"vMathematical\",\n        \"v-mathematical\": \"vMathematical\",\n        vocab: \"vocab\",\n        widths: \"widths\",\n        wordspacing: \"wordSpacing\",\n        \"word-spacing\": \"wordSpacing\",\n        writingmode: \"writingMode\",\n        \"writing-mode\": \"writingMode\",\n        x1: \"x1\",\n        x2: \"x2\",\n        x: \"x\",\n        xchannelselector: \"xChannelSelector\",\n        xheight: \"xHeight\",\n        \"x-height\": \"xHeight\",\n        xlinkactuate: \"xlinkActuate\",\n        \"xlink:actuate\": \"xlinkActuate\",\n        xlinkarcrole: \"xlinkArcrole\",\n        \"xlink:arcrole\": \"xlinkArcrole\",\n        xlinkhref: \"xlinkHref\",\n        \"xlink:href\": \"xlinkHref\",\n        xlinkrole: \"xlinkRole\",\n        \"xlink:role\": \"xlinkRole\",\n        xlinkshow: \"xlinkShow\",\n        \"xlink:show\": \"xlinkShow\",\n        xlinktitle: \"xlinkTitle\",\n        \"xlink:title\": \"xlinkTitle\",\n        xlinktype: \"xlinkType\",\n        \"xlink:type\": \"xlinkType\",\n        xmlbase: \"xmlBase\",\n        \"xml:base\": \"xmlBase\",\n        xmllang: \"xmlLang\",\n        \"xml:lang\": \"xmlLang\",\n        xmlns: \"xmlns\",\n        \"xml:space\": \"xmlSpace\",\n        xmlnsxlink: \"xmlnsXlink\",\n        \"xmlns:xlink\": \"xmlnsXlink\",\n        xmlspace: \"xmlSpace\",\n        y1: \"y1\",\n        y2: \"y2\",\n        y: \"y\",\n        ychannelselector: \"yChannelSelector\",\n        z: \"z\",\n        zoomandpan: \"zoomAndPan\"\n    }, ariaProperties = {\n        \"aria-current\": 0,\n        \"aria-description\": 0,\n        \"aria-details\": 0,\n        \"aria-disabled\": 0,\n        \"aria-hidden\": 0,\n        \"aria-invalid\": 0,\n        \"aria-keyshortcuts\": 0,\n        \"aria-label\": 0,\n        \"aria-roledescription\": 0,\n        \"aria-autocomplete\": 0,\n        \"aria-checked\": 0,\n        \"aria-expanded\": 0,\n        \"aria-haspopup\": 0,\n        \"aria-level\": 0,\n        \"aria-modal\": 0,\n        \"aria-multiline\": 0,\n        \"aria-multiselectable\": 0,\n        \"aria-orientation\": 0,\n        \"aria-placeholder\": 0,\n        \"aria-pressed\": 0,\n        \"aria-readonly\": 0,\n        \"aria-required\": 0,\n        \"aria-selected\": 0,\n        \"aria-sort\": 0,\n        \"aria-valuemax\": 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": 0,\n        \"aria-valuetext\": 0,\n        \"aria-atomic\": 0,\n        \"aria-busy\": 0,\n        \"aria-live\": 0,\n        \"aria-relevant\": 0,\n        \"aria-dropeffect\": 0,\n        \"aria-grabbed\": 0,\n        \"aria-activedescendant\": 0,\n        \"aria-colcount\": 0,\n        \"aria-colindex\": 0,\n        \"aria-colspan\": 0,\n        \"aria-controls\": 0,\n        \"aria-describedby\": 0,\n        \"aria-errormessage\": 0,\n        \"aria-flowto\": 0,\n        \"aria-labelledby\": 0,\n        \"aria-owns\": 0,\n        \"aria-posinset\": 0,\n        \"aria-rowcount\": 0,\n        \"aria-rowindex\": 0,\n        \"aria-rowspan\": 0,\n        \"aria-setsize\": 0\n    }, warnedProperties$1 = {}, rARIA$1 = RegExp(\"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"), rARIACamel$1 = RegExp(\"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"), didWarnValueNull = !1, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(\"^(aria)-[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"), rARIACamel = RegExp(\"^(aria)[A-Z][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"), isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = !1, canUseDOM = !( true || 0), passiveBrowserEventsSupported = !1;\n    if (canUseDOM) try {\n        var options$jscomp$0 = {};\n        Object.defineProperty(options$jscomp$0, \"passive\", {\n            get: function() {\n                passiveBrowserEventsSupported = !0;\n            }\n        });\n        window.addEventListener(\"test\", options$jscomp$0, options$jscomp$0);\n        window.removeEventListener(\"test\", options$jscomp$0, options$jscomp$0);\n    } catch (e) {\n        passiveBrowserEventsSupported = !1;\n    }\n    var root = null, startText = null, fallbackText = null, EventInterface = {\n        eventPhase: 0,\n        bubbles: 0,\n        cancelable: 0,\n        timeStamp: function(event) {\n            return event.timeStamp || Date.now();\n        },\n        defaultPrevented: 0,\n        isTrusted: 0\n    }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, {\n        view: 0,\n        detail: 0\n    }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {\n        screenX: 0,\n        screenY: 0,\n        clientX: 0,\n        clientY: 0,\n        pageX: 0,\n        pageY: 0,\n        ctrlKey: 0,\n        shiftKey: 0,\n        altKey: 0,\n        metaKey: 0,\n        getModifierState: getEventModifierState,\n        button: 0,\n        buttons: 0,\n        relatedTarget: function(event) {\n            return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;\n        },\n        movementX: function(event) {\n            if (\"movementX\" in event) return event.movementX;\n            event !== lastMouseEvent && (lastMouseEvent && \"mousemove\" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);\n            return lastMovementX;\n        },\n        movementY: function(event) {\n            return \"movementY\" in event ? event.movementY : lastMovementY;\n        }\n    }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, {\n        dataTransfer: 0\n    }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, {\n        relatedTarget: 0\n    }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {\n        animationName: 0,\n        elapsedTime: 0,\n        pseudoElement: 0\n    }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {\n        clipboardData: function(event) {\n            return \"clipboardData\" in event ? event.clipboardData : window.clipboardData;\n        }\n    }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, {\n        data: 0\n    }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {\n        Esc: \"Escape\",\n        Spacebar: \" \",\n        Left: \"ArrowLeft\",\n        Up: \"ArrowUp\",\n        Right: \"ArrowRight\",\n        Down: \"ArrowDown\",\n        Del: \"Delete\",\n        Win: \"OS\",\n        Menu: \"ContextMenu\",\n        Apps: \"ContextMenu\",\n        Scroll: \"ScrollLock\",\n        MozPrintableKey: \"Unidentified\"\n    }, translateToKey = {\n        8: \"Backspace\",\n        9: \"Tab\",\n        12: \"Clear\",\n        13: \"Enter\",\n        16: \"Shift\",\n        17: \"Control\",\n        18: \"Alt\",\n        19: \"Pause\",\n        20: \"CapsLock\",\n        27: \"Escape\",\n        32: \" \",\n        33: \"PageUp\",\n        34: \"PageDown\",\n        35: \"End\",\n        36: \"Home\",\n        37: \"ArrowLeft\",\n        38: \"ArrowUp\",\n        39: \"ArrowRight\",\n        40: \"ArrowDown\",\n        45: \"Insert\",\n        46: \"Delete\",\n        112: \"F1\",\n        113: \"F2\",\n        114: \"F3\",\n        115: \"F4\",\n        116: \"F5\",\n        117: \"F6\",\n        118: \"F7\",\n        119: \"F8\",\n        120: \"F9\",\n        121: \"F10\",\n        122: \"F11\",\n        123: \"F12\",\n        144: \"NumLock\",\n        145: \"ScrollLock\",\n        224: \"Meta\"\n    }, modifierKeyToProp = {\n        Alt: \"altKey\",\n        Control: \"ctrlKey\",\n        Meta: \"metaKey\",\n        Shift: \"shiftKey\"\n    }, KeyboardEventInterface = assign({}, UIEventInterface, {\n        key: function(nativeEvent) {\n            if (nativeEvent.key) {\n                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n                if (\"Unidentified\" !== key) return key;\n            }\n            return \"keypress\" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? \"Enter\" : String.fromCharCode(nativeEvent)) : \"keydown\" === nativeEvent.type || \"keyup\" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || \"Unidentified\" : \"\";\n        },\n        code: 0,\n        location: 0,\n        ctrlKey: 0,\n        shiftKey: 0,\n        altKey: 0,\n        metaKey: 0,\n        repeat: 0,\n        locale: 0,\n        getModifierState: getEventModifierState,\n        charCode: function(event) {\n            return \"keypress\" === event.type ? getEventCharCode(event) : 0;\n        },\n        keyCode: function(event) {\n            return \"keydown\" === event.type || \"keyup\" === event.type ? event.keyCode : 0;\n        },\n        which: function(event) {\n            return \"keypress\" === event.type ? getEventCharCode(event) : \"keydown\" === event.type || \"keyup\" === event.type ? event.keyCode : 0;\n        }\n    }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {\n        pointerId: 0,\n        width: 0,\n        height: 0,\n        pressure: 0,\n        tangentialPressure: 0,\n        tiltX: 0,\n        tiltY: 0,\n        twist: 0,\n        pointerType: 0,\n        isPrimary: 0\n    }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {\n        touches: 0,\n        targetTouches: 0,\n        changedTouches: 0,\n        altKey: 0,\n        metaKey: 0,\n        ctrlKey: 0,\n        shiftKey: 0,\n        getModifierState: getEventModifierState\n    }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {\n        propertyName: 0,\n        elapsedTime: 0,\n        pseudoElement: 0\n    }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {\n        deltaX: function(event) {\n            return \"deltaX\" in event ? event.deltaX : \"wheelDeltaX\" in event ? -event.wheelDeltaX : 0;\n        },\n        deltaY: function(event) {\n            return \"deltaY\" in event ? event.deltaY : \"wheelDeltaY\" in event ? -event.wheelDeltaY : \"wheelDelta\" in event ? -event.wheelDelta : 0;\n        },\n        deltaZ: 0,\n        deltaMode: 0\n    }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {\n        newState: 0,\n        oldState: 0\n    }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [\n        9,\n        13,\n        27,\n        32\n    ], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && \"CompositionEvent\" in window, documentMode = null;\n    canUseDOM && \"documentMode\" in document && (documentMode = document.documentMode);\n    var canUseTextInputEvent = canUseDOM && \"TextEvent\" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = !1, isComposing = !1, supportedInputTypes = {\n        color: !0,\n        date: !0,\n        datetime: !0,\n        \"datetime-local\": !0,\n        email: !0,\n        month: !0,\n        number: !0,\n        password: !0,\n        range: !0,\n        search: !0,\n        tel: !0,\n        text: !0,\n        time: !0,\n        url: !0,\n        week: !0\n    }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = !1;\n    canUseDOM && (isInputEventSupported = isEventSupported(\"input\") && (!document.documentMode || 9 < document.documentMode));\n    var objectIs = \"function\" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && \"documentMode\" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = !1, vendorPrefixes = {\n        animationend: makePrefixMap(\"Animation\", \"AnimationEnd\"),\n        animationiteration: makePrefixMap(\"Animation\", \"AnimationIteration\"),\n        animationstart: makePrefixMap(\"Animation\", \"AnimationStart\"),\n        transitionrun: makePrefixMap(\"Transition\", \"TransitionRun\"),\n        transitionstart: makePrefixMap(\"Transition\", \"TransitionStart\"),\n        transitioncancel: makePrefixMap(\"Transition\", \"TransitionCancel\"),\n        transitionend: makePrefixMap(\"Transition\", \"TransitionEnd\")\n    }, prefixedEventNames = {}, style = {};\n    canUseDOM && (style = document.createElement(\"div\").style, \"AnimationEvent\" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), \"TransitionEvent\" in window || delete vendorPrefixes.transitionend.transition);\n    var ANIMATION_END = getVendorPrefixedEventName(\"animationend\"), ANIMATION_ITERATION = getVendorPrefixedEventName(\"animationiteration\"), ANIMATION_START = getVendorPrefixedEventName(\"animationstart\"), TRANSITION_RUN = getVendorPrefixedEventName(\"transitionrun\"), TRANSITION_START = getVendorPrefixedEventName(\"transitionstart\"), TRANSITION_CANCEL = getVendorPrefixedEventName(\"transitioncancel\"), TRANSITION_END = getVendorPrefixedEventName(\"transitionend\"), topLevelEventsToReactNames = new Map(), simpleEventPluginEvents = \"abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel\".split(\" \");\n    simpleEventPluginEvents.push(\"scrollEnd\");\n    var CapturedStacks = new WeakMap(), OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, NoStrictPassiveEffectsMode = 64, SuspenseyImagesMode = 32;\n    var hasBadMapPolyfill = !1;\n    try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        new Map([\n            [\n                nonExtensibleObject,\n                null\n            ]\n        ]);\n        new Set([\n            nonExtensibleObject\n        ]);\n    } catch (e$3) {\n        hasBadMapPolyfill = !0;\n    }\n    var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = \"\", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error(\"Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), lastResetTime = 0;\n    if (\"object\" === typeof performance && \"function\" === typeof performance.now) {\n        var localPerformance = performance;\n        var getCurrentTime = function() {\n            return localPerformance.now();\n        };\n    } else {\n        var localDate = Date;\n        getCurrentTime = function() {\n            return localDate.now();\n        };\n    }\n    var valueCursor = createCursor(null);\n    var rendererCursorDEV = createCursor(null);\n    var rendererSigil = {};\n    var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = !1, AbortControllerLocal = \"undefined\" !== typeof AbortController ? AbortController : function() {\n        var listeners = [], signal = this.signal = {\n            aborted: !1,\n            addEventListener: function(type, listener) {\n                listeners.push(listener);\n            }\n        };\n        this.abort = function() {\n            signal.aborted = !0;\n            listeners.forEach(function(listener) {\n                return listener();\n            });\n        };\n    }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        Consumer: null,\n        Provider: null,\n        _currentValue: null,\n        _currentValue2: null,\n        _threadCount: 0,\n        _currentRenderer: null,\n        _currentRenderer2: null\n    }, now = Scheduler.unstable_now, renderStartTime = -0, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, componentEffectStartTime = -1.1, currentUpdateIsNested = !1, nestedUpdateScheduled = !1, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;\n    ReactSharedInternals.S = function(transition, returnValue) {\n        \"object\" === typeof returnValue && null !== returnValue && \"function\" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);\n        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);\n    };\n    var resumedCache = createCursor(null), ReactStrictModeWarnings = {\n        recordUnsafeLifecycleWarnings: function() {},\n        flushPendingUnsafeLifecycleWarnings: function() {},\n        recordLegacyContextWarning: function() {},\n        flushLegacyContextWarning: function() {},\n        discardPendingWarnings: function() {}\n    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set();\n    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n        didWarnAboutUnsafeLifecycles.has(fiber.type) || (\"function\" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && \"function\" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), \"function\" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), \"function\" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && \"function\" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));\n    };\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n        var componentWillMountUniqueNames = new Set();\n        0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {\n            componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillMountWarnings = []);\n        var UNSAFE_componentWillMountUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillMountWarnings = []);\n        var componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillReceivePropsWarnings = []);\n        var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);\n        var componentWillUpdateUniqueNames = new Set();\n        0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n            componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillUpdateWarnings = []);\n        var UNSAFE_componentWillUpdateUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillUpdateWarnings = []);\n        if (0 < UNSAFE_componentWillMountUniqueNames.size) {\n            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n            console.error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\\nPlease update the following components: %s\", sortedNames);\n        }\n        0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(\"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(\"componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n    };\n    var pendingLegacyContextWarning = new Map(), didWarnAboutLegacyContext = new Set();\n    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n        var strictRoot = null;\n        for(var node = fiber; null !== node;)node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;\n        null === strictRoot ? console.error(\"Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.\") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && \"function\" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));\n    };\n    ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n        pendingLegacyContextWarning.forEach(function(fiberArray) {\n            if (0 !== fiberArray.length) {\n                var firstFiber = fiberArray[0], uniqueNames = new Set();\n                fiberArray.forEach(function(fiber) {\n                    uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                    didWarnAboutLegacyContext.add(fiber.type);\n                });\n                var sortedNames = setToSortedString(uniqueNames);\n                runWithFiberInDEV(firstFiber, function() {\n                    console.error(\"Legacy context API has been detected within a strict-mode tree.\\n\\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\\n\\nPlease update the following components: %s\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context\", sortedNames);\n                });\n            }\n        });\n    };\n    ReactStrictModeWarnings.discardPendingWarnings = function() {\n        pendingComponentWillMountWarnings = [];\n        pendingUNSAFE_ComponentWillMountWarnings = [];\n        pendingComponentWillReceivePropsWarnings = [];\n        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n        pendingComponentWillUpdateWarnings = [];\n        pendingUNSAFE_ComponentWillUpdateWarnings = [];\n        pendingLegacyContextWarning = new Map();\n    };\n    var SuspenseException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"), SuspenseyCommitException = Error(\"Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), SuspenseActionException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary.\"), noopSuspenseyCommitThenable = {\n        then: function() {\n            console.error('Internal React error: A listener was unexpectedly attached to a \"noop\" thenable. This is a bug in React. Please file an issue.');\n        }\n    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = !1, callComponent = {\n        \"react-stack-bottom-frame\": function(Component, props, secondArg) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return Component(props, secondArg);\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callComponentInDEV = callComponent[\"react-stack-bottom-frame\"].bind(callComponent), callRender = {\n        \"react-stack-bottom-frame\": function(instance) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return instance.render();\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender), callComponentDidMount = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance) {\n            try {\n                instance.componentDidMount();\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidMountInDEV = callComponentDidMount[\"react-stack-bottom-frame\"].bind(callComponentDidMount), callComponentDidUpdate = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance, prevProps, prevState, snapshot) {\n            try {\n                instance.componentDidUpdate(prevProps, prevState, snapshot);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidUpdateInDEV = callComponentDidUpdate[\"react-stack-bottom-frame\"].bind(callComponentDidUpdate), callComponentDidCatch = {\n        \"react-stack-bottom-frame\": function(instance, errorInfo) {\n            var stack = errorInfo.stack;\n            instance.componentDidCatch(errorInfo.value, {\n                componentStack: null !== stack ? stack : \"\"\n            });\n        }\n    }, callComponentDidCatchInDEV = callComponentDidCatch[\"react-stack-bottom-frame\"].bind(callComponentDidCatch), callComponentWillUnmount = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, instance) {\n            try {\n                instance.componentWillUnmount();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callComponentWillUnmountInDEV = callComponentWillUnmount[\"react-stack-bottom-frame\"].bind(callComponentWillUnmount), callCreate = {\n        \"react-stack-bottom-frame\": function(effect) {\n            var create = effect.create;\n            effect = effect.inst;\n            create = create();\n            return effect.destroy = create;\n        }\n    }, callCreateInDEV = callCreate[\"react-stack-bottom-frame\"].bind(callCreate), callDestroy = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callDestroyInDEV = callDestroy[\"react-stack-bottom-frame\"].bind(callDestroy), callLazyInit = {\n        \"react-stack-bottom-frame\": function(lazy) {\n            var init = lazy._init;\n            return init(lazy._payload);\n        }\n    }, callLazyInitInDEV = callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit), thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;\n    var didWarnAboutGenerators = didWarnAboutMaps = !1;\n    var ownerHasKeyUseWarning = {};\n    var ownerHasFunctionTypeWarning = {};\n    var ownerHasSymbolTypeWarning = {};\n    warnForMissingKey = function(returnFiber, workInProgress, child) {\n        if (null !== child && \"object\" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {\n            if (\"object\" !== typeof child._store) throw Error(\"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\");\n            child._store.validated = 1;\n            var componentName = getComponentNameFromFiber(returnFiber), componentKey = componentName || \"null\";\n            if (!ownerHasKeyUseWarning[componentKey]) {\n                ownerHasKeyUseWarning[componentKey] = !0;\n                child = child._owner;\n                returnFiber = returnFiber._debugOwner;\n                var currentComponentErrorInfo = \"\";\n                returnFiber && \"number\" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = \"\\n\\nCheck the render method of `\" + componentKey + \"`.\");\n                currentComponentErrorInfo || componentName && (currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\");\n                var childOwnerAppendix = \"\";\n                null != child && returnFiber !== child && (componentName = null, \"number\" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : \"string\" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = \" It was passed a child from \" + componentName + \".\"));\n                runWithFiberInDEV(workInProgress, function() {\n                    console.error('Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                });\n            }\n        }\n    };\n    var reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1;\n    var didWarnUpdateInsideUpdate = !1;\n    var currentlyProcessingQueue = null;\n    var didReadFromEntangledAsyncAction = !1, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;\n    var didWarnAboutMismatchedHooksForComponent = new Set();\n    var didWarnAboutUseWrappedInTryCatch = new Set();\n    var didWarnAboutAsyncClientComponent = new Set();\n    var didWarnAboutUseFormState = new Set();\n    var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1, ContextOnlyDispatcher = {\n        readContext: readContext,\n        use: use,\n        useCallback: throwInvalidHookError,\n        useContext: throwInvalidHookError,\n        useEffect: throwInvalidHookError,\n        useImperativeHandle: throwInvalidHookError,\n        useLayoutEffect: throwInvalidHookError,\n        useInsertionEffect: throwInvalidHookError,\n        useMemo: throwInvalidHookError,\n        useReducer: throwInvalidHookError,\n        useRef: throwInvalidHookError,\n        useState: throwInvalidHookError,\n        useDebugValue: throwInvalidHookError,\n        useDeferredValue: throwInvalidHookError,\n        useTransition: throwInvalidHookError,\n        useSyncExternalStore: throwInvalidHookError,\n        useId: throwInvalidHookError,\n        useHostTransitionStatus: throwInvalidHookError,\n        useFormState: throwInvalidHookError,\n        useActionState: throwInvalidHookError,\n        useOptimistic: throwInvalidHookError,\n        useMemoCache: throwInvalidHookError,\n        useCacheRefresh: throwInvalidHookError\n    }, HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n    HooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            mountHookTypesDev();\n            return mountId();\n        },\n        useFormState: function(action, initialState) {\n            currentHookNameInDev = \"useFormState\";\n            mountHookTypesDev();\n            warnOnUseFormStateInDev();\n            return mountActionState(action, initialState);\n        },\n        useActionState: function(action, initialState) {\n            currentHookNameInDev = \"useActionState\";\n            mountHookTypesDev();\n            return mountActionState(action, initialState);\n        },\n        useOptimistic: function(passthrough) {\n            currentHookNameInDev = \"useOptimistic\";\n            mountHookTypesDev();\n            return mountOptimistic(passthrough);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useMemoCache: useMemoCache,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return mountId();\n        },\n        useActionState: function(action, initialState) {\n            currentHookNameInDev = \"useActionState\";\n            updateHookTypesDev();\n            return mountActionState(action, initialState);\n        },\n        useFormState: function(action, initialState) {\n            currentHookNameInDev = \"useFormState\";\n            updateHookTypesDev();\n            warnOnUseFormStateInDev();\n            return mountActionState(action, initialState);\n        },\n        useOptimistic: function(passthrough) {\n            currentHookNameInDev = \"useOptimistic\";\n            updateHookTypesDev();\n            return mountOptimistic(passthrough);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useMemoCache: useMemoCache,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useFormState: function(action) {\n            currentHookNameInDev = \"useFormState\";\n            updateHookTypesDev();\n            warnOnUseFormStateInDev();\n            return updateActionState(action);\n        },\n        useActionState: function(action) {\n            currentHookNameInDev = \"useActionState\";\n            updateHookTypesDev();\n            return updateActionState(action);\n        },\n        useOptimistic: function(passthrough, reducer) {\n            currentHookNameInDev = \"useOptimistic\";\n            updateHookTypesDev();\n            return updateOptimistic(passthrough, reducer);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useMemoCache: useMemoCache,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useFormState: function(action) {\n            currentHookNameInDev = \"useFormState\";\n            updateHookTypesDev();\n            warnOnUseFormStateInDev();\n            return rerenderActionState(action);\n        },\n        useActionState: function(action) {\n            currentHookNameInDev = \"useActionState\";\n            updateHookTypesDev();\n            return rerenderActionState(action);\n        },\n        useOptimistic: function(passthrough, reducer) {\n            currentHookNameInDev = \"useOptimistic\";\n            updateHookTypesDev();\n            return rerenderOptimistic(passthrough, reducer);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useMemoCache: useMemoCache,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountId();\n        },\n        useFormState: function(action, initialState) {\n            currentHookNameInDev = \"useFormState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountActionState(action, initialState);\n        },\n        useActionState: function(action, initialState) {\n            currentHookNameInDev = \"useActionState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountActionState(action, initialState);\n        },\n        useOptimistic: function(passthrough) {\n            currentHookNameInDev = \"useOptimistic\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountOptimistic(passthrough);\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useFormState: function(action) {\n            currentHookNameInDev = \"useFormState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateActionState(action);\n        },\n        useActionState: function(action) {\n            currentHookNameInDev = \"useActionState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateActionState(action);\n        },\n        useOptimistic: function(passthrough, reducer) {\n            currentHookNameInDev = \"useOptimistic\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateOptimistic(passthrough, reducer);\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useFormState: function(action) {\n            currentHookNameInDev = \"useFormState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderActionState(action);\n        },\n        useActionState: function(action) {\n            currentHookNameInDev = \"useActionState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderActionState(action);\n        },\n        useOptimistic: function(passthrough, reducer) {\n            currentHookNameInDev = \"useOptimistic\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderOptimistic(passthrough, reducer);\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        },\n        useHostTransitionStatus: useHostTransitionStatus,\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    var fakeInternalInstance = {};\n    var didWarnAboutStateAssignmentForComponent = new Set();\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    Object.freeze(fakeInternalInstance);\n    var classComponentUpdater = {\n        enqueueSetState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueReplaceState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ReplaceState;\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueForceUpdate: function(inst, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ForceUpdate;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            callback = enqueueUpdate(inst, update, lane);\n            null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));\n            null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);\n        }\n    }, reportGlobalError = \"function\" === typeof reportError ? reportError : function(error) {\n        if (false) { var event; } else if (\"object\" === typeof process && \"function\" === typeof process.emit) {\n            process.emit(\"uncaughtException\", error);\n            return;\n        }\n        console.error(error);\n    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(\"This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue.\"), didReceiveUpdate = !1;\n    var didWarnAboutBadClass = {};\n    var didWarnAboutContextTypeOnFunctionComponent = {};\n    var didWarnAboutContextTypes = {};\n    var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n    var didWarnAboutReassigningProps = !1;\n    var didWarnAboutRevealOrder = {};\n    var didWarnAboutTailOptions = {};\n    var SUSPENDED_MARKER = {\n        dehydrated: null,\n        treeContext: null,\n        retryLane: 0,\n        hydrationErrors: null\n    }, hasWarnedAboutUsingNoValuePropOnContextProvider = !1, didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n    var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = !1, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {\n        getCacheForType: function(resourceType) {\n            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);\n            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));\n            return cacheForType;\n        },\n        getOwner: function() {\n            return current;\n        }\n    };\n    if (\"function\" === typeof Symbol && Symbol.for) {\n        var symbolFor = Symbol.for;\n        symbolFor(\"selector.component\");\n        symbolFor(\"selector.has_pseudo_class\");\n        symbolFor(\"selector.role\");\n        symbolFor(\"selector.test_id\");\n        symbolFor(\"selector.text\");\n    }\n    var commitHooks = [], PossiblyWeakMap = \"function\" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = !1, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = !1;\n    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n    var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, didScheduleMicrotask_act = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0, fakeActCallbackNode = {};\n    (function() {\n        for(var i = 0; i < simpleEventPluginEvents.length; i++){\n            var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();\n            eventName = eventName[0].toUpperCase() + eventName.slice(1);\n            registerSimpleEvent(domEventName, \"on\" + eventName);\n        }\n        registerSimpleEvent(ANIMATION_END, \"onAnimationEnd\");\n        registerSimpleEvent(ANIMATION_ITERATION, \"onAnimationIteration\");\n        registerSimpleEvent(ANIMATION_START, \"onAnimationStart\");\n        registerSimpleEvent(\"dblclick\", \"onDoubleClick\");\n        registerSimpleEvent(\"focusin\", \"onFocus\");\n        registerSimpleEvent(\"focusout\", \"onBlur\");\n        registerSimpleEvent(TRANSITION_RUN, \"onTransitionRun\");\n        registerSimpleEvent(TRANSITION_START, \"onTransitionStart\");\n        registerSimpleEvent(TRANSITION_CANCEL, \"onTransitionCancel\");\n        registerSimpleEvent(TRANSITION_END, \"onTransitionEnd\");\n    })();\n    registerDirectEvent(\"onMouseEnter\", [\n        \"mouseout\",\n        \"mouseover\"\n    ]);\n    registerDirectEvent(\"onMouseLeave\", [\n        \"mouseout\",\n        \"mouseover\"\n    ]);\n    registerDirectEvent(\"onPointerEnter\", [\n        \"pointerout\",\n        \"pointerover\"\n    ]);\n    registerDirectEvent(\"onPointerLeave\", [\n        \"pointerout\",\n        \"pointerover\"\n    ]);\n    registerTwoPhaseEvent(\"onChange\", \"change click focusin focusout input keydown keyup selectionchange\".split(\" \"));\n    registerTwoPhaseEvent(\"onSelect\", \"focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange\".split(\" \"));\n    registerTwoPhaseEvent(\"onBeforeInput\", [\n        \"compositionend\",\n        \"keypress\",\n        \"textInput\",\n        \"paste\"\n    ]);\n    registerTwoPhaseEvent(\"onCompositionEnd\", \"compositionend focusout keydown keypress keyup mousedown\".split(\" \"));\n    registerTwoPhaseEvent(\"onCompositionStart\", \"compositionstart focusout keydown keypress keyup mousedown\".split(\" \"));\n    registerTwoPhaseEvent(\"onCompositionUpdate\", \"compositionupdate focusout keydown keypress keyup mousedown\".split(\" \"));\n    var mediaEventTypes = \"abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting\".split(\" \"), nonDelegatedEvents = new Set(\"beforetoggle cancel close invalid load scroll scrollend toggle\".split(\" \").concat(mediaEventTypes)), listeningMarker = \"_reactListening\" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = !1, didWarnUncontrolledToControlled = !1, didWarnFormActionType = !1, didWarnFormActionName = !1, didWarnFormActionTarget = !1, didWarnFormActionMethod = !1, didWarnPopoverTargetObject = !1;\n    var didWarnForNewBooleanPropsWithEmptyValue = {};\n    var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g, xlinkNamespace = \"http://www.w3.org/1999/xlink\", xmlNamespace = \"http://www.w3.org/XML/1998/namespace\", EXPECTED_FORM_ACTION_URL = \"javascript:throw new Error('React form unexpectedly submitted.')\", SUPPRESS_HYDRATION_WARNING = \"suppressHydrationWarning\", SUSPENSE_START_DATA = \"$\", SUSPENSE_END_DATA = \"/$\", SUSPENSE_PENDING_START_DATA = \"$?\", SUSPENSE_FALLBACK_START_DATA = \"$!\", PREAMBLE_CONTRIBUTION_HTML = 1, PREAMBLE_CONTRIBUTION_BODY = 2, PREAMBLE_CONTRIBUTION_HEAD = 4, FORM_STATE_IS_MATCHING = \"F!\", FORM_STATE_IS_NOT_MATCHING = \"F\", DOCUMENT_READY_STATE_COMPLETE = \"complete\", STYLE = \"style\", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = {\n        dialog: !0,\n        webview: !0\n    }, currentPopstateTransitionEvent = null, scheduleTimeout = \"function\" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = \"function\" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = \"function\" === typeof Promise ? Promise : void 0, scheduleMicrotask = \"function\" === typeof queueMicrotask ? queueMicrotask : \"undefined\" !== typeof localPromise ? function(callback) {\n        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);\n    } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = new Map(), preconnectsSet = new Set(), previousDispatcher = ReactDOMSharedInternals.d;\n    ReactDOMSharedInternals.d = {\n        f: function() {\n            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();\n            return previousWasRendering || wasRendering;\n        },\n        r: function(form) {\n            var formInst = getInstanceFromNode(form);\n            null !== formInst && 5 === formInst.tag && \"form\" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);\n        },\n        D: function(href) {\n            previousDispatcher.D(href);\n            preconnectAs(\"dns-prefetch\", href, null);\n        },\n        C: function(href, crossOrigin) {\n            previousDispatcher.C(href, crossOrigin);\n            preconnectAs(\"preconnect\", href, crossOrigin);\n        },\n        L: function(href, as, options) {\n            previousDispatcher.L(href, as, options);\n            var ownerDocument = globalDocument;\n            if (ownerDocument && href && as) {\n                var preloadSelector = 'link[rel=\"preload\"][as=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '\"]';\n                \"image\" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet) + '\"]', \"string\" === typeof options.imageSizes && (preloadSelector += '[imagesizes=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes) + '\"]')) : preloadSelector += '[href=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '\"]' : preloadSelector += '[href=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '\"]';\n                var key = preloadSelector;\n                switch(as){\n                    case \"style\":\n                        key = getStyleKey(href);\n                        break;\n                    case \"script\":\n                        key = getScriptKey(href);\n                }\n                preloadPropsMap.has(key) || (href = assign({\n                    rel: \"preload\",\n                    href: \"image\" === as && options && options.imageSrcSet ? void 0 : href,\n                    as: as\n                }, options), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || \"style\" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || \"script\" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement(\"link\"), setInitialProperties(as, \"link\", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));\n            }\n        },\n        m: function(href, options) {\n            previousDispatcher.m(href, options);\n            var ownerDocument = globalDocument;\n            if (ownerDocument && href) {\n                var as = options && \"string\" === typeof options.as ? options.as : \"script\", preloadSelector = 'link[rel=\"modulepreload\"][as=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '\"][href=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '\"]', key = preloadSelector;\n                switch(as){\n                    case \"audioworklet\":\n                    case \"paintworklet\":\n                    case \"serviceworker\":\n                    case \"sharedworker\":\n                    case \"worker\":\n                    case \"script\":\n                        key = getScriptKey(href);\n                }\n                if (!preloadPropsMap.has(key) && (href = assign({\n                    rel: \"modulepreload\",\n                    href: href\n                }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {\n                    switch(as){\n                        case \"audioworklet\":\n                        case \"paintworklet\":\n                        case \"serviceworker\":\n                        case \"sharedworker\":\n                        case \"worker\":\n                        case \"script\":\n                            if (ownerDocument.querySelector(getScriptSelectorFromKey(key))) return;\n                    }\n                    as = ownerDocument.createElement(\"link\");\n                    setInitialProperties(as, \"link\", href);\n                    markNodeAsHoistable(as);\n                    ownerDocument.head.appendChild(as);\n                }\n            }\n        },\n        X: function(src, options) {\n            previousDispatcher.X(src, options);\n            var ownerDocument = globalDocument;\n            if (ownerDocument && src) {\n                var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);\n                resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({\n                    src: src,\n                    async: !0\n                }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement(\"script\"), markNodeAsHoistable(resource), setInitialProperties(resource, \"link\", src), ownerDocument.head.appendChild(resource)), resource = {\n                    type: \"script\",\n                    instance: resource,\n                    count: 1,\n                    state: null\n                }, scripts.set(key, resource));\n            }\n        },\n        S: function(href, precedence, options) {\n            previousDispatcher.S(href, precedence, options);\n            var ownerDocument = globalDocument;\n            if (ownerDocument && href) {\n                var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);\n                precedence = precedence || \"default\";\n                var resource = styles.get(key);\n                if (!resource) {\n                    var state = {\n                        loading: NotLoaded,\n                        preload: null\n                    };\n                    if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) state.loading = Loaded | Inserted;\n                    else {\n                        href = assign({\n                            rel: \"stylesheet\",\n                            href: href,\n                            \"data-precedence\": precedence\n                        }, options);\n                        (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);\n                        var link = resource = ownerDocument.createElement(\"link\");\n                        markNodeAsHoistable(link);\n                        setInitialProperties(link, \"link\", href);\n                        link._p = new Promise(function(resolve, reject) {\n                            link.onload = resolve;\n                            link.onerror = reject;\n                        });\n                        link.addEventListener(\"load\", function() {\n                            state.loading |= Loaded;\n                        });\n                        link.addEventListener(\"error\", function() {\n                            state.loading |= Errored;\n                        });\n                        state.loading |= Inserted;\n                        insertStylesheet(resource, precedence, ownerDocument);\n                    }\n                    resource = {\n                        type: \"stylesheet\",\n                        instance: resource,\n                        count: 1,\n                        state: state\n                    };\n                    styles.set(key, resource);\n                }\n            }\n        },\n        M: function(src, options) {\n            previousDispatcher.M(src, options);\n            var ownerDocument = globalDocument;\n            if (ownerDocument && src) {\n                var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);\n                resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({\n                    src: src,\n                    async: !0,\n                    type: \"module\"\n                }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement(\"script\"), markNodeAsHoistable(resource), setInitialProperties(resource, \"link\", src), ownerDocument.head.appendChild(resource)), resource = {\n                    type: \"script\",\n                    instance: resource,\n                    count: 1,\n                    state: null\n                }, scripts.set(key, resource));\n            }\n        }\n    };\n    var globalDocument = \"undefined\" === typeof document ? null : document, tagCaches = null, suspendedState = null, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        Provider: null,\n        Consumer: null,\n        _currentValue: NotPendingTransition,\n        _currentValue2: NotPendingTransition,\n        _threadCount: 0\n    }, badgeFormat = \"%c%s%c \", badgeStyle = \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\", resetStyle = \"\", pad = \" \", bind = Function.prototype.bind;\n    var didWarnAboutNestedUpdates = !1;\n    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;\n    overrideHookState = function(fiber, id, path, value) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateDeletePath = function(fiber, id, path) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n        id = findHook(fiber, id);\n        null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));\n    };\n    overrideProps = function(fiber, path, value) {\n        fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsDeletePath = function(fiber, path) {\n        fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsRenamePath = function(fiber, oldPath, newPath) {\n        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        oldPath = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);\n    };\n    scheduleUpdate = function(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    };\n    setErrorHandler = function(newShouldErrorImpl) {\n        shouldErrorImpl = newShouldErrorImpl;\n    };\n    setSuspenseHandler = function(newShouldSuspendImpl) {\n        shouldSuspendImpl = newShouldSuspendImpl;\n    };\n    var _enabled = !0, return_targetInst = null, hasScheduledReplayAttempt = !1, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = new Map(), queuedPointerCaptures = new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = \"mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset\".split(\" \"), lastScheduledReplayQueue = null;\n    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {\n        var root = this._internalRoot;\n        if (null === root) throw Error(\"Cannot update an unmounted root.\");\n        var args = arguments;\n        \"function\" === typeof args[1] ? console.error(\"does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().\") : isValidContainer(args[1]) ? console.error(\"You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.\") : \"undefined\" !== typeof args[1] && console.error(\"You passed a second argument to root.render(...) but it only accepts one argument.\");\n        args = children;\n        var current = root.current, lane = requestUpdateLane(current);\n        updateContainerImpl(current, lane, args, root, null, null);\n    };\n    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {\n        var args = arguments;\n        \"function\" === typeof args[0] && console.error(\"does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().\");\n        args = this._internalRoot;\n        if (null !== args) {\n            this._internalRoot = null;\n            var container = args.containerInfo;\n            (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(\"Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.\");\n            updateContainerImpl(args.current, 2, null, args, null, null);\n            flushSyncWork$1();\n            container[internalContainerInstanceKey] = null;\n        }\n    };\n    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {\n        if (target) {\n            var updatePriority = resolveUpdatePriority();\n            target = {\n                blockedOn: null,\n                target: target,\n                priority: updatePriority\n            };\n            for(var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++);\n            queuedExplicitHydrationTargets.splice(i, 0, target);\n            0 === i && attemptExplicitHydrationTarget(target);\n        }\n    };\n    (function() {\n        var isomorphicReactPackageVersion = React.version;\n        if (\"19.2.0-canary-3fbfb9ba-20250409\" !== isomorphicReactPackageVersion) throw Error('Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' + (isomorphicReactPackageVersion + \"\\n  - react-dom:  19.2.0-canary-3fbfb9ba-20250409\\nLearn more: https://react.dev/warnings/version-mismatch\"));\n    })();\n    \"function\" === typeof Map && null != Map.prototype && \"function\" === typeof Map.prototype.forEach && \"function\" === typeof Set && null != Set.prototype && \"function\" === typeof Set.prototype.clear && \"function\" === typeof Set.prototype.forEach || console.error(\"React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills\");\n    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {\n        var fiber = componentOrElement._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof componentOrElement.render) throw Error(\"Unable to find node on an unmounted component.\");\n            componentOrElement = Object.keys(componentOrElement).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + componentOrElement);\n        }\n        componentOrElement = findCurrentFiberUsingSlowPath(fiber);\n        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;\n        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;\n        return componentOrElement;\n    };\n    if (!function() {\n        var internals = {\n            bundleType: 1,\n            version: \"19.2.0-canary-3fbfb9ba-20250409\",\n            rendererPackageName: \"react-dom\",\n            currentDispatcherRef: ReactSharedInternals,\n            reconcilerVersion: \"19.2.0-canary-3fbfb9ba-20250409\"\n        };\n        internals.overrideHookState = overrideHookState;\n        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;\n        internals.overrideProps = overrideProps;\n        internals.overridePropsDeletePath = overridePropsDeletePath;\n        internals.overridePropsRenamePath = overridePropsRenamePath;\n        internals.scheduleUpdate = scheduleUpdate;\n        internals.setErrorHandler = setErrorHandler;\n        internals.setSuspenseHandler = setSuspenseHandler;\n        internals.scheduleRefresh = scheduleRefresh;\n        internals.scheduleRoot = scheduleRoot;\n        internals.setRefreshHandler = setRefreshHandler;\n        internals.getCurrentFiber = getCurrentFiberForDevTools;\n        internals.getLaneLabelMap = getLaneLabelMap;\n        internals.injectProfilingHooks = injectProfilingHooks;\n        return injectInternals(internals);\n    }() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf(\"Chrome\") && -1 === navigator.userAgent.indexOf(\"Edge\") || -1 < navigator.userAgent.indexOf(\"Firefox\"))) {\n        var protocol = window.location.protocol;\n        /^(https?|file):$/.test(protocol) && console.info(\"%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools\" + (\"file:\" === protocol ? \"\\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq\" : \"\"), \"font-weight:bold\");\n    }\n    exports.createRoot = function(container, options) {\n        if (!isValidContainer(container)) throw Error(\"Target container is not a DOM element.\");\n        warnIfReactDOMContainerInDEV(container);\n        var isStrictMode = !1, identifierPrefix = \"\", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;\n        null !== options && void 0 !== options && (options.hydrate ? console.warn(\"hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.\") : \"object\" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(\"You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\\n\\n  let root = createRoot(domContainer);\\n  root.render(<App />);\"), !0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));\n        options = createFiberRoot(container, 1, !1, null, null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);\n        container[internalContainerInstanceKey] = options.current;\n        listenToAllSupportedEvents(container);\n        return new ReactDOMRoot(options);\n    };\n    exports.hydrateRoot = function(container, initialChildren, options) {\n        if (!isValidContainer(container)) throw Error(\"Target container is not a DOM element.\");\n        warnIfReactDOMContainerInDEV(container);\n        void 0 === initialChildren && console.error(\"Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)\");\n        var isStrictMode = !1, identifierPrefix = \"\", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;\n        null !== options && void 0 !== options && (!0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));\n        initialChildren = createFiberRoot(container, 1, !0, initialChildren, null != options ? options : null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);\n        initialChildren.context = getContextForSubtree(null);\n        options = initialChildren.current;\n        isStrictMode = requestUpdateLane(options);\n        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);\n        identifierPrefix = createUpdate(isStrictMode);\n        identifierPrefix.callback = null;\n        enqueueUpdate(options, identifierPrefix, isStrictMode);\n        options = isStrictMode;\n        initialChildren.current.lanes = options;\n        markRootUpdated$1(initialChildren, options);\n        ensureRootIsScheduled(initialChildren);\n        container[internalContainerInstanceKey] = initialChildren.current;\n        listenToAllSupportedEvents(container);\n        return new ReactDOMHydrationRoot(initialChildren);\n    };\n    exports.version = \"19.2.0-canary-3fbfb9ba-20250409\";\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && \"function\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLWNsaWVudC5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEOztBQUVBLEdBQ2E7QUFDYixLQWdESyxJQS9DSDtJQUNFLFNBQVNBLFNBQVNDLEtBQUssRUFBRUMsRUFBRTtRQUN6QixJQUFLRCxRQUFRQSxNQUFNRSxhQUFhLEVBQUUsU0FBU0YsU0FBUyxJQUFJQyxJQUN0RCxRQUFTRCxNQUFNRyxJQUFJLEVBQUdGO1FBQ3hCLE9BQU9EO0lBQ1Q7SUFDQSxTQUFTSSxnQkFBZ0JDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7UUFDOUMsSUFBSUQsU0FBU0QsS0FBS0csTUFBTSxFQUFFLE9BQU9EO1FBQ2pDLElBQUlFLE1BQU1KLElBQUksQ0FBQ0MsTUFBTSxFQUNuQkksVUFBVUMsWUFBWVAsT0FBT0EsSUFBSVEsS0FBSyxLQUFLQyxPQUFPLENBQUMsR0FBR1Q7UUFDeERNLE9BQU8sQ0FBQ0QsSUFBSSxHQUFHTixnQkFBZ0JDLEdBQUcsQ0FBQ0ssSUFBSSxFQUFFSixNQUFNQyxRQUFRLEdBQUdDO1FBQzFELE9BQU9HO0lBQ1Q7SUFDQSxTQUFTSSxlQUFlVixHQUFHLEVBQUVXLE9BQU8sRUFBRUMsT0FBTztRQUMzQyxJQUFJRCxRQUFRUCxNQUFNLEtBQUtRLFFBQVFSLE1BQU0sRUFDbkNTLFFBQVFDLElBQUksQ0FBQzthQUNWO1lBQ0gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILFFBQVFSLE1BQU0sR0FBRyxHQUFHVyxJQUN0QyxJQUFJSixPQUFPLENBQUNJLEVBQUUsS0FBS0gsT0FBTyxDQUFDRyxFQUFFLEVBQUU7Z0JBQzdCRixRQUFRQyxJQUFJLENBQ1Y7Z0JBRUY7WUFDRjtZQUNGLE9BQU9FLG1CQUFtQmhCLEtBQUtXLFNBQVNDLFNBQVM7UUFDbkQ7SUFDRjtJQUNBLFNBQVNJLG1C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QW1ELGlCQUNBTSxlQUNBMmlCLG9CQUNBaVUscUJBQ0E1OUI7UUFFRnk5QixnQkFBZ0J4dEUsT0FBTyxHQUFHNnRFLHFCQUFxQjtRQUMvQ3p6RCxVQUFVb3pELGdCQUFnQnJ0RSxPQUFPO1FBQ2pDdXRFLGVBQWVuN0Isa0JBQWtCbjRCO1FBQ2pDc3pELGVBQWUxN0QsZ0NBQWdDMDdEO1FBQy9DcDZCLG1CQUFtQi9RLGFBQWFtckM7UUFDaENwNkIsaUJBQWlCMW5DLFFBQVEsR0FBRztRQUM1QjgyQixjQUFjdG9CLFNBQVNrNUIsa0JBQWtCbzZCO1FBQ3pDdHpELFVBQVVzekQ7UUFDVkYsZ0JBQWdCcnRFLE9BQU8sQ0FBQzBPLEtBQUssR0FBR3VMO1FBQ2hDMUosa0JBQWtCODhELGlCQUFpQnB6RDtRQUNuQzgxQyxzQkFBc0JzZDtRQUN0QmpPLFNBQVMsQ0FBQ3ByRCw2QkFBNkIsR0FBR3E1RCxnQkFBZ0JydEUsT0FBTztRQUNqRThpRCwyQkFBMkJzYztRQUMzQixPQUFPLElBQUk4UixzQkFBc0I3RDtJQUNuQztJQUNBcXNCLGVBQWUsR0FBRztJQUNsQixnQkFBZ0IsT0FBT3RzRixrQ0FDckIsZUFDRSxPQUFPQSwrQkFBK0Iyc0YsMEJBQTBCLElBQ2xFM3NGLCtCQUErQjJzRiwwQkFBMEIsQ0FBQ3g0RjtBQUM5RCIsInNvdXJjZXMiOlsiL1ZvbHVtZXMvU29mdHdhYXJlIFByb2dyYW0vYXBwdGl2aXR5IGZpbmFsIHYxL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tY2xpZW50LmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS1jbGllbnQuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qXG4gTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBmaW5kSG9vayhmaWJlciwgaWQpIHtcbiAgICAgIGZvciAoZmliZXIgPSBmaWJlci5tZW1vaXplZFN0YXRlOyBudWxsICE9PSBmaWJlciAmJiAwIDwgaWQ7IClcbiAgICAgICAgKGZpYmVyID0gZmliZXIubmV4dCksIGlkLS07XG4gICAgICByZXR1cm4gZmliZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKGluZGV4ID49IHBhdGgubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aFNldEltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgaWYgKG9sZFBhdGgubGVuZ3RoICE9PSBuZXdQYXRoLmxlbmd0aClcbiAgICAgICAgY29uc29sZS53YXJuKFwiY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIG9mIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4KSB7XG4gICAgICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICBpbmRleCArIDEgPT09IG9sZFBhdGgubGVuZ3RoXG4gICAgICAgID8gKCh1cGRhdGVkW25ld1BhdGhbaW5kZXhdXSA9IHVwZGF0ZWRbb2xkS2V5XSksXG4gICAgICAgICAgaXNBcnJheUltcGwodXBkYXRlZClcbiAgICAgICAgICAgID8gdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKVxuICAgICAgICAgICAgOiBkZWxldGUgdXBkYXRlZFtvbGRLZXldKVxuICAgICAgICA6ICh1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZUltcGwoXG4gICAgICAgICAgICBvYmpbb2xkS2V5XSxcbiAgICAgICAgICAgIG9sZFBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoLFxuICAgICAgICAgICAgaW5kZXggKyAxXG4gICAgICAgICAgKSk7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVdpdGhEZWxldGVJbXBsKG9iaiwgcGF0aCwgaW5kZXgpIHtcbiAgICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XSxcbiAgICAgICAgdXBkYXRlZCA9IGlzQXJyYXlJbXBsKG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTtcbiAgICAgIGlmIChpbmRleCArIDEgPT09IHBhdGgubGVuZ3RoKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGlzQXJyYXlJbXBsKHVwZGF0ZWQpID8gdXBkYXRlZC5zcGxpY2Uoa2V5LCAxKSA6IGRlbGV0ZSB1cGRhdGVkW2tleV0sXG4gICAgICAgICAgdXBkYXRlZFxuICAgICAgICApO1xuICAgICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhEZWxldGVJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFN1c3BlbmRJbXBsKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRFcnJvckltcGwoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybkludmFsaWRIb29rQWNjZXNzKCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuIFlvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AkMigpIHt9XG4gICAgZnVuY3Rpb24gd2FybkZvck1pc3NpbmdLZXkoKSB7fVxuICAgIGZ1bmN0aW9uIHNldFRvU29ydGVkU3RyaW5nKHNldCkge1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcnJheS5zb3J0KCkuam9pbihcIiwgXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlcih0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gICAgICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSb290KHJvb3QsIGVsZW1lbnQpIHtcbiAgICAgIHJvb3QuY29udGV4dCA9PT0gZW1wdHlDb250ZXh0T2JqZWN0ICYmXG4gICAgICAgICh1cGRhdGVDb250YWluZXJJbXBsKHJvb3QuY3VycmVudCwgMiwgZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCksXG4gICAgICAgIGZsdXNoU3luY1dvcmskMSgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWZyZXNoKHJvb3QsIHVwZGF0ZSkge1xuICAgICAgaWYgKG51bGwgIT09IHJlc29sdmVGYW1pbHkpIHtcbiAgICAgICAgdmFyIHN0YWxlRmFtaWxpZXMgPSB1cGRhdGUuc3RhbGVGYW1pbGllcztcbiAgICAgICAgdXBkYXRlID0gdXBkYXRlLnVwZGF0ZWRGYW1pbGllcztcbiAgICAgICAgZmx1c2hQZW5kaW5nRWZmZWN0cygpO1xuICAgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgIHJvb3QuY3VycmVudCxcbiAgICAgICAgICB1cGRhdGUsXG4gICAgICAgICAgc3RhbGVGYW1pbGllc1xuICAgICAgICApO1xuICAgICAgICBmbHVzaFN5bmNXb3JrJDEoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UmVmcmVzaEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgcmVzb2x2ZUZhbWlseSA9IGhhbmRsZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICAgICAgcmV0dXJuICEoXG4gICAgICAgICFub2RlIHx8XG4gICAgICAgICgxICE9PSBub2RlLm5vZGVUeXBlICYmIDkgIT09IG5vZGUubm9kZVR5cGUgJiYgMTEgIT09IG5vZGUubm9kZVR5cGUpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gICAgICB2YXIgbm9kZSA9IGZpYmVyLFxuICAgICAgICBuZWFyZXN0TW91bnRlZCA9IGZpYmVyO1xuICAgICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkgZm9yICg7IG5vZGUucmV0dXJuOyApIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmaWJlciA9IG5vZGU7XG4gICAgICAgIGRvXG4gICAgICAgICAgKG5vZGUgPSBmaWJlciksXG4gICAgICAgICAgICAwICE9PSAobm9kZS5mbGFncyAmIDQwOTgpICYmIChuZWFyZXN0TW91bnRlZCA9IG5vZGUucmV0dXJuKSxcbiAgICAgICAgICAgIChmaWJlciA9IG5vZGUucmV0dXJuKTtcbiAgICAgICAgd2hpbGUgKGZpYmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAzID09PSBub2RlLnRhZyA/IG5lYXJlc3RNb3VudGVkIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihmaWJlcikge1xuICAgICAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICBudWxsID09PSBzdXNwZW5zZVN0YXRlICYmXG4gICAgICAgICAgKChmaWJlciA9IGZpYmVyLmFsdGVybmF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gZmliZXIgJiYgKHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlKSk7XG4gICAgICAgIGlmIChudWxsICE9PSBzdXNwZW5zZVN0YXRlKSByZXR1cm4gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAgICAgaWYgKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpICE9PSBmaWJlcilcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpO1xuICAgICAgICBpZiAobnVsbCA9PT0gYWx0ZXJuYXRlKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgcmV0dXJuIGFsdGVybmF0ZSAhPT0gZmliZXIgPyBudWxsIDogZmliZXI7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBhID0gZmliZXIsIGIgPSBhbHRlcm5hdGU7IDsgKSB7XG4gICAgICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG4gICAgICAgIGlmIChudWxsID09PSBwYXJlbnRBKSBicmVhaztcbiAgICAgICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKG51bGwgPT09IHBhcmVudEIpIHtcbiAgICAgICAgICBiID0gcGFyZW50QS5yZXR1cm47XG4gICAgICAgICAgaWYgKG51bGwgIT09IGIpIHtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICAgICAgZm9yIChwYXJlbnRCID0gcGFyZW50QS5jaGlsZDsgcGFyZW50QjsgKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50QiA9PT0gYSkgcmV0dXJuIGFzc2VydElzTW91bnRlZChwYXJlbnRBKSwgZmliZXI7XG4gICAgICAgICAgICBpZiAocGFyZW50QiA9PT0gYikgcmV0dXJuIGFzc2VydElzTW91bnRlZChwYXJlbnRBKSwgYWx0ZXJuYXRlO1xuICAgICAgICAgICAgcGFyZW50QiA9IHBhcmVudEIuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIChhID0gcGFyZW50QSksIChiID0gcGFyZW50Qik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGRpZEZpbmRDaGlsZCA9ICExLCBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkOyBfY2hpbGQ7ICkge1xuICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICAgIGZvciAoX2NoaWxkID0gcGFyZW50Qi5jaGlsZDsgX2NoaWxkOyApIHtcbiAgICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGlkRmluZENoaWxkKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoMyAhPT0gYS50YWcpXG4gICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgIHJldHVybiBhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhID8gZmliZXIgOiBhbHRlcm5hdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZyB8fCA2ID09PSB0YWcpIHJldHVybiBub2RlO1xuICAgICAgZm9yIChub2RlID0gbm9kZS5jaGlsZDsgbnVsbCAhPT0gbm9kZTsgKSB7XG4gICAgICAgIHRhZyA9IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKTtcbiAgICAgICAgaWYgKG51bGwgIT09IHRhZykgcmV0dXJuIHRhZztcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICAgIGlmIChudWxsID09PSBtYXliZUl0ZXJhYmxlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIG1heWJlSXRlcmFibGUgPVxuICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgbWF5YmVJdGVyYWJsZVtcIkBAaXRlcmF0b3JcIl07XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSA/IG1heWJlSXRlcmFibGUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbU93bmVyKG93bmVyKSB7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIiA9PT0gdHlwZW9mIG93bmVyLnRhZ1xuICAgICAgICA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpXG4gICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG93bmVyLm5hbWVcbiAgICAgICAgICA/IG93bmVyLm5hbWVcbiAgICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHtcbiAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gXCJDYWNoZVwiO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgcmV0dXJuIFwiRGVoeWRyYXRlZEZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaWJlciA9IHR5cGUucmVuZGVyKSxcbiAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICAgIChcIlwiICE9PSBmaWJlciA/IFwiRm9yd2FyZFJlZihcIiArIGZpYmVyICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gXCJSb290XCI7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gXCJUZXh0XCI7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID8gXCJTdHJpY3RNb2RlXCIgOiBcIk1vZGVcIjtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXR1cm4gXCJPZmZzY3JlZW5cIjtcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIHJldHVybiBcIlNjb3BlXCI7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gXCJUcmFjaW5nTWFya2VyXCI7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICB0eXBlID0gZmliZXIuX2RlYnVnSW5mbztcbiAgICAgICAgICBpZiAobnVsbCAhPSB0eXBlKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHR5cGUubGVuZ3RoIC0gMTsgMCA8PSBpOyBpLS0pXG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZVtpXS5uYW1lKSByZXR1cm4gdHlwZVtpXS5uYW1lO1xuICAgICAgICAgIGlmIChudWxsICE9PSBmaWJlci5yZXR1cm4pXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlci5yZXR1cm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICAgICAgMCA+IGluZGV4JGpzY29tcCQwXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgcG9wLlwiKVxuICAgICAgICA6IChmaWJlciAhPT0gZmliZXJTdGFja1tpbmRleCRqc2NvbXAkMF0gJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC5cIiksXG4gICAgICAgICAgKGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleCRqc2NvbXAkMF0pLFxuICAgICAgICAgICh2YWx1ZVN0YWNrW2luZGV4JGpzY29tcCQwXSA9IG51bGwpLFxuICAgICAgICAgIChmaWJlclN0YWNrW2luZGV4JGpzY29tcCQwXSA9IG51bGwpLFxuICAgICAgICAgIGluZGV4JGpzY29tcCQwLS0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gICAgICBpbmRleCRqc2NvbXAkMCsrO1xuICAgICAgdmFsdWVTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBjdXJzb3IuY3VycmVudDtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXgkanNjb21wJDBdID0gZmliZXI7XG4gICAgICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICAgbnVsbCA9PT0gYyAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgICAgIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbnVsbCwgZmliZXIpO1xuICAgICAgdmFyIG5leHRSb290Q29udGV4dCA9IG5leHRSb290SW5zdGFuY2Uubm9kZVR5cGU7XG4gICAgICBzd2l0Y2ggKG5leHRSb290Q29udGV4dCkge1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgbmV4dFJvb3RDb250ZXh0ID0gOSA9PT0gbmV4dFJvb3RDb250ZXh0ID8gXCIjZG9jdW1lbnRcIiA6IFwiI2ZyYWdtZW50XCI7XG4gICAgICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IChuZXh0Um9vdEluc3RhbmNlID1cbiAgICAgICAgICAgIG5leHRSb290SW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50KVxuICAgICAgICAgICAgPyAobmV4dFJvb3RJbnN0YW5jZSA9IG5leHRSb290SW5zdGFuY2UubmFtZXNwYWNlVVJJKVxuICAgICAgICAgICAgICA/IGdldE93bkhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpXG4gICAgICAgICAgICAgIDogSG9zdENvbnRleHROYW1lc3BhY2VOb25lXG4gICAgICAgICAgICA6IEhvc3RDb250ZXh0TmFtZXNwYWNlTm9uZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoKG5leHRSb290Q29udGV4dCA9IG5leHRSb290SW5zdGFuY2UudGFnTmFtZSksXG4gICAgICAgICAgICAobmV4dFJvb3RJbnN0YW5jZSA9IG5leHRSb290SW5zdGFuY2UubmFtZXNwYWNlVVJJKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICAobmV4dFJvb3RJbnN0YW5jZSA9IGdldE93bkhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpKSxcbiAgICAgICAgICAgICAgKG5leHRSb290SW5zdGFuY2UgPSBnZXRDaGlsZEhvc3RDb250ZXh0UHJvZChcbiAgICAgICAgICAgICAgICBuZXh0Um9vdEluc3RhbmNlLFxuICAgICAgICAgICAgICAgIG5leHRSb290Q29udGV4dFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzd2l0Y2ggKG5leHRSb290Q29udGV4dCkge1xuICAgICAgICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgICAgICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IEhvc3RDb250ZXh0TmFtZXNwYWNlU3ZnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgICAgICAgICAgIG5leHRSb290SW5zdGFuY2UgPSBIb3N0Q29udGV4dE5hbWVzcGFjZU1hdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IEhvc3RDb250ZXh0TmFtZXNwYWNlTm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRSb290Q29udGV4dCA9IG5leHRSb290Q29udGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgbmV4dFJvb3RDb250ZXh0ID0gdXBkYXRlZEFuY2VzdG9ySW5mb0RldihudWxsLCBuZXh0Um9vdENvbnRleHQpO1xuICAgICAgbmV4dFJvb3RDb250ZXh0ID0ge1xuICAgICAgICBjb250ZXh0OiBuZXh0Um9vdEluc3RhbmNlLFxuICAgICAgICBhbmNlc3RvckluZm86IG5leHRSb290Q29udGV4dFxuICAgICAgfTtcbiAgICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICAgICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgICBudWxsICE9PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgIHB1c2goaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICAgIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgIHZhciBuZXh0Q29udGV4dCA9IGdldENoaWxkSG9zdENvbnRleHRQcm9kKGNvbnRleHQuY29udGV4dCwgdHlwZSk7XG4gICAgICB0eXBlID0gdXBkYXRlZEFuY2VzdG9ySW5mb0Rldihjb250ZXh0LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICBuZXh0Q29udGV4dCA9IHsgY29udGV4dDogbmV4dENvbnRleHQsIGFuY2VzdG9ySW5mbzogdHlwZSB9O1xuICAgICAgY29udGV4dCAhPT0gbmV4dENvbnRleHQgJiZcbiAgICAgICAgKHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlciksXG4gICAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAgIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyICYmXG4gICAgICAgIChwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlciksIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpKTtcbiAgICAgIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IuY3VycmVudCA9PT0gZmliZXIgJiZcbiAgICAgICAgKHBvcChob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLCBmaWJlciksXG4gICAgICAgIChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IE5vdFBlbmRpbmdUcmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbiAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc2FibGVkRGVwdGgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0geyBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZMb2cgfSksXG4gICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkluZm8gfSksXG4gICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldldhcm4gfSksXG4gICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZFcnJvciB9KSxcbiAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwIH0pLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWQgfSksXG4gICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cEVuZCB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIDAgPiBkaXNhYmxlZERlcHRoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgXCJcIjtcbiAgICAgICAgICBzdWZmaXggPVxuICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlxcblwiICsgcHJlZml4ICsgbmFtZSArIHN1ZmZpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHJldHVybiBcIlwiO1xuICAgICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgIHJlZW50cnkgPSAhMDtcbiAgICAgIGZyYW1lID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBudWxsO1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICAgICAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0geDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQxKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sID0geCQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoRmFrZSA9IGZuKCkpICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBGYWtlLmNhdGNoICYmXG4gICAgICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCI7XG4gICAgICAgIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICApO1xuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICB7IHZhbHVlOiBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiIH1cbiAgICAgICAgICApO1xuICAgICAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID1cbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcbiAgICAgICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBuYW1lUHJvcERlc2NyaXB0b3IgPSAwO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPCBjb250cm9sTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIrKztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID09PSBjb250cm9sTGluZXMubGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgJiZcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXTtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXI7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLSwgX1J1bkluUm9vdEZyYW1lJERldGVyLS1cbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IG5hbWVQcm9wRGVzY3JpcHRvciB8fCAxICE9PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpIHtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAobmFtZVByb3BEZXNjcmlwdG9yLS0sXG4gICAgICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tLFxuICAgICAgICAgICAgICAgICAgICAwID4gX1J1bkluUm9vdEZyYW1lJERldGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IG5ldyBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IFwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4uZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChfZnJhbWUgPSBfZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHJlZW50cnkgPSAhMSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXIpLFxuICAgICAgICAgIHJlZW5hYmxlTG9ncygpLFxuICAgICAgICAgIChFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZyYW1lKTtcbiAgICAgIH1cbiAgICAgIHNhbXBsZUxpbmVzID0gKHNhbXBsZUxpbmVzID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIilcbiAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShzYW1wbGVMaW5lcylcbiAgICAgICAgOiBcIlwiO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiYgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHNhbXBsZUxpbmVzKTtcbiAgICAgIHJldHVybiBzYW1wbGVMaW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0T3duZXJTdGFjayhlcnJvcikge1xuICAgICAgdmFyIHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICBlcnJvciA9IGVycm9yLnN0YWNrO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2UHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBlcnJvci5zdGFydHNXaXRoKFwiRXJyb3I6IHJlYWN0LXN0YWNrLXRvcC1mcmFtZVxcblwiKSAmJlxuICAgICAgICAoZXJyb3IgPSBlcnJvci5zbGljZSgyOSkpO1xuICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlID0gZXJyb3IuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgIC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgJiZcbiAgICAgICAgKGVycm9yID0gZXJyb3Iuc2xpY2UocHJldlByZXBhcmVTdGFja1RyYWNlICsgMSkpO1xuICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlID0gZXJyb3IuaW5kZXhPZihcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiKTtcbiAgICAgIC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgJiZcbiAgICAgICAgKHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IGVycm9yLmxhc3RJbmRleE9mKFxuICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgcHJldlByZXBhcmVTdGFja1RyYWNlXG4gICAgICAgICkpO1xuICAgICAgaWYgKC0xICE9PSBwcmV2UHJlcGFyZVN0YWNrVHJhY2UpXG4gICAgICAgIGVycm9yID0gZXJyb3Iuc2xpY2UoMCwgcHJldlByZXBhcmVTdGFja1RyYWNlKTtcbiAgICAgIGVsc2UgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiTGF6eVwiKTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLCAhMSk7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZS5yZW5kZXIsICExKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUsICEwKTtcbiAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJBY3Rpdml0eVwiKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBkZWJ1Z0luZm8gPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvO1xuICAgICAgICAgIGlmIChkZWJ1Z0luZm8pXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IGRlYnVnSW5mb1tpXTtcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBlbnRyeS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IGluZm8sXG4gICAgICAgICAgICAgICAgICBlbnYgPSBlbnRyeS5lbnY7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgICAgICAgICAgZW50cnkubmFtZSArIChlbnYgPyBcIiBbXCIgKyBlbnYgKyBcIl1cIiA6IFwiXCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpbmZvID0gSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIlxcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6IFwiICsgeC5tZXNzYWdlICsgXCJcXG5cIiArIHguc3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZVdpdGhvdXRMaW5lTnVtYmVyKGZuKSB7XG4gICAgICByZXR1cm4gKGZuID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIilcbiAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmbilcbiAgICAgICAgOiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgICByZXR1cm4gbnVsbCAhPSBvd25lciA/IGdldENvbXBvbmVudE5hbWVGcm9tT3duZXIob3duZXIpIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgIDYgPT09IHdvcmtJblByb2dyZXNzLnRhZyAmJiAod29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm4pO1xuICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHdvcmtJblByb2dyZXNzLnR5cGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VMaXN0XCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJBY3Rpdml0eVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgfHxcbiAgICAgICAgICAgICAgXCJcIiAhPT0gaW5mbyB8fFxuICAgICAgICAgICAgICAoaW5mbyArPSBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWVXaXRob3V0TGluZU51bWJlcihcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyIHx8XG4gICAgICAgICAgICAgIFwiXCIgIT09IGluZm8gfHxcbiAgICAgICAgICAgICAgKGluZm8gKz0gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lV2l0aG91dExpbmVOdW1iZXIoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZS5yZW5kZXJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHdvcmtJblByb2dyZXNzOyApXG4gICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgICAgIHZhciBmaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBmaWJlci5fZGVidWdPd25lcjtcbiAgICAgICAgICAgIHZhciBkZWJ1Z1N0YWNrID0gZmliZXIuX2RlYnVnU3RhY2s7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyAmJlxuICAgICAgICAgICAgICBkZWJ1Z1N0YWNrICYmXG4gICAgICAgICAgICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2YgZGVidWdTdGFjayAmJlxuICAgICAgICAgICAgICAgIChmaWJlci5fZGVidWdTdGFjayA9IGRlYnVnU3RhY2sgPSBmb3JtYXRPd25lclN0YWNrKGRlYnVnU3RhY2spKSxcbiAgICAgICAgICAgICAgXCJcIiAhPT0gZGVidWdTdGFjayAmJiAoaW5mbyArPSBcIlxcblwiICsgZGVidWdTdGFjaykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5kZWJ1Z1N0YWNrKSB7XG4gICAgICAgICAgICB2YXIgb3duZXJTdGFjayA9IHdvcmtJblByb2dyZXNzLmRlYnVnU3RhY2s7XG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5vd25lcikgJiZcbiAgICAgICAgICAgICAgb3duZXJTdGFjayAmJlxuICAgICAgICAgICAgICAoaW5mbyArPSBcIlxcblwiICsgZm9ybWF0T3duZXJTdGFjayhvd25lclN0YWNrKSk7XG4gICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gaW5mbztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICAgICAgICBcIlxcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6IFwiICsgeC5tZXNzYWdlICsgXCJcXG5cIiArIHguc3RhY2s7XG4gICAgICB9XG4gICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgY2FsbGJhY2ssIGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbnVsbCAhPT0gZmliZXIgJiYgZmliZXIuX2RlYnVnVGFza1xuICAgICAgICAgID8gZmliZXIuX2RlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICAgIGNhbGxiYWNrLmJpbmQobnVsbCwgYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNClcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNhbGxiYWNrKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKHByZXZpb3VzRmliZXIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwicnVuV2l0aEZpYmVySW5ERVYgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBpbiBwcm9kdWN0aW9uLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9XG4gICAgICAgIG51bGwgPT09IGZpYmVyID8gbnVsbCA6IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgICBpc1JlbmRlcmluZyA9ICExO1xuICAgICAgY3VycmVudCA9IGZpYmVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgXCJPYmplY3RcIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpLCAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGAlc2AgYXR0cmlidXRlIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgICAgYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsIHByb3BOYW1lKSB7XG4gICAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBwcm92aWRlZCBgJXNgIENTUyBwcm9wZXJ0eSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgdHlwZU5hbWUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrRm9ybUZpZWxkVmFsdWVTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJGb3JtIGZpZWxkIHZhbHVlcyAodmFsdWUsIGNoZWNrZWQsIGRlZmF1bHRWYWx1ZSwgb3IgZGVmYXVsdENoZWNrZWQgcHJvcHMpIG11c3QgYmUgc3RyaW5ncywgbm90ICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAgIHR5cGVOYW1lKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykgcmV0dXJuICExO1xuICAgICAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gICAgICBpZiAoaG9vay5pc0Rpc2FibGVkKSByZXR1cm4gITA7XG4gICAgICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayB3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcmVhY3QtZGV2dG9vbHNcIlxuICAgICAgICAgICksXG4gICAgICAgICAgITBcbiAgICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIChyZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKSksIChpbmplY3RlZEhvb2sgPSBob29rKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy5cIiwgZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob29rLmNoZWNrRENFID8gITAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMobmV3SXNTdHJpY3RNb2RlKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsb2ckMSAmJlxuICAgICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZShuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgaWYgKGluamVjdGVkSG9vayAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2suc2V0U3RyaWN0TW9kZSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmplY3RlZEhvb2suc2V0U3RyaWN0TW9kZShyZW5kZXJlcklELCBuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluamVjdFByb2ZpbGluZ0hvb2tzKHByb2ZpbGluZ0hvb2tzKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gcHJvZmlsaW5nSG9va3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtDb21taXRTdG9wcGVkKCkge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0b3BwZWQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JlbmRlclN0b3BwZWQoKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0b3BwZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgICAgIHggPj4+PSAwO1xuICAgICAgcmV0dXJuIDAgPT09IHggPyAzMiA6ICgzMSAtICgobG9nKHgpIC8gTE4yKSB8IDApKSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExhYmVsRm9yTGFuZShsYW5lKSB7XG4gICAgICBpZiAobGFuZSAmIDEpIHJldHVybiBcIlN5bmNIeWRyYXRpb25MYW5lXCI7XG4gICAgICBpZiAobGFuZSAmIDIpIHJldHVybiBcIlN5bmNcIjtcbiAgICAgIGlmIChsYW5lICYgNCkgcmV0dXJuIFwiSW5wdXRDb250aW51b3VzSHlkcmF0aW9uXCI7XG4gICAgICBpZiAobGFuZSAmIDgpIHJldHVybiBcIklucHV0Q29udGludW91c1wiO1xuICAgICAgaWYgKGxhbmUgJiAxNikgcmV0dXJuIFwiRGVmYXVsdEh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiAzMikgcmV0dXJuIFwiRGVmYXVsdFwiO1xuICAgICAgaWYgKGxhbmUgJiAxMjgpIHJldHVybiBcIlRyYW5zaXRpb25IeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgNDE5NDA0OCkgcmV0dXJuIFwiVHJhbnNpdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiA2MjkxNDU2MCkgcmV0dXJuIFwiUmV0cnlcIjtcbiAgICAgIGlmIChsYW5lICYgNjcxMDg4NjQpIHJldHVybiBcIlNlbGVjdGl2ZUh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiAxMzQyMTc3MjgpIHJldHVybiBcIklkbGVIeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgMjY4NDM1NDU2KSByZXR1cm4gXCJJZGxlXCI7XG4gICAgICBpZiAobGFuZSAmIDUzNjg3MDkxMikgcmV0dXJuIFwiT2Zmc2NyZWVuXCI7XG4gICAgICBpZiAobGFuZSAmIDEwNzM3NDE4MjQpIHJldHVybiBcIkRlZmVycmVkXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gICAgICB2YXIgcGVuZGluZ1N5bmNMYW5lcyA9IGxhbmVzICYgNDI7XG4gICAgICBpZiAoMCAhPT0gcGVuZGluZ1N5bmNMYW5lcykgcmV0dXJuIHBlbmRpbmdTeW5jTGFuZXM7XG4gICAgICBzd2l0Y2ggKGxhbmVzICYgLWxhbmVzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgIHJldHVybiA2NDtcbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAgcmV0dXJuIDEyODtcbiAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgIGNhc2UgNTEyOlxuICAgICAgICBjYXNlIDEwMjQ6XG4gICAgICAgIGNhc2UgMjA0ODpcbiAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICBjYXNlIDgxOTI6XG4gICAgICAgIGNhc2UgMTYzODQ6XG4gICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgIGNhc2UgNjU1MzY6XG4gICAgICAgIGNhc2UgMTMxMDcyOlxuICAgICAgICBjYXNlIDI2MjE0NDpcbiAgICAgICAgY2FzZSA1MjQyODg6XG4gICAgICAgIGNhc2UgMTA0ODU3NjpcbiAgICAgICAgY2FzZSAyMDk3MTUyOlxuICAgICAgICAgIHJldHVybiBsYW5lcyAmIDQxOTQwNDg7XG4gICAgICAgIGNhc2UgNDE5NDMwNDpcbiAgICAgICAgY2FzZSA4Mzg4NjA4OlxuICAgICAgICBjYXNlIDE2Nzc3MjE2OlxuICAgICAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgICAgIHJldHVybiBsYW5lcyAmIDYyOTE0NTYwO1xuICAgICAgICBjYXNlIDY3MTA4ODY0OlxuICAgICAgICAgIHJldHVybiA2NzEwODg2NDtcbiAgICAgICAgY2FzZSAxMzQyMTc3Mjg6XG4gICAgICAgICAgcmV0dXJuIDEzNDIxNzcyODtcbiAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgcmV0dXJuIDI2ODQzNTQ1NjtcbiAgICAgICAgY2FzZSA1MzY4NzA5MTI6XG4gICAgICAgICAgcmV0dXJuIDUzNjg3MDkxMjtcbiAgICAgICAgY2FzZSAxMDczNzQxODI0OlxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlNob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMsIHJvb3RIYXNQZW5kaW5nQ29tbWl0KSB7XG4gICAgICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICBpZiAoMCA9PT0gcGVuZGluZ0xhbmVzKSByZXR1cm4gMDtcbiAgICAgIHZhciBuZXh0TGFuZXMgPSAwLFxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcbiAgICAgIHJvb3QgPSByb290Lndhcm1MYW5lcztcbiAgICAgIHZhciBub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgMTM0MjE3NzI3O1xuICAgICAgMCAhPT0gbm9uSWRsZVBlbmRpbmdMYW5lc1xuICAgICAgICA/ICgocGVuZGluZ0xhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcyksXG4gICAgICAgICAgMCAhPT0gcGVuZGluZ0xhbmVzXG4gICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwZW5kaW5nTGFuZXMpKVxuICAgICAgICAgICAgOiAoKHBpbmdlZExhbmVzICY9IG5vbklkbGVQZW5kaW5nTGFuZXMpLFxuICAgICAgICAgICAgICAwICE9PSBwaW5nZWRMYW5lc1xuICAgICAgICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKSlcbiAgICAgICAgICAgICAgICA6IHJvb3RIYXNQZW5kaW5nQ29tbWl0IHx8XG4gICAgICAgICAgICAgICAgICAoKHJvb3RIYXNQZW5kaW5nQ29tbWl0ID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH5yb290KSxcbiAgICAgICAgICAgICAgICAgIDAgIT09IHJvb3RIYXNQZW5kaW5nQ29tbWl0ICYmXG4gICAgICAgICAgICAgICAgICAgIChuZXh0TGFuZXMgPVxuICAgICAgICAgICAgICAgICAgICAgIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHJvb3RIYXNQZW5kaW5nQ29tbWl0KSkpKSlcbiAgICAgICAgOiAoKG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXMpLFxuICAgICAgICAgIDAgIT09IG5vbklkbGVQZW5kaW5nTGFuZXNcbiAgICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVQZW5kaW5nTGFuZXMpKVxuICAgICAgICAgICAgOiAwICE9PSBwaW5nZWRMYW5lc1xuICAgICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwaW5nZWRMYW5lcykpXG4gICAgICAgICAgICAgIDogcm9vdEhhc1BlbmRpbmdDb21taXQgfHxcbiAgICAgICAgICAgICAgICAoKHJvb3RIYXNQZW5kaW5nQ29tbWl0ID0gcGVuZGluZ0xhbmVzICYgfnJvb3QpLFxuICAgICAgICAgICAgICAgIDAgIT09IHJvb3RIYXNQZW5kaW5nQ29tbWl0ICYmXG4gICAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocm9vdEhhc1BlbmRpbmdDb21taXQpKSkpO1xuICAgICAgcmV0dXJuIDAgPT09IG5leHRMYW5lc1xuICAgICAgICA/IDBcbiAgICAgICAgOiAwICE9PSB3aXBMYW5lcyAmJlxuICAgICAgICAgICAgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJlxuICAgICAgICAgICAgMCA9PT0gKHdpcExhbmVzICYgc3VzcGVuZGVkTGFuZXMpICYmXG4gICAgICAgICAgICAoKHN1c3BlbmRlZExhbmVzID0gbmV4dExhbmVzICYgLW5leHRMYW5lcyksXG4gICAgICAgICAgICAocm9vdEhhc1BlbmRpbmdDb21taXQgPSB3aXBMYW5lcyAmIC13aXBMYW5lcyksXG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA+PSByb290SGFzUGVuZGluZ0NvbW1pdCB8fFxuICAgICAgICAgICAgICAoMzIgPT09IHN1c3BlbmRlZExhbmVzICYmIDAgIT09IChyb290SGFzUGVuZGluZ0NvbW1pdCAmIDQxOTQwNDgpKSlcbiAgICAgICAgICA/IHdpcExhbmVzXG4gICAgICAgICAgOiBuZXh0TGFuZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDAgPT09XG4gICAgICAgIChyb290LnBlbmRpbmdMYW5lcyAmXG4gICAgICAgICAgfihyb290LnN1c3BlbmRlZExhbmVzICYgfnJvb3QucGluZ2VkTGFuZXMpICZcbiAgICAgICAgICByZW5kZXJMYW5lcylcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSkge1xuICAgICAgc3dpdGNoIChsYW5lKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICByZXR1cm4gY3VycmVudFRpbWUgKyAyNTA7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgIGNhc2UgMTI4OlxuICAgICAgICBjYXNlIDI1NjpcbiAgICAgICAgY2FzZSA1MTI6XG4gICAgICAgIGNhc2UgMTAyNDpcbiAgICAgICAgY2FzZSAyMDQ4OlxuICAgICAgICBjYXNlIDQwOTY6XG4gICAgICAgIGNhc2UgODE5MjpcbiAgICAgICAgY2FzZSAxNjM4NDpcbiAgICAgICAgY2FzZSAzMjc2ODpcbiAgICAgICAgY2FzZSA2NTUzNjpcbiAgICAgICAgY2FzZSAxMzEwNzI6XG4gICAgICAgIGNhc2UgMjYyMTQ0OlxuICAgICAgICBjYXNlIDUyNDI4ODpcbiAgICAgICAgY2FzZSAxMDQ4NTc2OlxuICAgICAgICBjYXNlIDIwOTcxNTI6XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgNWUzO1xuICAgICAgICBjYXNlIDQxOTQzMDQ6XG4gICAgICAgIGNhc2UgODM4ODYwODpcbiAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgY2FzZSAzMzU1NDQzMjpcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGNhc2UgNjcxMDg4NjQ6XG4gICAgICAgIGNhc2UgMTM0MjE3NzI4OlxuICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgY2FzZSA1MzY4NzA5MTI6XG4gICAgICAgIGNhc2UgMTA3Mzc0MTgyNDpcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAtMVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCkge1xuICAgICAgdmFyIGxhbmUgPSBuZXh0VHJhbnNpdGlvbkxhbmU7XG4gICAgICBuZXh0VHJhbnNpdGlvbkxhbmUgPDw9IDE7XG4gICAgICAwID09PSAobmV4dFRyYW5zaXRpb25MYW5lICYgNDE5NDA0OCkgJiYgKG5leHRUcmFuc2l0aW9uTGFuZSA9IDI1Nik7XG4gICAgICByZXR1cm4gbGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhaW1OZXh0UmV0cnlMYW5lKCkge1xuICAgICAgdmFyIGxhbmUgPSBuZXh0UmV0cnlMYW5lO1xuICAgICAgbmV4dFJldHJ5TGFuZSA8PD0gMTtcbiAgICAgIDAgPT09IChuZXh0UmV0cnlMYW5lICYgNjI5MTQ1NjApICYmIChuZXh0UmV0cnlMYW5lID0gNDE5NDMwNCk7XG4gICAgICByZXR1cm4gbGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTGFuZU1hcChpbml0aWFsKSB7XG4gICAgICBmb3IgKHZhciBsYW5lTWFwID0gW10sIGkgPSAwOyAzMSA+IGk7IGkrKykgbGFuZU1hcC5wdXNoKGluaXRpYWwpO1xuICAgICAgcmV0dXJuIGxhbmVNYXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSb290VXBkYXRlZCQxKHJvb3QsIHVwZGF0ZUxhbmUpIHtcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzIHw9IHVwZGF0ZUxhbmU7XG4gICAgICAyNjg0MzU0NTYgIT09IHVwZGF0ZUxhbmUgJiZcbiAgICAgICAgKChyb290LnN1c3BlbmRlZExhbmVzID0gMCksXG4gICAgICAgIChyb290LnBpbmdlZExhbmVzID0gMCksXG4gICAgICAgIChyb290Lndhcm1MYW5lcyA9IDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RGaW5pc2hlZChcbiAgICAgIHJvb3QsXG4gICAgICBmaW5pc2hlZExhbmVzLFxuICAgICAgcmVtYWluaW5nTGFuZXMsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXNcbiAgICApIHtcbiAgICAgIHZhciBwcmV2aW91c2x5UGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICByb290LnBlbmRpbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzO1xuICAgICAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IDA7XG4gICAgICByb290LnBpbmdlZExhbmVzID0gMDtcbiAgICAgIHJvb3Qud2FybUxhbmVzID0gMDtcbiAgICAgIHJvb3QuZXhwaXJlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICAgICAgcm9vdC5lbnRhbmdsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgICAgIHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LnNoZWxsU3VzcGVuZENvdW50ZXIgPSAwO1xuICAgICAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHMsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzLFxuICAgICAgICBoaWRkZW5VcGRhdGVzID0gcm9vdC5oaWRkZW5VcGRhdGVzO1xuICAgICAgZm9yIChcbiAgICAgICAgcmVtYWluaW5nTGFuZXMgPSBwcmV2aW91c2x5UGVuZGluZ0xhbmVzICYgfnJlbWFpbmluZ0xhbmVzO1xuICAgICAgICAwIDwgcmVtYWluaW5nTGFuZXM7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKHJlbWFpbmluZ0xhbmVzKSxcbiAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgZW50YW5nbGVtZW50c1tpbmRleF0gPSAwO1xuICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gLTE7XG4gICAgICAgIHZhciBoaWRkZW5VcGRhdGVzRm9yTGFuZSA9IGhpZGRlblVwZGF0ZXNbaW5kZXhdO1xuICAgICAgICBpZiAobnVsbCAhPT0gaGlkZGVuVXBkYXRlc0ZvckxhbmUpXG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIGhpZGRlblVwZGF0ZXNbaW5kZXhdID0gbnVsbCwgaW5kZXggPSAwO1xuICAgICAgICAgICAgaW5kZXggPCBoaWRkZW5VcGRhdGVzRm9yTGFuZS5sZW5ndGg7XG4gICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gaGlkZGVuVXBkYXRlc0ZvckxhbmVbaW5kZXhdO1xuICAgICAgICAgICAgbnVsbCAhPT0gdXBkYXRlICYmICh1cGRhdGUubGFuZSAmPSAtNTM2ODcwOTEzKTtcbiAgICAgICAgICB9XG4gICAgICAgIHJlbWFpbmluZ0xhbmVzICY9IH5sYW5lO1xuICAgICAgfVxuICAgICAgMCAhPT0gc3Bhd25lZExhbmUgJiYgbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIDApO1xuICAgICAgMCAhPT0gc3VzcGVuZGVkUmV0cnlMYW5lcyAmJlxuICAgICAgICAwID09PSB1cGRhdGVkTGFuZXMgJiZcbiAgICAgICAgMCAhPT0gcm9vdC50YWcgJiZcbiAgICAgICAgKHJvb3Quc3VzcGVuZGVkTGFuZXMgfD1cbiAgICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzICYgfihwcmV2aW91c2x5UGVuZGluZ0xhbmVzICYgfmZpbmlzaGVkTGFuZXMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIGVudGFuZ2xlZExhbmVzKSB7XG4gICAgICByb290LnBlbmRpbmdMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgJj0gfnNwYXduZWRMYW5lO1xuICAgICAgdmFyIHNwYXduZWRMYW5lSW5kZXggPSAzMSAtIGNsejMyKHNwYXduZWRMYW5lKTtcbiAgICAgIHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gc3Bhd25lZExhbmU7XG4gICAgICByb290LmVudGFuZ2xlbWVudHNbc3Bhd25lZExhbmVJbmRleF0gPVxuICAgICAgICByb290LmVudGFuZ2xlbWVudHNbc3Bhd25lZExhbmVJbmRleF0gfFxuICAgICAgICAxMDczNzQxODI0IHxcbiAgICAgICAgKGVudGFuZ2xlZExhbmVzICYgNDE5NDA5MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGVudGFuZ2xlZExhbmVzKSB7XG4gICAgICB2YXIgcm9vdEVudGFuZ2xlZExhbmVzID0gKHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gZW50YW5nbGVkTGFuZXMpO1xuICAgICAgZm9yIChyb290ID0gcm9vdC5lbnRhbmdsZW1lbnRzOyByb290RW50YW5nbGVkTGFuZXM7ICkge1xuICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKHJvb3RFbnRhbmdsZWRMYW5lcyksXG4gICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgIChsYW5lICYgZW50YW5nbGVkTGFuZXMpIHwgKHJvb3RbaW5kZXhdICYgZW50YW5nbGVkTGFuZXMpICYmXG4gICAgICAgICAgKHJvb3RbaW5kZXhdIHw9IGVudGFuZ2xlZExhbmVzKTtcbiAgICAgICAgcm9vdEVudGFuZ2xlZExhbmVzICY9IH5sYW5lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uQnlMYW5lKGxhbmUpIHtcbiAgICAgIHN3aXRjaCAobGFuZSkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbGFuZSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBsYW5lID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICBsYW5lID0gMTY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjU2OlxuICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgY2FzZSA0MTk0MzA0OlxuICAgICAgICBjYXNlIDgzODg2MDg6XG4gICAgICAgIGNhc2UgMTY3NzcyMTY6XG4gICAgICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICAgICAgbGFuZSA9IDEyODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgbGFuZSA9IDEzNDIxNzcyODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsYW5lID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmVzKSB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpXG4gICAgICAgIGZvciAocm9vdCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDsgMCA8IGxhbmVzOyApIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKSxcbiAgICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICAgIHJvb3RbaW5kZXhdLmFkZChmaWJlcik7XG4gICAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKSB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSByb290LnBlbmRpbmdVcGRhdGVyc0xhbmVNYXAsXG4gICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuICAgICAgICAgIDAgPCBsYW5lcztcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKTtcbiAgICAgICAgICByb290ID0gMSA8PCBpbmRleDtcbiAgICAgICAgICBpbmRleCA9IHBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO1xuICAgICAgICAgIDAgPCBpbmRleC5zaXplICYmXG4gICAgICAgICAgICAoaW5kZXguZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICAgICAgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBtZW1vaXplZFVwZGF0ZXJzLmhhcyhhbHRlcm5hdGUpKSB8fFxuICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuYWRkKGZpYmVyKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5kZXguY2xlYXIoKSk7XG4gICAgICAgICAgbGFuZXMgJj0gfnJvb3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbGFuZXNUb0V2ZW50UHJpb3JpdHkobGFuZXMpIHtcbiAgICAgIGxhbmVzICY9IC1sYW5lcztcbiAgICAgIHJldHVybiAwICE9PSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHkgJiYgRGlzY3JldGVFdmVudFByaW9yaXR5IDwgbGFuZXNcbiAgICAgICAgPyAwICE9PSBDb250aW51b3VzRXZlbnRQcmlvcml0eSAmJiBDb250aW51b3VzRXZlbnRQcmlvcml0eSA8IGxhbmVzXG4gICAgICAgICAgPyAwICE9PSAobGFuZXMgJiAxMzQyMTc3MjcpXG4gICAgICAgICAgICA/IERlZmF1bHRFdmVudFByaW9yaXR5XG4gICAgICAgICAgICA6IElkbGVFdmVudFByaW9yaXR5XG4gICAgICAgICAgOiBDb250aW51b3VzRXZlbnRQcmlvcml0eVxuICAgICAgICA6IERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVwZGF0ZVByaW9yaXR5KCkge1xuICAgICAgdmFyIHVwZGF0ZVByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgICAgIGlmICgwICE9PSB1cGRhdGVQcmlvcml0eSkgcmV0dXJuIHVwZGF0ZVByaW9yaXR5O1xuICAgICAgdXBkYXRlUHJpb3JpdHkgPSB3aW5kb3cuZXZlbnQ7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSB1cGRhdGVQcmlvcml0eVxuICAgICAgICA/IERlZmF1bHRFdmVudFByaW9yaXR5XG4gICAgICAgIDogZ2V0RXZlbnRQcmlvcml0eSh1cGRhdGVQcmlvcml0eS50eXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuV2l0aFByaW9yaXR5KHByaW9yaXR5LCBmbikge1xuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJpb3JpdHkpLCBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByZXZpb3VzUHJpb3JpdHk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGFjaERlbGV0ZWRJbnN0YW5jZShub2RlKSB7XG4gICAgICBkZWxldGUgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgICAgIGRlbGV0ZSBub2RlW2ludGVybmFsUHJvcHNLZXldO1xuICAgICAgZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XTtcbiAgICAgIGRlbGV0ZSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyTGlzdGVuZXJzS2V5XTtcbiAgICAgIGRlbGV0ZSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVzU2V0S2V5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0Tm9kZSkge1xuICAgICAgdmFyIHRhcmdldEluc3QgPSB0YXJnZXROb2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgICAgaWYgKHRhcmdldEluc3QpIHJldHVybiB0YXJnZXRJbnN0O1xuICAgICAgZm9yICh2YXIgcGFyZW50Tm9kZSA9IHRhcmdldE5vZGUucGFyZW50Tm9kZTsgcGFyZW50Tm9kZTsgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAodGFyZ2V0SW5zdCA9XG4gICAgICAgICAgICBwYXJlbnROb2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldIHx8XG4gICAgICAgICAgICBwYXJlbnROb2RlW2ludGVybmFsSW5zdGFuY2VLZXldKVxuICAgICAgICApIHtcbiAgICAgICAgICBwYXJlbnROb2RlID0gdGFyZ2V0SW5zdC5hbHRlcm5hdGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCAhPT0gdGFyZ2V0SW5zdC5jaGlsZCB8fFxuICAgICAgICAgICAgKG51bGwgIT09IHBhcmVudE5vZGUgJiYgbnVsbCAhPT0gcGFyZW50Tm9kZS5jaGlsZClcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB0YXJnZXROb2RlID0gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXROb2RlKTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gdGFyZ2V0Tm9kZTtcblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgocGFyZW50Tm9kZSA9IHRhcmdldE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgICAgICAgICAgICB0YXJnZXROb2RlID0gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXROb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgICAgcGFyZW50Tm9kZSA9IHRhcmdldE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKG5vZGUgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldIHx8IG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0pXG4gICAgICApIHtcbiAgICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgNSA9PT0gdGFnIHx8XG4gICAgICAgICAgNiA9PT0gdGFnIHx8XG4gICAgICAgICAgMTMgPT09IHRhZyB8fFxuICAgICAgICAgIDI2ID09PSB0YWcgfHxcbiAgICAgICAgICAyNyA9PT0gdGFnIHx8XG4gICAgICAgICAgMyA9PT0gdGFnXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIHtcbiAgICAgIHZhciB0YWcgPSBpbnN0LnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnIHx8IDYgPT09IHRhZylcbiAgICAgICAgcmV0dXJuIGluc3Quc3RhdGVOb2RlO1xuICAgICAgdGhyb3cgRXJyb3IoXCJnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmVzb3VyY2VzRnJvbVJvb3Qocm9vdCkge1xuICAgICAgdmFyIHJlc291cmNlcyA9IHJvb3RbaW50ZXJuYWxSb290Tm9kZVJlc291cmNlc0tleV07XG4gICAgICByZXNvdXJjZXMgfHxcbiAgICAgICAgKHJlc291cmNlcyA9IHJvb3RbaW50ZXJuYWxSb290Tm9kZVJlc291cmNlc0tleV0gPVxuICAgICAgICAgIHsgaG9pc3RhYmxlU3R5bGVzOiBuZXcgTWFwKCksIGhvaXN0YWJsZVNjcmlwdHM6IG5ldyBNYXAoKSB9KTtcbiAgICAgIHJldHVybiByZXNvdXJjZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtOb2RlQXNIb2lzdGFibGUobm9kZSkge1xuICAgICAgbm9kZVtpbnRlcm5hbEhvaXN0YWJsZU1hcmtlcl0gPSAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJUd29QaGFzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcykge1xuICAgICAgcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lICsgXCJDYXB0dXJlXCIsIGRlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFdmVudFJlZ2lzdHJ5OiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC5cIixcbiAgICAgICAgICByZWdpc3RyYXRpb25OYW1lXG4gICAgICAgICk7XG4gICAgICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gZGVwZW5kZW5jaWVzO1xuICAgICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gPSByZWdpc3RyYXRpb25OYW1lO1xuICAgICAgXCJvbkRvdWJsZUNsaWNrXCIgPT09IHJlZ2lzdHJhdGlvbk5hbWUgJiZcbiAgICAgICAgKHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgZm9yIChcbiAgICAgICAgcmVnaXN0cmF0aW9uTmFtZSA9IDA7XG4gICAgICAgIHJlZ2lzdHJhdGlvbk5hbWUgPCBkZXBlbmRlbmNpZXMubGVuZ3RoO1xuICAgICAgICByZWdpc3RyYXRpb25OYW1lKytcbiAgICAgIClcbiAgICAgICAgYWxsTmF0aXZlRXZlbnRzLmFkZChkZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gICAgICBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlIHx8XG4gICAgICAgIHByb3BzLm9uSW5wdXQgfHxcbiAgICAgICAgcHJvcHMucmVhZE9ubHkgfHxcbiAgICAgICAgcHJvcHMuZGlzYWJsZWQgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICAoXCJzZWxlY3RcIiA9PT0gdGFnTmFtZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiB0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsIHNldCBgb25DaGFuZ2VgLlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiBgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmIHRoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuXCJcbiAgICAgICAgICAgICkpO1xuICAgICAgcHJvcHMub25DaGFuZ2UgfHxcbiAgICAgICAgcHJvcHMucmVhZE9ubHkgfHxcbiAgICAgICAgcHJvcHMuZGlzYWJsZWQgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcy5jaGVja2VkIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiBgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmIHRoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCBzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgcmV0dXJuICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSAhMCk7XG4gICAgICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gITA7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYFwiLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGVPbkN1c3RvbUNvbXBvbmVudChub2RlLCBuYW1lLCBleHBlY3RlZCkge1xuICAgICAgaWYgKGlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICBpZiAoITEgPT09IGV4cGVjdGVkKSByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IGV4cGVjdGVkID8gdm9pZCAwIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIGlmIChcIlwiID09PSBub2RlICYmICEwID09PSBleHBlY3RlZCkgcmV0dXJuICEwO1xuICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGV4cGVjdGVkLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IFwiXCIgKyBleHBlY3RlZCA/IGV4cGVjdGVkIDogbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKVxuICAgICAgICBpZiAobnVsbCA9PT0gdmFsdWUpIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgICAgICBpZiAoXCJkYXRhLVwiICE9PSBwcmVmaXggJiYgXCJhcmlhLVwiICE9PSBwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gdmFsdWUpIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIFwiXCIgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFZhbHVlRm9yTmFtZXNwYWNlZEF0dHJpYnV0ZShub2RlLCBuYW1lc3BhY2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gdmFsdWUpIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCBcIlwiICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgcmV0dXJuIGNoZWNrRm9ybUZpZWxkVmFsdWVTdHJpbmdDb2VyY2lvbih2YWx1ZSksIHZhbHVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NoZWNrYWJsZShlbGVtKSB7XG4gICAgICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChlbGVtID0gZWxlbS5ub2RlTmFtZSkgJiZcbiAgICAgICAgXCJpbnB1dFwiID09PSBlbGVtLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgKFwiY2hlY2tib3hcIiA9PT0gdHlwZSB8fCBcInJhZGlvXCIgPT09IHR5cGUpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyBcImNoZWNrZWRcIiA6IFwidmFsdWVcIixcbiAgICAgICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgbm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsXG4gICAgICAgICAgdmFsdWVGaWVsZFxuICAgICAgICApO1xuICAgICAgY2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKG5vZGVbdmFsdWVGaWVsZF0pO1xuICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IFwiXCIgKyBub2RlW3ZhbHVlRmllbGRdO1xuICAgICAgaWYgKFxuICAgICAgICAhbm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSAmJlxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZGVzY3JpcHRvciAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkZXNjcmlwdG9yLmdldCAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkZXNjcmlwdG9yLnNldFxuICAgICAgKSB7XG4gICAgICAgIHZhciBnZXQgPSBkZXNjcmlwdG9yLmdldCxcbiAgICAgICAgICBzZXQgPSBkZXNjcmlwdG9yLnNldDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNoZWNrRm9ybUZpZWxkVmFsdWVTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgICBzZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBub2RlLl92YWx1ZVRyYWNrZXIgPSBudWxsO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gICAgICBub2RlLl92YWx1ZVRyYWNrZXIgfHwgKG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZUlmQ2hhbmdlZChub2RlKSB7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybiAhMTtcbiAgICAgIHZhciB0cmFja2VyID0gbm9kZS5fdmFsdWVUcmFja2VyO1xuICAgICAgaWYgKCF0cmFja2VyKSByZXR1cm4gITA7XG4gICAgICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICAgICAgdmFyIHZhbHVlID0gXCJcIjtcbiAgICAgIG5vZGUgJiZcbiAgICAgICAgKHZhbHVlID0gaXNDaGVja2FibGUobm9kZSlcbiAgICAgICAgICA/IG5vZGUuY2hlY2tlZFxuICAgICAgICAgICAgPyBcInRydWVcIlxuICAgICAgICAgICAgOiBcImZhbHNlXCJcbiAgICAgICAgICA6IG5vZGUudmFsdWUpO1xuICAgICAgbm9kZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG5vZGUgIT09IGxhc3RWYWx1ZSA/ICh0cmFja2VyLnNldFZhbHVlKG5vZGUpLCAhMCkgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHtcbiAgICAgIGRvYyA9IGRvYyB8fCAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGRvY3VtZW50ID8gZG9jdW1lbnQgOiB2b2lkIDApO1xuICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBkb2MpIHJldHVybiBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50IHx8IGRvYy5ib2R5O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZG9jLmJvZHk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXModmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKFxuICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzUmVnZXgsXG4gICAgICAgIGZ1bmN0aW9uIChjaCkge1xuICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSW5wdXRQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAgICAgdm9pZCAwID09PSBwcm9wcy5jaGVja2VkIHx8XG4gICAgICAgIHZvaWQgMCA9PT0gcHJvcHMuZGVmYXVsdENoZWNrZWQgfHxcbiAgICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCB8fFxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIiVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiBJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiLFxuICAgICAgICAgIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgXCJBIGNvbXBvbmVudFwiLFxuICAgICAgICAgIHByb3BzLnR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSAhMCkpO1xuICAgICAgdm9pZCAwID09PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICB2b2lkIDAgPT09IHByb3BzLmRlZmF1bHRWYWx1ZSB8fFxuICAgICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSB8fFxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIiVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuIElucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIChzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90IGJvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0IGVsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIixcbiAgICAgICAgICBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8IFwiQSBjb21wb25lbnRcIixcbiAgICAgICAgICBwcm9wcy50eXBlXG4gICAgICAgICksXG4gICAgICAgIChkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9ICEwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUlucHV0KFxuICAgICAgZWxlbWVudCxcbiAgICAgIHZhbHVlLFxuICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgbGFzdERlZmF1bHRWYWx1ZSxcbiAgICAgIGNoZWNrZWQsXG4gICAgICBkZWZhdWx0Q2hlY2tlZCxcbiAgICAgIHR5cGUsXG4gICAgICBuYW1lXG4gICAgKSB7XG4gICAgICBlbGVtZW50Lm5hbWUgPSBcIlwiO1xuICAgICAgbnVsbCAhPSB0eXBlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiB0eXBlXG4gICAgICAgID8gKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odHlwZSwgXCJ0eXBlXCIpLCAoZWxlbWVudC50eXBlID0gdHlwZSkpXG4gICAgICAgIDogZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuICAgICAgaWYgKG51bGwgIT0gdmFsdWUpXG4gICAgICAgIGlmIChcIm51bWJlclwiID09PSB0eXBlKSB7XG4gICAgICAgICAgaWYgKCgwID09PSB2YWx1ZSAmJiBcIlwiID09PSBlbGVtZW50LnZhbHVlKSB8fCBlbGVtZW50LnZhbHVlICE9IHZhbHVlKVxuICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZWxlbWVudC52YWx1ZSAhPT0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpICYmXG4gICAgICAgICAgICAoZWxlbWVudC52YWx1ZSA9IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSk7XG4gICAgICBlbHNlXG4gICAgICAgIChcInN1Ym1pdFwiICE9PSB0eXBlICYmIFwicmVzZXRcIiAhPT0gdHlwZSkgfHxcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICAgICAgbnVsbCAhPSB2YWx1ZVxuICAgICAgICA/IHNldERlZmF1bHRWYWx1ZShlbGVtZW50LCB0eXBlLCBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSlcbiAgICAgICAgOiBudWxsICE9IGRlZmF1bHRWYWx1ZVxuICAgICAgICAgID8gc2V0RGVmYXVsdFZhbHVlKGVsZW1lbnQsIHR5cGUsIGdldFRvU3RyaW5nVmFsdWUoZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgICA6IG51bGwgIT0gbGFzdERlZmF1bHRWYWx1ZSAmJiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICAgICAgbnVsbCA9PSBjaGVja2VkICYmXG4gICAgICAgIG51bGwgIT0gZGVmYXVsdENoZWNrZWQgJiZcbiAgICAgICAgKGVsZW1lbnQuZGVmYXVsdENoZWNrZWQgPSAhIWRlZmF1bHRDaGVja2VkKTtcbiAgICAgIG51bGwgIT0gY2hlY2tlZCAmJlxuICAgICAgICAoZWxlbWVudC5jaGVja2VkID1cbiAgICAgICAgICBjaGVja2VkICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2hlY2tlZCAmJlxuICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBjaGVja2VkKTtcbiAgICAgIG51bGwgIT0gbmFtZSAmJlxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgbmFtZSAmJlxuICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIG5hbWUgJiZcbiAgICAgIFwiYm9vbGVhblwiICE9PSB0eXBlb2YgbmFtZVxuICAgICAgICA/IChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKG5hbWUsIFwibmFtZVwiKSxcbiAgICAgICAgICAoZWxlbWVudC5uYW1lID0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUobmFtZSkpKVxuICAgICAgICA6IGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwibmFtZVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdElucHV0KFxuICAgICAgZWxlbWVudCxcbiAgICAgIHZhbHVlLFxuICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgY2hlY2tlZCxcbiAgICAgIGRlZmF1bHRDaGVja2VkLFxuICAgICAgdHlwZSxcbiAgICAgIG5hbWUsXG4gICAgICBpc0h5ZHJhdGluZ1xuICAgICkge1xuICAgICAgbnVsbCAhPSB0eXBlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHR5cGUsIFwidHlwZVwiKSwgKGVsZW1lbnQudHlwZSA9IHR5cGUpKTtcbiAgICAgIGlmIChudWxsICE9IHZhbHVlIHx8IG51bGwgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKFxuICAgICAgICAgICAgKFwic3VibWl0XCIgIT09IHR5cGUgJiYgXCJyZXNldFwiICE9PSB0eXBlKSB8fFxuICAgICAgICAgICAgKHZvaWQgMCAhPT0gdmFsdWUgJiYgbnVsbCAhPT0gdmFsdWUpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWZhdWx0VmFsdWUgPVxuICAgICAgICAgIG51bGwgIT0gZGVmYXVsdFZhbHVlID8gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUoZGVmYXVsdFZhbHVlKSA6IFwiXCI7XG4gICAgICAgIHZhbHVlID0gbnVsbCAhPSB2YWx1ZSA/IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgaXNIeWRyYXRpbmcgfHwgdmFsdWUgPT09IGVsZW1lbnQudmFsdWUgfHwgKGVsZW1lbnQudmFsdWUgPSB2YWx1ZSk7XG4gICAgICAgIGVsZW1lbnQuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBjaGVja2VkID0gbnVsbCAhPSBjaGVja2VkID8gY2hlY2tlZCA6IGRlZmF1bHRDaGVja2VkO1xuICAgICAgY2hlY2tlZCA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNoZWNrZWQgJiZcbiAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGNoZWNrZWQgJiZcbiAgICAgICAgISFjaGVja2VkO1xuICAgICAgZWxlbWVudC5jaGVja2VkID0gaXNIeWRyYXRpbmcgPyBlbGVtZW50LmNoZWNrZWQgOiAhIWNoZWNrZWQ7XG4gICAgICBlbGVtZW50LmRlZmF1bHRDaGVja2VkID0gISFjaGVja2VkO1xuICAgICAgbnVsbCAhPSBuYW1lICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG5hbWUgJiZcbiAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIG5hbWUgJiZcbiAgICAgICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiBuYW1lICYmXG4gICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKG5hbWUsIFwibmFtZVwiKSwgKGVsZW1lbnQubmFtZSA9IG5hbWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZSAmJiBnZXRBY3RpdmVFbGVtZW50KG5vZGUub3duZXJEb2N1bWVudCkgPT09IG5vZGUpIHx8XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID09PSBcIlwiICsgdmFsdWUgfHxcbiAgICAgICAgKG5vZGUuZGVmYXVsdFZhbHVlID0gXCJcIiArIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25Qcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAgICAgbnVsbCA9PSBwcm9wcy52YWx1ZSAmJlxuICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHByb3BzLmNoaWxkcmVuICYmIG51bGwgIT09IHByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgPyBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgbnVsbCA9PSBjaGlsZCB8fFxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkQ2hpbGQgfHxcbiAgICAgICAgICAgICAgICAoKGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSAhMCksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gUGFzcyBhIGB2YWx1ZWAgcHJvcCBvciB1c2UgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4gdG8gPG9wdGlvbj4uXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgOiBudWxsID09IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIHx8XG4gICAgICAgICAgICBkaWRXYXJuSW52YWxpZElubmVySFRNTCB8fFxuICAgICAgICAgICAgKChkaWRXYXJuSW52YWxpZElubmVySFRNTCA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUGFzcyBhIGB2YWx1ZWAgcHJvcCBpZiB5b3Ugc2V0IGRhbmdlcm91c2x5SW5uZXJIVE1MIHNvIFJlYWN0IGtub3dzIHdoaWNoIHZhbHVlIHNob3VsZCBiZSBzZWxlY3RlZC5cIlxuICAgICAgICAgICAgKSkpO1xuICAgICAgbnVsbCA9PSBwcm9wcy5zZWxlY3RlZCB8fFxuICAgICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiB8fFxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mIHNldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi5cIlxuICAgICAgICApLFxuICAgICAgICAoZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSAhMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gICAgICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtcbiAgICAgIHJldHVybiBvd25lck5hbWVcbiAgICAgICAgPyBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyTmFtZSArIFwiYC5cIlxuICAgICAgICA6IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSwgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICBub2RlID0gbm9kZS5vcHRpb25zO1xuICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgIG11bHRpcGxlID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIG11bHRpcGxlW1wiJFwiICsgcHJvcFZhbHVlW2ldXSA9ICEwO1xuICAgICAgICBmb3IgKHByb3BWYWx1ZSA9IDA7IHByb3BWYWx1ZSA8IG5vZGUubGVuZ3RoOyBwcm9wVmFsdWUrKylcbiAgICAgICAgICAoaSA9IG11bHRpcGxlLmhhc093blByb3BlcnR5KFwiJFwiICsgbm9kZVtwcm9wVmFsdWVdLnZhbHVlKSksXG4gICAgICAgICAgICBub2RlW3Byb3BWYWx1ZV0uc2VsZWN0ZWQgIT09IGkgJiYgKG5vZGVbcHJvcFZhbHVlXS5zZWxlY3RlZCA9IGkpLFxuICAgICAgICAgICAgaSAmJiBzZXREZWZhdWx0U2VsZWN0ZWQgJiYgKG5vZGVbcHJvcFZhbHVlXS5kZWZhdWx0U2VsZWN0ZWQgPSAhMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wVmFsdWUgPSBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZShwcm9wVmFsdWUpO1xuICAgICAgICBtdWx0aXBsZSA9IG51bGw7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5vZGVbaV0udmFsdWUgPT09IHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgbm9kZVtpXS5zZWxlY3RlZCA9ICEwO1xuICAgICAgICAgICAgc2V0RGVmYXVsdFNlbGVjdGVkICYmIChub2RlW2ldLmRlZmF1bHRTZWxlY3RlZCA9ICEwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCAhPT0gbXVsdGlwbGUgfHwgbm9kZVtpXS5kaXNhYmxlZCB8fCAobXVsdGlwbGUgPSBub2RlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBudWxsICE9PSBtdWx0aXBsZSAmJiAobXVsdGlwbGUuc2VsZWN0ZWQgPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU2VsZWN0UHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgICAgIGZvciAoZWxlbWVudCA9IDA7IGVsZW1lbnQgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGVsZW1lbnQrKykge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tlbGVtZW50XTtcbiAgICAgICAgaWYgKG51bGwgIT0gcHJvcHNbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lSXNBcnJheSA9IGlzQXJyYXlJbXBsKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgICAgcHJvcHMubXVsdGlwbGUgJiYgIXByb3BOYW1lSXNBcnJheVxuICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmIGBtdWx0aXBsZWAgaXMgdHJ1ZS4lc1wiLFxuICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogIXByb3BzLm11bHRpcGxlICYmXG4gICAgICAgICAgICAgIHByb3BOYW1lSXNBcnJheSAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyIHZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXNcIixcbiAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKVxuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2b2lkIDAgPT09IHByb3BzLnZhbHVlIHx8XG4gICAgICAgIHZvaWQgMCA9PT0gcHJvcHMuZGVmYXVsdFZhbHVlIHx8XG4gICAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSB8fFxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlNlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiXG4gICAgICAgICksXG4gICAgICAgIChkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSAhMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVRleHRhcmVhUHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgICAgIHZvaWQgMCA9PT0gcHJvcHMudmFsdWUgfHxcbiAgICAgICAgdm9pZCAwID09PSBwcm9wcy5kZWZhdWx0VmFsdWUgfHxcbiAgICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgfHxcbiAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCIlcyBjb250YWlucyBhIHRleHRhcmVhIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiBUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCBib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0LmRldi9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50c1wiLFxuICAgICAgICAgIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgXCJBIGNvbXBvbmVudFwiXG4gICAgICAgICksXG4gICAgICAgIChkaWRXYXJuVmFsRGVmYXVsdFZhbCA9ICEwKSk7XG4gICAgICBudWxsICE9IHByb3BzLmNoaWxkcmVuICYmXG4gICAgICAgIG51bGwgPT0gcHJvcHMudmFsdWUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgY2hpbGRyZW4gb24gPHRleHRhcmVhPi5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUZXh0YXJlYShlbGVtZW50LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgKCh2YWx1ZSA9IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSksXG4gICAgICAgIHZhbHVlICE9PSBlbGVtZW50LnZhbHVlICYmIChlbGVtZW50LnZhbHVlID0gdmFsdWUpLFxuICAgICAgICBudWxsID09IGRlZmF1bHRWYWx1ZSlcbiAgICAgICkge1xuICAgICAgICBlbGVtZW50LmRlZmF1bHRWYWx1ZSAhPT0gdmFsdWUgJiYgKGVsZW1lbnQuZGVmYXVsdFZhbHVlID0gdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbGVtZW50LmRlZmF1bHRWYWx1ZSA9XG4gICAgICAgIG51bGwgIT0gZGVmYXVsdFZhbHVlID8gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUoZGVmYXVsdFZhbHVlKSA6IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRUZXh0YXJlYShlbGVtZW50LCB2YWx1ZSwgZGVmYXVsdFZhbHVlLCBjaGlsZHJlbikge1xuICAgICAgaWYgKG51bGwgPT0gdmFsdWUpIHtcbiAgICAgICAgaWYgKG51bGwgIT0gY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAobnVsbCAhPSBkZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgaWYgKDEgPCBjaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlwiKTtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIG51bGwgPT0gZGVmYXVsdFZhbHVlICYmIChkZWZhdWx0VmFsdWUgPSBcIlwiKTtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBkZWZhdWx0VmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKTtcbiAgICAgIGVsZW1lbnQuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgY2hpbGRyZW4gPSBlbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgY2hpbGRyZW4gPT09IGRlZmF1bHRWYWx1ZSAmJlxuICAgICAgICBcIlwiICE9PSBjaGlsZHJlbiAmJlxuICAgICAgICBudWxsICE9PSBjaGlsZHJlbiAmJlxuICAgICAgICAoZWxlbWVudC52YWx1ZSA9IGNoaWxkcmVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZE5vdGFibGVOb2RlKG5vZGUsIGluZGVudCkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gbm9kZS5zZXJ2ZXJQcm9wcyAmJlxuICAgICAgICAwID09PSBub2RlLnNlcnZlclRhaWwubGVuZ3RoICYmXG4gICAgICAgIDEgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIDMgPCBub2RlLmRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgbm9kZS5kaXN0YW5jZUZyb21MZWFmID4gMTUgLSBpbmRlbnRcbiAgICAgICAgPyBmaW5kTm90YWJsZU5vZGUobm9kZS5jaGlsZHJlblswXSwgaW5kZW50KVxuICAgICAgICA6IG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluZGVudGF0aW9uKGluZGVudCkge1xuICAgICAgcmV0dXJuIFwiICBcIiArIFwiICBcIi5yZXBlYXQoaW5kZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkZWQoaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCIrIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVkKGluZGVudCkge1xuICAgICAgcmV0dXJuIFwiLSBcIiArIFwiICBcIi5yZXBlYXQoaW5kZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVGaWJlclR5cGUoZmliZXIpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZmliZXIudHlwZTtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gXCJMYXp5XCI7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiAoZmliZXIgPSBmaWJlci50eXBlKSwgZmliZXIuZGlzcGxheU5hbWUgfHwgZmliZXIubmFtZSB8fCBudWxsO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci50eXBlLnJlbmRlciksIGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZmliZXIudHlwZSksIGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgbnVsbDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVUZXh0Tm9kZShjb250ZW50LCBtYXhMZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZWVkc0VzY2FwaW5nLnRlc3QoY29udGVudClcbiAgICAgICAgPyAoKGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShjb250ZW50KSksXG4gICAgICAgICAgY29udGVudC5sZW5ndGggPiBtYXhMZW5ndGggLSAyXG4gICAgICAgICAgICA/IDggPiBtYXhMZW5ndGhcbiAgICAgICAgICAgICAgPyAne1wiLi4uXCJ9J1xuICAgICAgICAgICAgICA6IFwie1wiICsgY29udGVudC5zbGljZSgwLCBtYXhMZW5ndGggLSA3KSArICcuLi5cIn0nXG4gICAgICAgICAgICA6IFwie1wiICsgY29udGVudCArIFwifVwiKVxuICAgICAgICA6IGNvbnRlbnQubGVuZ3RoID4gbWF4TGVuZ3RoXG4gICAgICAgICAgPyA1ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICA/ICd7XCIuLi5cIn0nXG4gICAgICAgICAgICA6IGNvbnRlbnQuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gMykgKyBcIi4uLlwiXG4gICAgICAgICAgOiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVRleHREaWZmKGNsaWVudFRleHQsIHNlcnZlclByb3BzLCBpbmRlbnQpIHtcbiAgICAgIHZhciBtYXhMZW5ndGggPSAxMjAgLSAyICogaW5kZW50O1xuICAgICAgaWYgKG51bGwgPT09IHNlcnZlclByb3BzKVxuICAgICAgICByZXR1cm4gYWRkZWQoaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArIFwiXFxuXCI7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNlcnZlclByb3BzKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGZpcnN0RGlmZiA9IDA7XG4gICAgICAgICAgZmlyc3REaWZmIDwgc2VydmVyUHJvcHMubGVuZ3RoICYmXG4gICAgICAgICAgZmlyc3REaWZmIDwgY2xpZW50VGV4dC5sZW5ndGggJiZcbiAgICAgICAgICBzZXJ2ZXJQcm9wcy5jaGFyQ29kZUF0KGZpcnN0RGlmZikgPT09XG4gICAgICAgICAgICBjbGllbnRUZXh0LmNoYXJDb2RlQXQoZmlyc3REaWZmKTtcbiAgICAgICAgICBmaXJzdERpZmYrK1xuICAgICAgICApO1xuICAgICAgICBmaXJzdERpZmYgPiBtYXhMZW5ndGggLSA4ICYmXG4gICAgICAgICAgMTAgPCBmaXJzdERpZmYgJiZcbiAgICAgICAgICAoKGNsaWVudFRleHQgPSBcIi4uLlwiICsgY2xpZW50VGV4dC5zbGljZShmaXJzdERpZmYgLSA4KSksXG4gICAgICAgICAgKHNlcnZlclByb3BzID0gXCIuLi5cIiArIHNlcnZlclByb3BzLnNsaWNlKGZpcnN0RGlmZiAtIDgpKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYWRkZWQoaW5kZW50KSArXG4gICAgICAgICAgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICtcbiAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICByZW1vdmVkKGluZGVudCkgK1xuICAgICAgICAgIGRlc2NyaWJlVGV4dE5vZGUoc2VydmVyUHJvcHMsIG1heExlbmd0aCkgK1xuICAgICAgICAgIFwiXFxuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGluZGVudGF0aW9uKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgKyBcIlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvYmplY3ROYW1lKG9iamVjdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgLmNhbGwob2JqZWN0KVxuICAgICAgICAucmVwbGFjZSgvXlxcW29iamVjdCAoLiopXFxdJC8sIGZ1bmN0aW9uIChtLCBwMCkge1xuICAgICAgICAgIHJldHVybiBwMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVmFsdWUodmFsdWUsIG1heExlbmd0aCkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAodmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpLFxuICAgICAgICAgICAgdmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICAgID8gNSA+IG1heExlbmd0aFxuICAgICAgICAgICAgICAgID8gJ1wiLi4uXCInXG4gICAgICAgICAgICAgICAgOiB2YWx1ZS5zbGljZSgwLCBtYXhMZW5ndGggLSA0KSArICcuLi5cIidcbiAgICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAobnVsbCA9PT0gdmFsdWUpIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwodmFsdWUpKSByZXR1cm4gXCJbLi4uXVwiO1xuICAgICAgICAgIGlmICh2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIChtYXhMZW5ndGggPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodmFsdWUudHlwZSkpXG4gICAgICAgICAgICAgID8gXCI8XCIgKyBtYXhMZW5ndGggKyBcIj5cIlxuICAgICAgICAgICAgICA6IFwiPC4uLj5cIjtcbiAgICAgICAgICB2YXIgbmFtZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuICAgICAgICAgIGlmIChcIk9iamVjdFwiID09PSBuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG1heExlbmd0aCAtPSAyO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdmFsdWUpXG4gICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvblByb3BOYW1lID0gSlNPTi5zdHJpbmdpZnkocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIGpzb25Qcm9wTmFtZSAhPT0gJ1wiJyArIHByb3BOYW1lICsgJ1wiJyAmJlxuICAgICAgICAgICAgICAgICAgKHByb3BOYW1lID0ganNvblByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICBqc29uUHJvcE5hbWUgPSBkZXNjcmliZVZhbHVlKFxuICAgICAgICAgICAgICAgICAgdmFsdWVbcHJvcE5hbWVdLFxuICAgICAgICAgICAgICAgICAgMTUgPiBtYXhMZW5ndGggPyBtYXhMZW5ndGggOiAxNVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoIC09IGpzb25Qcm9wTmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKDAgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIG5hbWUgKz0gXCJcIiA9PT0gbmFtZSA/IFwiLi4uXCIgOiBcIiwgLi4uXCI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZSArPVxuICAgICAgICAgICAgICAgICAgKFwiXCIgPT09IG5hbWUgPyBcIlwiIDogXCIsXCIpICsgcHJvcE5hbWUgKyBcIjpcIiArIGpzb25Qcm9wTmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwie1wiICsgbmFtZSArIFwifVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIChtYXhMZW5ndGggPSB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lKVxuICAgICAgICAgICAgPyBcImZ1bmN0aW9uIFwiICsgbWF4TGVuZ3RoXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVQcm9wVmFsdWUodmFsdWUsIG1heExlbmd0aCkge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT09IHR5cGVvZiB2YWx1ZSB8fCBuZWVkc0VzY2FwaW5nLnRlc3QodmFsdWUpXG4gICAgICAgID8gXCJ7XCIgKyBkZXNjcmliZVZhbHVlKHZhbHVlLCBtYXhMZW5ndGggLSAyKSArIFwifVwiXG4gICAgICAgIDogdmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoIC0gMlxuICAgICAgICAgID8gNSA+IG1heExlbmd0aFxuICAgICAgICAgICAgPyAnXCIuLi5cIidcbiAgICAgICAgICAgIDogJ1wiJyArIHZhbHVlLnNsaWNlKDAsIG1heExlbmd0aCAtIDUpICsgJy4uLlwiJ1xuICAgICAgICAgIDogJ1wiJyArIHZhbHVlICsgJ1wiJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQodHlwZSwgcHJvcHMsIHJvd1ByZWZpeCkge1xuICAgICAgdmFyIHJlbWFpbmluZ1Jvd0xlbmd0aCA9IDEyMCAtIHJvd1ByZWZpeC5sZW5ndGggLSB0eXBlLmxlbmd0aCxcbiAgICAgICAgcHJvcGVydGllcyA9IFtdLFxuICAgICAgICBwcm9wTmFtZTtcbiAgICAgIGZvciAocHJvcE5hbWUgaW4gcHJvcHMpXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgXCJjaGlsZHJlblwiICE9PSBwcm9wTmFtZSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShcbiAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSxcbiAgICAgICAgICAgIDEyMCAtIHJvd1ByZWZpeC5sZW5ndGggLSBwcm9wTmFtZS5sZW5ndGggLSAxXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZW1haW5pbmdSb3dMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoICsgcHJvcFZhbHVlLmxlbmd0aCArIDI7XG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BOYW1lICsgXCI9XCIgKyBwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gMCA9PT0gcHJvcGVydGllcy5sZW5ndGhcbiAgICAgICAgPyByb3dQcmVmaXggKyBcIjxcIiArIHR5cGUgKyBcIj5cXG5cIlxuICAgICAgICA6IDAgPCByZW1haW5pbmdSb3dMZW5ndGhcbiAgICAgICAgICA/IHJvd1ByZWZpeCArIFwiPFwiICsgdHlwZSArIFwiIFwiICsgcHJvcGVydGllcy5qb2luKFwiIFwiKSArIFwiPlxcblwiXG4gICAgICAgICAgOiByb3dQcmVmaXggK1xuICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgdHlwZSArXG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgIHJvd1ByZWZpeCArXG4gICAgICAgICAgICBcIiAgXCIgK1xuICAgICAgICAgICAgcHJvcGVydGllcy5qb2luKFwiXFxuXCIgKyByb3dQcmVmaXggKyBcIiAgXCIpICtcbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgcm93UHJlZml4ICtcbiAgICAgICAgICAgIFwiPlxcblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVByb3BlcnRpZXNEaWZmKGNsaWVudE9iamVjdCwgc2VydmVyT2JqZWN0LCBpbmRlbnQpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gXCJcIixcbiAgICAgICAgcmVtYWluaW5nU2VydmVyUHJvcGVydGllcyA9IGFzc2lnbih7fSwgc2VydmVyT2JqZWN0KSxcbiAgICAgICAgcHJvcE5hbWU7XG4gICAgICBmb3IgKHByb3BOYW1lIGluIGNsaWVudE9iamVjdClcbiAgICAgICAgaWYgKGNsaWVudE9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICBkZWxldGUgcmVtYWluaW5nU2VydmVyUHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiBpbmRlbnQgLSBwcm9wTmFtZS5sZW5ndGggLSAyLFxuICAgICAgICAgICAgY2xpZW50UHJvcFZhbHVlID0gZGVzY3JpYmVWYWx1ZShjbGllbnRPYmplY3RbcHJvcE5hbWVdLCBtYXhMZW5ndGgpO1xuICAgICAgICAgIHNlcnZlck9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSlcbiAgICAgICAgICAgID8gKChtYXhMZW5ndGggPSBkZXNjcmliZVZhbHVlKHNlcnZlck9iamVjdFtwcm9wTmFtZV0sIG1heExlbmd0aCkpLFxuICAgICAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgICAgIGFkZGVkKGluZGVudCkgKyBwcm9wTmFtZSArIFwiOiBcIiArIGNsaWVudFByb3BWYWx1ZSArIFwiXFxuXCIpLFxuICAgICAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50KSArIHByb3BOYW1lICsgXCI6IFwiICsgbWF4TGVuZ3RoICsgXCJcXG5cIikpXG4gICAgICAgICAgICA6IChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50KSArIHByb3BOYW1lICsgXCI6IFwiICsgY2xpZW50UHJvcFZhbHVlICsgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgIGZvciAodmFyIF9wcm9wTmFtZSBpbiByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzKVxuICAgICAgICByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KF9wcm9wTmFtZSkgJiZcbiAgICAgICAgICAoKGNsaWVudE9iamVjdCA9IGRlc2NyaWJlVmFsdWUoXG4gICAgICAgICAgICByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzW19wcm9wTmFtZV0sXG4gICAgICAgICAgICAxMjAgLSAyICogaW5kZW50IC0gX3Byb3BOYW1lLmxlbmd0aCAtIDJcbiAgICAgICAgICApKSxcbiAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQpICsgX3Byb3BOYW1lICsgXCI6IFwiICsgY2xpZW50T2JqZWN0ICsgXCJcXG5cIikpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudERpZmYodHlwZSwgY2xpZW50UHJvcHMsIHNlcnZlclByb3BzLCBpbmRlbnQpIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIixcbiAgICAgICAgc2VydmVyUHJvcE5hbWVzID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChwcm9wTmFtZSRqc2NvbXAkMCBpbiBzZXJ2ZXJQcm9wcylcbiAgICAgICAgc2VydmVyUHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUkanNjb21wJDApICYmXG4gICAgICAgICAgc2VydmVyUHJvcE5hbWVzLnNldChcbiAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBwcm9wTmFtZSRqc2NvbXAkMFxuICAgICAgICAgICk7XG4gICAgICBpZiAoMSA9PT0gc2VydmVyUHJvcE5hbWVzLnNpemUgJiYgc2VydmVyUHJvcE5hbWVzLmhhcyhcImNoaWxkcmVuXCIpKVxuICAgICAgICBjb250ZW50ICs9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgY2xpZW50UHJvcHMsXG4gICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KVxuICAgICAgICApO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9wcm9wTmFtZTIgaW4gY2xpZW50UHJvcHMpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2xpZW50UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lMikgJiZcbiAgICAgICAgICAgIFwiY2hpbGRyZW5cIiAhPT0gX3Byb3BOYW1lMlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIG1heExlbmd0aCRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgMTIwIC0gMiAqIChpbmRlbnQgKyAxKSAtIF9wcm9wTmFtZTIubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUgPSBzZXJ2ZXJQcm9wTmFtZXMuZ2V0KF9wcm9wTmFtZTIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBzZXJ2ZXJQcm9wTmFtZSkge1xuICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuZGVsZXRlKF9wcm9wTmFtZTIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgIHZhciBwcm9wTmFtZSRqc2NvbXAkMCA9IGNsaWVudFByb3BzW19wcm9wTmFtZTJdO1xuICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSA9IHNlcnZlclByb3BzW3NlcnZlclByb3BOYW1lXTtcbiAgICAgICAgICAgICAgdmFyIGNsaWVudFByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDAgPSBkZXNjcmliZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHByb3BOYW1lJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHByb3BOYW1lJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBzZXJ2ZXJQcm9wTmFtZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBzZXJ2ZXJQcm9wTmFtZSAmJlxuICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBvYmplY3ROYW1lKHByb3BOYW1lJGpzY29tcCQwKSAmJlxuICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBvYmplY3ROYW1lKHNlcnZlclByb3BOYW1lKSAmJlxuICAgICAgICAgICAgICAoMiA8IE9iamVjdC5rZXlzKHByb3BOYW1lJGpzY29tcCQwKS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAyIDwgT2JqZWN0LmtleXMoc2VydmVyUHJvcE5hbWUpLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIC0xIDwgY2xpZW50UHJvcFZhbHVlLmluZGV4T2YoXCIuLi5cIikgfHxcbiAgICAgICAgICAgICAgICAtMSA8IG1heExlbmd0aCRqc2NvbXAkMC5pbmRleE9mKFwiLi4uXCIpKVxuICAgICAgICAgICAgICAgID8gKGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9e3tcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlUHJvcGVydGllc0RpZmYoXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZW50ICsgMlxuICAgICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBcIn19XFxuXCIpXG4gICAgICAgICAgICAgICAgOiAoKGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRQcm9wVmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcblwiKSxcbiAgICAgICAgICAgICAgICAgIChjb250ZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDAgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcblwiKSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgY29udGVudCArPVxuICAgICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgZGVzY3JpYmVQcm9wVmFsdWUoY2xpZW50UHJvcHNbX3Byb3BOYW1lMl0sIG1heExlbmd0aCRqc2NvbXAkMCkgK1xuICAgICAgICAgICAgICAgIFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICBpZiAoXCJjaGlsZHJlblwiICE9PSBwcm9wTmFtZSkge1xuICAgICAgICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiAoaW5kZW50ICsgMSkgLSBwcm9wTmFtZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29udGVudCArPVxuICAgICAgICAgICAgICByZW1vdmVkKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgcHJvcE5hbWUgK1xuICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgIGRlc2NyaWJlUHJvcFZhbHVlKHNlcnZlclByb3BzW3Byb3BOYW1lXSwgbWF4TGVuZ3RoKSArXG4gICAgICAgICAgICAgIFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGVudCA9XG4gICAgICAgICAgXCJcIiA9PT0gY29udGVudFxuICAgICAgICAgICAgPyBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCI8XCIgKyB0eXBlICsgXCI+XFxuXCJcbiAgICAgICAgICAgIDogaW5kZW50YXRpb24oaW5kZW50KSArXG4gICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgdHlwZSArXG4gICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICBjb250ZW50ICtcbiAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArXG4gICAgICAgICAgICAgIFwiPlxcblwiO1xuICAgICAgfVxuICAgICAgdHlwZSA9IHNlcnZlclByb3BzLmNoaWxkcmVuO1xuICAgICAgY2xpZW50UHJvcHMgPSBjbGllbnRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICkge1xuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMgPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzXG4gICAgICAgIClcbiAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMgPSBcIlwiICsgY2xpZW50UHJvcHM7XG4gICAgICAgIGNvbnRlbnQgKz0gZGVzY3JpYmVUZXh0RGlmZihzZXJ2ZXJQcm9wTmFtZXMsIFwiXCIgKyB0eXBlLCBpbmRlbnQgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjbGllbnRQcm9wcyB8fFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzXG4gICAgICApXG4gICAgICAgIGNvbnRlbnQgPVxuICAgICAgICAgIG51bGwgPT0gdHlwZVxuICAgICAgICAgICAgPyBjb250ZW50ICsgZGVzY3JpYmVUZXh0RGlmZihcIlwiICsgY2xpZW50UHJvcHMsIG51bGwsIGluZGVudCArIDEpXG4gICAgICAgICAgICA6IGNvbnRlbnQgKyBkZXNjcmliZVRleHREaWZmKFwiXCIgKyBjbGllbnRQcm9wcywgdm9pZCAwLCBpbmRlbnQgKyAxKTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVNpYmxpbmdGaWJlcihmaWJlciwgaW5kZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IGRlc2NyaWJlRmliZXJUeXBlKGZpYmVyKTtcbiAgICAgIGlmIChudWxsID09PSB0eXBlKSB7XG4gICAgICAgIHR5cGUgPSBcIlwiO1xuICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IGZpYmVyOyApXG4gICAgICAgICAgKHR5cGUgKz0gZGVzY3JpYmVTaWJsaW5nRmliZXIoZmliZXIsIGluZGVudCkpLFxuICAgICAgICAgICAgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGVudGF0aW9uKGluZGVudCkgKyBcIjxcIiArIHR5cGUgKyBcIj5cXG5cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOb2RlKG5vZGUsIGluZGVudCkge1xuICAgICAgdmFyIHNraXBUb05vZGUgPSBmaW5kTm90YWJsZU5vZGUobm9kZSwgaW5kZW50KTtcbiAgICAgIGlmIChcbiAgICAgICAgc2tpcFRvTm9kZSAhPT0gbm9kZSAmJlxuICAgICAgICAoMSAhPT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggfHwgbm9kZS5jaGlsZHJlblswXSAhPT0gc2tpcFRvTm9kZSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCIuLi5cXG5cIiArIGRlc2NyaWJlTm9kZShza2lwVG9Ob2RlLCBpbmRlbnQgKyAxKVxuICAgICAgICApO1xuICAgICAgc2tpcFRvTm9kZSA9IFwiXCI7XG4gICAgICB2YXIgZGVidWdJbmZvID0gbm9kZS5maWJlci5fZGVidWdJbmZvO1xuICAgICAgaWYgKGRlYnVnSW5mbylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWJ1Z0luZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc2VydmVyQ29tcG9uZW50TmFtZSA9IGRlYnVnSW5mb1tpXS5uYW1lO1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzZXJ2ZXJDb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAoKHNraXBUb05vZGUgKz1cbiAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArIFwiPFwiICsgc2VydmVyQ29tcG9uZW50TmFtZSArIFwiPlxcblwiKSxcbiAgICAgICAgICAgIGluZGVudCsrKTtcbiAgICAgICAgfVxuICAgICAgZGVidWdJbmZvID0gXCJcIjtcbiAgICAgIGkgPSBub2RlLmZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgIGlmICg2ID09PSBub2RlLmZpYmVyLnRhZylcbiAgICAgICAgKGRlYnVnSW5mbyA9IGRlc2NyaWJlVGV4dERpZmYoaSwgbm9kZS5zZXJ2ZXJQcm9wcywgaW5kZW50KSksIGluZGVudCsrO1xuICAgICAgZWxzZSBpZiAoXG4gICAgICAgICgoc2VydmVyQ29tcG9uZW50TmFtZSA9IGRlc2NyaWJlRmliZXJUeXBlKG5vZGUuZmliZXIpKSxcbiAgICAgICAgbnVsbCAhPT0gc2VydmVyQ29tcG9uZW50TmFtZSlcbiAgICAgIClcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gbm9kZS5zZXJ2ZXJQcm9wcykge1xuICAgICAgICAgIGRlYnVnSW5mbyA9IGluZGVudDtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIGRlYnVnSW5mbyAtIHNlcnZlckNvbXBvbmVudE5hbWUubGVuZ3RoIC0gMixcbiAgICAgICAgICAgIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIGZvciAocHJvcE5hbWUgaW4gaSlcbiAgICAgICAgICAgIGlmIChpLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiBcImNoaWxkcmVuXCIgIT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShpW3Byb3BOYW1lXSwgMTUpO1xuICAgICAgICAgICAgICBtYXhMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoICsgcHJvcFZhbHVlLmxlbmd0aCArIDI7XG4gICAgICAgICAgICAgIGlmICgwID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCArPSBcIiAuLi5cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250ZW50ICs9IFwiIFwiICsgcHJvcE5hbWUgKyBcIj1cIiArIHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWJ1Z0luZm8gPVxuICAgICAgICAgICAgaW5kZW50YXRpb24oZGVidWdJbmZvKSArXG4gICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lICtcbiAgICAgICAgICAgIGNvbnRlbnQgK1xuICAgICAgICAgICAgXCI+XFxuXCI7XG4gICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIG51bGwgPT09IG5vZGUuc2VydmVyUHJvcHNcbiAgICAgICAgICAgID8gKChkZWJ1Z0luZm8gPSBkZXNjcmliZUV4cGFuZGVkRWxlbWVudChcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50KVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgaW5kZW50KyspXG4gICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBub2RlLnNlcnZlclByb3BzXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiU2hvdWxkIG5vdCBoYXZlIG1hdGNoZWQgYSBub24gSG9zdFRleHQgZmliZXIgdG8gYSBUZXh0IG5vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogKChkZWJ1Z0luZm8gPSBkZXNjcmliZUVsZW1lbnREaWZmKFxuICAgICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICBub2RlLnNlcnZlclByb3BzLFxuICAgICAgICAgICAgICAgICAgaW5kZW50XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgaW5kZW50KyspO1xuICAgICAgdmFyIHByb3BOYW1lID0gXCJcIjtcbiAgICAgIGkgPSBub2RlLmZpYmVyLmNoaWxkO1xuICAgICAgZm9yIChcbiAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSA9IDA7XG4gICAgICAgIGkgJiYgc2VydmVyQ29tcG9uZW50TmFtZSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICApXG4gICAgICAgIChtYXhMZW5ndGggPSBub2RlLmNoaWxkcmVuW3NlcnZlckNvbXBvbmVudE5hbWVdKSxcbiAgICAgICAgICBtYXhMZW5ndGguZmliZXIgPT09IGlcbiAgICAgICAgICAgID8gKChwcm9wTmFtZSArPSBkZXNjcmliZU5vZGUobWF4TGVuZ3RoLCBpbmRlbnQpKSxcbiAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSsrKVxuICAgICAgICAgICAgOiAocHJvcE5hbWUgKz0gZGVzY3JpYmVTaWJsaW5nRmliZXIoaSwgaW5kZW50KSksXG4gICAgICAgICAgKGkgPSBpLnNpYmxpbmcpO1xuICAgICAgaSAmJlxuICAgICAgICAwIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgKHByb3BOYW1lICs9IGluZGVudGF0aW9uKGluZGVudCkgKyBcIi4uLlxcblwiKTtcbiAgICAgIGkgPSBub2RlLnNlcnZlclRhaWw7XG4gICAgICBudWxsID09PSBub2RlLnNlcnZlclByb3BzICYmIGluZGVudC0tO1xuICAgICAgZm9yIChub2RlID0gMDsgbm9kZSA8IGkubGVuZ3RoOyBub2RlKyspXG4gICAgICAgIChzZXJ2ZXJDb21wb25lbnROYW1lID0gaVtub2RlXSksXG4gICAgICAgICAgKHByb3BOYW1lID1cbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzZXJ2ZXJDb21wb25lbnROYW1lXG4gICAgICAgICAgICAgID8gcHJvcE5hbWUgK1xuICAgICAgICAgICAgICAgIChyZW1vdmVkKGluZGVudCkgK1xuICAgICAgICAgICAgICAgICAgZGVzY3JpYmVUZXh0Tm9kZShzZXJ2ZXJDb21wb25lbnROYW1lLCAxMjAgLSAyICogaW5kZW50KSArXG4gICAgICAgICAgICAgICAgICBcIlxcblwiKVxuICAgICAgICAgICAgICA6IHByb3BOYW1lICtcbiAgICAgICAgICAgICAgICBkZXNjcmliZUV4cGFuZGVkRWxlbWVudChcbiAgICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUudHlwZSxcbiAgICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUucHJvcHMsXG4gICAgICAgICAgICAgICAgICByZW1vdmVkKGluZGVudClcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgIHJldHVybiBza2lwVG9Ob2RlICsgZGVidWdJbmZvICsgcHJvcE5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRGlmZihyb290Tm9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFwiXFxuXFxuXCIgKyBkZXNjcmliZU5vZGUocm9vdE5vZGUsIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVBbmNlc3RvcnMoYW5jZXN0b3IsIGNoaWxkLCBwcm9wcykge1xuICAgICAgZm9yICh2YXIgZmliZXIgPSBjaGlsZCwgbm9kZSA9IG51bGwsIGRpc3RhbmNlRnJvbUxlYWYgPSAwOyBmaWJlcjsgKVxuICAgICAgICBmaWJlciA9PT0gYW5jZXN0b3IgJiYgKGRpc3RhbmNlRnJvbUxlYWYgPSAwKSxcbiAgICAgICAgICAobm9kZSA9IHtcbiAgICAgICAgICAgIGZpYmVyOiBmaWJlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBudWxsICE9PSBub2RlID8gW25vZGVdIDogW10sXG4gICAgICAgICAgICBzZXJ2ZXJQcm9wczpcbiAgICAgICAgICAgICAgZmliZXIgPT09IGNoaWxkID8gcHJvcHMgOiBmaWJlciA9PT0gYW5jZXN0b3IgPyBudWxsIDogdm9pZCAwLFxuICAgICAgICAgICAgc2VydmVyVGFpbDogW10sXG4gICAgICAgICAgICBkaXN0YW5jZUZyb21MZWFmOiBkaXN0YW5jZUZyb21MZWFmXG4gICAgICAgICAgfSksXG4gICAgICAgICAgZGlzdGFuY2VGcm9tTGVhZisrLFxuICAgICAgICAgIChmaWJlciA9IGZpYmVyLnJldHVybik7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gbm9kZSA/IGRlc2NyaWJlRGlmZihub2RlKS5yZXBsYWNlQWxsKC9eWystXS9nbSwgXCI+XCIpIDogXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlZEFuY2VzdG9ySW5mb0RldihvbGRJbmZvLCB0YWcpIHtcbiAgICAgIHZhciBhbmNlc3RvckluZm8gPSBhc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm9EZXYpLFxuICAgICAgICBpbmZvID0geyB0YWc6IHRhZyB9O1xuICAgICAgLTEgIT09IGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAmJlxuICAgICAgICAoKGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGwpLFxuICAgICAgICAoYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsKSxcbiAgICAgICAgKGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGwpKTtcbiAgICAgIC0xICE9PSBidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICYmXG4gICAgICAgIChhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsKTtcbiAgICAgIC0xICE9PSBzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgJiZcbiAgICAgICAgXCJhZGRyZXNzXCIgIT09IHRhZyAmJlxuICAgICAgICBcImRpdlwiICE9PSB0YWcgJiZcbiAgICAgICAgXCJwXCIgIT09IHRhZyAmJlxuICAgICAgICAoKGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbCksXG4gICAgICAgIChhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsKSk7XG4gICAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG4gICAgICBcImZvcm1cIiA9PT0gdGFnICYmIChhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm8pO1xuICAgICAgXCJhXCIgPT09IHRhZyAmJiAoYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbyk7XG4gICAgICBcImJ1dHRvblwiID09PSB0YWcgJiYgKGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbyk7XG4gICAgICBcIm5vYnJcIiA9PT0gdGFnICYmIChhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvKTtcbiAgICAgIFwicFwiID09PSB0YWcgJiYgKGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm8pO1xuICAgICAgXCJsaVwiID09PSB0YWcgJiYgKGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbyk7XG4gICAgICBpZiAoXCJkZFwiID09PSB0YWcgfHwgXCJkdFwiID09PSB0YWcpXG4gICAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgICBcIiNkb2N1bWVudFwiID09PSB0YWcgfHwgXCJodG1sXCIgPT09IHRhZ1xuICAgICAgICA/IChhbmNlc3RvckluZm8uY29udGFpbmVyVGFnSW5TY29wZSA9IG51bGwpXG4gICAgICAgIDogYW5jZXN0b3JJbmZvLmNvbnRhaW5lclRhZ0luU2NvcGUgfHxcbiAgICAgICAgICAoYW5jZXN0b3JJbmZvLmNvbnRhaW5lclRhZ0luU2NvcGUgPSBpbmZvKTtcbiAgICAgIG51bGwgIT09IG9sZEluZm8gfHxcbiAgICAgIChcIiNkb2N1bWVudFwiICE9PSB0YWcgJiYgXCJodG1sXCIgIT09IHRhZyAmJiBcImJvZHlcIiAhPT0gdGFnKVxuICAgICAgICA/ICEwID09PSBhbmNlc3RvckluZm8uaW1wbGljaXRSb290U2NvcGUgJiZcbiAgICAgICAgICAoYW5jZXN0b3JJbmZvLmltcGxpY2l0Um9vdFNjb3BlID0gITEpXG4gICAgICAgIDogKGFuY2VzdG9ySW5mby5pbXBsaWNpdFJvb3RTY29wZSA9ICEwKTtcbiAgICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnLCBpbXBsaWNpdFJvb3RTY29wZSkge1xuICAgICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBcImhyXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJvcHRpb25cIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcIm9wdGdyb3VwXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJzY3JpcHRcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcInRlbXBsYXRlXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCIjdGV4dFwiID09PSB0YWdcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwib3B0Z3JvdXBcIjpcbiAgICAgICAgICByZXR1cm4gXCJvcHRpb25cIiA9PT0gdGFnIHx8IFwiI3RleHRcIiA9PT0gdGFnO1xuICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIFwiI3RleHRcIiA9PT0gdGFnO1xuICAgICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgXCJ0aFwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwidGRcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcInN0eWxlXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJzY3JpcHRcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcInRlbXBsYXRlXCIgPT09IHRhZ1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgICBjYXNlIFwidGhlYWRcIjpcbiAgICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFwidHJcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcInN0eWxlXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJzY3JpcHRcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcInRlbXBsYXRlXCIgPT09IHRhZ1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxuICAgICAgICAgIHJldHVybiBcImNvbFwiID09PSB0YWcgfHwgXCJ0ZW1wbGF0ZVwiID09PSB0YWc7XG4gICAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBcImNhcHRpb25cIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcImNvbGdyb3VwXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJ0Ym9keVwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwidGZvb3RcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcInRoZWFkXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJzdHlsZVwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwic2NyaXB0XCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJ0ZW1wbGF0ZVwiID09PSB0YWdcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBcImJhc2VcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcImJhc2Vmb250XCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJiZ3NvdW5kXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJsaW5rXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJtZXRhXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJ0aXRsZVwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwibm9zY3JpcHRcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICBcIm5vZnJhbWVzXCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJzdHlsZVwiID09PSB0YWcgfHxcbiAgICAgICAgICAgIFwic2NyaXB0XCIgPT09IHRhZyB8fFxuICAgICAgICAgICAgXCJ0ZW1wbGF0ZVwiID09PSB0YWdcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgIGlmIChpbXBsaWNpdFJvb3RTY29wZSkgYnJlYWs7XG4gICAgICAgICAgcmV0dXJuIFwiaGVhZFwiID09PSB0YWcgfHwgXCJib2R5XCIgPT09IHRhZyB8fCBcImZyYW1lc2V0XCIgPT09IHRhZztcbiAgICAgICAgY2FzZSBcImZyYW1lc2V0XCI6XG4gICAgICAgICAgcmV0dXJuIFwiZnJhbWVcIiA9PT0gdGFnO1xuICAgICAgICBjYXNlIFwiI2RvY3VtZW50XCI6XG4gICAgICAgICAgaWYgKCFpbXBsaWNpdFJvb3RTY29wZSkgcmV0dXJuIFwiaHRtbFwiID09PSB0YWc7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIFwiaDFcIjpcbiAgICAgICAgY2FzZSBcImgyXCI6XG4gICAgICAgIGNhc2UgXCJoM1wiOlxuICAgICAgICBjYXNlIFwiaDRcIjpcbiAgICAgICAgY2FzZSBcImg1XCI6XG4gICAgICAgIGNhc2UgXCJoNlwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBcImgxXCIgIT09IHBhcmVudFRhZyAmJlxuICAgICAgICAgICAgXCJoMlwiICE9PSBwYXJlbnRUYWcgJiZcbiAgICAgICAgICAgIFwiaDNcIiAhPT0gcGFyZW50VGFnICYmXG4gICAgICAgICAgICBcImg0XCIgIT09IHBhcmVudFRhZyAmJlxuICAgICAgICAgICAgXCJoNVwiICE9PSBwYXJlbnRUYWcgJiZcbiAgICAgICAgICAgIFwiaDZcIiAhPT0gcGFyZW50VGFnXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcInJwXCI6XG4gICAgICAgIGNhc2UgXCJydFwiOlxuICAgICAgICAgIHJldHVybiAtMSA9PT0gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpO1xuICAgICAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgICAgICBjYXNlIFwiY29sXCI6XG4gICAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxuICAgICAgICBjYXNlIFwiZnJhbWVzZXRcIjpcbiAgICAgICAgY2FzZSBcImZyYW1lXCI6XG4gICAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgICBjYXNlIFwidGRcIjpcbiAgICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgICBjYXNlIFwidGhlYWRcIjpcbiAgICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgICAgcmV0dXJuIG51bGwgPT0gcGFyZW50VGFnO1xuICAgICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICAgIHJldHVybiBpbXBsaWNpdFJvb3RTY29wZSB8fCBudWxsID09PSBwYXJlbnRUYWc7XG4gICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChpbXBsaWNpdFJvb3RTY29wZSAmJiBcIiNkb2N1bWVudFwiID09PSBwYXJlbnRUYWcpIHx8XG4gICAgICAgICAgICBudWxsID09PSBwYXJlbnRUYWdcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoaW1wbGljaXRSb290U2NvcGUgJiZcbiAgICAgICAgICAgICAgKFwiI2RvY3VtZW50XCIgPT09IHBhcmVudFRhZyB8fCBcImh0bWxcIiA9PT0gcGFyZW50VGFnKSkgfHxcbiAgICAgICAgICAgIG51bGwgPT09IHBhcmVudFRhZ1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgIGNhc2UgXCJhcnRpY2xlXCI6XG4gICAgICAgIGNhc2UgXCJhc2lkZVwiOlxuICAgICAgICBjYXNlIFwiYmxvY2txdW90ZVwiOlxuICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgIGNhc2UgXCJkZXRhaWxzXCI6XG4gICAgICAgIGNhc2UgXCJkaWFsb2dcIjpcbiAgICAgICAgY2FzZSBcImRpclwiOlxuICAgICAgICBjYXNlIFwiZGl2XCI6XG4gICAgICAgIGNhc2UgXCJkbFwiOlxuICAgICAgICBjYXNlIFwiZmllbGRzZXRcIjpcbiAgICAgICAgY2FzZSBcImZpZ2NhcHRpb25cIjpcbiAgICAgICAgY2FzZSBcImZpZ3VyZVwiOlxuICAgICAgICBjYXNlIFwiZm9vdGVyXCI6XG4gICAgICAgIGNhc2UgXCJoZWFkZXJcIjpcbiAgICAgICAgY2FzZSBcImhncm91cFwiOlxuICAgICAgICBjYXNlIFwibWFpblwiOlxuICAgICAgICBjYXNlIFwibWVudVwiOlxuICAgICAgICBjYXNlIFwibmF2XCI6XG4gICAgICAgIGNhc2UgXCJvbFwiOlxuICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBjYXNlIFwic2VjdGlvblwiOlxuICAgICAgICBjYXNlIFwic3VtbWFyeVwiOlxuICAgICAgICBjYXNlIFwidWxcIjpcbiAgICAgICAgY2FzZSBcInByZVwiOlxuICAgICAgICBjYXNlIFwibGlzdGluZ1wiOlxuICAgICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgIGNhc2UgXCJ4bXBcIjpcbiAgICAgICAgY2FzZSBcImgxXCI6XG4gICAgICAgIGNhc2UgXCJoMlwiOlxuICAgICAgICBjYXNlIFwiaDNcIjpcbiAgICAgICAgY2FzZSBcImg0XCI6XG4gICAgICAgIGNhc2UgXCJoNVwiOlxuICAgICAgICBjYXNlIFwiaDZcIjpcbiAgICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuICAgICAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG4gICAgICAgIGNhc2UgXCJsaVwiOlxuICAgICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcbiAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgIGNhc2UgXCJkdFwiOlxuICAgICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG4gICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcbiAgICAgICAgY2FzZSBcIm5vYnJcIjpcbiAgICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRBbmNlc3RvcihwYXJlbnQsIHRhZ05hbWUpIHtcbiAgICAgIGZvciAoOyBwYXJlbnQ7ICkge1xuICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSB0YWdOYW1lKSByZXR1cm4gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVET01OZXN0aW5nKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mb0RldjtcbiAgICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgICBhbmNlc3RvckluZm8gPSAocGFyZW50SW5mbyA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KFxuICAgICAgICBjaGlsZFRhZyxcbiAgICAgICAgcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZyxcbiAgICAgICAgYW5jZXN0b3JJbmZvLmltcGxpY2l0Um9vdFNjb3BlXG4gICAgICApXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHBhcmVudEluZm8pXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgICBhbmNlc3RvckluZm8gPSBwYXJlbnRJbmZvIHx8IGFuY2VzdG9ySW5mbztcbiAgICAgIGlmICghYW5jZXN0b3JJbmZvKSByZXR1cm4gITA7XG4gICAgICB2YXIgYW5jZXN0b3JUYWcgPSBhbmNlc3RvckluZm8udGFnO1xuICAgICAgYW5jZXN0b3JJbmZvID0gU3RyaW5nKCEhcGFyZW50SW5mbykgKyBcInxcIiArIGNoaWxkVGFnICsgXCJ8XCIgKyBhbmNlc3RvclRhZztcbiAgICAgIGlmIChkaWRXYXJuW2FuY2VzdG9ySW5mb10pIHJldHVybiAhMTtcbiAgICAgIGRpZFdhcm5bYW5jZXN0b3JJbmZvXSA9ICEwO1xuICAgICAgdmFyIGFuY2VzdG9yID0gKGFuY2VzdG9ySW5mbyA9IGN1cnJlbnQpXG4gICAgICAgICAgPyBmaW5kQW5jZXN0b3IoYW5jZXN0b3JJbmZvLnJldHVybiwgYW5jZXN0b3JUYWcpXG4gICAgICAgICAgOiBudWxsLFxuICAgICAgICBhbmNlc3RvckRlc2NyaXB0aW9uID1cbiAgICAgICAgICBudWxsICE9PSBhbmNlc3RvckluZm8gJiYgbnVsbCAhPT0gYW5jZXN0b3JcbiAgICAgICAgICAgID8gZGVzY3JpYmVBbmNlc3RvcnMoYW5jZXN0b3IsIGFuY2VzdG9ySW5mbywgbnVsbClcbiAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSBcIjxcIiArIGNoaWxkVGFnICsgXCI+XCI7XG4gICAgICBwYXJlbnRJbmZvXG4gICAgICAgID8gKChwYXJlbnRJbmZvID0gXCJcIiksXG4gICAgICAgICAgXCJ0YWJsZVwiID09PSBhbmNlc3RvclRhZyAmJlxuICAgICAgICAgICAgXCJ0clwiID09PSBjaGlsZFRhZyAmJlxuICAgICAgICAgICAgKHBhcmVudEluZm8gKz1cbiAgICAgICAgICAgICAgXCIgQWRkIGEgPHRib2R5PiwgPHRoZWFkPiBvciA8dGZvb3Q+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5IHRoZSBicm93c2VyLlwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbiBIVE1MLCAlcyBjYW5ub3QgYmUgYSBjaGlsZCBvZiA8JXM+LiVzXFxuVGhpcyB3aWxsIGNhdXNlIGEgaHlkcmF0aW9uIGVycm9yLiVzXCIsXG4gICAgICAgICAgICB0YWdEaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIGFuY2VzdG9yVGFnLFxuICAgICAgICAgICAgcGFyZW50SW5mbyxcbiAgICAgICAgICAgIGFuY2VzdG9yRGVzY3JpcHRpb25cbiAgICAgICAgICApKVxuICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkluIEhUTUwsICVzIGNhbm5vdCBiZSBhIGRlc2NlbmRhbnQgb2YgPCVzPi5cXG5UaGlzIHdpbGwgY2F1c2UgYSBoeWRyYXRpb24gZXJyb3IuJXNcIixcbiAgICAgICAgICAgIHRhZ0Rpc3BsYXlOYW1lLFxuICAgICAgICAgICAgYW5jZXN0b3JUYWcsXG4gICAgICAgICAgICBhbmNlc3RvckRlc2NyaXB0aW9uXG4gICAgICAgICAgKTtcbiAgICAgIGFuY2VzdG9ySW5mbyAmJlxuICAgICAgICAoKGNoaWxkVGFnID0gYW5jZXN0b3JJbmZvLnJldHVybiksXG4gICAgICAgIG51bGwgPT09IGFuY2VzdG9yIHx8XG4gICAgICAgICAgbnVsbCA9PT0gY2hpbGRUYWcgfHxcbiAgICAgICAgICAoYW5jZXN0b3IgPT09IGNoaWxkVGFnICYmXG4gICAgICAgICAgICBjaGlsZFRhZy5fZGVidWdPd25lciA9PT0gYW5jZXN0b3JJbmZvLl9kZWJ1Z093bmVyKSB8fFxuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGFuY2VzdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIjwlcz4gY2Fubm90IGNvbnRhaW4gYSBuZXN0ZWQgJXMuXFxuU2VlIHRoaXMgbG9nIGZvciB0aGUgYW5jZXN0b3Igc3RhY2sgdHJhY2UuXCIsXG4gICAgICAgICAgICAgIGFuY2VzdG9yVGFnLFxuICAgICAgICAgICAgICB0YWdEaXNwbGF5TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSk7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlVGV4dE5lc3RpbmcoY2hpbGRUZXh0LCBwYXJlbnRUYWcsIGltcGxpY2l0Um9vdFNjb3BlKSB7XG4gICAgICBpZiAoaW1wbGljaXRSb290U2NvcGUgfHwgaXNUYWdWYWxpZFdpdGhQYXJlbnQoXCIjdGV4dFwiLCBwYXJlbnRUYWcsICExKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaW1wbGljaXRSb290U2NvcGUgPSBcIiN0ZXh0fFwiICsgcGFyZW50VGFnO1xuICAgICAgaWYgKGRpZFdhcm5baW1wbGljaXRSb290U2NvcGVdKSByZXR1cm4gITE7XG4gICAgICBkaWRXYXJuW2ltcGxpY2l0Um9vdFNjb3BlXSA9ICEwO1xuICAgICAgdmFyIGFuY2VzdG9yID0gKGltcGxpY2l0Um9vdFNjb3BlID0gY3VycmVudClcbiAgICAgICAgPyBmaW5kQW5jZXN0b3IoaW1wbGljaXRSb290U2NvcGUsIHBhcmVudFRhZylcbiAgICAgICAgOiBudWxsO1xuICAgICAgaW1wbGljaXRSb290U2NvcGUgPVxuICAgICAgICBudWxsICE9PSBpbXBsaWNpdFJvb3RTY29wZSAmJiBudWxsICE9PSBhbmNlc3RvclxuICAgICAgICAgID8gZGVzY3JpYmVBbmNlc3RvcnMoXG4gICAgICAgICAgICAgIGFuY2VzdG9yLFxuICAgICAgICAgICAgICBpbXBsaWNpdFJvb3RTY29wZSxcbiAgICAgICAgICAgICAgNiAhPT0gaW1wbGljaXRSb290U2NvcGUudGFnID8geyBjaGlsZHJlbjogbnVsbCB9IDogbnVsbFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogXCJcIjtcbiAgICAgIC9cXFMvLnRlc3QoY2hpbGRUZXh0KVxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkluIEhUTUwsIHRleHQgbm9kZXMgY2Fubm90IGJlIGEgY2hpbGQgb2YgPCVzPi5cXG5UaGlzIHdpbGwgY2F1c2UgYSBoeWRyYXRpb24gZXJyb3IuJXNcIixcbiAgICAgICAgICAgIHBhcmVudFRhZyxcbiAgICAgICAgICAgIGltcGxpY2l0Um9vdFNjb3BlXG4gICAgICAgICAgKVxuICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkluIEhUTUwsIHdoaXRlc3BhY2UgdGV4dCBub2RlcyBjYW5ub3QgYmUgYSBjaGlsZCBvZiA8JXM+LiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIGVhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLlxcblRoaXMgd2lsbCBjYXVzZSBhIGh5ZHJhdGlvbiBlcnJvci4lc1wiLFxuICAgICAgICAgICAgcGFyZW50VGFnLFxuICAgICAgICAgICAgaW1wbGljaXRSb290U2NvcGVcbiAgICAgICAgICApO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRUZXh0Q29udGVudChub2RlLCB0ZXh0KSB7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGZpcnN0Q2hpbGQgJiZcbiAgICAgICAgICBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJlxuICAgICAgICAgIDMgPT09IGZpcnN0Q2hpbGQubm9kZVR5cGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGh5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGUoc3R5bGUsIHN0eWxlTmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gMCA9PT0gc3R5bGVOYW1lLmluZGV4T2YoXCItLVwiKTtcbiAgICAgIGlzQ3VzdG9tUHJvcGVydHkgfHxcbiAgICAgICAgKC0xIDwgc3R5bGVOYW1lLmluZGV4T2YoXCItXCIpXG4gICAgICAgICAgPyAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmXG4gICAgICAgICAgICAgIHdhcm5lZFN0eWxlTmFtZXNbc3R5bGVOYW1lXSkgfHxcbiAgICAgICAgICAgICgod2FybmVkU3R5bGVOYW1lc1tzdHlsZU5hbWVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzP1wiLFxuICAgICAgICAgICAgICBzdHlsZU5hbWUsXG4gICAgICAgICAgICAgIGNhbWVsaXplKHN0eWxlTmFtZS5yZXBsYWNlKG1zUGF0dGVybiwgXCJtcy1cIikpXG4gICAgICAgICAgICApKVxuICAgICAgICAgIDogYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3Qoc3R5bGVOYW1lKVxuICAgICAgICAgICAgPyAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmXG4gICAgICAgICAgICAgICAgd2FybmVkU3R5bGVOYW1lc1tzdHlsZU5hbWVdKSB8fFxuICAgICAgICAgICAgICAoKHdhcm5lZFN0eWxlTmFtZXNbc3R5bGVOYW1lXSA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzP1wiLFxuICAgICAgICAgICAgICAgIHN0eWxlTmFtZSxcbiAgICAgICAgICAgICAgICBzdHlsZU5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHlsZU5hbWUuc2xpY2UoMSlcbiAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIDogIWJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgICAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB8fFxuICAgICAgICAgICAgICAoKHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uIFRyeSBcIiVzOiAlc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICBzdHlsZU5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sIFwiXCIpXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAoaXNOYU4odmFsdWUpXG4gICAgICAgICAgICA/IHdhcm5lZEZvck5hTlZhbHVlIHx8XG4gICAgICAgICAgICAgICgod2FybmVkRm9yTmFOVmFsdWUgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVOYW1lXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6IGlzRmluaXRlKHZhbHVlKSB8fFxuICAgICAgICAgICAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlIHx8XG4gICAgICAgICAgICAgICgod2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcImBJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LlwiLFxuICAgICAgICAgICAgICAgIHN0eWxlTmFtZVxuICAgICAgICAgICAgICApKSkpO1xuICAgICAgbnVsbCA9PSB2YWx1ZSB8fCBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlIHx8IFwiXCIgPT09IHZhbHVlXG4gICAgICAgID8gaXNDdXN0b21Qcm9wZXJ0eVxuICAgICAgICAgID8gc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCBcIlwiKVxuICAgICAgICAgIDogXCJmbG9hdFwiID09PSBzdHlsZU5hbWVcbiAgICAgICAgICAgID8gKHN0eWxlLmNzc0Zsb2F0ID0gXCJcIilcbiAgICAgICAgICAgIDogKHN0eWxlW3N0eWxlTmFtZV0gPSBcIlwiKVxuICAgICAgICA6IGlzQ3VzdG9tUHJvcGVydHlcbiAgICAgICAgICA/IHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgdmFsdWUpXG4gICAgICAgICAgOiBcIm51bWJlclwiICE9PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgICAgMCA9PT0gdmFsdWUgfHxcbiAgICAgICAgICAgICAgdW5pdGxlc3NOdW1iZXJzLmhhcyhzdHlsZU5hbWUpXG4gICAgICAgICAgICA/IFwiZmxvYXRcIiA9PT0gc3R5bGVOYW1lXG4gICAgICAgICAgICAgID8gKHN0eWxlLmNzc0Zsb2F0ID0gdmFsdWUpXG4gICAgICAgICAgICAgIDogKGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbih2YWx1ZSwgc3R5bGVOYW1lKSxcbiAgICAgICAgICAgICAgICAoc3R5bGVbc3R5bGVOYW1lXSA9IChcIlwiICsgdmFsdWUpLnRyaW0oKSkpXG4gICAgICAgICAgICA6IChzdHlsZVtzdHlsZU5hbWVdID0gdmFsdWUgKyBcInB4XCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZXMsIHByZXZTdHlsZXMpIHtcbiAgICAgIGlmIChudWxsICE9IHN0eWxlcyAmJiBcIm9iamVjdFwiICE9PSB0eXBlb2Ygc3R5bGVzKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIHVzaW5nIEpTWC5cIlxuICAgICAgICApO1xuICAgICAgc3R5bGVzICYmIE9iamVjdC5mcmVlemUoc3R5bGVzKTtcbiAgICAgIG5vZGUgPSBub2RlLnN0eWxlO1xuICAgICAgaWYgKG51bGwgIT0gcHJldlN0eWxlcykge1xuICAgICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgICAgdmFyIGV4cGFuZGVkVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIGlmIChwcmV2U3R5bGVzKVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByZXZTdHlsZXMpXG4gICAgICAgICAgICAgIGlmIChwcmV2U3R5bGVzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICB2YXIgbG9uZ2hhbmRzID0gc2hvcnRoYW5kVG9Mb25naGFuZFtrZXldIHx8IFtrZXldLCBpID0gMDtcbiAgICAgICAgICAgICAgICAgIGkgPCBsb25naGFuZHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgZXhwYW5kZWRVcGRhdGVzW2xvbmdoYW5kc1tpXV0gPSBrZXk7XG4gICAgICAgICAgZm9yICh2YXIgX2tleSBpbiBzdHlsZXMpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShfa2V5KSAmJlxuICAgICAgICAgICAgICAoIXByZXZTdHlsZXMgfHwgcHJldlN0eWxlc1tfa2V5XSAhPT0gc3R5bGVzW19rZXldKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIGtleSA9IHNob3J0aGFuZFRvTG9uZ2hhbmRbX2tleV0gfHwgW19rZXldLCBsb25naGFuZHMgPSAwO1xuICAgICAgICAgICAgICAgIGxvbmdoYW5kcyA8IGtleS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbG9uZ2hhbmRzKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGV4cGFuZGVkVXBkYXRlc1trZXlbbG9uZ2hhbmRzXV0gPSBfa2V5O1xuICAgICAgICAgIF9rZXkgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkkanNjb21wJDAgaW4gc3R5bGVzKVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAga2V5ID0gc2hvcnRoYW5kVG9Mb25naGFuZFtrZXkkanNjb21wJDBdIHx8IFtrZXkkanNjb21wJDBdLFxuICAgICAgICAgICAgICAgIGxvbmdoYW5kcyA9IDA7XG4gICAgICAgICAgICAgIGxvbmdoYW5kcyA8IGtleS5sZW5ndGg7XG4gICAgICAgICAgICAgIGxvbmdoYW5kcysrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIF9rZXlba2V5W2xvbmdoYW5kc11dID0ga2V5JGpzY29tcCQwO1xuICAgICAgICAgIGtleSRqc2NvbXAkMCA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIF9rZXkyIGluIGV4cGFuZGVkVXBkYXRlcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChrZXkgPSBleHBhbmRlZFVwZGF0ZXNbX2tleTJdKSxcbiAgICAgICAgICAgICAgKGxvbmdoYW5kcyA9IF9rZXlbX2tleTJdKSAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gbG9uZ2hhbmRzICYmXG4gICAgICAgICAgICAgICAgKChpID0ga2V5ICsgXCIsXCIgKyBsb25naGFuZHMpLCAha2V5JGpzY29tcCQwW2ldKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBrZXkkanNjb21wJDBbaV0gPSAhMDtcbiAgICAgICAgICAgICAgaSA9IGNvbnNvbGU7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgICAgICAgICAgICBpLmVycm9yLmNhbGwoXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBcIiVzIGEgc3R5bGUgcHJvcGVydHkgZHVyaW5nIHJlcmVuZGVyICglcykgd2hlbiBhIGNvbmZsaWN0aW5nIHByb3BlcnR5IGlzIHNldCAoJXMpIGNhbiBsZWFkIHRvIHN0eWxpbmcgYnVncy4gVG8gYXZvaWQgdGhpcywgZG9uJ3QgbWl4IHNob3J0aGFuZCBhbmQgbm9uLXNob3J0aGFuZCBwcm9wZXJ0aWVzIGZvciB0aGUgc2FtZSB2YWx1ZTsgaW5zdGVhZCwgcmVwbGFjZSB0aGUgc2hvcnRoYW5kIHdpdGggc2VwYXJhdGUgdmFsdWVzLlwiLFxuICAgICAgICAgICAgICAgIG51bGwgPT0gdmFsdWUgfHwgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZSB8fCBcIlwiID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgPyBcIlJlbW92aW5nXCJcbiAgICAgICAgICAgICAgICAgIDogXCJVcGRhdGluZ1wiLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBsb25naGFuZHNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gcHJldlN0eWxlcylcbiAgICAgICAgICAhcHJldlN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpIHx8XG4gICAgICAgICAgICAobnVsbCAhPSBzdHlsZXMgJiYgc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHx8XG4gICAgICAgICAgICAoMCA9PT0gc3R5bGVOYW1lLmluZGV4T2YoXCItLVwiKVxuICAgICAgICAgICAgICA/IG5vZGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCBcIlwiKVxuICAgICAgICAgICAgICA6IFwiZmxvYXRcIiA9PT0gc3R5bGVOYW1lXG4gICAgICAgICAgICAgICAgPyAobm9kZS5jc3NGbG9hdCA9IFwiXCIpXG4gICAgICAgICAgICAgICAgOiAobm9kZVtzdHlsZU5hbWVdID0gXCJcIikpO1xuICAgICAgICBmb3IgKHZhciBfc3R5bGVOYW1lIGluIHN0eWxlcylcbiAgICAgICAgICAoX2tleTIgPSBzdHlsZXNbX3N0eWxlTmFtZV0pLFxuICAgICAgICAgICAgc3R5bGVzLmhhc093blByb3BlcnR5KF9zdHlsZU5hbWUpICYmXG4gICAgICAgICAgICAgIHByZXZTdHlsZXNbX3N0eWxlTmFtZV0gIT09IF9rZXkyICYmXG4gICAgICAgICAgICAgIHNldFZhbHVlRm9yU3R5bGUobm9kZSwgX3N0eWxlTmFtZSwgX2tleTIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGZvciAoZXhwYW5kZWRVcGRhdGVzIGluIHN0eWxlcylcbiAgICAgICAgICBzdHlsZXMuaGFzT3duUHJvcGVydHkoZXhwYW5kZWRVcGRhdGVzKSAmJlxuICAgICAgICAgICAgc2V0VmFsdWVGb3JTdHlsZShub2RlLCBleHBhbmRlZFVwZGF0ZXMsIHN0eWxlc1tleHBhbmRlZFVwZGF0ZXNdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHRhZ05hbWUpIHtcbiAgICAgIGlmICgtMSA9PT0gdGFnTmFtZS5pbmRleE9mKFwiLVwiKSkgcmV0dXJuICExO1xuICAgICAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLXhtbFwiOlxuICAgICAgICBjYXNlIFwiY29sb3ItcHJvZmlsZVwiOlxuICAgICAgICBjYXNlIFwiZm9udC1mYWNlXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2Utc3JjXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtdXJpXCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6XG4gICAgICAgIGNhc2UgXCJmb250LWZhY2UtbmFtZVwiOlxuICAgICAgICBjYXNlIFwibWlzc2luZy1nbHlwaFwiOlxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUFsaWFzKG5hbWUpIHtcbiAgICAgIHJldHVybiBhbGlhc2VzLmdldChuYW1lKSB8fCBuYW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5JDEodGFnTmFtZSwgbmFtZSkge1xuICAgICAgaWYgKFxuICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiZcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdXG4gICAgICApXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChyQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgICB0YWdOYW1lID0gXCJhcmlhLVwiICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0YWdOYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgPyB0YWdOYW1lIDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgPT0gdGFnTmFtZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS5cIixcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobmFtZSAhPT0gdGFnTmFtZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICB0YWdOYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRhZ05hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRhZ05hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSA/IHRhZ05hbWUgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCA9PSB0YWdOYW1lKSByZXR1cm4gKHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9ICEwKSwgITE7XG4gICAgICAgIG5hbWUgIT09IHRhZ05hbWUgJiZcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD9cIixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0YWdOYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gITApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpIHtcbiAgICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXSxcbiAgICAgICAga2V5O1xuICAgICAgZm9yIChrZXkgaW4gcHJvcHMpXG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXkpIHx8IGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgICBwcm9wcyA9IGludmFsaWRQcm9wc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYFwiICsgcHJvcCArIFwiYFwiO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgMSA9PT0gaW52YWxpZFByb3BzLmxlbmd0aFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1hcmlhLXByb3BzXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApXG4gICAgICAgIDogMSA8IGludmFsaWRQcm9wcy5sZW5ndGggJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWFyaWEtcHJvcHNcIixcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChcIm9uZm9jdXNpblwiID09PSBsb3dlckNhc2VkTmFtZSB8fCBcIm9uZm9jdXNvdXRcIiA9PT0gbG93ZXJDYXNlZE5hbWUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuIEFsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAoKFwiZm9ybVwiID09PSB0YWdOYW1lICYmIFwiYWN0aW9uXCIgPT09IG5hbWUpIHx8XG4gICAgICAgICAgKFwiaW5wdXRcIiA9PT0gdGFnTmFtZSAmJiBcImZvcm1BY3Rpb25cIiA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAoXCJidXR0b25cIiA9PT0gdGFnTmFtZSAmJiBcImZvcm1BY3Rpb25cIiA9PT0gbmFtZSkpXG4gICAgICApXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChudWxsICE9IGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgICAgdGFnTmFtZSA9IGV2ZW50UmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcbiAgICAgICAgaWYgKGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGV2ZW50UmVnaXN0cnkgPSB0YWdOYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICAgID8gdGFnTmFtZVtsb3dlckNhc2VkTmFtZV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9IGV2ZW50UmVnaXN0cnkpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgP1wiLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBldmVudFJlZ2lzdHJ5XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlVua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAod2FybmVkUHJvcGVydGllc1tuYW1lXSA9ICEwKVxuICAgICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuXCIsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwudGVzdChuYW1lKSkgcmV0dXJuICEwO1xuICAgICAgaWYgKFwiaW5uZXJodG1sXCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkRpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXCJhcmlhXCIgPT09IGxvd2VyQ2FzZWROYW1lKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiBQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIFwiaXNcIiA9PT0gbG93ZXJDYXNlZE5hbWUgJiZcbiAgICAgICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICAgICAgdm9pZCAwICE9PSB2YWx1ZSAmJlxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgdmFsdWVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0IHRoZSB2YWx1ZSB0byBhIHN0cmluZy5cIixcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgJiYgaXNOYU4odmFsdWUpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0IHRoZSB2YWx1ZSB0byBhIHN0cmluZy5cIixcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApXG4gICAgICAgICk7XG4gICAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKChsb3dlckNhc2VkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV0pLFxuICAgICAgICAgIGxvd2VyQ2FzZWROYW1lICE9PSBuYW1lKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/XCIsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGxvd2VyQ2FzZWROYW1lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChuYW1lICE9PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tIGF0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSBpdCBmcm9tIHRoZSBET00gZWxlbWVudC5cIixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBsb3dlckNhc2VkTmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMClcbiAgICAgICAgKTtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICBjYXNlIFwicmVmXCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiYXV0b0ZvY3VzXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbnRlbnRFZGl0YWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInNwZWxsQ2hlY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkcmFnZ2FibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgY2FzZSBcImF1dG9SZXZlcnNlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImZvY3VzYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInByZXNlcnZlQWxwaGFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJhbGxvd0Z1bGxTY3JlZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgICAgICBjYXNlIFwiY29udHJvbHNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgICAgICBjYXNlIFwiZm9ybU5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgICAgICBjYXNlIFwibm9Nb2R1bGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgY2FzZSBcInBsYXlzSW5saW5lXCI6XG4gICAgICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInJldmVyc2VkXCI6XG4gICAgICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpdGVtU2NvcGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjYXB0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZG93bmxvYWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbmVydFwiOlxuICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICAgICAgaWYgKFwiZGF0YS1cIiA9PT0gbG93ZXJDYXNlZE5hbWUgfHwgXCJhcmlhLVwiID09PSBsb3dlckNhc2VkTmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG5JZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG5JZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sIHBhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuICh3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITApO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICByZXR1cm4gKHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSAhMCksICExO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgaWYgKFwiZmFsc2VcIiA9PT0gdmFsdWUgfHwgXCJ0cnVlXCIgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwibXV0ZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImFsbG93RnVsbFNjcmVlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJjb250cm9sc1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRpc2FibGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmb3JtTm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJub01vZHVsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwicGxheXNJbmxpbmVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmV2ZXJzZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIml0ZW1TY29wZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICVzIERpZCB5b3UgbWVhbiAlcz17JXN9P1wiLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgXCJmYWxzZVwiID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gXCJUaGUgYnJvd3NlciB3aWxsIGludGVycHJldCBpdCBhcyBhIHRydXRoeSB2YWx1ZS5cIlxuICAgICAgICAgICAgICAgIDogJ0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJyxcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gITA7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICAgIHZhciB1bmtub3duUHJvcHMgPSBbXSxcbiAgICAgICAga2V5O1xuICAgICAgZm9yIChrZXkgaW4gcHJvcHMpXG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5LCBwcm9wc1trZXldLCBldmVudFJlZ2lzdHJ5KSB8fFxuICAgICAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgICBwcm9wcyA9IHVua25vd25Qcm9wc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYFwiICsgcHJvcCArIFwiYFwiO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIiwgXCIpO1xuICAgICAgMSA9PT0gdW5rbm93blByb3BzLmxlbmd0aFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiBGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yIFwiLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgKVxuICAgICAgICA6IDEgPCB1bmtub3duUHJvcHMubGVuZ3RoICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uIEZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgXCIsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAgICAgIHJldHVybiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KFwiXCIgKyB1cmwpXG4gICAgICAgID8gXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignUmVhY3QgaGFzIGJsb2NrZWQgYSBqYXZhc2NyaXB0OiBVUkwgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLicpXCJcbiAgICAgICAgOiB1cmw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gICAgICBuYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcbiAgICAgIG5hdGl2ZUV2ZW50LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50ICYmXG4gICAgICAgIChuYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtcbiAgICAgIHJldHVybiAzID09PSBuYXRpdmVFdmVudC5ub2RlVHlwZSA/IG5hdGl2ZUV2ZW50LnBhcmVudE5vZGUgOiBuYXRpdmVFdmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlICYmICh0YXJnZXQgPSBpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSkpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGFyZ2V0W2ludGVybmFsUHJvcHNLZXldIHx8IG51bGw7XG4gICAgICAgIGE6IHN3aXRjaCAoXG4gICAgICAgICAgKCh0YXJnZXQgPSBpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSksIGludGVybmFsSW5zdGFuY2UudHlwZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgICB1cGRhdGVJbnB1dChcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBwcm9wcy52YWx1ZSxcbiAgICAgICAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgIHByb3BzLmNoZWNrZWQsXG4gICAgICAgICAgICAgIHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgICAgICAgICAgICBwcm9wcy50eXBlLFxuICAgICAgICAgICAgICBwcm9wcy5uYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSA9IHByb3BzLm5hbWU7XG4gICAgICAgICAgICBpZiAoXCJyYWRpb1wiID09PSBwcm9wcy50eXBlICYmIG51bGwgIT0gaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgICAgICAgICBmb3IgKHByb3BzID0gdGFyZ2V0OyBwcm9wcy5wYXJlbnROb2RlOyApIHByb3BzID0gcHJvcHMucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihpbnRlcm5hbEluc3RhbmNlLCBcIm5hbWVcIik7XG4gICAgICAgICAgICAgIHByb3BzID0gcHJvcHMucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICAgICAgICAnaW5wdXRbbmFtZT1cIicgK1xuICAgICAgICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhcbiAgICAgICAgICAgICAgICAgICAgXCJcIiArIGludGVybmFsSW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICAgJ1wiXVt0eXBlPVwicmFkaW9cIl0nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSA8IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlKytcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyTm9kZSA9IHByb3BzW2ludGVybmFsSW5zdGFuY2VdO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlck5vZGUgIT09IHRhcmdldCAmJiBvdGhlck5vZGUuZm9ybSA9PT0gdGFyZ2V0LmZvcm0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvdGhlclByb3BzID0gb3RoZXJOb2RlW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAoIW90aGVyUHJvcHMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZUlucHV0KFxuICAgICAgICAgICAgICAgICAgICBvdGhlck5vZGUsXG4gICAgICAgICAgICAgICAgICAgIG90aGVyUHJvcHMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG90aGVyUHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvdGhlclByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJQcm9wcy5jaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICBvdGhlclByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICBvdGhlclByb3BzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG90aGVyUHJvcHMubmFtZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlID0gMDtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlIDwgcHJvcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKG90aGVyTm9kZSA9IHByb3BzW2ludGVybmFsSW5zdGFuY2VdKSxcbiAgICAgICAgICAgICAgICAgIG90aGVyTm9kZS5mb3JtID09PSB0YXJnZXQuZm9ybSAmJlxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZUlmQ2hhbmdlZChvdGhlck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgICAgIHVwZGF0ZVRleHRhcmVhKHRhcmdldCwgcHJvcHMudmFsdWUsIHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICAgIChpbnRlcm5hbEluc3RhbmNlID0gcHJvcHMudmFsdWUpLFxuICAgICAgICAgICAgICBudWxsICE9IGludGVybmFsSW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgICB1cGRhdGVPcHRpb25zKHRhcmdldCwgISFwcm9wcy5tdWx0aXBsZSwgaW50ZXJuYWxJbnN0YW5jZSwgITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzJDEoZm4sIGEsIGIpIHtcbiAgICAgIGlmIChpc0luc2lkZUV2ZW50SGFuZGxlcikgcmV0dXJuIGZuKGEsIGIpO1xuICAgICAgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSAhMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBmbihhKTtcbiAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gITEpLFxuICAgICAgICAgIG51bGwgIT09IHJlc3RvcmVUYXJnZXQgfHwgbnVsbCAhPT0gcmVzdG9yZVF1ZXVlKVxuICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGZsdXNoU3luY1dvcmskMSgpLFxuICAgICAgICAgICAgcmVzdG9yZVRhcmdldCAmJlxuICAgICAgICAgICAgICAoKGEgPSByZXN0b3JlVGFyZ2V0KSxcbiAgICAgICAgICAgICAgKGZuID0gcmVzdG9yZVF1ZXVlKSxcbiAgICAgICAgICAgICAgKHJlc3RvcmVRdWV1ZSA9IHJlc3RvcmVUYXJnZXQgPSBudWxsKSxcbiAgICAgICAgICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQoYSksXG4gICAgICAgICAgICAgIGZuKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgZm4ubGVuZ3RoOyBhKyspIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KGZuW2FdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuICAgICAgaWYgKG51bGwgPT09IHN0YXRlTm9kZSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgcHJvcHMgPSBzdGF0ZU5vZGVbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbiAgICAgIGlmIChudWxsID09PSBwcm9wcykgcmV0dXJuIG51bGw7XG4gICAgICBzdGF0ZU5vZGUgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIGE6IHN3aXRjaCAocmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgICBjYXNlIFwib25DbGlja1wiOlxuICAgICAgICBjYXNlIFwib25DbGlja0NhcHR1cmVcIjpcbiAgICAgICAgY2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpcbiAgICAgICAgY2FzZSBcIm9uRG91YmxlQ2xpY2tDYXB0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJvbk1vdXNlRG93blwiOlxuICAgICAgICBjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJvbk1vdXNlTW92ZVwiOlxuICAgICAgICBjYXNlIFwib25Nb3VzZU1vdmVDYXB0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJvbk1vdXNlVXBcIjpcbiAgICAgICAgY2FzZSBcIm9uTW91c2VVcENhcHR1cmVcIjpcbiAgICAgICAgY2FzZSBcIm9uTW91c2VFbnRlclwiOlxuICAgICAgICAgIChwcm9wcyA9ICFwcm9wcy5kaXNhYmxlZCkgfHxcbiAgICAgICAgICAgICgoaW5zdCA9IGluc3QudHlwZSksXG4gICAgICAgICAgICAocHJvcHMgPSAhKFxuICAgICAgICAgICAgICBcImJ1dHRvblwiID09PSBpbnN0IHx8XG4gICAgICAgICAgICAgIFwiaW5wdXRcIiA9PT0gaW5zdCB8fFxuICAgICAgICAgICAgICBcInNlbGVjdFwiID09PSBpbnN0IHx8XG4gICAgICAgICAgICAgIFwidGV4dGFyZWFcIiA9PT0gaW5zdFxuICAgICAgICAgICAgKSkpO1xuICAgICAgICAgIGluc3QgPSAhcHJvcHM7XG4gICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpbnN0ID0gITE7XG4gICAgICB9XG4gICAgICBpZiAoaW5zdCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoc3RhdGVOb2RlICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHN0YXRlTm9kZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCBgXCIgK1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9uTmFtZSArXG4gICAgICAgICAgICBcImAgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgXCIgK1xuICAgICAgICAgICAgdHlwZW9mIHN0YXRlTm9kZSArXG4gICAgICAgICAgICBcImAgdHlwZS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHN0YXRlTm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgICAgIGlmIChmYWxsYmFja1RleHQpIHJldHVybiBmYWxsYmFja1RleHQ7XG4gICAgICB2YXIgc3RhcnQsXG4gICAgICAgIHN0YXJ0VmFsdWUgPSBzdGFydFRleHQsXG4gICAgICAgIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGgsXG4gICAgICAgIGVuZCxcbiAgICAgICAgZW5kVmFsdWUgPSBcInZhbHVlXCIgaW4gcm9vdCA/IHJvb3QudmFsdWUgOiByb290LnRleHRDb250ZW50LFxuICAgICAgICBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG4gICAgICBmb3IgKFxuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIHN0YXJ0IDwgc3RhcnRMZW5ndGggJiYgc3RhcnRWYWx1ZVtzdGFydF0gPT09IGVuZFZhbHVlW3N0YXJ0XTtcbiAgICAgICAgc3RhcnQrK1xuICAgICAgKTtcbiAgICAgIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICAgICAgZm9yIChcbiAgICAgICAgZW5kID0gMTtcbiAgICAgICAgZW5kIDw9IG1pbkVuZCAmJlxuICAgICAgICBzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSA9PT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXTtcbiAgICAgICAgZW5kKytcbiAgICAgICk7XG4gICAgICByZXR1cm4gKGZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCAxIDwgZW5kID8gMSAtIGVuZCA6IHZvaWQgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gICAgICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG4gICAgICBcImNoYXJDb2RlXCIgaW4gbmF0aXZlRXZlbnRcbiAgICAgICAgPyAoKG5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQuY2hhckNvZGUpLFxuICAgICAgICAgIDAgPT09IG5hdGl2ZUV2ZW50ICYmIDEzID09PSBrZXlDb2RlICYmIChuYXRpdmVFdmVudCA9IDEzKSlcbiAgICAgICAgOiAobmF0aXZlRXZlbnQgPSBrZXlDb2RlKTtcbiAgICAgIDEwID09PSBuYXRpdmVFdmVudCAmJiAobmF0aXZlRXZlbnQgPSAxMyk7XG4gICAgICByZXR1cm4gMzIgPD0gbmF0aXZlRXZlbnQgfHwgMTMgPT09IG5hdGl2ZUV2ZW50ID8gbmF0aXZlRXZlbnQgOiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSgpIHtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTeW50aGV0aWNFdmVudChJbnRlcmZhY2UpIHtcbiAgICAgIGZ1bmN0aW9uIFN5bnRoZXRpY0Jhc2VFdmVudChcbiAgICAgICAgcmVhY3ROYW1lLFxuICAgICAgICByZWFjdEV2ZW50VHlwZSxcbiAgICAgICAgdGFyZ2V0SW5zdCxcbiAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fcmVhY3ROYW1lID0gcmVhY3ROYW1lO1xuICAgICAgICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgdGhpcy50eXBlID0gcmVhY3RFdmVudFR5cGU7XG4gICAgICAgIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKVxuICAgICAgICAgIEludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiZcbiAgICAgICAgICAgICgocmVhY3ROYW1lID0gSW50ZXJmYWNlW3Byb3BOYW1lXSksXG4gICAgICAgICAgICAodGhpc1twcm9wTmFtZV0gPSByZWFjdE5hbWVcbiAgICAgICAgICAgICAgPyByZWFjdE5hbWUobmF0aXZlRXZlbnQpXG4gICAgICAgICAgICAgIDogbmF0aXZlRXZlbnRbcHJvcE5hbWVdKSk7XG4gICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gKFxuICAgICAgICAgIG51bGwgIT0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICAgICAgICAgICAgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkXG4gICAgICAgICAgICA6ICExID09PSBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZVxuICAgICAgICApXG4gICAgICAgICAgPyBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZVxuICAgICAgICAgIDogZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGFzc2lnbihTeW50aGV0aWNCYXNlRXZlbnQucHJvdG90eXBlLCB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITA7XG4gICAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICAgICAgICBldmVudCAmJlxuICAgICAgICAgICAgKGV2ZW50LnByZXZlbnREZWZhdWx0XG4gICAgICAgICAgICAgID8gZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICA6IFwidW5rbm93blwiICE9PSB0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAoZXZlbnQucmV0dXJuVmFsdWUgPSAhMSksXG4gICAgICAgICAgICAodGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSkpO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgICAgICAgIGV2ZW50ICYmXG4gICAgICAgICAgICAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgID8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgOiBcInVua25vd25cIiAhPT0gdHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAmJlxuICAgICAgICAgICAgICAgIChldmVudC5jYW5jZWxCdWJibGUgPSAhMCksXG4gICAgICAgICAgICAodGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBpc1BlcnNpc3RlbnQ6IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTeW50aGV0aWNCYXNlRXZlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gICAgICB2YXIgbmF0aXZlRXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGVcbiAgICAgICAgPyBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZylcbiAgICAgICAgOiAoa2V5QXJnID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXSlcbiAgICAgICAgICA/ICEhbmF0aXZlRXZlbnRba2V5QXJnXVxuICAgICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgY2FzZSBcImtleXVwXCI6XG4gICAgICAgICAgcmV0dXJuIC0xICE9PSBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKTtcbiAgICAgICAgY2FzZSBcImtleWRvd25cIjpcbiAgICAgICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICAgICAgY2FzZSBcImtleXByZXNzXCI6XG4gICAgICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICAgICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICAgICAgbmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gICAgICByZXR1cm4gXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5hdGl2ZUV2ZW50ICYmIFwiZGF0YVwiIGluIG5hdGl2ZUV2ZW50XG4gICAgICAgID8gbmF0aXZlRXZlbnQuZGF0YVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgICAgICBjYXNlIFwia2V5cHJlc3NcIjpcbiAgICAgICAgICBpZiAobmF0aXZlRXZlbnQud2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHJldHVybiBudWxsO1xuICAgICAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSAhMDtcbiAgICAgICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcbiAgICAgICAgY2FzZSBcInRleHRJbnB1dFwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZG9tRXZlbnROYW1lID0gbmF0aXZlRXZlbnQuZGF0YSksXG4gICAgICAgICAgICBkb21FdmVudE5hbWUgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzc1xuICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgOiBkb21FdmVudE5hbWVcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKVxuICAgICAgICByZXR1cm4gXCJjb21wb3NpdGlvbmVuZFwiID09PSBkb21FdmVudE5hbWUgfHxcbiAgICAgICAgICAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiZcbiAgICAgICAgICAgIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSlcbiAgICAgICAgICA/ICgoZG9tRXZlbnROYW1lID0gZ2V0RGF0YSgpKSxcbiAgICAgICAgICAgIChmYWxsYmFja1RleHQgPSBzdGFydFRleHQgPSByb290ID0gbnVsbCksXG4gICAgICAgICAgICAoaXNDb21wb3NpbmcgPSAhMSksXG4gICAgICAgICAgICBkb21FdmVudE5hbWUpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgY2FzZSBcInBhc3RlXCI6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJrZXlwcmVzc1wiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHxcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnQuYWx0S2V5IHx8XG4gICAgICAgICAgICAgIG5hdGl2ZUV2ZW50Lm1ldGFLZXlcbiAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgIChuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIDEgPCBuYXRpdmVFdmVudC5jaGFyLmxlbmd0aClcbiAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgICAgICBpZiAobmF0aXZlRXZlbnQud2hpY2gpXG4gICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbmVuZFwiOlxuICAgICAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSAmJiBcImtvXCIgIT09IG5hdGl2ZUV2ZW50LmxvY2FsZVxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIFwiaW5wdXRcIiA9PT0gbm9kZU5hbWVcbiAgICAgICAgPyAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXVxuICAgICAgICA6IFwidGV4dGFyZWFcIiA9PT0gbm9kZU5hbWVcbiAgICAgICAgICA/ICEwXG4gICAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgpIHtcbiAgICAgIGlmICghY2FuVXNlRE9NKSByZXR1cm4gITE7XG4gICAgICBldmVudE5hbWVTdWZmaXggPSBcIm9uXCIgKyBldmVudE5hbWVTdWZmaXg7XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWVTdWZmaXggaW4gZG9jdW1lbnQ7XG4gICAgICBpc1N1cHBvcnRlZCB8fFxuICAgICAgICAoKGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSksXG4gICAgICAgIGlzU3VwcG9ydGVkLnNldEF0dHJpYnV0ZShldmVudE5hbWVTdWZmaXgsIFwicmV0dXJuO1wiKSxcbiAgICAgICAgKGlzU3VwcG9ydGVkID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaXNTdXBwb3J0ZWRbZXZlbnROYW1lU3VmZml4XSkpO1xuICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoXG4gICAgICBkaXNwYXRjaFF1ZXVlLFxuICAgICAgaW5zdCxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgdGFyZ2V0XG4gICAgKSB7XG4gICAgICByZXN0b3JlVGFyZ2V0XG4gICAgICAgID8gcmVzdG9yZVF1ZXVlXG4gICAgICAgICAgPyByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpXG4gICAgICAgICAgOiAocmVzdG9yZVF1ZXVlID0gW3RhcmdldF0pXG4gICAgICAgIDogKHJlc3RvcmVUYXJnZXQgPSB0YXJnZXQpO1xuICAgICAgaW5zdCA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhpbnN0LCBcIm9uQ2hhbmdlXCIpO1xuICAgICAgMCA8IGluc3QubGVuZ3RoICYmXG4gICAgICAgICgobmF0aXZlRXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoXG4gICAgICAgICAgXCJvbkNoYW5nZVwiLFxuICAgICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICB0YXJnZXRcbiAgICAgICAgKSksXG4gICAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7IGV2ZW50OiBuYXRpdmVFdmVudCwgbGlzdGVuZXJzOiBpbnN0IH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGRpc3BhdGNoUXVldWUpIHtcbiAgICAgIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKGRpc3BhdGNoUXVldWUsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCkge1xuICAgICAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpO1xuICAgICAgaWYgKHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKHRhcmdldE5vZGUpKSByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICAgICAgaWYgKFwiY2hhbmdlXCIgPT09IGRvbUV2ZW50TmFtZSkgcmV0dXJuIHRhcmdldEluc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICAgICAgYWN0aXZlRWxlbWVudCQxICYmXG4gICAgICAgIChhY3RpdmVFbGVtZW50JDEuZGV0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKSxcbiAgICAgICAgKGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBhY3RpdmVFbGVtZW50JDEgPSBudWxsKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gICAgICBpZiAoXG4gICAgICAgIFwidmFsdWVcIiA9PT0gbmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICYmXG4gICAgICAgIGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCQxKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBkaXNwYXRjaFF1ZXVlID0gW107XG4gICAgICAgIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChcbiAgICAgICAgICBkaXNwYXRjaFF1ZXVlLFxuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEsXG4gICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpXG4gICAgICAgICk7XG4gICAgICAgIGJhdGNoZWRVcGRhdGVzJDEocnVuRXZlbnRJbkJhdGNoLCBkaXNwYXRjaFF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKFxuICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGFyZ2V0SW5zdFxuICAgICkge1xuICAgICAgXCJmb2N1c2luXCIgPT09IGRvbUV2ZW50TmFtZVxuICAgICAgICA/IChzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpLFxuICAgICAgICAgIChhY3RpdmVFbGVtZW50JDEgPSB0YXJnZXQpLFxuICAgICAgICAgIChhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdCksXG4gICAgICAgICAgYWN0aXZlRWxlbWVudCQxLmF0dGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSkpXG4gICAgICAgIDogXCJmb2N1c291dFwiID09PSBkb21FdmVudE5hbWUgJiYgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbChkb21FdmVudE5hbWUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzZWxlY3Rpb25jaGFuZ2VcIiA9PT0gZG9tRXZlbnROYW1lIHx8XG4gICAgICAgIFwia2V5dXBcIiA9PT0gZG9tRXZlbnROYW1lIHx8XG4gICAgICAgIFwia2V5ZG93blwiID09PSBkb21FdmVudE5hbWVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCQxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gICAgICBpZiAoXCJjbGlja1wiID09PSBkb21FdmVudE5hbWUpIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gICAgICBpZiAoXCJpbnB1dFwiID09PSBkb21FdmVudE5hbWUgfHwgXCJjaGFuZ2VcIiA9PT0gZG9tRXZlbnROYW1lKVxuICAgICAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgICByZXR1cm4gKHggPT09IHkgJiYgKDAgIT09IHggfHwgMSAvIHggPT09IDEgLyB5KSkgfHwgKHggIT09IHggJiYgeSAhPT0geSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gICAgICBpZiAob2JqZWN0SXMob2JqQSwgb2JqQikpIHJldHVybiAhMDtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9iakEgfHxcbiAgICAgICAgbnVsbCA9PT0gb2JqQSB8fFxuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb2JqQiB8fFxuICAgICAgICBudWxsID09PSBvYmpCXG4gICAgICApXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpLFxuICAgICAgICBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICAgICAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICBmb3IgKGtleXNCID0gMDsga2V5c0IgPCBrZXlzQS5sZW5ndGg7IGtleXNCKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzQVtrZXlzQl07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBjdXJyZW50S2V5KSB8fFxuICAgICAgICAgICFvYmplY3RJcyhvYmpBW2N1cnJlbnRLZXldLCBvYmpCW2N1cnJlbnRLZXldKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gICAgICBmb3IgKDsgbm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQ7ICkgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICAgICAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgICAgIHJvb3QgPSAwO1xuICAgICAgZm9yICh2YXIgbm9kZUVuZDsgbm9kZTsgKSB7XG4gICAgICAgIGlmICgzID09PSBub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgbm9kZUVuZCA9IHJvb3QgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICBpZiAocm9vdCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBvZmZzZXQ6IG9mZnNldCAtIHJvb3QgfTtcbiAgICAgICAgICByb290ID0gbm9kZUVuZDtcbiAgICAgICAgfVxuICAgICAgICBhOiB7XG4gICAgICAgICAgZm9yICg7IG5vZGU7ICkge1xuICAgICAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBnZXRMZWFmTm9kZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gICAgICByZXR1cm4gb3V0ZXJOb2RlICYmIGlubmVyTm9kZVxuICAgICAgICA/IG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlXG4gICAgICAgICAgPyAhMFxuICAgICAgICAgIDogb3V0ZXJOb2RlICYmIDMgPT09IG91dGVyTm9kZS5ub2RlVHlwZVxuICAgICAgICAgICAgPyAhMVxuICAgICAgICAgICAgOiBpbm5lck5vZGUgJiYgMyA9PT0gaW5uZXJOb2RlLm5vZGVUeXBlXG4gICAgICAgICAgICAgID8gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgIDogXCJjb250YWluc1wiIGluIG91dGVyTm9kZVxuICAgICAgICAgICAgICAgID8gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSlcbiAgICAgICAgICAgICAgICA6IG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuICAgICAgICAgICAgICAgICAgPyAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KVxuICAgICAgICAgICAgICAgICAgOiAhMVxuICAgICAgICA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50RGVlcChjb250YWluZXJJbmZvKSB7XG4gICAgICBjb250YWluZXJJbmZvID1cbiAgICAgICAgbnVsbCAhPSBjb250YWluZXJJbmZvICYmXG4gICAgICAgIG51bGwgIT0gY29udGFpbmVySW5mby5vd25lckRvY3VtZW50ICYmXG4gICAgICAgIG51bGwgIT0gY29udGFpbmVySW5mby5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3XG4gICAgICAgICAgPyBjb250YWluZXJJbmZvLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXdcbiAgICAgICAgICA6IHdpbmRvdztcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudChjb250YWluZXJJbmZvLmRvY3VtZW50KTtcbiAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIGNvbnRhaW5lckluZm8uSFRNTElGcmFtZUVsZW1lbnQ7XG5cbiAgICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVsZW1lbnQuY29udGVudFdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSBjb250YWluZXJJbmZvID0gZWxlbWVudC5jb250ZW50V2luZG93O1xuICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudChjb250YWluZXJJbmZvLmRvY3VtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZWxlbSkge1xuICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG5vZGVOYW1lICYmXG4gICAgICAgICgoXCJpbnB1dFwiID09PSBub2RlTmFtZSAmJlxuICAgICAgICAgIChcInRleHRcIiA9PT0gZWxlbS50eXBlIHx8XG4gICAgICAgICAgICBcInNlYXJjaFwiID09PSBlbGVtLnR5cGUgfHxcbiAgICAgICAgICAgIFwidGVsXCIgPT09IGVsZW0udHlwZSB8fFxuICAgICAgICAgICAgXCJ1cmxcIiA9PT0gZWxlbS50eXBlIHx8XG4gICAgICAgICAgICBcInBhc3N3b3JkXCIgPT09IGVsZW0udHlwZSkpIHx8XG4gICAgICAgICAgXCJ0ZXh0YXJlYVwiID09PSBub2RlTmFtZSB8fFxuICAgICAgICAgIFwidHJ1ZVwiID09PSBlbGVtLmNvbnRlbnRFZGl0YWJsZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KFxuICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICApIHtcbiAgICAgIHZhciBkb2MgPVxuICAgICAgICBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgPyBuYXRpdmVFdmVudFRhcmdldC5kb2N1bWVudFxuICAgICAgICAgIDogOSA9PT0gbmF0aXZlRXZlbnRUYXJnZXQubm9kZVR5cGVcbiAgICAgICAgICAgID8gbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgIDogbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIG1vdXNlRG93biB8fFxuICAgICAgICBudWxsID09IGFjdGl2ZUVsZW1lbnQgfHxcbiAgICAgICAgYWN0aXZlRWxlbWVudCAhPT0gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHx8XG4gICAgICAgICgoZG9jID0gYWN0aXZlRWxlbWVudCksXG4gICAgICAgIFwic2VsZWN0aW9uU3RhcnRcIiBpbiBkb2MgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGRvYylcbiAgICAgICAgICA/IChkb2MgPSB7IHN0YXJ0OiBkb2Muc2VsZWN0aW9uU3RhcnQsIGVuZDogZG9jLnNlbGVjdGlvbkVuZCB9KVxuICAgICAgICAgIDogKChkb2MgPSAoXG4gICAgICAgICAgICAgIChkb2Mub3duZXJEb2N1bWVudCAmJiBkb2Mub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHxcbiAgICAgICAgICAgICAgd2luZG93XG4gICAgICAgICAgICApLmdldFNlbGVjdGlvbigpKSxcbiAgICAgICAgICAgIChkb2MgPSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGU6IGRvYy5hbmNob3JOb2RlLFxuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQ6IGRvYy5hbmNob3JPZmZzZXQsXG4gICAgICAgICAgICAgIGZvY3VzTm9kZTogZG9jLmZvY3VzTm9kZSxcbiAgICAgICAgICAgICAgZm9jdXNPZmZzZXQ6IGRvYy5mb2N1c09mZnNldFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAobGFzdFNlbGVjdGlvbiAmJiBzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgZG9jKSkgfHxcbiAgICAgICAgICAoKGxhc3RTZWxlY3Rpb24gPSBkb2MpLFxuICAgICAgICAgIChkb2MgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoYWN0aXZlRWxlbWVudEluc3QsIFwib25TZWxlY3RcIikpLFxuICAgICAgICAgIDAgPCBkb2MubGVuZ3RoICYmXG4gICAgICAgICAgICAoKG5hdGl2ZUV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KFxuICAgICAgICAgICAgICBcIm9uU2VsZWN0XCIsXG4gICAgICAgICAgICAgIFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goeyBldmVudDogbmF0aXZlRXZlbnQsIGxpc3RlbmVyczogZG9jIH0pLFxuICAgICAgICAgICAgKG5hdGl2ZUV2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQpKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gICAgICB2YXIgcHJlZml4ZXMgPSB7fTtcbiAgICAgIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcHJlZml4ZXNbXCJXZWJraXRcIiArIHN0eWxlUHJvcF0gPSBcIndlYmtpdFwiICsgZXZlbnROYW1lO1xuICAgICAgcHJlZml4ZXNbXCJNb3pcIiArIHN0eWxlUHJvcF0gPSBcIm1velwiICsgZXZlbnROYW1lO1xuICAgICAgcmV0dXJuIHByZWZpeGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgICAgIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICAgICAgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSByZXR1cm4gZXZlbnROYW1lO1xuICAgICAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0sXG4gICAgICAgIHN0eWxlUHJvcDtcbiAgICAgIGZvciAoc3R5bGVQcm9wIGluIHByZWZpeE1hcClcbiAgICAgICAgaWYgKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApICYmIHN0eWxlUHJvcCBpbiBzdHlsZSlcbiAgICAgICAgICByZXR1cm4gKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF0pO1xuICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJTaW1wbGVFdmVudChkb21FdmVudE5hbWUsIHJlYWN0TmFtZSkge1xuICAgICAgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuc2V0KGRvbUV2ZW50TmFtZSwgcmVhY3ROYW1lKTtcbiAgICAgIHJlZ2lzdGVyVHdvUGhhc2VFdmVudChyZWFjdE5hbWUsIFtkb21FdmVudE5hbWVdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZSkge1xuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBDYXB0dXJlZFN0YWNrcy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAodm9pZCAwICE9PSBleGlzdGluZykgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICAgICAgICB9O1xuICAgICAgICBDYXB0dXJlZFN0YWNrcy5zZXQodmFsdWUsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgZW5kSW5kZXggPSBjb25jdXJyZW50UXVldWVzSW5kZXgsXG4gICAgICAgICAgaSA9IChjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSBjb25jdXJyZW50UXVldWVzSW5kZXggPSAwKTtcbiAgICAgICAgaSA8IGVuZEluZGV4O1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgdmFyIHF1ZXVlID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIHZhciBsYW5lID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IHF1ZXVlICYmIG51bGwgIT09IHVwZGF0ZSkge1xuICAgICAgICAgIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcbiAgICAgICAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgICAgIDogKCh1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dCksIChwZW5kaW5nLm5leHQgPSB1cGRhdGUpKTtcbiAgICAgICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIDAgIT09IGxhbmUgJiYgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBmaWJlcjtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gcXVldWU7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHVwZGF0ZTtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gbGFuZTtcbiAgICAgIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyB8PSBsYW5lO1xuICAgICAgZmliZXIubGFuZXMgfD0gbGFuZTtcbiAgICAgIGZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gZmliZXIgJiYgKGZpYmVyLmxhbmVzIHw9IGxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSkge1xuICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBudWxsLCBudWxsLCBsYW5lKTtcbiAgICAgIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qoc291cmNlRmliZXIsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgc291cmNlRmliZXIubGFuZXMgfD0gbGFuZTtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5sYW5lcyB8PSBsYW5lKTtcbiAgICAgIGZvciAodmFyIGlzSGlkZGVuID0gITEsIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgICAgIChwYXJlbnQuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAoYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAyMiA9PT0gcGFyZW50LnRhZyAmJlxuICAgICAgICAgICAgKChzb3VyY2VGaWJlciA9IHBhcmVudC5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXIgfHxcbiAgICAgICAgICAgICAgc291cmNlRmliZXIuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5WaXNpYmxlIHx8XG4gICAgICAgICAgICAgIChpc0hpZGRlbiA9ICEwKSksXG4gICAgICAgICAgKHNvdXJjZUZpYmVyID0gcGFyZW50KSxcbiAgICAgICAgICAocGFyZW50ID0gcGFyZW50LnJldHVybik7XG4gICAgICByZXR1cm4gMyA9PT0gc291cmNlRmliZXIudGFnXG4gICAgICAgID8gKChwYXJlbnQgPSBzb3VyY2VGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgICAgICBudWxsICE9PSB1cGRhdGUgJiZcbiAgICAgICAgICAgICgoaXNIaWRkZW4gPSAzMSAtIGNsejMyKGxhbmUpKSxcbiAgICAgICAgICAgIChzb3VyY2VGaWJlciA9IHBhcmVudC5oaWRkZW5VcGRhdGVzKSxcbiAgICAgICAgICAgIChhbHRlcm5hdGUgPSBzb3VyY2VGaWJlcltpc0hpZGRlbl0pLFxuICAgICAgICAgICAgbnVsbCA9PT0gYWx0ZXJuYXRlXG4gICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyW2lzSGlkZGVuXSA9IFt1cGRhdGVdKVxuICAgICAgICAgICAgICA6IGFsdGVybmF0ZS5wdXNoKHVwZGF0ZSksXG4gICAgICAgICAgICAodXBkYXRlLmxhbmUgPSBsYW5lIHwgNTM2ODcwOTEyKSksXG4gICAgICAgICAgcGFyZW50KVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoc291cmNlRmliZXIpIHtcbiAgICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpXG4gICAgICAgIHRocm93IChcbiAgICAgICAgICAoKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IG5lc3RlZFVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsKSxcbiAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgIFwiTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IHJlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlwiXG4gICAgICAgICAgKSlcbiAgICAgICAgKTtcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA+IE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCAmJlxuICAgICAgICAoKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAocm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGwpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IGNhbGxzIHNldFN0YXRlIGluc2lkZSB1c2VFZmZlY3QsIGJ1dCB1c2VFZmZlY3QgZWl0aGVyIGRvZXNuJ3QgaGF2ZSBhIGRlcGVuZGVuY3kgYXJyYXksIG9yIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMgb24gZXZlcnkgcmVuZGVyLlwiXG4gICAgICAgICkpO1xuICAgICAgbnVsbCA9PT0gc291cmNlRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgIDAgIT09IChzb3VyY2VGaWJlci5mbGFncyAmIDQwOTgpICYmXG4gICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpO1xuICAgICAgZm9yICh2YXIgbm9kZSA9IHNvdXJjZUZpYmVyLCBwYXJlbnQgPSBub2RlLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgICAgIG51bGwgPT09IG5vZGUuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgMCAhPT0gKG5vZGUuZmxhZ3MgJiA0MDk4KSAmJlxuICAgICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpLFxuICAgICAgICAgIChub2RlID0gcGFyZW50KSxcbiAgICAgICAgICAocGFyZW50ID0gbm9kZS5yZXR1cm4pO1xuICAgICAgcmV0dXJuIDMgPT09IG5vZGUudGFnID8gbm9kZS5zdGF0ZU5vZGUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpIHJldHVybiB0eXBlO1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBmYW1pbHkgPyB0eXBlIDogZmFtaWx5LmN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gdHlwZTtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZmFtaWx5XG4gICAgICAgID8gbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUucmVuZGVyICYmXG4gICAgICAgICAgKChmYW1pbHkgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZS5yZW5kZXIpKSxcbiAgICAgICAgICB0eXBlLnJlbmRlciAhPT0gZmFtaWx5KVxuICAgICAgICAgID8gKChmYW1pbHkgPSB7ICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLCByZW5kZXI6IGZhbWlseSB9KSxcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAoZmFtaWx5LmRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSksXG4gICAgICAgICAgICBmYW1pbHkpXG4gICAgICAgICAgOiB0eXBlXG4gICAgICAgIDogZmFtaWx5LmN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlciwgZWxlbWVudCkge1xuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpIHJldHVybiAhMTtcbiAgICAgIHZhciBwcmV2VHlwZSA9IGZpYmVyLmVsZW1lbnRUeXBlO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQudHlwZTtcbiAgICAgIHZhciBuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICExLFxuICAgICAgICAkJHR5cGVvZk5leHRUeXBlID1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudCAmJiBudWxsICE9PSBlbGVtZW50XG4gICAgICAgICAgICA/IGVsZW1lbnQuJCR0eXBlb2ZcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlbGVtZW50ICYmIChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGVsZW1lbnRcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRVxuICAgICAgICAgICAgPyAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMClcbiAgICAgICAgICAgIDogJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgIChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9NRU1PX1RZUEVcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5lZWRzQ29tcGFyZUZhbWlsaWVzICYmXG4gICAgICAgICgoZmliZXIgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKSksXG4gICAgICAgIHZvaWQgMCAhPT0gZmliZXIgJiYgZmliZXIgPT09IHJlc29sdmVGYW1pbHkoZWxlbWVudCkpXG4gICAgICAgID8gITBcbiAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpIHtcbiAgICAgIG51bGwgIT09IHJlc29sdmVGYW1pbHkgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha1NldCAmJlxuICAgICAgICAobnVsbCA9PT0gZmFpbGVkQm91bmRhcmllcyAmJiAoZmFpbGVkQm91bmRhcmllcyA9IG5ldyBXZWFrU2V0KCkpLFxuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgZmliZXIsXG4gICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICBzdGFsZUZhbWlsaWVzXG4gICAgKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlLFxuICAgICAgICBjaGlsZCA9IGZpYmVyLmNoaWxkLFxuICAgICAgICBzaWJsaW5nID0gZmliZXIuc2libGluZyxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZSxcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IG51bGw7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCA9PT0gcmVzb2x2ZUZhbWlseSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC5cIik7XG4gICAgICB2YXIgbmVlZHNSZW5kZXIgPSAhMTtcbiAgICAgIHR5cGUgPSAhMTtcbiAgICAgIG51bGwgIT09IGNhbmRpZGF0ZVR5cGUgJiZcbiAgICAgICAgKChjYW5kaWRhdGVUeXBlID0gcmVzb2x2ZUZhbWlseShjYW5kaWRhdGVUeXBlKSksXG4gICAgICAgIHZvaWQgMCAhPT0gY2FuZGlkYXRlVHlwZSAmJlxuICAgICAgICAgIChzdGFsZUZhbWlsaWVzLmhhcyhjYW5kaWRhdGVUeXBlKVxuICAgICAgICAgICAgPyAodHlwZSA9ICEwKVxuICAgICAgICAgICAgOiB1cGRhdGVkRmFtaWxpZXMuaGFzKGNhbmRpZGF0ZVR5cGUpICYmXG4gICAgICAgICAgICAgICgxID09PSB0YWcgPyAodHlwZSA9ICEwKSA6IChuZWVkc1JlbmRlciA9ICEwKSkpKTtcbiAgICAgIG51bGwgIT09IGZhaWxlZEJvdW5kYXJpZXMgJiZcbiAgICAgICAgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fFxuICAgICAgICAgIChudWxsICE9PSBhbHRlcm5hdGUgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoYWx0ZXJuYXRlKSkpICYmXG4gICAgICAgICh0eXBlID0gITApO1xuICAgICAgdHlwZSAmJiAoZmliZXIuX2RlYnVnTmVlZHNSZW1vdW50ID0gITApO1xuICAgICAgaWYgKHR5cGUgfHwgbmVlZHNSZW5kZXIpXG4gICAgICAgIChhbHRlcm5hdGUgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGFsdGVybmF0ZSwgZmliZXIsIDIpO1xuICAgICAgbnVsbCA9PT0gY2hpbGQgfHxcbiAgICAgICAgdHlwZSB8fFxuICAgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIHVwZGF0ZWRGYW1pbGllcyxcbiAgICAgICAgICBzdGFsZUZhbWlsaWVzXG4gICAgICAgICk7XG4gICAgICBudWxsICE9PSBzaWJsaW5nICYmXG4gICAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoXG4gICAgICAgICAgc2libGluZyxcbiAgICAgICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICAgICAgc3RhbGVGYW1pbGllc1xuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuc2libGluZyA9XG4gICAgICAgIHRoaXMuY2hpbGQgPVxuICAgICAgICB0aGlzLnJldHVybiA9XG4gICAgICAgIHRoaXMuc3RhdGVOb2RlID1cbiAgICAgICAgdGhpcy50eXBlID1cbiAgICAgICAgdGhpcy5lbGVtZW50VHlwZSA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgdGhpcy5yZWZDbGVhbnVwID0gdGhpcy5yZWYgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcyA9XG4gICAgICAgIHRoaXMubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgIHRoaXMudXBkYXRlUXVldWUgPVxuICAgICAgICB0aGlzLm1lbW9pemVkUHJvcHMgPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5zdWJ0cmVlRmxhZ3MgPSB0aGlzLmZsYWdzID0gMDtcbiAgICAgIHRoaXMuZGVsZXRpb25zID0gbnVsbDtcbiAgICAgIHRoaXMuY2hpbGRMYW5lcyA9IHRoaXMubGFuZXMgPSAwO1xuICAgICAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IC0wO1xuICAgICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMS4xO1xuICAgICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gLTA7XG4gICAgICB0aGlzLl9kZWJ1Z1Rhc2sgPVxuICAgICAgICB0aGlzLl9kZWJ1Z1N0YWNrID1cbiAgICAgICAgdGhpcy5fZGVidWdPd25lciA9XG4gICAgICAgIHRoaXMuX2RlYnVnSW5mbyA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gITE7XG4gICAgICB0aGlzLl9kZWJ1Z0hvb2tUeXBlcyA9IG51bGw7XG4gICAgICBoYXNCYWRNYXBQb2x5ZmlsbCB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgfHxcbiAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gICAgICBDb21wb25lbnQgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEoIUNvbXBvbmVudCB8fCAhQ29tcG9uZW50LmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBwZW5kaW5nUHJvcHMpIHtcbiAgICAgIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoXG4gICAgICAgICAgICBjdXJyZW50LnRhZyxcbiAgICAgICAgICAgIHBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIGN1cnJlbnQua2V5LFxuICAgICAgICAgICAgY3VycmVudC5tb2RlXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lciksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z1N0YWNrID0gY3VycmVudC5fZGVidWdTdGFjayksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z1Rhc2sgPSBjdXJyZW50Ll9kZWJ1Z1Rhc2spLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQpLFxuICAgICAgICAgIChjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzKSlcbiAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gLTApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMS4xKSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGN1cnJlbnQuZmxhZ3MgJiA2NTAxMTcxMjtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHBlbmRpbmdQcm9wcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCA9PT0gcGVuZGluZ1Byb3BzXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIGxhbmVzOiBwZW5kaW5nUHJvcHMubGFuZXMsXG4gICAgICAgICAgICAgIGZpcnN0Q29udGV4dDogcGVuZGluZ1Byb3BzLmZpcnN0Q29udGV4dCxcbiAgICAgICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogcGVuZGluZ1Byb3BzLl9kZWJ1Z1RoZW5hYmxlU3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5yZWZDbGVhbnVwID0gY3VycmVudC5yZWZDbGVhbnVwO1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvID0gY3VycmVudC5fZGVidWdJbmZvO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ID0gY3VycmVudC5fZGVidWdOZWVkc1JlbW91bnQ7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gNjUwMTE3MTQ7XG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSAwKSlcbiAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAgICAgKHJlbmRlckxhbmVzID0gY3VycmVudC5kZXBlbmRlbmNpZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPVxuICAgICAgICAgICAgbnVsbCA9PT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgbGFuZXM6IHJlbmRlckxhbmVzLmxhbmVzLFxuICAgICAgICAgICAgICAgICAgZmlyc3RDb250ZXh0OiByZW5kZXJMYW5lcy5maXJzdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICBfZGVidWdUaGVuYWJsZVN0YXRlOiByZW5kZXJMYW5lcy5fZGVidWdUaGVuYWJsZVN0YXRlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb24pLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICBvd25lcixcbiAgICAgIG1vZGUsXG4gICAgICBsYW5lc1xuICAgICkge1xuICAgICAgdmFyIGZpYmVyVGFnID0gMCxcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gdHlwZTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiYgKGZpYmVyVGFnID0gMSksXG4gICAgICAgICAgKHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpKTtcbiAgICAgIGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICAoZmliZXJUYWcgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAoZmliZXJUYWcgPSBpc0hvc3RIb2lzdGFibGVUeXBlKHR5cGUsIHBlbmRpbmdQcm9wcywgZmliZXJUYWcpXG4gICAgICAgICAgICA/IDI2XG4gICAgICAgICAgICA6IFwiaHRtbFwiID09PSB0eXBlIHx8IFwiaGVhZFwiID09PSB0eXBlIHx8IFwiYm9keVwiID09PSB0eXBlXG4gICAgICAgICAgICAgID8gMjdcbiAgICAgICAgICAgICAgOiA1KTtcbiAgICAgIGVsc2VcbiAgICAgICAgYTogc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IGNyZWF0ZUZpYmVyKDMxLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkpLFxuICAgICAgICAgICAgICAoa2V5LmVsZW1lbnRUeXBlID0gUkVBQ1RfQUNUSVZJVFlfVFlQRSksXG4gICAgICAgICAgICAgIChrZXkubGFuZXMgPSBsYW5lcyksXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgIHBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgICBmaWJlclRhZyA9IDg7XG4gICAgICAgICAgICBtb2RlIHw9IFN0cmljdExlZ2FjeU1vZGU7XG4gICAgICAgICAgICBtb2RlIHw9IFN0cmljdEVmZmVjdHNNb2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHR5cGUgPSBwZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgICAob3duZXIgPSBtb2RlKSxcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHR5cGUuaWQgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgb2YgdHlwZSBgc3RyaW5nYCBhcyBhIHByb3AuIFJlY2VpdmVkIHRoZSB0eXBlIGAlc2AgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHR5cGUuaWRcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoa2V5ID0gY3JlYXRlRmliZXIoMTIsIHR5cGUsIGtleSwgb3duZXIgfCBQcm9maWxlTW9kZSkpLFxuICAgICAgICAgICAgICAoa2V5LmVsZW1lbnRUeXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRSksXG4gICAgICAgICAgICAgIChrZXkubGFuZXMgPSBsYW5lcyksXG4gICAgICAgICAgICAgIChrZXkuc3RhdGVOb2RlID0geyBlZmZlY3REdXJhdGlvbjogMCwgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiAwIH0pLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IGNyZWF0ZUZpYmVyKDEzLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkpLFxuICAgICAgICAgICAgICAoa2V5LmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRSksXG4gICAgICAgICAgICAgIChrZXkubGFuZXMgPSBsYW5lcyksXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxOSwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpKSxcbiAgICAgICAgICAgICAgKGtleS5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSksXG4gICAgICAgICAgICAgIChrZXkubGFuZXMgPSBsYW5lcyksXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmIG51bGwgIT09IHR5cGUpXG4gICAgICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gMTA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDE2O1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gdHlwZSB8fFxuICAgICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAgICAgMCA9PT0gT2JqZWN0LmtleXModHlwZSkubGVuZ3RoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgKz1cbiAgICAgICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgICAgICBudWxsID09PSB0eXBlXG4gICAgICAgICAgICAgID8gKHBlbmRpbmdQcm9wcyA9IFwibnVsbFwiKVxuICAgICAgICAgICAgICA6IGlzQXJyYXlJbXBsKHR5cGUpXG4gICAgICAgICAgICAgICAgPyAocGVuZGluZ1Byb3BzID0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICAgICAgPyAoKHBlbmRpbmdQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgICAgIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIlVua25vd25cIikgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgICAgICAocmVzb2x2ZWRUeXBlID1cbiAgICAgICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgICAgIDogKHBlbmRpbmdQcm9wcyA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgICAgIChmaWJlclRhZyA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZUZyb21Pd25lcihvd25lcikgOiBudWxsKSAmJlxuICAgICAgICAgICAgICAocmVzb2x2ZWRUeXBlICs9XG4gICAgICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBmaWJlclRhZyArIFwiYC5cIik7XG4gICAgICAgICAgICBmaWJlclRhZyA9IDI5O1xuICAgICAgICAgICAgcGVuZGluZ1Byb3BzID0gRXJyb3IoXG4gICAgICAgICAgICAgIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgKHBlbmRpbmdQcm9wcyArIFwiLlwiICsgcmVzb2x2ZWRUeXBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIGtleSA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gICAgICBrZXkuZWxlbWVudFR5cGUgPSB0eXBlO1xuICAgICAga2V5LnR5cGUgPSByZXNvbHZlZFR5cGU7XG4gICAgICBrZXkubGFuZXMgPSBsYW5lcztcbiAgICAgIGtleS5fZGVidWdPd25lciA9IG93bmVyO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBtb2RlLCBsYW5lcykge1xuICAgICAgbW9kZSA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgICAgZWxlbWVudC50eXBlLFxuICAgICAgICBlbGVtZW50LmtleSxcbiAgICAgICAgZWxlbWVudC5wcm9wcyxcbiAgICAgICAgZWxlbWVudC5fb3duZXIsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGxhbmVzXG4gICAgICApO1xuICAgICAgbW9kZS5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgbW9kZS5fZGVidWdTdGFjayA9IGVsZW1lbnQuX2RlYnVnU3RhY2s7XG4gICAgICBtb2RlLl9kZWJ1Z1Rhc2sgPSBlbGVtZW50Ll9kZWJ1Z1Rhc2s7XG4gICAgICByZXR1cm4gbW9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgICAgIGVsZW1lbnRzID0gY3JlYXRlRmliZXIoNywgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gICAgICBlbGVtZW50cy5sYW5lcyA9IGxhbmVzO1xuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIG1vZGUsIGxhbmVzKSB7XG4gICAgICBjb250ZW50ID0gY3JlYXRlRmliZXIoNiwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gICAgICBjb250ZW50LmxhbmVzID0gbGFuZXM7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgbW9kZSwgbGFuZXMpIHtcbiAgICAgIG1vZGUgPSBjcmVhdGVGaWJlcihcbiAgICAgICAgNCxcbiAgICAgICAgbnVsbCAhPT0gcG9ydGFsLmNoaWxkcmVuID8gcG9ydGFsLmNoaWxkcmVuIDogW10sXG4gICAgICAgIHBvcnRhbC5rZXksXG4gICAgICAgIG1vZGVcbiAgICAgICk7XG4gICAgICBtb2RlLmxhbmVzID0gbGFuZXM7XG4gICAgICBtb2RlLnN0YXRlTm9kZSA9IHtcbiAgICAgICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICAgICAgfTtcbiAgICAgIHJldHVybiBtb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4pIHtcbiAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICAgICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtDb3VudDtcbiAgICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrUHJvdmlkZXI7XG4gICAgICB0cmVlRm9ya1Byb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB0cmVlRm9ya0NvdW50ID0gdG90YWxDaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbiwgaW5kZXgpIHtcbiAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICAgICAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkO1xuICAgICAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICAgICAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyO1xuICAgICAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgICAgIHZhciBiYXNlTGVuZ3RoID0gMzIgLSBjbHozMihiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJj0gfigxIDw8IGJhc2VMZW5ndGgpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIHZhciBsZW5ndGggPSAzMiAtIGNsejMyKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDtcbiAgICAgIGlmICgzMCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgbnVtYmVyT2ZPdmVyZmxvd0JpdHMgPSBiYXNlTGVuZ3RoIC0gKGJhc2VMZW5ndGggJSA1KTtcbiAgICAgICAgbGVuZ3RoID0gKFxuICAgICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ICZcbiAgICAgICAgICAoKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMSlcbiAgICAgICAgKS50b1N0cmluZygzMik7XG4gICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ID4+PSBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICAgICAgYmFzZUxlbmd0aCAtPSBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICAgICAgdHJlZUNvbnRleHRJZCA9XG4gICAgICAgICAgKDEgPDwgKDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoKSkgfFxuICAgICAgICAgIChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8XG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQ7XG4gICAgICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBsZW5ndGggKyB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH0gZWxzZVxuICAgICAgICAodHJlZUNvbnRleHRJZCA9XG4gICAgICAgICAgKDEgPDwgbGVuZ3RoKSB8IChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8IGJhc2VJZFdpdGhMZWFkaW5nQml0KSxcbiAgICAgICAgICAodHJlZUNvbnRleHRPdmVyZmxvdyA9IHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm4gJiZcbiAgICAgICAgKHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgMSksIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIDEsIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGZvciAoOyB3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUZvcmtQcm92aWRlcjsgKVxuICAgICAgICAodHJlZUZvcmtQcm92aWRlciA9IGZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XSksXG4gICAgICAgICAgKGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICAgICAodHJlZUZvcmtDb3VudCA9IGZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XSksXG4gICAgICAgICAgKGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsKTtcbiAgICAgIGZvciAoOyB3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUNvbnRleHRQcm92aWRlcjsgKVxuICAgICAgICAodHJlZUNvbnRleHRQcm92aWRlciA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgICAgICh0cmVlQ29udGV4dElkID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybklmTm90SHlkcmF0aW5nKCkge1xuICAgICAgaXNIeWRyYXRpbmcgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHRvIGJlIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgZGlzdGFuY2VGcm9tTGVhZikge1xuICAgICAgaWYgKG51bGwgPT09IGZpYmVyLnJldHVybikge1xuICAgICAgICBpZiAobnVsbCA9PT0gaHlkcmF0aW9uRGlmZlJvb3RERVYpXG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSB7XG4gICAgICAgICAgICBmaWJlcjogZmliZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICAgICAgc2VydmVyVGFpbDogW10sXG4gICAgICAgICAgICBkaXN0YW5jZUZyb21MZWFmOiBkaXN0YW5jZUZyb21MZWFmXG4gICAgICAgICAgfTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGh5ZHJhdGlvbkRpZmZSb290REVWLmZpYmVyICE9PSBmaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlNhdyBtdWx0aXBsZSBoeWRyYXRpb24gZGlmZiByb290cyBpbiBhIHBhc3MuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFVi5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgfVxuICAgICAgdmFyIHNpYmxpbmdzID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShcbiAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICBkaXN0YW5jZUZyb21MZWFmICsgMVxuICAgICAgKS5jaGlsZHJlbjtcbiAgICAgIGlmICgwIDwgc2libGluZ3MubGVuZ3RoICYmIHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdLmZpYmVyID09PSBmaWJlcilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoc2libGluZ3MgPSBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXSksXG4gICAgICAgICAgc2libGluZ3MuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChzaWJsaW5ncy5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZiksXG4gICAgICAgICAgc2libGluZ3NcbiAgICAgICAgKTtcbiAgICAgIGRpc3RhbmNlRnJvbUxlYWYgPSB7XG4gICAgICAgIGZpYmVyOiBmaWJlcixcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICAgICAgZGlzdGFuY2VGcm9tTGVhZjogZGlzdGFuY2VGcm9tTGVhZlxuICAgICAgfTtcbiAgICAgIHNpYmxpbmdzLnB1c2goZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICByZXR1cm4gZGlzdGFuY2VGcm9tTGVhZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsIHJlamVjdGVkQ2FuZGlkYXRlKSB7XG4gICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViB8fFxuICAgICAgICAoKGZpYmVyID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCkpLFxuICAgICAgICAoZmliZXIuc2VydmVyUHJvcHMgPSBudWxsKSxcbiAgICAgICAgbnVsbCAhPT0gcmVqZWN0ZWRDYW5kaWRhdGUgJiZcbiAgICAgICAgICAoKHJlamVjdGVkQ2FuZGlkYXRlID1cbiAgICAgICAgICAgIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MocmVqZWN0ZWRDYW5kaWRhdGUpKSxcbiAgICAgICAgICBmaWJlci5zZXJ2ZXJUYWlsLnB1c2gocmVqZWN0ZWRDYW5kaWRhdGUpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcikge1xuICAgICAgdmFyIGZyb21UZXh0ID1cbiAgICAgICAgICAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6ICExLFxuICAgICAgICBkaWZmID0gXCJcIixcbiAgICAgICAgZGlmZlJvb3QgPSBoeWRyYXRpb25EaWZmUm9vdERFVjtcbiAgICAgIG51bGwgIT09IGRpZmZSb290ICYmXG4gICAgICAgICgoaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsKSwgKGRpZmYgPSBkZXNjcmliZURpZmYoZGlmZlJvb3QpKSk7XG4gICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKFxuICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgIFwiSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgXCIgK1xuICAgICAgICAgICAgICAoZnJvbVRleHQgPyBcInRleHRcIiA6IFwiSFRNTFwiKSArXG4gICAgICAgICAgICAgIFwiIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50LiBBcyBhIHJlc3VsdCB0aGlzIHRyZWUgd2lsbCBiZSByZWdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcblxcbi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuLSBWYXJpYWJsZSBpbnB1dCBzdWNoIGFzIGBEYXRlLm5vdygpYCBvciBgTWF0aC5yYW5kb20oKWAgd2hpY2ggY2hhbmdlcyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuXFxuLSBEYXRlIGZvcm1hdHRpbmcgaW4gYSB1c2VyJ3MgbG9jYWxlIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggdGhlIHNlcnZlci5cXG4tIEV4dGVybmFsIGNoYW5naW5nIGRhdGEgd2l0aG91dCBzZW5kaW5nIGEgc25hcHNob3Qgb2YgaXQgYWxvbmcgd2l0aCB0aGUgSFRNTC5cXG4tIEludmFsaWQgSFRNTCB0YWcgbmVzdGluZy5cXG5cXG5JdCBjYW4gYWxzbyBoYXBwZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBicm93c2VyIGV4dGVuc2lvbiBpbnN0YWxsZWQgd2hpY2ggbWVzc2VzIHdpdGggdGhlIEhUTUwgYmVmb3JlIFJlYWN0IGxvYWRlZC5cXG5cXG5odHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaFwiICtcbiAgICAgICAgICAgICAgZGlmZlxuICAgICAgICAgICksXG4gICAgICAgICAgZmliZXJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRocm93IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyKSB7XG4gICAgICB2YXIgZGlkSHlkcmF0ZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZSxcbiAgICAgICAgcHJvcHMgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgZGlkSHlkcmF0ZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGZpYmVyO1xuICAgICAgZGlkSHlkcmF0ZVtpbnRlcm5hbFByb3BzS2V5XSA9IHByb3BzO1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0eXBlLCBwcm9wcyk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImRpYWxvZ1wiOlxuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJjYW5jZWxcIiwgZGlkSHlkcmF0ZSk7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImNsb3NlXCIsIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaWZyYW1lXCI6XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgY2FzZSBcImVtYmVkXCI6XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImxvYWRcIiwgZGlkSHlkcmF0ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2aWRlb1wiOlxuICAgICAgICBjYXNlIFwiYXVkaW9cIjpcbiAgICAgICAgICBmb3IgKHR5cGUgPSAwOyB0eXBlIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgdHlwZSsrKVxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbdHlwZV0sIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImVycm9yXCIsIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBkaWRIeWRyYXRlKTtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwibG9hZFwiLCBkaWRIeWRyYXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRldGFpbHNcIjpcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwidG9nZ2xlXCIsIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwiaW5wdXRcIiwgcHJvcHMpO1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJpbnZhbGlkXCIsIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIHZhbGlkYXRlSW5wdXRQcm9wcyhkaWRIeWRyYXRlLCBwcm9wcyk7XG4gICAgICAgICAgaW5pdElucHV0KFxuICAgICAgICAgICAgZGlkSHlkcmF0ZSxcbiAgICAgICAgICAgIHByb3BzLnZhbHVlLFxuICAgICAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCxcbiAgICAgICAgICAgIHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgICAgICAgICAgcHJvcHMudHlwZSxcbiAgICAgICAgICAgIHByb3BzLm5hbWUsXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICAgICAgdHJhY2soZGlkSHlkcmF0ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICB2YWxpZGF0ZU9wdGlvblByb3BzKGRpZEh5ZHJhdGUsIHByb3BzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoXCJzZWxlY3RcIiwgcHJvcHMpO1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJpbnZhbGlkXCIsIGRpZEh5ZHJhdGUpO1xuICAgICAgICAgIHZhbGlkYXRlU2VsZWN0UHJvcHMoZGlkSHlkcmF0ZSwgcHJvcHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwidGV4dGFyZWFcIiwgcHJvcHMpLFxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImludmFsaWRcIiwgZGlkSHlkcmF0ZSksXG4gICAgICAgICAgICB2YWxpZGF0ZVRleHRhcmVhUHJvcHMoZGlkSHlkcmF0ZSwgcHJvcHMpLFxuICAgICAgICAgICAgaW5pdFRleHRhcmVhKFxuICAgICAgICAgICAgICBkaWRIeWRyYXRlLFxuICAgICAgICAgICAgICBwcm9wcy52YWx1ZSxcbiAgICAgICAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICBwcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHRyYWNrKGRpZEh5ZHJhdGUpO1xuICAgICAgfVxuICAgICAgdHlwZSA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgIFwibnVtYmVyXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgIFwiYmlnaW50XCIgIT09IHR5cGVvZiB0eXBlKSB8fFxuICAgICAgZGlkSHlkcmF0ZS50ZXh0Q29udGVudCA9PT0gXCJcIiArIHR5cGUgfHxcbiAgICAgICEwID09PSBwcm9wcy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgfHxcbiAgICAgIGNoZWNrRm9yVW5tYXRjaGVkVGV4dChkaWRIeWRyYXRlLnRleHRDb250ZW50LCB0eXBlKVxuICAgICAgICA/IChudWxsICE9IHByb3BzLnBvcG92ZXIgJiZcbiAgICAgICAgICAgIChsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiYmVmb3JldG9nZ2xlXCIsIGRpZEh5ZHJhdGUpLFxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInRvZ2dsZVwiLCBkaWRIeWRyYXRlKSksXG4gICAgICAgICAgbnVsbCAhPSBwcm9wcy5vblNjcm9sbCAmJlxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbFwiLCBkaWRIeWRyYXRlKSxcbiAgICAgICAgICBudWxsICE9IHByb3BzLm9uU2Nyb2xsRW5kICYmXG4gICAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwic2Nyb2xsZW5kXCIsIGRpZEh5ZHJhdGUpLFxuICAgICAgICAgIG51bGwgIT0gcHJvcHMub25DbGljayAmJiAoZGlkSHlkcmF0ZS5vbmNsaWNrID0gbm9vcCQxKSxcbiAgICAgICAgICAoZGlkSHlkcmF0ZSA9ICEwKSlcbiAgICAgICAgOiAoZGlkSHlkcmF0ZSA9ICExKTtcbiAgICAgIGRpZEh5ZHJhdGUgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgICAgIGZvciAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47IGh5ZHJhdGlvblBhcmVudEZpYmVyOyApXG4gICAgICAgIHN3aXRjaCAoaHlkcmF0aW9uUGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSByZXR1cm4gITE7XG4gICAgICBpZiAoIWlzSHlkcmF0aW5nKVxuICAgICAgICByZXR1cm4gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlciksIChpc0h5ZHJhdGluZyA9ICEwKSwgITE7XG4gICAgICB2YXIgdGFnID0gZmliZXIudGFnLFxuICAgICAgICBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICBpZiAoKEpTQ29tcGlsZXJfdGVtcCA9IDMgIT09IHRhZyAmJiAyNyAhPT0gdGFnKSkge1xuICAgICAgICBpZiAoKEpTQ29tcGlsZXJfdGVtcCA9IDUgPT09IHRhZykpXG4gICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IGZpYmVyLnR5cGUpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICEoXCJmb3JtXCIgIT09IEpTQ29tcGlsZXJfdGVtcCAmJiBcImJ1dHRvblwiICE9PSBKU0NvbXBpbGVyX3RlbXApIHx8XG4gICAgICAgICAgICAgIHNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKTtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wID0gIUpTQ29tcGlsZXJfdGVtcDtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX3RlbXAgJiYgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSkge1xuICAgICAgICBmb3IgKEpTQ29tcGlsZXJfdGVtcCA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7IEpTQ29tcGlsZXJfdGVtcDsgKSB7XG4gICAgICAgICAgdmFyIGRpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9XG4gICAgICAgICAgICAgIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MoSlNDb21waWxlcl90ZW1wKTtcbiAgICAgICAgICBkaWZmTm9kZS5zZXJ2ZXJUYWlsLnB1c2goZGVzY3JpcHRpb24pO1xuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICBcIlN1c3BlbnNlXCIgPT09IGRlc2NyaXB0aW9uLnR5cGVcbiAgICAgICAgICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKEpTQ29tcGlsZXJfdGVtcClcbiAgICAgICAgICAgICAgOiBnZXROZXh0SHlkcmF0YWJsZShKU0NvbXBpbGVyX3RlbXAubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gICAgICB9XG4gICAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICAgIGlmICgxMyA9PT0gdGFnKSB7XG4gICAgICAgIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgZmliZXIgPSBudWxsICE9PSBmaWJlciA/IGZpYmVyLmRlaHlkcmF0ZWQgOiBudWxsO1xuICAgICAgICBpZiAoIWZpYmVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKGZpYmVyKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAyNyA9PT0gdGFnXG4gICAgICAgICAgPyAoKHRhZyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgaXNTaW5nbGV0b25TY29wZShmaWJlci50eXBlKVxuICAgICAgICAgICAgICA/ICgoZmliZXIgPSBwcmV2aW91c0h5ZHJhdGFibGVPbkVudGVyaW5nU2NvcGVkU2luZ2xldG9uKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNIeWRyYXRhYmxlT25FbnRlcmluZ1Njb3BlZFNpbmdsZXRvbiA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZmliZXIpKVxuICAgICAgICAgICAgICA6IChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gdGFnKSlcbiAgICAgICAgICA6IChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXJcbiAgICAgICAgICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZShmaWJlci5zdGF0ZU5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBpc0h5ZHJhdGluZyA9ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpIHtcbiAgICAgIHZhciBxdWV1ZWRFcnJvcnMgPSBoeWRyYXRpb25FcnJvcnM7XG4gICAgICBudWxsICE9PSBxdWV1ZWRFcnJvcnMgJiZcbiAgICAgICAgKG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzXG4gICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBxdWV1ZWRFcnJvcnMpXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgcXVldWVkRXJyb3JzXG4gICAgICAgICAgICApLFxuICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCkpO1xuICAgICAgcmV0dXJuIHF1ZXVlZEVycm9ycztcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVldWVIeWRyYXRpb25FcnJvcihlcnJvcikge1xuICAgICAgbnVsbCA9PT0gaHlkcmF0aW9uRXJyb3JzXG4gICAgICAgID8gKGh5ZHJhdGlvbkVycm9ycyA9IFtlcnJvcl0pXG4gICAgICAgIDogaHlkcmF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCkge1xuICAgICAgdmFyIGRpZmZSb290ID0gaHlkcmF0aW9uRGlmZlJvb3RERVY7XG4gICAgICBpZiAobnVsbCAhPT0gZGlmZlJvb3QpIHtcbiAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBkaWZmID0gZGVzY3JpYmVEaWZmKGRpZmZSb290KTsgMCA8IGRpZmZSb290LmNoaWxkcmVuLmxlbmd0aDsgKVxuICAgICAgICAgIGRpZmZSb290ID0gZGlmZlJvb3QuY2hpbGRyZW5bMF07XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGRpZmZSb290LmZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiQSB0cmVlIGh5ZHJhdGVkIGJ1dCBzb21lIGF0dHJpYnV0ZXMgb2YgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50IHByb3BlcnRpZXMuIFRoaXMgd29uJ3QgYmUgcGF0Y2hlZCB1cC4gVGhpcyBjYW4gaGFwcGVuIGlmIGEgU1NSLWVkIENsaWVudCBDb21wb25lbnQgdXNlZDpcXG5cXG4tIEEgc2VydmVyL2NsaWVudCBicmFuY2ggYGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylgLlxcbi0gVmFyaWFibGUgaW5wdXQgc3VjaCBhcyBgRGF0ZS5ub3coKWAgb3IgYE1hdGgucmFuZG9tKClgIHdoaWNoIGNoYW5nZXMgZWFjaCB0aW1lIGl0J3MgY2FsbGVkLlxcbi0gRGF0ZSBmb3JtYXR0aW5nIGluIGEgdXNlcidzIGxvY2FsZSB3aGljaCBkb2Vzbid0IG1hdGNoIHRoZSBzZXJ2ZXIuXFxuLSBFeHRlcm5hbCBjaGFuZ2luZyBkYXRhIHdpdGhvdXQgc2VuZGluZyBhIHNuYXBzaG90IG9mIGl0IGFsb25nIHdpdGggdGhlIEhUTUwuXFxuLSBJbnZhbGlkIEhUTUwgdGFnIG5lc3RpbmcuXFxuXFxuSXQgY2FuIGFsc28gaGFwcGVuIGlmIHRoZSBjbGllbnQgaGFzIGEgYnJvd3NlciBleHRlbnNpb24gaW5zdGFsbGVkIHdoaWNoIG1lc3NlcyB3aXRoIHRoZSBIVE1MIGJlZm9yZSBSZWFjdCBsb2FkZWQuXFxuXFxuJXMlc1wiLFxuICAgICAgICAgICAgXCJodHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaFwiLFxuICAgICAgICAgICAgZGlmZlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSB7XG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIsIGNvbnRleHQsIG5leHRWYWx1ZSkge1xuICAgICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICAgIHB1c2gocmVuZGVyZXJDdXJzb3JERVYsIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciwgcHJvdmlkZXJGaWJlcik7XG4gICAgICB2b2lkIDAgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAmJlxuICAgICAgICBudWxsICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICApO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCwgcHJvdmlkZXJGaWJlcikge1xuICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgICAgIHZhciBjdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlckN1cnNvckRFVi5jdXJyZW50O1xuICAgICAgcG9wKHJlbmRlcmVyQ3Vyc29yREVWLCBwcm92aWRlckZpYmVyKTtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IGN1cnJlbnRSZW5kZXJlcjtcbiAgICAgIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICBwYXJlbnQsXG4gICAgICByZW5kZXJMYW5lcyxcbiAgICAgIHByb3BhZ2F0aW9uUm9vdFxuICAgICkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHBhcmVudDsgKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgICAgICAocGFyZW50LmNoaWxkTGFuZXMgJiByZW5kZXJMYW5lcykgIT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgPyAoKHBhcmVudC5jaGlsZExhbmVzIHw9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gcmVuZGVyTGFuZXMpKVxuICAgICAgICAgIDogbnVsbCAhPT0gYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgJiByZW5kZXJMYW5lcykgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBwcm9wYWdhdGlvblJvb3QpIGJyZWFrO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgfVxuICAgICAgcGFyZW50ICE9PSBwcm9wYWdhdGlvblJvb3QgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHRvIGZpbmQgdGhlIHByb3BhZ2F0aW9uIHJvb3Qgd2hlbiBzY2hlZHVsaW5nIGNvbnRleHQgd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY29udGV4dHMsXG4gICAgICByZW5kZXJMYW5lcyxcbiAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuICAgICkge1xuICAgICAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBudWxsICE9PSBmaWJlciAmJiAoZmliZXIucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZm9yICg7IG51bGwgIT09IGZpYmVyOyApIHtcbiAgICAgICAgdmFyIGxpc3QgPSBmaWJlci5kZXBlbmRlbmNpZXM7XG4gICAgICAgIGlmIChudWxsICE9PSBsaXN0KSB7XG4gICAgICAgICAgdmFyIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgICAgICAgIGxpc3QgPSBsaXN0LmZpcnN0Q29udGV4dDtcbiAgICAgICAgICBhOiBmb3IgKDsgbnVsbCAhPT0gbGlzdDsgKSB7XG4gICAgICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IGxpc3Q7XG4gICAgICAgICAgICBsaXN0ID0gZmliZXI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeS5jb250ZXh0ID09PSBjb250ZXh0c1tpXSkge1xuICAgICAgICAgICAgICAgIGxpc3QubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IGxpc3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgICAgIG51bGwgIT09IGRlcGVuZGVuY3kgJiYgKGRlcGVuZGVuY3kubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICAgICAgICAgICAgICBsaXN0LnJldHVybixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZSB8fCAobmV4dEZpYmVyID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdCA9IGRlcGVuZGVuY3kubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoMTggPT09IGZpYmVyLnRhZykge1xuICAgICAgICAgIG5leHRGaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbmV4dEZpYmVyKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiV2UganVzdCBjYW1lIGZyb20gYSBwYXJlbnQgc28gd2UgbXVzdCBoYXZlIGhhZCBhIHBhcmVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBuZXh0RmliZXIubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgbGlzdCA9IG5leHRGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgbnVsbCAhPT0gbGlzdCAmJiAobGlzdC5sYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgICAgICAgIG5leHRGaWJlcixcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApO1xuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgaWYgKG51bGwgIT09IG5leHRGaWJlcikgbmV4dEZpYmVyLnJldHVybiA9IGZpYmVyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChuZXh0RmliZXIgPSBmaWJlcjsgbnVsbCAhPT0gbmV4dEZpYmVyOyApIHtcbiAgICAgICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmliZXIgPSBuZXh0RmliZXIuc2libGluZztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaWJlcikge1xuICAgICAgICAgICAgICBmaWJlci5yZXR1cm4gPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgICBuZXh0RmliZXIgPSBmaWJlcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgZmliZXIgPSBuZXh0RmliZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWVcbiAgICApIHtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIHBhcmVudCA9IHdvcmtJblByb2dyZXNzLCBpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dCA9ICExO1xuICAgICAgICBudWxsICE9PSBwYXJlbnQ7XG5cbiAgICAgICkge1xuICAgICAgICBpZiAoIWlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0KVxuICAgICAgICAgIGlmICgwICE9PSAocGFyZW50LmZsYWdzICYgNTI0Mjg4KSkgaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQgPSAhMDtcbiAgICAgICAgICBlbHNlIGlmICgwICE9PSAocGFyZW50LmZsYWdzICYgMjYyMTQ0KSkgYnJlYWs7XG4gICAgICAgIGlmICgxMCA9PT0gcGFyZW50LnRhZykge1xuICAgICAgICAgIHZhciBjdXJyZW50UGFyZW50ID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudFBhcmVudClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIGhhdmUgYSBjdXJyZW50IGZpYmVyLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgb2JqZWN0SXMocGFyZW50LnBlbmRpbmdQcm9wcy52YWx1ZSwgY3VycmVudFBhcmVudC52YWx1ZSkgfHxcbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQucHVzaChjb250ZXh0KVxuICAgICAgICAgICAgICAgIDogKGN1cnJlbnQgPSBbY29udGV4dF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50ID09PSBob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLmN1cnJlbnQpIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudFBhcmVudClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIGhhdmUgYSBjdXJyZW50IGZpYmVyLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgICAgICBjdXJyZW50UGFyZW50Lm1lbW9pemVkU3RhdGUubWVtb2l6ZWRTdGF0ZSAhPT1cbiAgICAgICAgICAgIHBhcmVudC5tZW1vaXplZFN0YXRlLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gY3VycmVudC5wdXNoKEhvc3RUcmFuc2l0aW9uQ29udGV4dClcbiAgICAgICAgICAgICAgOiAoY3VycmVudCA9IFtIb3N0VHJhbnNpdGlvbkNvbnRleHRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWVcbiAgICAgICAgKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDI2MjE0NDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnREZXBlbmRlbmNpZXMpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudERlcGVuZGVuY2llcztcblxuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhb2JqZWN0SXMoXG4gICAgICAgICAgICBjdXJyZW50RGVwZW5kZW5jaWVzLmNvbnRleHQuX2N1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMubWVtb2l6ZWRWYWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcztcbiAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzICYmICh3b3JrSW5Qcm9ncmVzcy5maXJzdENvbnRleHQgPSBudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCkge1xuICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKGNvbnN1bWVyLCBjb250ZXh0KSB7XG4gICAgICBudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxICYmIHByZXBhcmVUb1JlYWRDb250ZXh0KGNvbnN1bWVyKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCkge1xuICAgICAgdmFyIHZhbHVlID0gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgY29udGV4dCA9IHsgY29udGV4dDogY29udGV4dCwgbWVtb2l6ZWRWYWx1ZTogdmFsdWUsIG5leHQ6IG51bGwgfTtcbiAgICAgIGlmIChudWxsID09PSBsYXN0Q29udGV4dERlcGVuZGVuY3kpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGNvbnN1bWVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN1bWVyLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBmaXJzdENvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBjb25zdW1lci5mbGFncyB8PSA1MjQyODg7XG4gICAgICB9IGVsc2UgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXJMb2NhbCgpLFxuICAgICAgICBkYXRhOiBuZXcgTWFwKCksXG4gICAgICAgIHJlZkNvdW50OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRhaW5DYWNoZShjYWNoZSkge1xuICAgICAgY2FjaGUuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJBIGNhY2hlIGluc3RhbmNlIHdhcyByZXRhaW5lZCBhZnRlciBpdCB3YXMgYWxyZWFkeSBmcmVlZC4gVGhpcyBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICBjYWNoZS5yZWZDb3VudCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxlYXNlQ2FjaGUoY2FjaGUpIHtcbiAgICAgIGNhY2hlLnJlZkNvdW50LS07XG4gICAgICAwID4gY2FjaGUucmVmQ291bnQgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiQSBjYWNoZSBpbnN0YW5jZSB3YXMgcmVsZWFzZWQgYWZ0ZXIgaXQgd2FzIGFscmVhZHkgZnJlZWQuIFRoaXMgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgMCA9PT0gY2FjaGUucmVmQ291bnQgJiZcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayQyKE5vcm1hbFByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FjaGUuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpIHtcbiAgICAgIHZhciBwcmV2RWZmZWN0RHVyYXRpb24gPSBwcm9maWxlckVmZmVjdER1cmF0aW9uO1xuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICByZXR1cm4gcHJldkVmZmVjdER1cmF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKSB7XG4gICAgICB2YXIgZWxhcHNlZFRpbWUgPSBwcm9maWxlckVmZmVjdER1cmF0aW9uO1xuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICAgIHJldHVybiBlbGFwc2VkVGltZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbikge1xuICAgICAgdmFyIGVsYXBzZWRUaW1lID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gKz0gcHJldkVmZmVjdER1cmF0aW9uO1xuICAgICAgcmV0dXJuIGVsYXBzZWRUaW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQ29tcG9uZW50RWZmZWN0U3RhcnQoKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdFN0YXJ0ID0gY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lO1xuICAgICAgY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lID0gLTEuMTtcbiAgICAgIHJldHVybiBwcmV2RWZmZWN0U3RhcnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcENvbXBvbmVudEVmZmVjdFN0YXJ0KHByZXZFZmZlY3RTdGFydCkge1xuICAgICAgMCA8PSBwcmV2RWZmZWN0U3RhcnQgJiYgKGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSA9IHByZXZFZmZlY3RTdGFydCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0UHJvZmlsZXJUaW1lcihmaWJlcikge1xuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3coKTtcbiAgICAgIDAgPiBmaWJlci5hY3R1YWxTdGFydFRpbWUgJiYgKGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IHByb2ZpbGVyU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbihmaWJlcikge1xuICAgICAgaWYgKDAgPD0gcHJvZmlsZXJTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICAgICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgIGZpYmVyLnNlbGZCYXNlRHVyYXRpb24gPSBlbGFwc2VkVGltZTtcbiAgICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmRJbmNvbXBsZXRlRHVyYXRpb24oZmliZXIpIHtcbiAgICAgIGlmICgwIDw9IHByb2ZpbGVyU3RhcnRUaW1lKSB7XG4gICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvcmRFZmZlY3REdXJhdGlvbigpIHtcbiAgICAgIGlmICgwIDw9IHByb2ZpbGVyU3RhcnRUaW1lKSB7XG4gICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gICAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0RWZmZWN0VGltZXIoKSB7XG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgMCA+IGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSAmJlxuICAgICAgICAoY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lID0gcHJvZmlsZXJTdGFydFRpbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKGZpYmVyKSB7XG4gICAgICBmb3IgKHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkOyBjaGlsZDsgKVxuICAgICAgICAoZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb24pLCAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCB0aGVuYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGVudGFuZ2xlZExpc3RlbmVycyA9IChjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gW10pO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0ge1xuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgZW50YW5nbGVkTGlzdGVuZXJzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCsrO1xuICAgICAgdGhlbmFibGUudGhlbihwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlLCBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gLS1jdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnNcbiAgICAgICkge1xuICAgICAgICBudWxsICE9PSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgJiZcbiAgICAgICAgICAoY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpO1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVycztcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gMDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspICgwLCBsaXN0ZW5lcnNbaV0pKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoYWluVGhlbmFibGVWYWx1ZSh0aGVuYWJsZSwgcmVzdWx0KSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gW10sXG4gICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlID0ge1xuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB0aGVuYWJsZS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS52YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykgKDAsIGxpc3RlbmVyc1tpXSkocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgIGZvciAoZXJyb3IgPSAwOyBlcnJvciA8IGxpc3RlbmVycy5sZW5ndGg7IGVycm9yKyspXG4gICAgICAgICAgICAoMCwgbGlzdGVuZXJzW2Vycm9yXSkodm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZVdpdGhPdmVycmlkZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVla0NhY2hlRnJvbVBvb2woKSB7XG4gICAgICB2YXIgY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyID0gcmVzdW1lZENhY2hlLmN1cnJlbnQ7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyXG4gICAgICAgID8gY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyXG4gICAgICAgIDogd29ya0luUHJvZ3Jlc3NSb290LnBvb2xlZENhY2hlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJhbnNpdGlvbihvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcywgcHJldkNhY2hlUG9vbCkge1xuICAgICAgbnVsbCA9PT0gcHJldkNhY2hlUG9vbFxuICAgICAgICA/IHB1c2gocmVzdW1lZENhY2hlLCByZXN1bWVkQ2FjaGUuY3VycmVudCwgb2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MpXG4gICAgICAgIDogcHVzaChyZXN1bWVkQ2FjaGUsIHByZXZDYWNoZVBvb2wucG9vbCwgb2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5kZWRDYWNoZSgpIHtcbiAgICAgIHZhciBjYWNoZUZyb21Qb29sID0gcGVla0NhY2hlRnJvbVBvb2woKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjYWNoZUZyb21Qb29sXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHsgcGFyZW50OiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSwgcG9vbDogY2FjaGVGcm9tUG9vbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVUaGVuYWJsZVN0YXRlKCkge1xuICAgICAgcmV0dXJuIHsgZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlOiAhMSwgdGhlbmFibGVzOiBbXSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1RoZW5hYmxlUmVzb2x2ZWQodGhlbmFibGUpIHtcbiAgICAgIHRoZW5hYmxlID0gdGhlbmFibGUuc3RhdHVzO1xuICAgICAgcmV0dXJuIFwiZnVsZmlsbGVkXCIgPT09IHRoZW5hYmxlIHx8IFwicmVqZWN0ZWRcIiA9PT0gdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AkMygpIHt9XG4gICAgZnVuY3Rpb24gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KSB7XG4gICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZGlkVXNlUHJvbWlzZSA9ICEwKTtcbiAgICAgIHZhciB0cmFja2VkVGhlbmFibGVzID0gdGhlbmFibGVTdGF0ZS50aGVuYWJsZXM7XG4gICAgICBpbmRleCA9IHRyYWNrZWRUaGVuYWJsZXNbaW5kZXhdO1xuICAgICAgdm9pZCAwID09PSBpbmRleFxuICAgICAgICA/IHRyYWNrZWRUaGVuYWJsZXMucHVzaCh0aGVuYWJsZSlcbiAgICAgICAgOiBpbmRleCAhPT0gdGhlbmFibGUgJiZcbiAgICAgICAgICAodGhlbmFibGVTdGF0ZS5kaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UgfHxcbiAgICAgICAgICAgICgodGhlbmFibGVTdGF0ZS5kaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkEgY29tcG9uZW50IHdhcyBzdXNwZW5kZWQgYnkgYW4gdW5jYWNoZWQgcHJvbWlzZS4gQ3JlYXRpbmcgcHJvbWlzZXMgaW5zaWRlIGEgQ2xpZW50IENvbXBvbmVudCBvciBob29rIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLCBleGNlcHQgdmlhIGEgU3VzcGVuc2UtY29tcGF0aWJsZSBsaWJyYXJ5IG9yIGZyYW1ld29yay5cIlxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgdGhlbmFibGUudGhlbihub29wJDMsIG5vb3AkMyksXG4gICAgICAgICAgKHRoZW5hYmxlID0gaW5kZXgpKTtcbiAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICgodGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlLnJlYXNvbiksXG4gICAgICAgICAgICBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaCh0aGVuYWJsZVN0YXRlKSxcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1cylcbiAgICAgICAgICAgIHRoZW5hYmxlLnRoZW4obm9vcCQzLCBub29wJDMpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbnVsbCAhPT0gdGhlbmFibGVTdGF0ZSAmJlxuICAgICAgICAgICAgICAxMDAgPCB0aGVuYWJsZVN0YXRlLnNoZWxsU3VzcGVuZENvdW50ZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJBbiB1bmtub3duIENvbXBvbmVudCBpcyBhbiBhc3luYyBDbGllbnQgQ29tcG9uZW50LiBPbmx5IFNlcnZlciBDb21wb25lbnRzIGNhbiBiZSBhc3luYyBhdCB0aGUgbW9tZW50LiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBmb3IgdGhlIHNlcnZlci5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgKCh0aGVuYWJsZVN0YXRlID0gdGhlbmFibGUucmVhc29uKSxcbiAgICAgICAgICAgICAgICBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaCh0aGVuYWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICB0aGVuYWJsZVN0YXRlKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITA7XG4gICAgICAgICAgdGhyb3cgU3VzcGVuc2VFeGNlcHRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAgICAgaWYgKG51bGwgPT09IHN1c3BlbmRlZFRoZW5hYmxlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIGEgc3VzcGVuZGVkIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICExO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaChyZWplY3RlZFJlYXNvbikge1xuICAgICAgaWYgKFxuICAgICAgICByZWplY3RlZFJlYXNvbiA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHxcbiAgICAgICAgcmVqZWN0ZWRSZWFzb24gPT09IFN1c3BlbnNlQWN0aW9uRXhjZXB0aW9uXG4gICAgICApXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiSG9va3MgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGFuIGFzeW5jIGNvbXBvbmVudC4gVGhpcyBlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5IGFkZGluZyBgJ3VzZSBjbGllbnQnYCB0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gZm9yIHRoZSBzZXJ2ZXIuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaERlYnVnSW5mbyhkZWJ1Z0luZm8pIHtcbiAgICAgIHZhciBwcmV2aW91c0RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICBudWxsICE9IGRlYnVnSW5mbyAmJlxuICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9XG4gICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNEZWJ1Z0luZm9cbiAgICAgICAgICAgID8gZGVidWdJbmZvXG4gICAgICAgICAgICA6IHByZXZpb3VzRGVidWdJbmZvLmNvbmNhdChkZWJ1Z0luZm8pKTtcbiAgICAgIHJldHVybiBwcmV2aW91c0RlYnVnSW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQsIGZpYmVyLCByZXR1cm5GaWJlcikge1xuICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQucHJvcHMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChcImNoaWxkcmVuXCIgIT09IGtleSAmJiBcImtleVwiICE9PSBrZXkpIHtcbiAgICAgICAgICBudWxsID09PSBmaWJlciAmJlxuICAgICAgICAgICAgKChmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgMCkpLFxuICAgICAgICAgICAgKGZpYmVyLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIChmaWJlci5yZXR1cm4gPSByZXR1cm5GaWJlcikpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3JlZEtleSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIixcbiAgICAgICAgICAgICAgICBlcnJvcmVkS2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXIkMTtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgKz0gMTtcbiAgICAgIG51bGwgPT09IHRoZW5hYmxlU3RhdGUkMSAmJiAodGhlbmFibGVTdGF0ZSQxID0gY3JlYXRlVGhlbmFibGVTdGF0ZSgpKTtcbiAgICAgIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlJDEsIHRoZW5hYmxlLCBpbmRleCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvZXJjZVJlZih3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucHJvcHMucmVmO1xuICAgICAgd29ya0luUHJvZ3Jlc3MucmVmID0gdm9pZCAwICE9PSBlbGVtZW50ID8gZWxlbWVudCA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ0EgUmVhY3QgRWxlbWVudCBmcm9tIGFuIG9sZGVyIHZlcnNpb24gb2YgUmVhY3Qgd2FzIHJlbmRlcmVkLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEl0IGNhbiBoYXBwZW4gaWY6XFxuLSBNdWx0aXBsZSBjb3BpZXMgb2YgdGhlIFwicmVhY3RcIiBwYWNrYWdlIGlzIHVzZWQuXFxuLSBBIGxpYnJhcnkgcHJlLWJ1bmRsZWQgYW4gb2xkIGNvcHkgb2YgXCJyZWFjdFwiIG9yIFwicmVhY3QvanN4LXJ1bnRpbWVcIi5cXG4tIEEgY29tcGlsZXIgdHJpZXMgdG8gXCJpbmxpbmVcIiBKU1ggaW5zdGVhZCBvZiB1c2luZyB0aGUgcnVudGltZS4nXG4gICAgICAgICk7XG4gICAgICByZXR1cm5GaWJlciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCk7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICtcbiAgICAgICAgICAoXCJbb2JqZWN0IE9iamVjdF1cIiA9PT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgID8gXCJvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKFwiLCBcIikgKyBcIn1cIlxuICAgICAgICAgICAgOiByZXR1cm5GaWJlcikgK1xuICAgICAgICAgIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIGludmFsaWRDaGlsZCkge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW3BhcmVudE5hbWVdIHx8XG4gICAgICAgICgob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW3BhcmVudE5hbWVdID0gITApLFxuICAgICAgICAoaW52YWxpZENoaWxkID1cbiAgICAgICAgICBpbnZhbGlkQ2hpbGQuZGlzcGxheU5hbWUgfHwgaW52YWxpZENoaWxkLm5hbWUgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIDMgPT09IHJldHVybkZpYmVyLnRhZ1xuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXFxuICByb290LnJlbmRlciglcylcIixcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXFxuICA8JXM+eyVzfTwvJXM+XCIsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWVcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBpbnZhbGlkQ2hpbGQpIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgIG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gfHxcbiAgICAgICAgKChvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nW3BhcmVudE5hbWVdID0gITApLFxuICAgICAgICAoaW52YWxpZENoaWxkID0gU3RyaW5nKGludmFsaWRDaGlsZCkpLFxuICAgICAgICAzID09PSByZXR1cm5GaWJlci50YWdcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU3ltYm9scyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuXFxuICByb290LnJlbmRlciglcylcIixcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlN5bWJvbHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLlxcbiAgPCVzPiVzPC8lcz5cIixcbiAgICAgICAgICAgICAgcGFyZW50TmFtZSxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lXG4gICAgICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgdmFyIGRlbGV0aW9ucyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcbiAgICAgICAgICBudWxsID09PSBkZWxldGlvbnNcbiAgICAgICAgICAgID8gKChyZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY2hpbGRUb0RlbGV0ZV0pLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIuZmxhZ3MgfD0gMTYpKVxuICAgICAgICAgICAgOiBkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAoOyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKVxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgICAgICBmb3IgKHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpOyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKVxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkLmtleVxuICAgICAgICAgICAgPyBleGlzdGluZ0NoaWxkcmVuLnNldChjdXJyZW50Rmlyc3RDaGlsZC5rZXksIGN1cnJlbnRGaXJzdENoaWxkKVxuICAgICAgICAgICAgOiBleGlzdGluZ0NoaWxkcmVuLnNldChjdXJyZW50Rmlyc3RDaGlsZC5pbmRleCwgY3VycmVudEZpcnN0Q2hpbGQpLFxuICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcykge1xuICAgICAgICBmaWJlciA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMpO1xuICAgICAgICBmaWJlci5pbmRleCA9IDA7XG4gICAgICAgIGZpYmVyLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cylcbiAgICAgICAgICByZXR1cm4gKG5ld0ZpYmVyLmZsYWdzIHw9IDEwNDg1NzYpLCBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICAgIG5ld0luZGV4ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmV3SW5kZXgpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChuZXdJbmRleCA9IG5ld0luZGV4LmluZGV4KSxcbiAgICAgICAgICAgIG5ld0luZGV4IDwgbGFzdFBsYWNlZEluZGV4XG4gICAgICAgICAgICAgID8gKChuZXdGaWJlci5mbGFncyB8PSA2NzEwODg2NiksIGxhc3RQbGFjZWRJbmRleClcbiAgICAgICAgICAgICAgOiBuZXdJbmRleFxuICAgICAgICAgICk7XG4gICAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IDY3MTA4ODY2O1xuICAgICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgbnVsbCA9PT0gbmV3RmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgKG5ld0ZpYmVyLmZsYWdzIHw9IDY3MTA4ODY2KTtcbiAgICAgICAgcmV0dXJuIG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCA2ICE9PSBjdXJyZW50LnRhZylcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdUYXNrID0gcmV0dXJuRmliZXIuX2RlYnVnVGFzayksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50KTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBsYW5lcykge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBlbGVtZW50LmtleVxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgY3VycmVudCwgcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnRUeXBlIHx8XG4gICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY3VycmVudCwgZWxlbWVudCkgfHxcbiAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudFR5cGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZWxlbWVudFR5cGUgJiZcbiAgICAgICAgICAgICAgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICBjYWxsTGF6eUluaXRJbkRFVihlbGVtZW50VHlwZSkgPT09IGN1cnJlbnQudHlwZSkpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzKSksXG4gICAgICAgICAgICBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICAgIGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQsIHBvcnRhbCwgbGFuZXMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICA0ICE9PSBjdXJyZW50LnRhZyB8fFxuICAgICAgICAgIGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8XG4gICAgICAgICAgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpKSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIGxhbmVzLCBrZXkpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgNyAhPT0gY3VycmVudC50YWcpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgIGZyYWdtZW50LFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnVGFzayA9IHJldHVybkZpYmVyLl9kZWJ1Z1Rhc2spLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBmcmFnbWVudCk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgbmV3Q2hpbGRcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobmV3Q2hpbGQgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAgICAgICBcIlwiICsgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAobmV3Q2hpbGQuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAobmV3Q2hpbGQuX2RlYnVnVGFzayA9IHJldHVybkZpYmVyLl9kZWJ1Z1Rhc2spLFxuICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIG5ld0NoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBfcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm87XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnVGFzayA9IHJldHVybkZpYmVyLl9kZWJ1Z1Rhc2spLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZC50aGVuKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKF9wcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGNyZWF0ZUNoaWxkKFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBfcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAgICAgdmFyIGtleSA9IG51bGwgIT09IG9sZEZpYmVyID8gb2xkRmliZXIua2V5IDogbnVsbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gbnVsbCAhPT0ga2V5XG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgICAgICA/ICgoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcilcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgICAgICA/IHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVTbG90KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGtleSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0ga2V5O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0ga2V5KSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG5ld0lkeCxcbiAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGwpLFxuICAgICAgICAgICAgdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGV4aXN0aW5nQ2hpbGRyZW4sIFwiXCIgKyBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChuZXdJZHggPVxuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5nZXQoXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICAgKSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGV4aXN0aW5nQ2hpbGRyZW4pLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID1cbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICkgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIF9wcmV2RGVidWdJbmZvNyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvNztcbiAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKG5ld0lkeCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbCksXG4gICAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGV4aXN0aW5nQ2hpbGRyZW4pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChfcHJldkRlYnVnSW5mbzcgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm83KSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCwga25vd25LZXlzKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgY2hpbGQgfHwgbnVsbCA9PT0gY2hpbGQpIHJldHVybiBrbm93bktleXM7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBrZXkpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGtub3duS2V5cykge1xuICAgICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYod29ya0luUHJvZ3Jlc3MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSBhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSBkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIFxcdTIwMTQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCBjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIixcbiAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAoY2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihjaGlsZCkpLFxuICAgICAgICAgICAgICB3YXJuT25JbnZhbGlkS2V5KHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGRyZW4sXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbCxcbiAgICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgICAgICBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBuZXdJZHgrK1xuICAgICAgICApIHtcbiAgICAgICAgICBvbGRGaWJlci5pbmRleCA+IG5ld0lkeFxuICAgICAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5ld0ZpYmVyKSB7XG4gICAgICAgICAgICBudWxsID09PSBvbGRGaWJlciAmJiAob2xkRmliZXIgPSBuZXh0T2xkRmliZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG5ld0ZpYmVyLFxuICAgICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICk7XG4gICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgb2xkRmliZXIgJiZcbiAgICAgICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdJZHgpO1xuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcilcbiAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyKTtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpLFxuICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpLFxuICAgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSBvbGRGaWJlcikge1xuICAgICAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKVxuICAgICAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG9sZEZpYmVyKSk7XG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICAgICAgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIG5ld0lkeCsrXG4gICAgICAgIClcbiAgICAgICAgICAobmV4dE9sZEZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlciAmJlxuICAgICAgICAgICAgICAoKGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dE9sZEZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgIG9sZEZpYmVyLmRlbGV0ZShcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5leHRPbGRGaWJlci5rZXkgPyBuZXdJZHggOiBuZXh0T2xkRmliZXIua2V5XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgbmV3SWR4XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5leHRPbGRGaWJlcilcbiAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXh0T2xkRmliZXIpLFxuICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG5leHRPbGRGaWJlcikpO1xuICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgb2xkRmliZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZHJlbixcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBpZiAobnVsbCA9PSBuZXdDaGlsZHJlbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkFuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci5cIik7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgICAgICBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsLFxuICAgICAgICAgICAga25vd25LZXlzID0gbnVsbCxcbiAgICAgICAgICAgIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiYgIXN0ZXAuZG9uZTtcbiAgICAgICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgICAgICApIHtcbiAgICAgICAgICBvbGRGaWJlci5pbmRleCA+IG5ld0lkeFxuICAgICAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXdGaWJlcikge1xuICAgICAgICAgICAgbnVsbCA9PT0gb2xkRmliZXIgJiYgKG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdGaWJlcixcbiAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgIG9sZEZpYmVyICYmXG4gICAgICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KTtcbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXIpXG4gICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcik7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGVwLmRvbmUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlciksXG4gICAgICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCksXG4gICAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IG9sZEZpYmVyKSB7XG4gICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKVxuICAgICAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG9sZEZpYmVyKSk7XG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICAgICAgIXN0ZXAuZG9uZTtcbiAgICAgICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgICAgICApXG4gICAgICAgICAgKG5leHRPbGRGaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIgJiZcbiAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICBvbGRGaWJlci5kZWxldGUoXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBuZXh0T2xkRmliZXIua2V5ID8gbmV3SWR4IDogbmV4dE9sZEZpYmVyLmtleVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXh0T2xkRmliZXIpXG4gICAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV4dE9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBuZXh0T2xkRmliZXIpKTtcbiAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgIG9sZEZpYmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICBudWxsICE9PSBuZXdDaGlsZCAmJlxuICAgICAgICAgIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiZcbiAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgJiZcbiAgICAgICAgICAodmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBudWxsLCByZXR1cm5GaWJlciksXG4gICAgICAgICAgKG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4pKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICB2YXIgcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgPSBuZXdDaGlsZC5rZXk7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBuZXdDaGlsZC50eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKDcgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdPd25lciA9IG5ld0NoaWxkLl9vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBsYW5lcywgcmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLmVsZW1lbnRUeXBlID09PSBrZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2Yga2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBrZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsTGF6eUluaXRJbkRFVihrZXkpID09PSBjdXJyZW50Rmlyc3RDaGlsZC50eXBlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z093bmVyID0gbmV3Q2hpbGQuX293bmVyO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFXG4gICAgICAgICAgICAgICAgICA/ICgobGFuZXMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnVGFzayA9IHJldHVybkZpYmVyLl9kZWJ1Z1Rhc2spLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMobmV3Q2hpbGQsIGxhbmVzLCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSlcbiAgICAgICAgICAgICAgICAgIDogKChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgY29lcmNlUmVmKGxhbmVzLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBwbGFjZVNpbmdsZUNoaWxkKHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm87XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gcHJldkRlYnVnSW5mby5rZXk7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkLmtleSA9PT0gbmV3Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICA0ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWcgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uY29udGFpbmVySW5mbyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uY2hpbGRyZW4gfHwgW11cbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmVzID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKFxuICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZHJlbkFycmF5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAga2V5ID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCk7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2Yga2V5KVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkFuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IGtleS5jYWxsKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZHJlbiA9PT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDAgIT09IHJldHVybkZpYmVyLnRhZyB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiAhPT1cbiAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXR1cm5GaWJlci50eXBlKSB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JdXCIgIT09XG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGRyZW4pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIHx8XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVzaW5nIEl0ZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgdW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlIGBbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gWW91IGNhbiBhbHNvIHVzZSBhbiBJdGVyYWJsZSB0aGF0IGNhbiBpdGVyYXRlIG11bHRpcGxlIHRpbWVzIG92ZXIgdGhlIHNhbWUgaXRlbXMuXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICEwKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBuZXdDaGlsZC5lbnRyaWVzICE9PSBrZXkgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgIG5ld0NoaWxkcmVuLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gXCJcIiArIG5ld0NoaWxkKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkICYmIDYgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZ1xuICAgICAgICAgICAgICA/IChkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGxhbmVzID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHByZXZEZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSlcbiAgICAgICAgICAgICAgOiAoZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdUYXNrID0gcmV0dXJuRmliZXIuX2RlYnVnVGFzayksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpLFxuICAgICAgICAgICAgcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcilcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAgICAgdmFyIHByZXZEZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbiAgICAgICAgICB2YXIgZmlyc3RDaGlsZEZpYmVyID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGRGaWJlcjtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGlmICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbiB8fCB4ID09PSBTdXNwZW5zZUFjdGlvbkV4Y2VwdGlvbikgdGhyb3cgeDtcbiAgICAgICAgICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcigyOSwgeCwgbnVsbCwgcmV0dXJuRmliZXIubW9kZSk7XG4gICAgICAgICAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgICAgICAgICBmaWJlci5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICB2YXIgZGVidWdJbmZvID0gKGZpYmVyLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKTtcbiAgICAgICAgICBmaWJlci5fZGVidWdPd25lciA9IHJldHVybkZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgICAgIGZpYmVyLl9kZWJ1Z1Rhc2sgPSByZXR1cm5GaWJlci5fZGVidWdUYXNrO1xuICAgICAgICAgIGlmIChudWxsICE9IGRlYnVnSW5mbylcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWJ1Z0luZm8ubGVuZ3RoIC0gMTsgMCA8PSBpOyBpLS0pXG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZGVidWdJbmZvW2ldLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgZmliZXIuX2RlYnVnT3duZXIgPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgICAgICAgZmliZXIuX2RlYnVnVGFzayA9IGRlYnVnSW5mb1tpXS5kZWJ1Z1Rhc2s7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm87XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVVcGRhdGVRdWV1ZShmaWJlcikge1xuICAgICAgZmliZXIudXBkYXRlUXVldWUgPSB7XG4gICAgICAgIGJhc2VTdGF0ZTogZmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICAgICAgc2hhcmVkOiB7IHBlbmRpbmc6IG51bGwsIGxhbmVzOiAwLCBoaWRkZW5DYWxsYmFja3M6IG51bGwgfSxcbiAgICAgICAgY2FsbGJhY2tzOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID09PSBjdXJyZW50ICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHtcbiAgICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnQuYmFzZVN0YXRlLFxuICAgICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogY3VycmVudC5maXJzdEJhc2VVcGRhdGUsXG4gICAgICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnQubGFzdEJhc2VVcGRhdGUsXG4gICAgICAgICAgc2hhcmVkOiBjdXJyZW50LnNoYXJlZCxcbiAgICAgICAgICBjYWxsYmFja3M6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZShsYW5lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYW5lOiBsYW5lLFxuICAgICAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgICAgICBwYXlsb2FkOiBudWxsLFxuICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICAgIGlmIChudWxsID09PSB1cGRhdGVRdWV1ZSkgcmV0dXJuIG51bGw7XG4gICAgICB1cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlLnNoYXJlZDtcbiAgICAgIGlmIChcbiAgICAgICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID09PSB1cGRhdGVRdWV1ZSAmJlxuICAgICAgICAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgY2FsbGJhY2suXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudDogJXNcIixcbiAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICk7XG4gICAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGNvbXBvbmVudE5hbWUgPSB1cGRhdGVRdWV1ZS5wZW5kaW5nKSxcbiAgICAgICAgICBudWxsID09PSBjb21wb25lbnROYW1lXG4gICAgICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgICAgIDogKCh1cGRhdGUubmV4dCA9IGNvbXBvbmVudE5hbWUubmV4dCksXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lLm5leHQgPSB1cGRhdGUpKSxcbiAgICAgICAgICAodXBkYXRlUXVldWUucGVuZGluZyA9IHVwZGF0ZSksXG4gICAgICAgICAgKHVwZGF0ZSA9IGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpKSxcbiAgICAgICAgICBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbnVsbCwgbGFuZSksXG4gICAgICAgICAgdXBkYXRlXG4gICAgICAgICk7XG4gICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHVwZGF0ZVF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgcmV0dXJuIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gICAgICBmaWJlciA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKG51bGwgIT09IGZpYmVyICYmICgoZmliZXIgPSBmaWJlci5zaGFyZWQpLCAwICE9PSAobGFuZSAmIDQxOTQwNDgpKSkge1xuICAgICAgICB2YXIgcXVldWVMYW5lcyA9IGZpYmVyLmxhbmVzO1xuICAgICAgICBxdWV1ZUxhbmVzICY9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgICBsYW5lIHw9IHF1ZXVlTGFuZXM7XG4gICAgICAgIGZpYmVyLmxhbmVzID0gbGFuZTtcbiAgICAgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY2FwdHVyZWRVcGRhdGUpIHtcbiAgICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLFxuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLCBxdWV1ZSA9PT0gY3VycmVudClcbiAgICAgICkge1xuICAgICAgICB2YXIgbmV3Rmlyc3QgPSBudWxsLFxuICAgICAgICAgIG5ld0xhc3QgPSBudWxsO1xuICAgICAgICBxdWV1ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IHF1ZXVlKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgICAgICBsYW5lOiBxdWV1ZS5sYW5lLFxuICAgICAgICAgICAgICB0YWc6IHF1ZXVlLnRhZyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogcXVldWUucGF5bG9hZCxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBudWxsID09PSBuZXdMYXN0XG4gICAgICAgICAgICAgID8gKG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNsb25lKVxuICAgICAgICAgICAgICA6IChuZXdMYXN0ID0gbmV3TGFzdC5uZXh0ID0gY2xvbmUpO1xuICAgICAgICAgICAgcXVldWUgPSBxdWV1ZS5uZXh0O1xuICAgICAgICAgIH0gd2hpbGUgKG51bGwgIT09IHF1ZXVlKTtcbiAgICAgICAgICBudWxsID09PSBuZXdMYXN0XG4gICAgICAgICAgICA/IChuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZSlcbiAgICAgICAgICAgIDogKG5ld0xhc3QgPSBuZXdMYXN0Lm5leHQgPSBjYXB0dXJlZFVwZGF0ZSk7XG4gICAgICAgIH0gZWxzZSBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgcXVldWUgPSB7XG4gICAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50LmJhc2VTdGF0ZSxcbiAgICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IG5ld0ZpcnN0LFxuICAgICAgICAgIGxhc3RCYXNlVXBkYXRlOiBuZXdMYXN0LFxuICAgICAgICAgIHNoYXJlZDogY3VycmVudC5zaGFyZWQsXG4gICAgICAgICAgY2FsbGJhY2tzOiBjdXJyZW50LmNhbGxiYWNrc1xuICAgICAgICB9O1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgPyAocXVldWUuZmlyc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGUpXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzLm5leHQgPSBjYXB0dXJlZFVwZGF0ZSk7XG4gICAgICBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCkge1xuICAgICAgaWYgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24pIHtcbiAgICAgICAgdmFyIGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xuICAgICAgICBpZiAobnVsbCAhPT0gZW50YW5nbGVkQWN0aW9uVGhlbmFibGUpIHRocm93IGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHByb3BzLFxuICAgICAgaW5zdGFuY2UkanNjb21wJDAsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICExO1xuICAgICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gcXVldWUuc2hhcmVkO1xuICAgICAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSxcbiAgICAgICAgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG4gICAgICBpZiAobnVsbCAhPT0gcGVuZGluZ1F1ZXVlKSB7XG4gICAgICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdmFyIGxhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlLFxuICAgICAgICAgIGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgICAgIGxhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuICAgICAgICBudWxsID09PSBsYXN0QmFzZVVwZGF0ZVxuICAgICAgICAgID8gKGZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZSlcbiAgICAgICAgICA6IChsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlKTtcbiAgICAgICAgbGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAocGVuZGluZ1F1ZXVlID0gY3VycmVudC5sYXN0QmFzZVVwZGF0ZSksXG4gICAgICAgICAgcGVuZGluZ1F1ZXVlICE9PSBsYXN0QmFzZVVwZGF0ZSAmJlxuICAgICAgICAgICAgKG51bGwgPT09IHBlbmRpbmdRdWV1ZVxuICAgICAgICAgICAgICA/IChjdXJyZW50LmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZSlcbiAgICAgICAgICAgICAgOiAocGVuZGluZ1F1ZXVlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGUpLFxuICAgICAgICAgICAgKGN1cnJlbnQubGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZSkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChudWxsICE9PSBmaXJzdEJhc2VVcGRhdGUpIHtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gcXVldWUuYmFzZVN0YXRlO1xuICAgICAgICBsYXN0QmFzZVVwZGF0ZSA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZSA9IG51bGw7XG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciB1cGRhdGVMYW5lID0gcGVuZGluZ1F1ZXVlLmxhbmUgJiAtNTM2ODcwOTEzLFxuICAgICAgICAgICAgaXNIaWRkZW5VcGRhdGUgPSB1cGRhdGVMYW5lICE9PSBwZW5kaW5nUXVldWUubGFuZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpc0hpZGRlblVwZGF0ZVxuICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgICAgIDogKHJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIDAgIT09IHVwZGF0ZUxhbmUgJiZcbiAgICAgICAgICAgICAgdXBkYXRlTGFuZSA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgICAgICAgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMCk7XG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5uZXh0ID1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgICAgICAgdGFnOiBwZW5kaW5nUXVldWUudGFnLFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGVuZGluZ1F1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgdXBkYXRlTGFuZSA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgICAgICAgICB2YXIgbmV4dFByb3BzID0gcHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgc3dpdGNoIChwYXJ0aWFsU3RhdGUudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSZXBsYWNlU3RhdGU6XG4gICAgICAgICAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBwYXJ0aWFsU3RhdGUucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICEwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gcGFydGlhbFN0YXRlLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVMYW5lLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsU3RhdGUuY2FsbChpbnN0YW5jZSwgbmV3U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gcGFydGlhbFN0YXRlO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIENhcHR1cmVVcGRhdGU6XG4gICAgICAgICAgICAgICAgICB1cGRhdGVMYW5lLmZsYWdzID0gKHVwZGF0ZUxhbmUuZmxhZ3MgJiAtNjU1MzcpIHwgMTI4O1xuICAgICAgICAgICAgICAgIGNhc2UgVXBkYXRlU3RhdGU6XG4gICAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSBwYXJ0aWFsU3RhdGUucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBuZXh0U3RhdGUuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUxhbmUubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKGluc3RhbmNlLCBuZXdTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgcGFydGlhbFN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHBhcnRpYWxTdGF0ZSB8fCB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZSkgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gYXNzaWduKHt9LCBuZXdTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBGb3JjZVVwZGF0ZTpcbiAgICAgICAgICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUxhbmUgPSBwZW5kaW5nUXVldWUuY2FsbGJhY2s7XG4gICAgICAgICAgICBudWxsICE9PSB1cGRhdGVMYW5lICYmXG4gICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjQpLFxuICAgICAgICAgICAgICBpc0hpZGRlblVwZGF0ZSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MiksXG4gICAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZSA9IHF1ZXVlLmNhbGxiYWNrcyksXG4gICAgICAgICAgICAgIG51bGwgPT09IGlzSGlkZGVuVXBkYXRlXG4gICAgICAgICAgICAgICAgPyAocXVldWUuY2FsbGJhY2tzID0gW3VwZGF0ZUxhbmVdKVxuICAgICAgICAgICAgICAgIDogaXNIaWRkZW5VcGRhdGUucHVzaCh1cGRhdGVMYW5lKSk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAoaXNIaWRkZW5VcGRhdGUgPSB7XG4gICAgICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgICAgIHRhZzogcGVuZGluZ1F1ZXVlLnRhZyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogcGVuZGluZ1F1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiBwZW5kaW5nUXVldWUuY2FsbGJhY2ssXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyAoKGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGN1cnJlbnQgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAgICAgICAobGFzdFBlbmRpbmdVcGRhdGUgPSBuZXdTdGF0ZSkpXG4gICAgICAgICAgICAgICAgOiAoY3VycmVudCA9IGN1cnJlbnQubmV4dCA9IGlzSGlkZGVuVXBkYXRlKSxcbiAgICAgICAgICAgICAgKGxhc3RCYXNlVXBkYXRlIHw9IHVwZGF0ZUxhbmUpO1xuICAgICAgICAgIHBlbmRpbmdRdWV1ZSA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgICAgIGlmIChudWxsID09PSBwZW5kaW5nUXVldWUpXG4gICAgICAgICAgICBpZiAoKChwZW5kaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQucGVuZGluZyksIG51bGwgPT09IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAoaXNIaWRkZW5VcGRhdGUgPSBwZW5kaW5nUXVldWUpLFxuICAgICAgICAgICAgICAgIChwZW5kaW5nUXVldWUgPSBpc0hpZGRlblVwZGF0ZS5uZXh0KSxcbiAgICAgICAgICAgICAgICAoaXNIaWRkZW5VcGRhdGUubmV4dCA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGlzSGlkZGVuVXBkYXRlKSxcbiAgICAgICAgICAgICAgICAocXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsKTtcbiAgICAgICAgfSB3aGlsZSAoMSk7XG4gICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiYgKGxhc3RQZW5kaW5nVXBkYXRlID0gbmV3U3RhdGUpO1xuICAgICAgICBxdWV1ZS5iYXNlU3RhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGN1cnJlbnQ7XG4gICAgICAgIG51bGwgPT09IGZpcnN0QmFzZVVwZGF0ZSAmJiAocXVldWUuc2hhcmVkLmxhbmVzID0gMCk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBsYXN0QmFzZVVwZGF0ZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYXN0QmFzZVVwZGF0ZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2spXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6IFwiICtcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICk7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIaWRkZW5DYWxsYmFja3ModXBkYXRlUXVldWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBoaWRkZW5DYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzO1xuICAgICAgaWYgKG51bGwgIT09IGhpZGRlbkNhbGxiYWNrcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB1cGRhdGVRdWV1ZS5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzID0gbnVsbCwgdXBkYXRlUXVldWUgPSAwO1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlIDwgaGlkZGVuQ2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSsrXG4gICAgICAgIClcbiAgICAgICAgICBjYWxsQ2FsbGJhY2soaGlkZGVuQ2FsbGJhY2tzW3VwZGF0ZVF1ZXVlXSwgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcztcbiAgICAgIGlmIChudWxsICE9PSBjYWxsYmFja3MpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdXBkYXRlUXVldWUuY2FsbGJhY2tzID0gbnVsbCwgdXBkYXRlUXVldWUgPSAwO1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlIDwgY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSsrXG4gICAgICAgIClcbiAgICAgICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2tzW3VwZGF0ZVF1ZXVlXSwgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hIaWRkZW5Db250ZXh0KGZpYmVyLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzID0gZW50YW5nbGVkUmVuZGVyTGFuZXM7XG4gICAgICBwdXNoKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzLCBmaWJlcik7XG4gICAgICBwdXNoKGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzIHwgY29udGV4dC5iYXNlTGFuZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2soZmliZXIpIHtcbiAgICAgIHB1c2gocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBlbnRhbmdsZWRSZW5kZXJMYW5lcywgZmliZXIpO1xuICAgICAgcHVzaChcbiAgICAgICAgY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvcixcbiAgICAgICAgY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50LFxuICAgICAgICBmaWJlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSGlkZGVuQ29udGV4dChmaWJlcikge1xuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IuY3VycmVudDtcbiAgICAgIHBvcChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgICBwb3AocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGhhbmRsZXIuYWx0ZXJuYXRlO1xuICAgICAgcHVzaChcbiAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2ssXG4gICAgICAgIGhhbmRsZXJcbiAgICAgICk7XG4gICAgICBwdXNoKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBoYW5kbGVyLCBoYW5kbGVyKTtcbiAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnkgJiZcbiAgICAgICAgKG51bGwgPT09IGN1cnJlbnQgfHwgbnVsbCAhPT0gY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgPyAoc2hlbGxCb3VuZGFyeSA9IGhhbmRsZXIpXG4gICAgICAgICAgOiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiYgKHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgICAgIGlmICgyMiA9PT0gZmliZXIudGFnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAocHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIGZpYmVyKSxcbiAgICAgICAgICBwdXNoKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpLFxuICAgICAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnkpXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgKHNoZWxsQm91bmRhcnkgPSBmaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2soZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2soZmliZXIpIHtcbiAgICAgIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBmaWJlcik7XG4gICAgICBwdXNoKFxuICAgICAgICBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvcixcbiAgICAgICAgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgICAgICAgZmliZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFN1c3BlbnNlSGFuZGxlcihmaWJlcikge1xuICAgICAgcG9wKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgICBzaGVsbEJvdW5kYXJ5ID09PSBmaWJlciAmJiAoc2hlbGxCb3VuZGFyeSA9IG51bGwpO1xuICAgICAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEZpcnN0U3VzcGVuZGVkKHJvdykge1xuICAgICAgZm9yICh2YXIgbm9kZSA9IHJvdzsgbnVsbCAhPT0gbm9kZTsgKSB7XG4gICAgICAgIGlmICgxMyA9PT0gbm9kZS50YWcpIHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCAhPT0gc3RhdGUgJiZcbiAgICAgICAgICAgICgoc3RhdGUgPSBzdGF0ZS5kZWh5ZHJhdGVkKSxcbiAgICAgICAgICAgIG51bGwgPT09IHN0YXRlIHx8XG4gICAgICAgICAgICAgIHN0YXRlLmRhdGEgPT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSB8fFxuICAgICAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdGF0ZSkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgMTkgPT09IG5vZGUudGFnICYmXG4gICAgICAgICAgdm9pZCAwICE9PSBub2RlLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXJcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKDAgIT09IChub2RlLmZsYWdzICYgMTI4KSkgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAobnVsbCAhPT0gbm9kZS5jaGlsZCkge1xuICAgICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gcm93KSBicmVhaztcbiAgICAgICAgZm9yICg7IG51bGwgPT09IG5vZGUuc2libGluZzsgKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSByb3cpIHJldHVybiBudWxsO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gICAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcbiAgICAgIG51bGwgPT09IGhvb2tUeXBlc0RldlxuICAgICAgICA/IChob29rVHlwZXNEZXYgPSBbaG9va05hbWVdKVxuICAgICAgICA6IGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICAgICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IGhvb2tUeXBlc0RldiAmJlxuICAgICAgICAoaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYrKyxcbiAgICAgICAgaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSAhPT0gaG9va05hbWUpXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSksXG4gICAgICAgICAgbnVsbCAhPT0gaG9va1R5cGVzRGV2KVxuICAgICAgICApIHtcbiAgICAgICAgICBmb3IgKHZhciB0YWJsZSA9IFwiXCIsIGkgPSAwOyBpIDw9IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvbGRIb29rTmFtZSA9IGhvb2tUeXBlc0RldltpXSxcbiAgICAgICAgICAgICAgbmV3SG9va05hbWUgPVxuICAgICAgICAgICAgICAgIGkgPT09IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID8gaG9va05hbWUgOiBvbGRIb29rTmFtZTtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG9sZEhvb2tOYW1lID0gaSArIDEgKyBcIi4gXCIgKyBvbGRIb29rTmFtZTtcbiAgICAgICAgICAgICAgMzAgPiBvbGRIb29rTmFtZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgb2xkSG9va05hbWUgKz0gXCIgXCI7XG4gICAgICAgICAgICBvbGRIb29rTmFtZSArPSBuZXdIb29rTmFtZSArIFwiXFxuXCI7XG4gICAgICAgICAgICB0YWJsZSArPSBvbGRIb29rTmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgaGFzIGRldGVjdGVkIGEgY2hhbmdlIGluIHRoZSBvcmRlciBvZiBIb29rcyBjYWxsZWQgYnkgJXMuIFRoaXMgd2lsbCBsZWFkIHRvIGJ1Z3MgYW5kIGVycm9ycyBpZiBub3QgZml4ZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZSBSdWxlcyBvZiBIb29rczogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1xcblxcbiAgIFByZXZpb3VzIHJlbmRlciAgICAgICAgICAgIE5leHQgcmVuZGVyXFxuICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJXMgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cXG5cIixcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICB0YWJsZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcykge1xuICAgICAgdm9pZCAwID09PSBkZXBzIHx8XG4gICAgICAgIG51bGwgPT09IGRlcHMgfHxcbiAgICAgICAgaXNBcnJheUltcGwoZGVwcykgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgdGhhdCBpcyBub3QgYW4gYXJyYXkgKGluc3RlYWQsIHJlY2VpdmVkIGAlc2ApLiBXaGVuIHNwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuXCIsXG4gICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYsXG4gICAgICAgICAgdHlwZW9mIGRlcHNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIpO1xuICAgICAgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlLmhhcyhjb21wb25lbnROYW1lKSB8fFxuICAgICAgICAoZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlLmFkZChjb21wb25lbnROYW1lKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0RE9NLnVzZUZvcm1TdGF0ZSBoYXMgYmVlbiByZW5hbWVkIHRvIFJlYWN0LnVzZUFjdGlvblN0YXRlLiBQbGVhc2UgdXBkYXRlICVzIHRvIHVzZSBSZWFjdC51c2VBY3Rpb25TdGF0ZS5cIixcbiAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgICAgIGlmIChpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcykgcmV0dXJuICExO1xuICAgICAgaWYgKG51bGwgPT09IHByZXZEZXBzKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGl0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLlwiLFxuICAgICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXZcbiAgICAgICAgICApLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgICBuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG5QcmV2aW91czogJXNcXG5JbmNvbWluZzogJXNcIixcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICBcIltcIiArIHByZXZEZXBzLmpvaW4oXCIsIFwiKSArIFwiXVwiLFxuICAgICAgICAgIFwiW1wiICsgbmV4dERlcHMuam9pbihcIiwgXCIpICsgXCJdXCJcbiAgICAgICAgKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHByb3BzLFxuICAgICAgc2Vjb25kQXJnLFxuICAgICAgbmV4dFJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICByZW5kZXJMYW5lcyA9IG5leHRSZW5kZXJMYW5lcztcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBob29rVHlwZXNEZXYgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5fZGVidWdIb29rVHlwZXMgOiBudWxsO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBjdXJyZW50LnR5cGUgIT09IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICBpZiAoXG4gICAgICAgIFwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwiID09PVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChDb21wb25lbnQpIHx8XG4gICAgICAgIFwiW29iamVjdCBBc3luY0dlbmVyYXRvckZ1bmN0aW9uXVwiID09PVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChDb21wb25lbnQpXG4gICAgICApXG4gICAgICAgIChuZXh0UmVuZGVyTGFuZXMgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyKSksXG4gICAgICAgICAgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQuaGFzKG5leHRSZW5kZXJMYW5lcykgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5hZGQobmV4dFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgaXMgYW4gYXN5bmMgQ2xpZW50IENvbXBvbmVudC4gT25seSBTZXJ2ZXIgQ29tcG9uZW50cyBjYW4gYmUgYXN5bmMgYXQgdGhlIG1vbWVudC4gVGhpcyBlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5IGFkZGluZyBgJ3VzZSBjbGllbnQnYCB0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gZm9yIHRoZSBzZXJ2ZXIuXCIsXG4gICAgICAgICAgICAgIG51bGwgPT09IG5leHRSZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgID8gXCJBbiB1bmtub3duIENvbXBvbmVudFwiXG4gICAgICAgICAgICAgICAgOiBcIjxcIiArIG5leHRSZW5kZXJMYW5lcyArIFwiPlwiXG4gICAgICAgICAgICApKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWXG4gICAgICAgICAgOiBudWxsICE9PSBob29rVHlwZXNEZXZcbiAgICAgICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVlxuICAgICAgICAgICAgOiBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9IG5leHRSZW5kZXJMYW5lcyA9XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkgIT09IE5vTW9kZTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNhbGxDb21wb25lbnRJbkRFVihDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpO1xuICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSAhMTtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyAmJlxuICAgICAgICAoY2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3NBZ2FpbihcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgc2Vjb25kQXJnXG4gICAgICAgICkpO1xuICAgICAgaWYgKG5leHRSZW5kZXJMYW5lcykge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3NBZ2FpbihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICBzZWNvbmRBcmdcbiAgICAgICAgICApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzXG4gICAgICAgID8gbnVsbCAhPT0gdGhlbmFibGVTdGF0ZSAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICAgIGZpcnN0Q29udGV4dDogbnVsbCxcbiAgICAgICAgICAgIF9kZWJ1Z1RoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGVcbiAgICAgICAgICB9KVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMuX2RlYnVnVGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlU3RhdGUpO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgICAgIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRIb29rICYmIG51bGwgIT09IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICByZW5kZXJMYW5lcyA9IDA7XG4gICAgICBob29rVHlwZXNEZXYgPVxuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9XG4gICAgICAgIGN1cnJlbnRIb29rID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPVxuICAgICAgICAgIG51bGw7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAoY3VycmVudC5mbGFncyAmIDY1MDExNzEyKSAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgNjUwMTE3MTIpICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJJbnRlcm5hbCBSZWFjdCBlcnJvcjogRXhwZWN0ZWQgc3RhdGljIGZsYWcgd2FzIG1pc3NpbmcuIFBsZWFzZSBub3RpZnkgdGhlIFJlYWN0IHRlYW0uXCJcbiAgICAgICAgKTtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgICAgaWYgKGRpZFJlbmRlclRvb0Zld0hvb2tzKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlJlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsIGVhcmx5IHJldHVybiBzdGF0ZW1lbnQuXCJcbiAgICAgICAgKTtcbiAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSB8fFxuICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LmRlcGVuZGVuY2llcyksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCkgJiZcbiAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSk7XG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFVlxuICAgICAgICA/ICgobmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSAhMSksIChjdXJyZW50ID0gITApKVxuICAgICAgICA6IChjdXJyZW50ID0gITEpO1xuICAgICAgY3VycmVudCAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcIlVua25vd25cIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoLmhhcyh3b3JrSW5Qcm9ncmVzcykgfHxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5oYXMod29ya0luUHJvZ3Jlc3MpIHx8XG4gICAgICAgICAgKGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoLmFkZCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiYHVzZWAgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIHRyeS9jYXRjaCBibG9jay4gVGhpcyBpcyBub3QgYWxsb3dlZCBhbmQgY2FuIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci4gVG8gaGFuZGxlIGVycm9ycyB0cmlnZ2VyZWQgYnkgYHVzZWAsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYSBlcnJvciBib3VuZGFyeS5cIlxuICAgICAgICAgICkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyAmJiAodGhlbmFibGVTdGF0ZSA9IG51bGwpO1xuICAgICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExO1xuICAgICAgICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPj0gUkVfUkVOREVSX0xJTUlUKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG4gICAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gITE7XG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBjaGlsZHJlbi5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICBjaGlsZHJlbi5ldmVudHMgPSBudWxsO1xuICAgICAgICAgIGNoaWxkcmVuLnN0b3JlcyA9IG51bGw7XG4gICAgICAgICAgbnVsbCAhPSBjaGlsZHJlbi5tZW1vQ2FjaGUgJiYgKGNoaWxkcmVuLm1lbW9DYWNoZS5pbmRleCA9IDApO1xuICAgICAgICB9XG4gICAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG4gICAgICAgIGNoaWxkcmVuID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICB9IHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50KCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5ILFxuICAgICAgICBtYXliZVRoZW5hYmxlID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpWzBdO1xuICAgICAgbWF5YmVUaGVuYWJsZSA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlVGhlbmFibGUudGhlblxuICAgICAgICAgID8gdXNlVGhlbmFibGUobWF5YmVUaGVuYWJsZSlcbiAgICAgICAgICA6IG1heWJlVGhlbmFibGU7XG4gICAgICBkaXNwYXRjaGVyID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpWzBdO1xuICAgICAgKG51bGwgIT09IGN1cnJlbnRIb29rID8gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSA6IG51bGwpICE9PVxuICAgICAgICBkaXNwYXRjaGVyICYmIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5mbGFncyB8PSAxMDI0KTtcbiAgICAgIHJldHVybiBtYXliZVRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0RpZFJlbmRlcklkSG9vaygpIHtcbiAgICAgIHZhciBkaWRSZW5kZXJJZEhvb2sgPSAwICE9PSBsb2NhbElkQ291bnRlcjtcbiAgICAgIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgICAgIHJldHVybiBkaWRSZW5kZXJJZEhvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID1cbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZVxuICAgICAgICAgID8gd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAtNDAyNjU1MjM3XG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIC0yMDUzO1xuICAgICAgY3VycmVudC5sYW5lcyAmPSB+bGFuZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0SG9va3NPblVud2luZCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MucXVldWU7XG4gICAgICAgICAgbnVsbCAhPT0gcXVldWUgJiYgKHF1ZXVlLnBlbmRpbmcgPSBudWxsKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICAgICAgfVxuICAgICAgcmVuZGVyTGFuZXMgPSAwO1xuICAgICAgaG9va1R5cGVzRGV2ID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgY3VycmVudEhvb2sgPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSAhMTtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAgICAgdmFyIGhvb2sgPSB7XG4gICAgICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICAgICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgICAgICBxdWV1ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaylcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBob29rKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50SG9vaykge1xuICAgICAgICB2YXIgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICBuZXh0Q3VycmVudEhvb2sgPVxuICAgICAgICAgIG51bGwgIT09IG5leHRDdXJyZW50SG9vayA/IG5leHRDdXJyZW50SG9vay5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgICAgIH0gZWxzZSBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50SG9vay5uZXh0O1xuICAgICAgdmFyIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgICA/IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgICAgaWYgKG51bGwgIT09IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2spXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rKSxcbiAgICAgICAgICAoY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2spO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChudWxsID09PSBuZXh0Q3VycmVudEhvb2spIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIuYWx0ZXJuYXRlKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVXBkYXRlIGhvb2sgY2FsbGVkIG9uIGluaXRpYWwgcmVuZGVyLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgICAgICBuZXh0Q3VycmVudEhvb2sgPSB7XG4gICAgICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnRIb29rLmJhc2VTdGF0ZSxcbiAgICAgICAgICBiYXNlUXVldWU6IGN1cnJlbnRIb29rLmJhc2VRdWV1ZSxcbiAgICAgICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgICAgICAgbmV4dEN1cnJlbnRIb29rKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV4dEN1cnJlbnRIb29rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSB7XG4gICAgICByZXR1cm4geyBsYXN0RWZmZWN0OiBudWxsLCBldmVudHM6IG51bGwsIHN0b3JlczogbnVsbCwgbWVtb0NhY2hlOiBudWxsIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlcjtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG4gICAgICBudWxsID09PSB0aGVuYWJsZVN0YXRlICYmICh0aGVuYWJsZVN0YXRlID0gY3JlYXRlVGhlbmFibGVTdGF0ZSgpKTtcbiAgICAgIHRoZW5hYmxlID0gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KTtcbiAgICAgIGluZGV4ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXI7XG4gICAgICBudWxsID09PVxuICAgICAgICAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgICAgPyBpbmRleC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCkgJiZcbiAgICAgICAgKChpbmRleCA9IGluZGV4LmFsdGVybmF0ZSksXG4gICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID1cbiAgICAgICAgICBudWxsICE9PSBpbmRleCAmJiBudWxsICE9PSBpbmRleC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICA/IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVZcbiAgICAgICAgICAgIDogSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWKSk7XG4gICAgICByZXR1cm4gdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZSh1c2FibGUpIHtcbiAgICAgIGlmIChudWxsICE9PSB1c2FibGUgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVzYWJsZSkge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdXNhYmxlLnRoZW4pIHJldHVybiB1c2VUaGVuYWJsZSh1c2FibGUpO1xuICAgICAgICBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHJldHVybiByZWFkQ29udGV4dCh1c2FibGUpO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJBbiB1bnN1cHBvcnRlZCB0eXBlIHdhcyBwYXNzZWQgdG8gdXNlKCk6IFwiICsgU3RyaW5nKHVzYWJsZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VNZW1vQ2FjaGUoc2l6ZSkge1xuICAgICAgdmFyIG1lbW9DYWNoZSA9IG51bGwsXG4gICAgICAgIHVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIudXBkYXRlUXVldWU7XG4gICAgICBudWxsICE9PSB1cGRhdGVRdWV1ZSAmJiAobWVtb0NhY2hlID0gdXBkYXRlUXVldWUubWVtb0NhY2hlKTtcbiAgICAgIGlmIChudWxsID09IG1lbW9DYWNoZSkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQubWVtb0NhY2hlKSxcbiAgICAgICAgICAgIG51bGwgIT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAobWVtb0NhY2hlID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IGN1cnJlbnQuZGF0YS5tYXAoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgbnVsbCA9PSBtZW1vQ2FjaGUgJiYgKG1lbW9DYWNoZSA9IHsgZGF0YTogW10sIGluZGV4OiAwIH0pO1xuICAgICAgbnVsbCA9PT0gdXBkYXRlUXVldWUgJiZcbiAgICAgICAgKCh1cGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlci51cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlKSk7XG4gICAgICB1cGRhdGVRdWV1ZS5tZW1vQ2FjaGUgPSBtZW1vQ2FjaGU7XG4gICAgICB1cGRhdGVRdWV1ZSA9IG1lbW9DYWNoZS5kYXRhW21lbW9DYWNoZS5pbmRleF07XG4gICAgICBpZiAodm9pZCAwID09PSB1cGRhdGVRdWV1ZSB8fCBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA9IG1lbW9DYWNoZS5kYXRhW21lbW9DYWNoZS5pbmRleF0gPSBBcnJheShzaXplKSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgICAgIGN1cnJlbnQgPCBzaXplO1xuICAgICAgICAgIGN1cnJlbnQrK1xuICAgICAgICApXG4gICAgICAgICAgdXBkYXRlUXVldWVbY3VycmVudF0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICAgICAgZWxzZVxuICAgICAgICB1cGRhdGVRdWV1ZS5sZW5ndGggIT09IHNpemUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCBhIGNvbnN0YW50IHNpemUgYXJndW1lbnQgZm9yIGVhY2ggaW52b2NhdGlvbiBvZiB1c2VNZW1vQ2FjaGUuIFRoZSBwcmV2aW91cyBjYWNoZSB3YXMgYWxsb2NhdGVkIHdpdGggc2l6ZSAlcyBidXQgc2l6ZSAlcyB3YXMgcmVxdWVzdGVkLlwiLFxuICAgICAgICAgICAgdXBkYXRlUXVldWUubGVuZ3RoLFxuICAgICAgICAgICAgc2l6ZVxuICAgICAgICAgICk7XG4gICAgICBtZW1vQ2FjaGUuaW5kZXgrKztcbiAgICAgIHJldHVybiB1cGRhdGVRdWV1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvbiA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAodm9pZCAwICE9PSBpbml0KSB7XG4gICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluaXQoaW5pdGlhbEFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICByZWR1Y2VyID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IHJlZHVjZXIsXG4gICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgICAgIH07XG4gICAgICBob29rLnF1ZXVlID0gcmVkdWNlcjtcbiAgICAgIHJlZHVjZXIgPSByZWR1Y2VyLmRpc3BhdGNoID0gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLFxuICAgICAgICByZWR1Y2VyXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIHJlZHVjZXJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudEhvb2ssIHJlZHVjZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVSZWR1Y2VySW1wbChob29rLCBjdXJyZW50LCByZWR1Y2VyKSB7XG4gICAgICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuICAgICAgaWYgKG51bGwgPT09IHF1ZXVlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlNob3VsZCBoYXZlIGEgcXVldWUuIFlvdSBhcmUgbGlrZWx5IGNhbGxpbmcgSG9va3MgY29uZGl0aW9uYWxseSwgd2hpY2ggaXMgbm90IGFsbG93ZWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsKVwiXG4gICAgICAgICk7XG4gICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHZhciBiYXNlUXVldWUgPSBob29rLmJhc2VRdWV1ZSxcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcbiAgICAgIGlmIChudWxsICE9PSBwZW5kaW5nUXVldWUpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGJhc2VRdWV1ZSkge1xuICAgICAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgICAgICBiYXNlUXVldWUubmV4dCA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgICAgIHBlbmRpbmdRdWV1ZS5uZXh0ID0gYmFzZUZpcnN0O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbCBlcnJvcjogRXhwZWN0ZWQgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSB0byBiZSBhIGNsb25lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudC5iYXNlUXVldWUgPSBiYXNlUXVldWUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcGVuZGluZ1F1ZXVlID0gaG9vay5iYXNlU3RhdGU7XG4gICAgICBpZiAobnVsbCA9PT0gYmFzZVF1ZXVlKSBob29rLm1lbW9pemVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3VycmVudCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgICAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSAoYmFzZUZpcnN0ID0gbnVsbCksXG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG51bGwsXG4gICAgICAgICAgdXBkYXRlID0gY3VycmVudCxcbiAgICAgICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lICYgLTUzNjg3MDkxMztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB1cGRhdGVMYW5lICE9PSB1cGRhdGUubGFuZVxuICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgICAgIDogKHJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciByZXZlcnRMYW5lID0gdXBkYXRlLnJldmVydExhbmU7XG4gICAgICAgICAgICBpZiAoMCA9PT0gcmV2ZXJ0TGFuZSlcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3QmFzZVF1ZXVlTGFzdCAmJlxuICAgICAgICAgICAgICAgIChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID1cbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgICAgICAgICAgICAgZ2VzdHVyZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKChyZW5kZXJMYW5lcyAmIHJldmVydExhbmUpID09PSByZXZlcnRMYW5lKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICAgICAgICByZXZlcnRMYW5lID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITApO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAodXBkYXRlTGFuZSA9IHtcbiAgICAgICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgICAgICAgIGdlc3R1cmU6IG51bGwsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3QmFzZVF1ZXVlTGFzdFxuICAgICAgICAgICAgICAgICAgPyAoKG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IHVwZGF0ZUxhbmUpLFxuICAgICAgICAgICAgICAgICAgICAoYmFzZUZpcnN0ID0gcGVuZGluZ1F1ZXVlKSlcbiAgICAgICAgICAgICAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSB1cGRhdGVMYW5lKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIubGFuZXMgfD0gcmV2ZXJ0TGFuZSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSByZXZlcnRMYW5lKTtcbiAgICAgICAgICAgIHVwZGF0ZUxhbmUgPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgJiZcbiAgICAgICAgICAgICAgcmVkdWNlcihwZW5kaW5nUXVldWUsIHVwZGF0ZUxhbmUpO1xuICAgICAgICAgICAgcGVuZGluZ1F1ZXVlID0gdXBkYXRlLmhhc0VhZ2VyU3RhdGVcbiAgICAgICAgICAgICAgPyB1cGRhdGUuZWFnZXJTdGF0ZVxuICAgICAgICAgICAgICA6IHJlZHVjZXIocGVuZGluZ1F1ZXVlLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChyZXZlcnRMYW5lID0ge1xuICAgICAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgICAgICByZXZlcnRMYW5lOiB1cGRhdGUucmV2ZXJ0TGFuZSxcbiAgICAgICAgICAgICAgZ2VzdHVyZTogdXBkYXRlLmdlc3R1cmUsXG4gICAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3QmFzZVF1ZXVlTGFzdFxuICAgICAgICAgICAgICAgID8gKChuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICAgICAgIChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmxhbmVzIHw9IHVwZGF0ZUxhbmUpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IHVwZGF0ZUxhbmUpO1xuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChudWxsICE9PSB1cGRhdGUgJiYgdXBkYXRlICE9PSBjdXJyZW50KTtcbiAgICAgICAgbnVsbCA9PT0gbmV3QmFzZVF1ZXVlTGFzdFxuICAgICAgICAgID8gKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSlcbiAgICAgICAgICA6IChuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBuZXdCYXNlUXVldWVGaXJzdCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhb2JqZWN0SXMocGVuZGluZ1F1ZXVlLCBob29rLm1lbW9pemVkU3RhdGUpICYmXG4gICAgICAgICAgKChkaWRSZWNlaXZlVXBkYXRlID0gITApLFxuICAgICAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gJiZcbiAgICAgICAgICAgICgocmVkdWNlciA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSksIG51bGwgIT09IHJlZHVjZXIpKVxuICAgICAgICApXG4gICAgICAgICAgdGhyb3cgcmVkdWNlcjtcbiAgICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgICBob29rLmJhc2VTdGF0ZSA9IGJhc2VGaXJzdDtcbiAgICAgICAgaG9vay5iYXNlUXVldWUgPSBuZXdCYXNlUXVldWVMYXN0O1xuICAgICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgIH1cbiAgICAgIG51bGwgPT09IGJhc2VRdWV1ZSAmJiAocXVldWUubGFuZXMgPSAwKTtcbiAgICAgIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBxdWV1ZS5kaXNwYXRjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBxdWV1ZSA9IGhvb2sucXVldWU7XG4gICAgICBpZiAobnVsbCA9PT0gcXVldWUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gWW91IGFyZSBsaWtlbHkgY2FsbGluZyBIb29rcyBjb25kaXRpb25hbGx5LCB3aGljaCBpcyBub3QgYWxsb3dlZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwpXCJcbiAgICAgICAgKTtcbiAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyO1xuICAgICAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2gsXG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHF1ZXVlLnBlbmRpbmcsXG4gICAgICAgIG5ld1N0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IChsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCk7XG4gICAgICAgIGRvXG4gICAgICAgICAgKG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgdXBkYXRlLmFjdGlvbikpLCAodXBkYXRlID0gdXBkYXRlLm5leHQpO1xuICAgICAgICB3aGlsZSAodXBkYXRlICE9PSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUpO1xuICAgICAgICBvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSB8fCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKTtcbiAgICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIG51bGwgPT09IGhvb2suYmFzZVF1ZXVlICYmIChob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlKTtcbiAgICAgICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIsXG4gICAgICAgIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICApO1xuICAgICAgICB2YXIgbmV4dFNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgfHxcbiAgICAgICAgICBuZXh0U25hcHNob3QgPT09IGdldFNlcnZlclNuYXBzaG90KCkgfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHJlc3VsdCBvZiBnZXRTZXJ2ZXJTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcIlxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IHx8XG4gICAgICAgICAgKChnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNuYXBzaG90KCkpLFxuICAgICAgICAgIG9iamVjdElzKG5leHRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITApKSk7XG4gICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDEyNCkgfHxcbiAgICAgICAgICBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcbiAgICAgIGdldFNlcnZlclNuYXBzaG90ID0geyB2YWx1ZTogbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QgfTtcbiAgICAgIGhvb2sucXVldWUgPSBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICAgIG1vdW50RWZmZWN0KFxuICAgICAgICBzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGdldFNlcnZlclNuYXBzaG90LCBzdWJzY3JpYmUpLFxuICAgICAgICBbc3Vic2NyaWJlXVxuICAgICAgKTtcbiAgICAgIGZpYmVyLmZsYWdzIHw9IDIwNDg7XG4gICAgICBwdXNoU2ltcGxlRWZmZWN0KFxuICAgICAgICBIYXNFZmZlY3QgfCBQYXNzaXZlLFxuICAgICAgICB7IGRlc3Ryb3k6IHZvaWQgMCB9LFxuICAgICAgICB1cGRhdGVTdG9yZUluc3RhbmNlLmJpbmQoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBmaWJlcixcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgICAgICBuZXh0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U25hcHNob3RcbiAgICAgICAgKSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXh0U25hcHNob3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgZ2V0U25hcHNob3QsXG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICkge1xuICAgICAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIsXG4gICAgICAgIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgaXNIeWRyYXRpbmckanNjb21wJDAgPSBpc0h5ZHJhdGluZztcbiAgICAgIGlmIChpc0h5ZHJhdGluZyRqc2NvbXAkMCkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBnZXRTZXJ2ZXJTbmFwc2hvdClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKChnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNuYXBzaG90KCkpLCAhZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNhY2hlZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcbiAgICAgICAgb2JqZWN0SXMoZ2V0U2VydmVyU25hcHNob3QsIGNhY2hlZFNuYXBzaG90KSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMCkpO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAoY2FjaGVkU25hcHNob3QgPSAhb2JqZWN0SXMoXG4gICAgICAgICAgKGN1cnJlbnRIb29rIHx8IGhvb2spLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKSlcbiAgICAgIClcbiAgICAgICAgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGdldFNlcnZlclNuYXBzaG90KSwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCk7XG4gICAgICBob29rID0gaG9vay5xdWV1ZTtcbiAgICAgIHZhciBjcmVhdGUgPSBzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGhvb2ssIHN1YnNjcmliZSk7XG4gICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgW3N1YnNjcmliZV0pO1xuICAgICAgaWYgKFxuICAgICAgICBob29rLmdldFNuYXBzaG90ICE9PSBnZXRTbmFwc2hvdCB8fFxuICAgICAgICBjYWNoZWRTbmFwc2hvdCB8fFxuICAgICAgICAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NIb29rICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUudGFnICYgSGFzRWZmZWN0KVxuICAgICAgKSB7XG4gICAgICAgIGZpYmVyLmZsYWdzIHw9IDIwNDg7XG4gICAgICAgIHB1c2hTaW1wbGVFZmZlY3QoXG4gICAgICAgICAgSGFzRWZmZWN0IHwgUGFzc2l2ZSxcbiAgICAgICAgICB7IGRlc3Ryb3k6IHZvaWQgMCB9LFxuICAgICAgICAgIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGhvb2ssXG4gICAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgICAgICAgIGdldFNuYXBzaG90XG4gICAgICAgICAgKSxcbiAgICAgICAgICBudWxsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGlzSHlkcmF0aW5nJGpzY29tcCQwIHx8XG4gICAgICAgICAgMCAhPT0gKHJlbmRlckxhbmVzICYgMTI0KSB8fFxuICAgICAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0U2VydmVyU25hcHNob3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCByZW5kZXJlZFNuYXBzaG90KSB7XG4gICAgICBmaWJlci5mbGFncyB8PSAxNjM4NDtcbiAgICAgIGZpYmVyID0geyBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QsIHZhbHVlOiByZW5kZXJlZFNuYXBzaG90IH07XG4gICAgICBnZXRTbmFwc2hvdCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgICAgbnVsbCA9PT0gZ2V0U25hcHNob3RcbiAgICAgICAgPyAoKGdldFNuYXBzaG90ID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpKSxcbiAgICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIudXBkYXRlUXVldWUgPSBnZXRTbmFwc2hvdCksXG4gICAgICAgICAgKGdldFNuYXBzaG90LnN0b3JlcyA9IFtmaWJlcl0pKVxuICAgICAgICA6ICgocmVuZGVyZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90LnN0b3JlcyksXG4gICAgICAgICAgbnVsbCA9PT0gcmVuZGVyZWRTbmFwc2hvdFxuICAgICAgICAgICAgPyAoZ2V0U25hcHNob3Quc3RvcmVzID0gW2ZpYmVyXSlcbiAgICAgICAgICAgIDogcmVuZGVyZWRTbmFwc2hvdC5wdXNoKGZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0b3JlSW5zdGFuY2UoZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpIHtcbiAgICAgIGluc3QudmFsdWUgPSBuZXh0U25hcHNob3Q7XG4gICAgICBpbnN0LmdldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7XG4gICAgICBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZVRvU3RvcmUoZmliZXIsIGluc3QsIHN1YnNjcmliZSkge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgICAgIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG4gICAgICBpbnN0ID0gaW5zdC52YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuICAgICAgICByZXR1cm4gIW9iamVjdElzKGluc3QsIG5leHRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcikge1xuICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN0YXRlSW1wbChpbml0aWFsU3RhdGUpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZUluaXRpYWxpemVyID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGVJbml0aWFsaXplcigpO1xuICAgICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZUluaXRpYWxpemVyKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgaG9vay5xdWV1ZSA9IHtcbiAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBob29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICAgICAgaW5pdGlhbFN0YXRlID0gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKTtcbiAgICAgIHZhciBxdWV1ZSA9IGluaXRpYWxTdGF0ZS5xdWV1ZSxcbiAgICAgICAgZGlzcGF0Y2ggPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIsIHF1ZXVlKTtcbiAgICAgIHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgICByZXR1cm4gW2luaXRpYWxTdGF0ZS5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgICAgIHZhciBxdWV1ZSA9IHtcbiAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogbnVsbFxuICAgICAgfTtcbiAgICAgIGhvb2sucXVldWUgPSBxdWV1ZTtcbiAgICAgIGhvb2sgPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcixcbiAgICAgICAgITAsXG4gICAgICAgIHF1ZXVlXG4gICAgICApO1xuICAgICAgcXVldWUuZGlzcGF0Y2ggPSBob29rO1xuICAgICAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgaG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudEhvb2ssIHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudCwgcGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gICAgICByZXR1cm4gdXBkYXRlUmVkdWNlckltcGwoXG4gICAgICAgIGhvb2ssXG4gICAgICAgIGN1cnJlbnRIb29rLFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWR1Y2VyID8gcmVkdWNlciA6IGJhc2ljU3RhdGVSZWR1Y2VyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudEhvb2spXG4gICAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50SG9vaywgcGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgICAgIHJldHVybiBbcGFzc3Rocm91Z2gsIGhvb2sucXVldWUuZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEFjdGlvblN0YXRlKFxuICAgICAgZmliZXIsXG4gICAgICBhY3Rpb25RdWV1ZSxcbiAgICAgIHNldFBlbmRpbmdTdGF0ZSxcbiAgICAgIHNldFN0YXRlLFxuICAgICAgcGF5bG9hZFxuICAgICkge1xuICAgICAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKVxuICAgICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgZm9ybSBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgICAgZmliZXIgPSBhY3Rpb25RdWV1ZS5hY3Rpb247XG4gICAgICBpZiAobnVsbCAhPT0gZmliZXIpIHtcbiAgICAgICAgdmFyIGFjdGlvbk5vZGUgPSB7XG4gICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICBhY3Rpb246IGZpYmVyLFxuICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgaXNUcmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgICAgICBsaXN0ZW5lcnM6IFtdLFxuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgYWN0aW9uTm9kZS5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5UXG4gICAgICAgICAgPyBzZXRQZW5kaW5nU3RhdGUoITApXG4gICAgICAgICAgOiAoYWN0aW9uTm9kZS5pc1RyYW5zaXRpb24gPSAhMSk7XG4gICAgICAgIHNldFN0YXRlKGFjdGlvbk5vZGUpO1xuICAgICAgICBzZXRQZW5kaW5nU3RhdGUgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuICAgICAgICBudWxsID09PSBzZXRQZW5kaW5nU3RhdGVcbiAgICAgICAgICA/ICgoYWN0aW9uTm9kZS5uZXh0ID0gYWN0aW9uUXVldWUucGVuZGluZyA9IGFjdGlvbk5vZGUpLFxuICAgICAgICAgICAgcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUpKVxuICAgICAgICAgIDogKChhY3Rpb25Ob2RlLm5leHQgPSBzZXRQZW5kaW5nU3RhdGUubmV4dCksXG4gICAgICAgICAgICAoYWN0aW9uUXVldWUucGVuZGluZyA9IHNldFBlbmRpbmdTdGF0ZS5uZXh0ID0gYWN0aW9uTm9kZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgbm9kZSkge1xuICAgICAgdmFyIGFjdGlvbiA9IG5vZGUuYWN0aW9uLFxuICAgICAgICBwYXlsb2FkID0gbm9kZS5wYXlsb2FkLFxuICAgICAgICBwcmV2U3RhdGUgPSBhY3Rpb25RdWV1ZS5zdGF0ZTtcbiAgICAgIGlmIChub2RlLmlzVHJhbnNpdGlvbikge1xuICAgICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZCksXG4gICAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKGN1cnJlbnRUcmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgbnVsbCAhPT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gcHJldlRyYW5zaXRpb24udHlwZXMgJiZcbiAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb24udHlwZXMgIT09IGN1cnJlbnRUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJXZSBleHBlY3RlZCBpbm5lciBUcmFuc2l0aW9ucyB0byBoYXZlIHRyYW5zZmVycmVkIHRoZSBvdXRlciB0eXBlcyBzZXQgYW5kIHRoYXQgeW91IGNhbm5vdCBhZGQgdG8gdGhlIG91dGVyIFRyYW5zaXRpb24gd2hpbGUgaW5zaWRlIHRoZSBpbm5lci5UaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAocHJldlRyYW5zaXRpb24udHlwZXMgPSBjdXJyZW50VHJhbnNpdGlvbi50eXBlcykpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2VHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyAmJlxuICAgICAgICAgICAgICAoKGFjdGlvblF1ZXVlID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZSksXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCksXG4gICAgICAgICAgICAgIDEwIDwgYWN0aW9uUXVldWUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIkRldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIChjdXJyZW50VHJhbnNpdGlvbiA9IGFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpKSxcbiAgICAgICAgICAgIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCBjdXJyZW50VHJhbnNpdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yJDQpIHtcbiAgICAgICAgICBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvciQ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZShhY3Rpb25RdWV1ZSwgbm9kZSwgcmV0dXJuVmFsdWUpIHtcbiAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW5cbiAgICAgICAgPyAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYXN5bmNUcmFuc2l0aW9ucysrLFxuICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4ocmVsZWFzZUFzeW5jVHJhbnNpdGlvbiwgcmVsZWFzZUFzeW5jVHJhbnNpdGlvbiksXG4gICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgICAgb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBub2RlLCBuZXh0U3RhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICksXG4gICAgICAgICAgbm9kZS5pc1RyYW5zaXRpb24gfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQW4gYXN5bmMgZnVuY3Rpb24gd2l0aCB1c2VBY3Rpb25TdGF0ZSB3YXMgY2FsbGVkIG91dHNpZGUgb2YgYSB0cmFuc2l0aW9uLiBUaGlzIGlzIGxpa2VseSBub3Qgd2hhdCB5b3UgaW50ZW5kZWQgKGZvciBleGFtcGxlLCBpc1BlbmRpbmcgd2lsbCBub3QgdXBkYXRlIGNvcnJlY3RseSkuIEVpdGhlciBjYWxsIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLCBvciBwYXNzIGl0IHRvIGFuIGBhY3Rpb25gIG9yIGBmb3JtQWN0aW9uYCBwcm9wLlwiXG4gICAgICAgICAgICApKVxuICAgICAgICA6IG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgbm9kZSwgcmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUsIG5leHRTdGF0ZSkge1xuICAgICAgYWN0aW9uTm9kZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgYWN0aW9uTm9kZS52YWx1ZSA9IG5leHRTdGF0ZTtcbiAgICAgIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKTtcbiAgICAgIGFjdGlvblF1ZXVlLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgYWN0aW9uTm9kZSA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gICAgICBudWxsICE9PSBhY3Rpb25Ob2RlICYmXG4gICAgICAgICgobmV4dFN0YXRlID0gYWN0aW9uTm9kZS5uZXh0KSxcbiAgICAgICAgbmV4dFN0YXRlID09PSBhY3Rpb25Ob2RlXG4gICAgICAgICAgPyAoYWN0aW9uUXVldWUucGVuZGluZyA9IG51bGwpXG4gICAgICAgICAgOiAoKG5leHRTdGF0ZSA9IG5leHRTdGF0ZS5uZXh0KSxcbiAgICAgICAgICAgIChhY3Rpb25Ob2RlLm5leHQgPSBuZXh0U3RhdGUpLFxuICAgICAgICAgICAgcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIG5leHRTdGF0ZSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSwgZXJyb3IpIHtcbiAgICAgIHZhciBsYXN0ID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICAgIGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgaWYgKG51bGwgIT09IGxhc3QpIHtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICAgICAgZG9cbiAgICAgICAgICAoYWN0aW9uTm9kZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLFxuICAgICAgICAgICAgKGFjdGlvbk5vZGUucmVhc29uID0gZXJyb3IpLFxuICAgICAgICAgICAgbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpLFxuICAgICAgICAgICAgKGFjdGlvbk5vZGUgPSBhY3Rpb25Ob2RlLm5leHQpO1xuICAgICAgICB3aGlsZSAoYWN0aW9uTm9kZSAhPT0gbGFzdCk7XG4gICAgICB9XG4gICAgICBhY3Rpb25RdWV1ZS5hY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3RpZnlBY3Rpb25MaXN0ZW5lcnMoYWN0aW9uTm9kZSkge1xuICAgICAgYWN0aW9uTm9kZSA9IGFjdGlvbk5vZGUubGlzdGVuZXJzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3Rpb25Ob2RlLmxlbmd0aDsgaSsrKSAoMCwgYWN0aW9uTm9kZVtpXSkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWN0aW9uU3RhdGVSZWR1Y2VyKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlUHJvcCkge1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHZhciBzc3JGb3JtU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QuZm9ybVN0YXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gc3NyRm9ybVN0YXRlKSB7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgdmFyIGlzTWF0Y2hpbmcgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcjtcbiAgICAgICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICAgICAgICBpZiAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGI6IHtcbiAgICAgICAgICAgICAgICAgIHZhciBtYXJrZXJJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5Sb290T3JTaW5nbGV0b24gPSByb290T3JTaW5nbGV0b25Db250ZXh0O1xuICAgICAgICAgICAgICAgICAgICA4ICE9PSBtYXJrZXJJbnN0YW5jZS5ub2RlVHlwZTtcblxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5Sb290T3JTaW5nbGV0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluc3RhbmNlLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBtYXJrZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpblJvb3RPclNpbmdsZXRvbiA9IG1hcmtlckluc3RhbmNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgIGluUm9vdE9yU2luZ2xldG9uID09PSBGT1JNX1NUQVRFX0lTX01BVENISU5HIHx8XG4gICAgICAgICAgICAgICAgICAgIGluUm9vdE9yU2luZ2xldG9uID09PSBGT1JNX1NUQVRFX0lTX05PVF9NQVRDSElOR1xuICAgICAgICAgICAgICAgICAgICAgID8gbWFya2VySW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZS5uZXh0U2libGluZ1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlzTWF0Y2hpbmcgPSBtYXJrZXJJbnN0YW5jZS5kYXRhID09PSBGT1JNX1NUQVRFX0lTX01BVENISU5HO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGlzTWF0Y2hpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNNYXRjaGluZyA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc01hdGNoaW5nICYmIChpbml0aWFsU3RhdGVQcm9wID0gc3NyRm9ybVN0YXRlWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3NyRm9ybVN0YXRlID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHNzckZvcm1TdGF0ZS5tZW1vaXplZFN0YXRlID0gc3NyRm9ybVN0YXRlLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZVByb3A7XG4gICAgICBpc01hdGNoaW5nID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGFjdGlvblN0YXRlUmVkdWNlcixcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVByb3BcbiAgICAgIH07XG4gICAgICBzc3JGb3JtU3RhdGUucXVldWUgPSBpc01hdGNoaW5nO1xuICAgICAgc3NyRm9ybVN0YXRlID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcixcbiAgICAgICAgaXNNYXRjaGluZ1xuICAgICAgKTtcbiAgICAgIGlzTWF0Y2hpbmcuZGlzcGF0Y2ggPSBzc3JGb3JtU3RhdGU7XG4gICAgICBpc01hdGNoaW5nID0gbW91bnRTdGF0ZUltcGwoITEpO1xuICAgICAgaW5Sb290T3JTaW5nbGV0b24gPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcixcbiAgICAgICAgITEsXG4gICAgICAgIGlzTWF0Y2hpbmcucXVldWVcbiAgICAgICk7XG4gICAgICBpc01hdGNoaW5nID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIG1hcmtlckluc3RhbmNlID0ge1xuICAgICAgICBzdGF0ZTogaW5pdGlhbFN0YXRlUHJvcCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBwZW5kaW5nOiBudWxsXG4gICAgICB9O1xuICAgICAgaXNNYXRjaGluZy5xdWV1ZSA9IG1hcmtlckluc3RhbmNlO1xuICAgICAgc3NyRm9ybVN0YXRlID0gZGlzcGF0Y2hBY3Rpb25TdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcixcbiAgICAgICAgbWFya2VySW5zdGFuY2UsXG4gICAgICAgIGluUm9vdE9yU2luZ2xldG9uLFxuICAgICAgICBzc3JGb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICBtYXJrZXJJbnN0YW5jZS5kaXNwYXRjaCA9IHNzckZvcm1TdGF0ZTtcbiAgICAgIGlzTWF0Y2hpbmcubWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgICAgIHJldHVybiBbaW5pdGlhbFN0YXRlUHJvcCwgc3NyRm9ybVN0YXRlLCAhMV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbikge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRIb29rLCBhY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVSZWR1Y2VySW1wbChcbiAgICAgICAgc3RhdGVIb29rLFxuICAgICAgICBjdXJyZW50U3RhdGVIb29rLFxuICAgICAgICBhY3Rpb25TdGF0ZVJlZHVjZXJcbiAgICAgIClbMF07XG4gICAgICBzdGF0ZUhvb2sgPSB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGN1cnJlbnRTdGF0ZUhvb2sgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudFN0YXRlSG9vayAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjdXJyZW50U3RhdGVIb29rLnRoZW5cbiAgICAgIClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB1c2VUaGVuYWJsZShjdXJyZW50U3RhdGVIb29rKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGlmICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbikgdGhyb3cgU3VzcGVuc2VBY3Rpb25FeGNlcHRpb247XG4gICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgfVxuICAgICAgZWxzZSBzdGF0ZSA9IGN1cnJlbnRTdGF0ZUhvb2s7XG4gICAgICBjdXJyZW50U3RhdGVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICB2YXIgYWN0aW9uUXVldWUgPSBjdXJyZW50U3RhdGVIb29rLnF1ZXVlLFxuICAgICAgICBkaXNwYXRjaCA9IGFjdGlvblF1ZXVlLmRpc3BhdGNoO1xuICAgICAgYWN0aW9uICE9PSBjdXJyZW50U3RhdGVIb29rLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgcHVzaFNpbXBsZUVmZmVjdChcbiAgICAgICAgICBIYXNFZmZlY3QgfCBQYXNzaXZlLFxuICAgICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgICAgYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QuYmluZChudWxsLCBhY3Rpb25RdWV1ZSwgYWN0aW9uKSxcbiAgICAgICAgICBudWxsXG4gICAgICAgICkpO1xuICAgICAgcmV0dXJuIFtzdGF0ZSwgZGlzcGF0Y2gsIHN0YXRlSG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjdGlvblN0YXRlQWN0aW9uRWZmZWN0KGFjdGlvblF1ZXVlLCBhY3Rpb24pIHtcbiAgICAgIGFjdGlvblF1ZXVlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pIHtcbiAgICAgIHZhciBzdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgY3VycmVudFN0YXRlSG9vayA9IGN1cnJlbnRIb29rO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRTdGF0ZUhvb2spXG4gICAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pO1xuICAgICAgdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBzdGF0ZUhvb2sgPSBzdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHZhciBkaXNwYXRjaCA9IGN1cnJlbnRTdGF0ZUhvb2sucXVldWUuZGlzcGF0Y2g7XG4gICAgICBjdXJyZW50U3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBhY3Rpb247XG4gICAgICByZXR1cm4gW3N0YXRlSG9vaywgZGlzcGF0Y2gsICExXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFNpbXBsZUVmZmVjdCh0YWcsIGluc3QsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgdGFnID0geyB0YWc6IHRhZywgY3JlYXRlOiBjcmVhdGUsIGRlcHM6IGRlcHMsIGluc3Q6IGluc3QsIG5leHQ6IG51bGwgfTtcbiAgICAgIGluc3QgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlci51cGRhdGVRdWV1ZTtcbiAgICAgIG51bGwgPT09IGluc3QgJiZcbiAgICAgICAgKChpbnN0ID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpKSxcbiAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLnVwZGF0ZVF1ZXVlID0gaW5zdCkpO1xuICAgICAgY3JlYXRlID0gaW5zdC5sYXN0RWZmZWN0O1xuICAgICAgbnVsbCA9PT0gY3JlYXRlXG4gICAgICAgID8gKGluc3QubGFzdEVmZmVjdCA9IHRhZy5uZXh0ID0gdGFnKVxuICAgICAgICA6ICgoZGVwcyA9IGNyZWF0ZS5uZXh0KSxcbiAgICAgICAgICAoY3JlYXRlLm5leHQgPSB0YWcpLFxuICAgICAgICAgICh0YWcubmV4dCA9IGRlcHMpLFxuICAgICAgICAgIChpbnN0Lmxhc3RFZmZlY3QgPSB0YWcpKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50UmVmKGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaW5pdGlhbFZhbHVlID0geyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfTtcbiAgICAgIHJldHVybiAoaG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5mbGFncyB8PSBmaWJlckZsYWdzO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaFNpbXBsZUVmZmVjdChcbiAgICAgICAgSGFzRWZmZWN0IHwgaG9va0ZsYWdzLFxuICAgICAgICB7IGRlc3Ryb3k6IHZvaWQgMCB9LFxuICAgICAgICBjcmVhdGUsXG4gICAgICAgIHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIGluc3QgPSBob29rLm1lbW9pemVkU3RhdGUuaW5zdDtcbiAgICAgIG51bGwgIT09IGN1cnJlbnRIb29rICYmXG4gICAgICBudWxsICE9PSBkZXBzICYmXG4gICAgICBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZS5kZXBzKVxuICAgICAgICA/IChob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoU2ltcGxlRWZmZWN0KGhvb2tGbGFncywgaW5zdCwgY3JlYXRlLCBkZXBzKSlcbiAgICAgICAgOiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmZsYWdzIHw9IGZpYmVyRmxhZ3MpLFxuICAgICAgICAgIChob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoU2ltcGxlRWZmZWN0KFxuICAgICAgICAgICAgSGFzRWZmZWN0IHwgaG9va0ZsYWdzLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNyZWF0ZSxcbiAgICAgICAgICAgIGRlcHNcbiAgICAgICAgICApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSAmJlxuICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLm1vZGUgJiBOb1N0cmljdFBhc3NpdmVFZmZlY3RzTW9kZSkgPT09IE5vTW9kZVxuICAgICAgICA/IG1vdW50RWZmZWN0SW1wbCgyNzY4MjYxMTIsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcylcbiAgICAgICAgOiBtb3VudEVmZmVjdEltcGwoODM5MDY1NiwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgZmliZXJGbGFncyA9IDQxOTQzMDg7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgIChmaWJlckZsYWdzIHw9IDEzNDIxNzcyOCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdChjcmVhdGUsIHJlZikge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZikge1xuICAgICAgICBjcmVhdGUgPSBjcmVhdGUoKTtcbiAgICAgICAgdmFyIHJlZkNsZWFudXAgPSByZWYoY3JlYXRlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWZDbGVhbnVwID8gcmVmQ2xlYW51cCgpIDogcmVmKG51bGwpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgIT09IHJlZiAmJiB2b2lkIDAgIT09IHJlZilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZWYuaGFzT3duUHJvcGVydHkoXCJjdXJyZW50XCIpIHx8XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSByZWYgY2FsbGJhY2sgb3IgUmVhY3QuY3JlYXRlUmVmKCkgb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgICAgXCJhbiBvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKHJlZikuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKGNyZWF0ZSA9IGNyZWF0ZSgpKSxcbiAgICAgICAgICAocmVmLmN1cnJlbnQgPSBjcmVhdGUpLFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY3JlYXRlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICBudWxsICE9PSBjcmVhdGUgPyB0eXBlb2YgY3JlYXRlIDogXCJudWxsXCJcbiAgICAgICAgKTtcbiAgICAgIGRlcHMgPSBudWxsICE9PSBkZXBzICYmIHZvaWQgMCAhPT0gZGVwcyA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gICAgICB2YXIgZmliZXJGbGFncyA9IDQxOTQzMDg7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgIChmaWJlckZsYWdzIHw9IDEzNDIxNzcyOCk7XG4gICAgICBtb3VudEVmZmVjdEltcGwoXG4gICAgICAgIGZpYmVyRmxhZ3MsXG4gICAgICAgIExheW91dCxcbiAgICAgICAgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSxcbiAgICAgICAgZGVwc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY3JlYXRlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICBudWxsICE9PSBjcmVhdGUgPyB0eXBlb2YgY3JlYXRlIDogXCJudWxsXCJcbiAgICAgICAgKTtcbiAgICAgIGRlcHMgPSBudWxsICE9PSBkZXBzICYmIHZvaWQgMCAhPT0gZGVwcyA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gICAgICB1cGRhdGVFZmZlY3RJbXBsKFxuICAgICAgICA0LFxuICAgICAgICBMYXlvdXQsXG4gICAgICAgIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksXG4gICAgICAgIGRlcHNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IFtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzXG4gICAgICBdO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gZGVwcyAmJiBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgcHJldlN0YXRlWzFdKSlcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgZGVwc107XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50TWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBkZXBzID0gdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHM7XG4gICAgICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0Q3JlYXRlKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBkZXBzXTtcbiAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gZGVwcyAmJiBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgcHJldlN0YXRlWzFdKSlcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIHByZXZTdGF0ZSA9IG5leHRDcmVhdGUoKTtcbiAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV4dENyZWF0ZSgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gW3ByZXZTdGF0ZSwgZGVwc107XG4gICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChcbiAgICAgICAgaG9vayxcbiAgICAgICAgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGluaXRpYWxWYWx1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY3VycmVudEhvb2tcbiAgICAgICAgPyBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpXG4gICAgICAgIDogdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoXG4gICAgICAgICAgICBob29rLFxuICAgICAgICAgICAgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgaW5pdGlhbFZhbHVlXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBpZiAodm9pZCAwID09PSBpbml0aWFsVmFsdWUgfHwgMCAhPT0gKHJlbmRlckxhbmVzICYgMTA3Mzc0MTgyNCkpXG4gICAgICAgIHJldHVybiAoaG9vay5tZW1vaXplZFN0YXRlID0gdmFsdWUpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgaG9vayA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmxhbmVzIHw9IGhvb2s7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gaG9vaztcbiAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgaWYgKG9iamVjdElzKHZhbHVlLCBwcmV2VmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50KVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChob29rID0gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSksXG4gICAgICAgICAgb2JqZWN0SXMoaG9vaywgcHJldlZhbHVlKSB8fCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSxcbiAgICAgICAgICBob29rXG4gICAgICAgICk7XG4gICAgICBpZiAoMCA9PT0gKHJlbmRlckxhbmVzICYgNDIpIHx8IDAgIT09IChyZW5kZXJMYW5lcyAmIDEwNzM3NDE4MjQpKVxuICAgICAgICByZXR1cm4gKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksIChob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZSk7XG4gICAgICBob29rID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIubGFuZXMgfD0gaG9vaztcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBob29rO1xuICAgICAgcmV0dXJuIHByZXZWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsZWFzZUFzeW5jVHJhbnNpdGlvbigpIHtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFzeW5jVHJhbnNpdGlvbnMtLTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgIGZpbmlzaGVkU3RhdGUsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICAgICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9XG4gICAgICAgIDAgIT09IHByZXZpb3VzUHJpb3JpdHkgJiYgcHJldmlvdXNQcmlvcml0eSA8IENvbnRpbnVvdXNFdmVudFByaW9yaXR5XG4gICAgICAgICAgPyBwcmV2aW91c1ByaW9yaXR5XG4gICAgICAgICAgOiBDb250aW51b3VzRXZlbnRQcmlvcml0eTtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG4gICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgICAgIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKGZpYmVyLCAhMSwgcXVldWUsIHBlbmRpbmdTdGF0ZSk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpLFxuICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuXG4gICAgICAgICkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFzeW5jVHJhbnNpdGlvbnMrKztcbiAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKHJlbGVhc2VBc3luY1RyYW5zaXRpb24sIHJlbGVhc2VBc3luY1RyYW5zaXRpb24pO1xuICAgICAgICAgIHZhciB0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUgPSBjaGFpblRoZW5hYmxlVmFsdWUoXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSxcbiAgICAgICAgICAgIGZpbmlzaGVkU3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICB0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUsXG4gICAgICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcilcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgZmluaXNoZWRTdGF0ZSxcbiAgICAgICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgZmliZXIsXG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgeyB0aGVuOiBmdW5jdGlvbiAoKSB7fSwgc3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbjogZXJyb3IgfSxcbiAgICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcilcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgbnVsbCAhPT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gcHJldlRyYW5zaXRpb24udHlwZXMgJiZcbiAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb24udHlwZXMgIT09IGN1cnJlbnRUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJXZSBleHBlY3RlZCBpbm5lciBUcmFuc2l0aW9ucyB0byBoYXZlIHRyYW5zZmVycmVkIHRoZSBvdXRlciB0eXBlcyBzZXQgYW5kIHRoYXQgeW91IGNhbm5vdCBhZGQgdG8gdGhlIG91dGVyIFRyYW5zaXRpb24gd2hpbGUgaW5zaWRlIHRoZSBpbm5lci5UaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAocHJldlRyYW5zaXRpb24udHlwZXMgPSBjdXJyZW50VHJhbnNpdGlvbi50eXBlcykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIG51bGwgPT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyAmJlxuICAgICAgICAgICAgKChmaWJlciA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemUpLFxuICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKSxcbiAgICAgICAgICAgIDEwIDwgZmliZXIgJiZcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiBJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiBPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0SG9zdFRyYW5zaXRpb24oZm9ybUZpYmVyLCBwZW5kaW5nU3RhdGUsIGFjdGlvbiwgZm9ybURhdGEpIHtcbiAgICAgIGlmICg1ICE9PSBmb3JtRmliZXIudGFnKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBmb3JtIGluc3RhbmNlIHRvIGJlIGEgSG9zdENvbXBvbmVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHF1ZXVlID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKS5xdWV1ZTtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbihcbiAgICAgICAgZm9ybUZpYmVyLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgcGVuZGluZ1N0YXRlLFxuICAgICAgICBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgbnVsbCA9PT0gYWN0aW9uXG4gICAgICAgICAgPyBub29wJDJcbiAgICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdEZvcm1SZXNldCQxKGZvcm1GaWJlcik7XG4gICAgICAgICAgICAgIHJldHVybiBhY3Rpb24oZm9ybURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKSB7XG4gICAgICB2YXIgZXhpc3RpbmdTdGF0ZUhvb2sgPSBmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBleGlzdGluZ1N0YXRlSG9vaykgcmV0dXJuIGV4aXN0aW5nU3RhdGVIb29rO1xuICAgICAgZXhpc3RpbmdTdGF0ZUhvb2sgPSB7XG4gICAgICAgIG1lbW9pemVkU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgICBiYXNlU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgICAgIHF1ZXVlOiB7XG4gICAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogTm90UGVuZGluZ1RyYW5zaXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIHZhciBpbml0aWFsUmVzZXRTdGF0ZSA9IHt9O1xuICAgICAgZXhpc3RpbmdTdGF0ZUhvb2submV4dCA9IHtcbiAgICAgICAgbWVtb2l6ZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgICAgIGJhc2VTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICAgICAgcXVldWU6IHtcbiAgICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICAgIGxhbmVzOiAwLFxuICAgICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZVxuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgZm9ybUZpYmVyLm1lbW9pemVkU3RhdGUgPSBleGlzdGluZ1N0YXRlSG9vaztcbiAgICAgIGZvcm1GaWJlciA9IGZvcm1GaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBmb3JtRmliZXIgJiYgKGZvcm1GaWJlci5tZW1vaXplZFN0YXRlID0gZXhpc3RpbmdTdGF0ZUhvb2spO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nU3RhdGVIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0Rm9ybVJlc2V0JDEoZm9ybUZpYmVyKSB7XG4gICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5UICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJyZXF1ZXN0Rm9ybVJlc2V0IHdhcyBjYWxsZWQgb3V0c2lkZSBhIHRyYW5zaXRpb24gb3IgYWN0aW9uLiBUbyBmaXgsIG1vdmUgdG8gYW4gYWN0aW9uLCBvciB3cmFwIHdpdGggc3RhcnRUcmFuc2l0aW9uLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgcmVzZXRTdGF0ZVF1ZXVlID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKS5uZXh0LnF1ZXVlO1xuICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICBmb3JtRmliZXIsXG4gICAgICAgIHJlc2V0U3RhdGVRdWV1ZSxcbiAgICAgICAge30sXG4gICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZvcm1GaWJlcilcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50VHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciBzdGF0ZUhvb2sgPSBtb3VudFN0YXRlSW1wbCghMSk7XG4gICAgICBzdGF0ZUhvb2sgPSBzdGFydFRyYW5zaXRpb24uYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIsXG4gICAgICAgIHN0YXRlSG9vay5xdWV1ZSxcbiAgICAgICAgITAsXG4gICAgICAgICExXG4gICAgICApO1xuICAgICAgbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gc3RhdGVIb29rO1xuICAgICAgcmV0dXJuIFshMSwgc3RhdGVIb29rXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciBib29sZWFuT3JUaGVuYWJsZSA9IHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdLFxuICAgICAgICBzdGFydCA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgICAgPyBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgIDogdXNlVGhlbmFibGUoYm9vbGVhbk9yVGhlbmFibGUpLFxuICAgICAgICBzdGFydFxuICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIGJvb2xlYW5PclRoZW5hYmxlID0gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXSxcbiAgICAgICAgc3RhcnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgID8gYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA6IHVzZVRoZW5hYmxlKGJvb2xlYW5PclRoZW5hYmxlKSxcbiAgICAgICAgc3RhcnRcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzKCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KEhvc3RUcmFuc2l0aW9uQ29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SWQoKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggPSB3b3JrSW5Qcm9ncmVzc1Jvb3QuaWRlbnRpZmllclByZWZpeDtcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICB2YXIgdHJlZUlkID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgICAgICAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICAgICAgICB0cmVlSWQgPVxuICAgICAgICAgIChcbiAgICAgICAgICAgIGlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgKDMyIC0gY2x6MzIoaWRXaXRoTGVhZGluZ0JpdCkgLSAxKSlcbiAgICAgICAgICApLnRvU3RyaW5nKDMyKSArIHRyZWVJZDtcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCA9IFwiXFx1MDBhYlwiICsgaWRlbnRpZmllclByZWZpeCArIFwiUlwiICsgdHJlZUlkO1xuICAgICAgICB0cmVlSWQgPSBsb2NhbElkQ291bnRlcisrO1xuICAgICAgICAwIDwgdHJlZUlkICYmIChpZGVudGlmaWVyUHJlZml4ICs9IFwiSFwiICsgdHJlZUlkLnRvU3RyaW5nKDMyKSk7XG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggKz0gXCJcXHUwMGJiXCI7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHRyZWVJZCA9IGdsb2JhbENsaWVudElkQ291bnRlcisrKSxcbiAgICAgICAgICAoaWRlbnRpZmllclByZWZpeCA9XG4gICAgICAgICAgICBcIlxcdTAwYWJcIiArIGlkZW50aWZpZXJQcmVmaXggKyBcInJcIiArIHRyZWVJZC50b1N0cmluZygzMikgKyBcIlxcdTAwYmJcIik7XG4gICAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGlkZW50aWZpZXJQcmVmaXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFJlZnJlc2goKSB7XG4gICAgICByZXR1cm4gKG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IHJlZnJlc2hDYWNoZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlclxuICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZnJlc2hDYWNoZShmaWJlciwgc2VlZEtleSkge1xuICAgICAgZm9yICh2YXIgcHJvdmlkZXIgPSBmaWJlci5yZXR1cm47IG51bGwgIT09IHByb3ZpZGVyOyApIHtcbiAgICAgICAgc3dpdGNoIChwcm92aWRlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUocHJvdmlkZXIpO1xuICAgICAgICAgICAgZmliZXIgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUocHJvdmlkZXIsIGZpYmVyLCBsYW5lKTtcbiAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBwcm92aWRlciwgbGFuZSksXG4gICAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgcHJvdmlkZXIsIGxhbmUpKTtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gY3JlYXRlQ2FjaGUoKTtcbiAgICAgICAgICAgIG51bGwgIT09IHNlZWRLZXkgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBzZWVkS2V5ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZSBzZWVkIGFyZ3VtZW50IGlzIG5vdCBlbmFibGVkIG91dHNpZGUgZXhwZXJpbWVudGFsIGNoYW5uZWxzLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaWJlci5wYXlsb2FkID0geyBjYWNoZTogcHJvdmlkZXIgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlciA9IHByb3ZpZGVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uKGZpYmVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFyZ3NbM10gJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIHNlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS5cIlxuICAgICAgICApO1xuICAgICAgYXJncyA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGxhbmU6IGFyZ3MsXG4gICAgICAgIHJldmVydExhbmU6IDAsXG4gICAgICAgIGdlc3R1cmU6IG51bGwsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBoYXNFYWdlclN0YXRlOiAhMSxcbiAgICAgICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpXG4gICAgICAgID8gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpXG4gICAgICAgIDogKCh1cGRhdGUgPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGFyZ3MpKSxcbiAgICAgICAgICBudWxsICE9PSB1cGRhdGUgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIodXBkYXRlLCBmaWJlciwgYXJncyksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUodXBkYXRlLCBxdWV1ZSwgYXJncykpKTtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2V0U3RhdGUoZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYXJnc1szXSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLlwiXG4gICAgICAgICk7XG4gICAgICBhcmdzID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKGZpYmVyLCBxdWV1ZSwgYWN0aW9uLCBhcmdzKTtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChmaWJlciwgcXVldWUsIGFjdGlvbiwgbGFuZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgbGFuZTogbGFuZSxcbiAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgZ2VzdHVyZTogbnVsbCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgICAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDAgPT09IGZpYmVyLmxhbmVzICYmXG4gICAgICAgICAgKG51bGwgPT09IGFsdGVybmF0ZSB8fCAwID09PSBhbHRlcm5hdGUubGFuZXMpICYmXG4gICAgICAgICAgKChhbHRlcm5hdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyKSwgbnVsbCAhPT0gYWx0ZXJuYXRlKVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlLFxuICAgICAgICAgICAgICBlYWdlclN0YXRlID0gYWx0ZXJuYXRlKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIHVwZGF0ZS5oYXNFYWdlclN0YXRlID0gITA7XG4gICAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG4gICAgICAgICAgICBpZiAob2JqZWN0SXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIDApLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgICAgICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY3Rpb24gPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICBpZiAobnVsbCAhPT0gYWN0aW9uKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoYWN0aW9uLCBmaWJlciwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUoYWN0aW9uLCBxdWV1ZSwgbGFuZSksXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKFxuICAgICAgZmliZXIsXG4gICAgICB0aHJvd0lmRHVyaW5nUmVuZGVyLFxuICAgICAgcXVldWUsXG4gICAgICBhY3Rpb25cbiAgICApIHtcbiAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgJiZcbiAgICAgICAgMCA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFuIG9wdGltaXN0aWMgc3RhdGUgdXBkYXRlIG9jY3VycmVkIG91dHNpZGUgYSB0cmFuc2l0aW9uIG9yIGFjdGlvbi4gVG8gZml4LCBtb3ZlIHRoZSB1cGRhdGUgdG8gYW4gYWN0aW9uLCBvciB3cmFwIHdpdGggc3RhcnRUcmFuc2l0aW9uLlwiXG4gICAgICAgICk7XG4gICAgICBhY3Rpb24gPSB7XG4gICAgICAgIGxhbmU6IDIsXG4gICAgICAgIHJldmVydExhbmU6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpLFxuICAgICAgICBnZXN0dXJlOiBudWxsLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICAgICAgaWYgKHRocm93SWZEdXJpbmdSZW5kZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIG9wdGltaXN0aWMgc3RhdGUgd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbm5vdCBjYWxsIHN0YXJ0VHJhbnNpdGlvbiB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0aHJvd0lmRHVyaW5nUmVuZGVyID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAyXG4gICAgICAgICkpLFxuICAgICAgICAgIG51bGwgIT09IHRocm93SWZEdXJpbmdSZW5kZXIgJiZcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcih0aHJvd0lmRHVyaW5nUmVuZGVyLCBmaWJlciwgMik7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZmliZXIgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyIHx8XG4gICAgICAgIChudWxsICE9PSBhbHRlcm5hdGUgJiYgYWx0ZXJuYXRlID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlcilcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKSB7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPVxuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITA7XG4gICAgICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG4gICAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICAgID8gKHVwZGF0ZS5uZXh0ID0gdXBkYXRlKVxuICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQpLCAocGVuZGluZy5uZXh0ID0gdXBkYXRlKSk7XG4gICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpIHtcbiAgICAgIGlmICgwICE9PSAobGFuZSAmIDQxOTQwNDgpKSB7XG4gICAgICAgIHZhciBxdWV1ZUxhbmVzID0gcXVldWUubGFuZXM7XG4gICAgICAgIHF1ZXVlTGFuZXMgJj0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAgIGxhbmUgfD0gcXVldWVMYW5lcztcbiAgICAgICAgcXVldWUubGFuZXMgPSBsYW5lO1xuICAgICAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2sgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGtleSA9IFN0cmluZyhjYWxsYmFjayk7XG4gICAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSB8fFxuICAgICAgICAgIChkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLFxuICAgICAgbmV4dFByb3BzXG4gICAgKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlICYmXG4gICAgICAgICgoY3RvciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjdG9yKSB8fFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGN0b3IpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLlwiLFxuICAgICAgICAgICAgY3RvclxuICAgICAgICAgICkpKTtcbiAgICAgIHByZXZTdGF0ZSA9XG4gICAgICAgIG51bGwgPT09IHBhcnRpYWxTdGF0ZSB8fCB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZVxuICAgICAgICAgID8gcHJldlN0YXRlXG4gICAgICAgICAgOiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBwcmV2U3RhdGU7XG4gICAgICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID0gcHJldlN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGN0b3IsXG4gICAgICBvbGRQcm9wcyxcbiAgICAgIG5ld1Byb3BzLFxuICAgICAgb2xkU3RhdGUsXG4gICAgICBuZXdTdGF0ZSxcbiAgICAgIG5leHRDb250ZXh0XG4gICAgKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgIG9sZFByb3BzID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgIG5leHRDb250ZXh0XG4gICAgICAgICk7XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2xkUHJvcHMgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgbmV4dENvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdm9pZCAwID09PSBvbGRQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhIGJvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG9sZFByb3BzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50XG4gICAgICAgID8gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG5leHRDb250ZXh0XG4gICAgKSB7XG4gICAgICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyh3b3JrSW5Qcm9ncmVzcykgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50LmFkZCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKSksXG4gICAgICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIGluc3RhbmNlLnN0YXRlLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gICAgICB2YXIgbmV3UHJvcHMgPSBiYXNlUHJvcHM7XG4gICAgICBpZiAoXCJyZWZcIiBpbiBiYXNlUHJvcHMpIHtcbiAgICAgICAgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gYmFzZVByb3BzKVxuICAgICAgICAgIFwicmVmXCIgIT09IHByb3BOYW1lICYmIChuZXdQcm9wc1twcm9wTmFtZV0gPSBiYXNlUHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIGlmICgoQ29tcG9uZW50ID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcykpIHtcbiAgICAgICAgbmV3UHJvcHMgPT09IGJhc2VQcm9wcyAmJiAobmV3UHJvcHMgPSBhc3NpZ24oe30sIG5ld1Byb3BzKSk7XG4gICAgICAgIGZvciAodmFyIF9wcm9wTmFtZSBpbiBDb21wb25lbnQpXG4gICAgICAgICAgdm9pZCAwID09PSBuZXdQcm9wc1tfcHJvcE5hbWVdICYmXG4gICAgICAgICAgICAobmV3UHJvcHNbX3Byb3BOYW1lXSA9IENvbXBvbmVudFtfcHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdQcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdE9uVW5jYXVnaHRFcnJvcihlcnJvcikge1xuICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIiVzXFxuXFxuJXNcXG5cIixcbiAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgID8gXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPiBjb21wb25lbnQuXCJcbiAgICAgICAgICA6IFwiQW4gZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50cy5cIixcbiAgICAgICAgXCJDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG5WaXNpdCBodHRwczovL3JlYWN0LmRldi9saW5rL2Vycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0T25DYXVnaHRFcnJvcihlcnJvcikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZVxuICAgICAgICAgID8gXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4gY29tcG9uZW50LlwiXG4gICAgICAgICAgOiBcIlRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzLlwiLFxuICAgICAgICByZWNyZWF0ZU1lc3NhZ2UgPVxuICAgICAgICAgIFwiUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggdXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgXCIgK1xuICAgICAgICAgICgoZXJyb3JCb3VuZGFyeU5hbWUgfHwgXCJBbm9ueW1vdXNcIikgKyBcIi5cIik7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IuZW52aXJvbm1lbnROYW1lXG4gICAgICApIHtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGVycm9yLmVudmlyb25tZW50TmFtZTtcbiAgICAgICAgZXJyb3IgPSBbXG4gICAgICAgICAgXCIlb1xcblxcbiVzXFxuXFxuJXNcXG5cIixcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBjb21wb25lbnROYW1lTWVzc2FnZSxcbiAgICAgICAgICByZWNyZWF0ZU1lc3NhZ2VcbiAgICAgICAgXS5zbGljZSgwKTtcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yWzBdXG4gICAgICAgICAgPyBlcnJvci5zcGxpY2UoXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgIGJhZGdlRm9ybWF0ICsgZXJyb3JbMF0sXG4gICAgICAgICAgICAgIGJhZGdlU3R5bGUsXG4gICAgICAgICAgICAgIHBhZCArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCArIHBhZCxcbiAgICAgICAgICAgICAgcmVzZXRTdHlsZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogZXJyb3Iuc3BsaWNlKFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBiYWRnZUZvcm1hdCxcbiAgICAgICAgICAgICAgYmFkZ2VTdHlsZSxcbiAgICAgICAgICAgICAgcGFkICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICsgcGFkLFxuICAgICAgICAgICAgICByZXNldFN0eWxlXG4gICAgICAgICAgICApO1xuICAgICAgICBlcnJvci51bnNoaWZ0KGNvbnNvbGUpO1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBiaW5kLmFwcGx5KGNvbnNvbGUuZXJyb3IsIGVycm9yKTtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIiVvXFxuXFxuJXNcXG5cXG4lc1xcblwiLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWVNZXNzYWdlLFxuICAgICAgICAgIHJlY3JlYXRlTWVzc2FnZVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yKGVycm9yKSB7XG4gICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1VuY2F1Z2h0RXJyb3Iocm9vdCwgZXJyb3JJbmZvKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb21wb25lbnROYW1lID0gZXJyb3JJbmZvLnNvdXJjZVxuICAgICAgICAgID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihlcnJvckluZm8uc291cmNlKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICAgIGlmIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSlcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBvblVuY2F1Z2h0RXJyb3IgPSByb290Lm9uVW5jYXVnaHRFcnJvcjtcbiAgICAgICAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IsIHsgY29tcG9uZW50U3RhY2s6IGVycm9ySW5mby5zdGFjayB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSQ1KSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IGUkNTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ0NhdWdodEVycm9yKHJvb3QsIGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbXBvbmVudE5hbWUgPSBlcnJvckluZm8uc291cmNlXG4gICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGVycm9ySW5mby5zb3VyY2UpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoYm91bmRhcnkpO1xuICAgICAgICB2YXIgb25DYXVnaHRFcnJvciA9IHJvb3Qub25DYXVnaHRFcnJvcjtcbiAgICAgICAgb25DYXVnaHRFcnJvcihlcnJvckluZm8udmFsdWUsIHtcbiAgICAgICAgICBjb21wb25lbnRTdGFjazogZXJyb3JJbmZvLnN0YWNrLFxuICAgICAgICAgIGVycm9yQm91bmRhcnk6IDEgPT09IGJvdW5kYXJ5LnRhZyA/IGJvdW5kYXJ5LnN0YXRlTm9kZSA6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlJDYpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZSQ2O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3QsIGVycm9ySW5mbywgbGFuZSkge1xuICAgICAgbGFuZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgIGxhbmUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgICAgIGxhbmUucGF5bG9hZCA9IHsgZWxlbWVudDogbnVsbCB9O1xuICAgICAgbGFuZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZXJyb3JJbmZvLnNvdXJjZSwgbG9nVW5jYXVnaHRFcnJvciwgcm9vdCwgZXJyb3JJbmZvKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShsYW5lKSB7XG4gICAgICBsYW5lID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgbGFuZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKHVwZGF0ZSwgcm9vdCwgZmliZXIsIGVycm9ySW5mbykge1xuICAgICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcikge1xuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZXJyb3JJbmZvLnNvdXJjZSxcbiAgICAgICAgICAgIGxvZ0NhdWdodEVycm9yLFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgZXJyb3JJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgbnVsbCAhPT0gaW5zdCAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoICYmXG4gICAgICAgICh1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZXJyb3JJbmZvLnNvdXJjZSxcbiAgICAgICAgICAgIGxvZ0NhdWdodEVycm9yLFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgZXJyb3JJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgJiZcbiAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZFxuICAgICAgICAgICAgICA/IChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW3RoaXNdKSlcbiAgICAgICAgICAgICAgOiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQodGhpcykpO1xuICAgICAgICAgIGNhbGxDb21wb25lbnREaWRDYXRjaEluREVWKHRoaXMsIGVycm9ySW5mbyk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgICAoMCA9PT0gKGZpYmVyLmxhbmVzICYgMikgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuIEluIHRoYXQgbWV0aG9kLCByZXR1cm4gYSBzdGF0ZSB1cGRhdGUgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIG9yIGZhbGxiYWNrIFVJLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24oXG4gICAgICByb290LFxuICAgICAgcmV0dXJuRmliZXIsXG4gICAgICBzb3VyY2VGaWJlcixcbiAgICAgIHZhbHVlLFxuICAgICAgcm9vdFJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBzb3VyY2VGaWJlci5mbGFncyB8PSAzMjc2ODtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlLnRoZW5cbiAgICAgICkge1xuICAgICAgICByZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgc291cmNlRmliZXIsXG4gICAgICAgICAgICByb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICAgIGlzSHlkcmF0aW5nICYmIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICEwKTtcbiAgICAgICAgc291cmNlRmliZXIgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgICBpZiAobnVsbCAhPT0gc291cmNlRmliZXIpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNvdXJjZUZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICA/IHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKVxuICAgICAgICAgICAgICAgICAgOiBudWxsID09PSBzb3VyY2VGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgJj0gLTI1NyksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgPSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGVcbiAgICAgICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDE2Mzg0KVxuICAgICAgICAgICAgICAgICAgOiAoKHJldHVybkZpYmVyID0gc291cmNlRmliZXIudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gbmV3IFNldChbdmFsdWVdKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHJldHVybkZpYmVyLmFkZCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlXG4gICAgICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci5mbGFncyB8PSAxNjM4NClcbiAgICAgICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICA/ICgocmV0dXJuRmliZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5UXVldWU6IG5ldyBTZXQoW3ZhbHVlXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gcmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICAgICAgICAgIDogKChzb3VyY2VGaWJlciA9IHJldHVybkZpYmVyLnJldHJ5UXVldWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAocmV0dXJuRmliZXIucmV0cnlRdWV1ZSA9IG5ldyBTZXQoW3ZhbHVlXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogc291cmNlRmliZXIuYWRkKHZhbHVlKSksXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuc2UgaGFuZGxlciB0YWcgKFwiICtcbiAgICAgICAgICAgICAgc291cmNlRmliZXIudGFnICtcbiAgICAgICAgICAgICAgXCIpLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgaWYgKGlzSHlkcmF0aW5nKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICEwKSxcbiAgICAgICAgICAocmV0dXJuRmliZXIgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgPyAoMCA9PT0gKHJldHVybkZpYmVyLmZsYWdzICYgNjU1MzYpICYmIChyZXR1cm5GaWJlci5mbGFncyB8PSAyNTYpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIubGFuZXMgPSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICB2YWx1ZSAhPT0gSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gJiZcbiAgICAgICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGh5ZHJhdGluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSBpbnN0ZWFkIGNsaWVudCByZW5kZXJpbmcgZnJvbSB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeS5cIixcbiAgICAgICAgICAgICAgICAgICAgICB7IGNhdXNlOiB2YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIDogKHZhbHVlICE9PSBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiAmJlxuICAgICAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5IGluc3RlYWQgY2xpZW50IHJlbmRlcmluZyB0aGUgZW50aXJlIHJvb3QuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgeyBjYXVzZTogdmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChyb290ID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgICAgIChyb290LmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyAmPSAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHJvb3QubGFuZXMgfD0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKSksXG4gICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgcm9vdC5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUocm9vdCwgcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQpKSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgdmFyIGVycm9yID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgIEVycm9yKFxuICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIGR1cmluZyBjb25jdXJyZW50IHJlbmRlcmluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSBpbnN0ZWFkIHN5bmNocm9ub3VzbHkgcmVuZGVyaW5nIHRoZSBlbnRpcmUgcm9vdC5cIixcbiAgICAgICAgICB7IGNhdXNlOiB2YWx1ZSB9XG4gICAgICAgICksXG4gICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICApO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9yc1xuICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gW2Vycm9yXSlcbiAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RFcnJvcmVkKTtcbiAgICAgIGlmIChudWxsID09PSByZXR1cm5GaWJlcikgcmV0dXJuICEwO1xuICAgICAgdmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpO1xuICAgICAgc291cmNlRmliZXIgPSByZXR1cm5GaWJlcjtcbiAgICAgIGRvIHtcbiAgICAgICAgc3dpdGNoIChzb3VyY2VGaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAocm9vdCA9IHJvb3RSZW5kZXJMYW5lcyAmIC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgfD0gcm9vdCksXG4gICAgICAgICAgICAgIChyb290ID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKFxuICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyLnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICByb290XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUoc291cmNlRmliZXIsIHJvb3QpLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgocmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci50eXBlKSxcbiAgICAgICAgICAgICAgKGVycm9yID0gc291cmNlRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgMCA9PT0gKHNvdXJjZUZpYmVyLmZsYWdzICYgMTI4KSAmJlxuICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5GaWJlci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAgIChudWxsICE9PSBlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlcnJvci5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAhbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGVycm9yKSkpKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgJj0gLXJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzIHw9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUocm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgICByb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgc291cmNlRmliZXIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHNvdXJjZUZpYmVyLCByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlRmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gICAgICB9IHdoaWxlIChudWxsICE9PSBzb3VyY2VGaWJlcik7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID1cbiAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgID8gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcylcbiAgICAgICAgICA6IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgY3VycmVudC5jaGlsZCxcbiAgICAgICAgICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBDb21wb25lbnQgPSBDb21wb25lbnQucmVuZGVyO1xuICAgICAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgIGlmIChcInJlZlwiIGluIG5leHRQcm9wcykge1xuICAgICAgICB2YXIgcHJvcHNXaXRob3V0UmVmID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBuZXh0UHJvcHMpXG4gICAgICAgICAgXCJyZWZcIiAhPT0ga2V5ICYmIChwcm9wc1dpdGhvdXRSZWZba2V5XSA9IG5leHRQcm9wc1trZXldKTtcbiAgICAgIH0gZWxzZSBwcm9wc1dpdGhvdXRSZWYgPSBuZXh0UHJvcHM7XG4gICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBuZXh0UHJvcHMgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHByb3BzV2l0aG91dFJlZixcbiAgICAgICAgcmVmLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICAgIGtleSA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgIWRpZFJlY2VpdmVVcGRhdGUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICk7XG4gICAgICBpc0h5ZHJhdGluZyAmJiBrZXkgJiYgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgIHZhciB0eXBlID0gQ29tcG9uZW50LnR5cGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgIXNob3VsZENvbnN0cnVjdCh0eXBlKSAmJlxuICAgICAgICAgIHZvaWQgMCA9PT0gdHlwZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICBudWxsID09PSBDb21wb25lbnQuY29tcGFyZVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChDb21wb25lbnQgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRhZyA9IDE1KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50KSxcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSksXG4gICAgICAgICAgICB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgICAgICBDb21wb25lbnQudHlwZSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudCk7XG4gICAgICB9XG4gICAgICB0eXBlID0gY3VycmVudC5jaGlsZDtcbiAgICAgIGlmICghY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIHZhciBwcmV2UHJvcHMgPSB0eXBlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgIENvbXBvbmVudCA9IENvbXBvbmVudC5jb21wYXJlO1xuICAgICAgICBDb21wb25lbnQgPSBudWxsICE9PSBDb21wb25lbnQgPyBDb21wb25lbnQgOiBzaGFsbG93RXF1YWw7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBDb21wb25lbnQocHJldlByb3BzLCBuZXh0UHJvcHMpICYmXG4gICAgICAgICAgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZlxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgY3VycmVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHR5cGUsIG5leHRQcm9wcyk7XG4gICAgICBjdXJyZW50LnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgIGN1cnJlbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiZcbiAgICAgICAgICBjdXJyZW50LnJlZiA9PT0gd29ya0luUHJvZ3Jlc3MucmVmICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gY3VycmVudC50eXBlXG4gICAgICAgIClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoKGRpZFJlY2VpdmVVcGRhdGUgPSAhMSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gbmV4dFByb3BzID0gcHJldlByb3BzKSxcbiAgICAgICAgICAgIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzMTA3MikgJiYgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcyksXG4gICAgICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuLFxuICAgICAgICBwcmV2U3RhdGUgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgICAgIGlmIChcImhpZGRlblwiID09PSBuZXh0UHJvcHMubW9kZSkge1xuICAgICAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSkge1xuICAgICAgICAgIG5leHRQcm9wcyA9XG4gICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICAgICAgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIHwgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgOiByZW5kZXJMYW5lcztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgICAgICAgZm9yIChwcmV2U3RhdGUgPSAwOyBudWxsICE9PSBuZXh0Q2hpbGRyZW47IClcbiAgICAgICAgICAgICAgKHByZXZTdGF0ZSA9XG4gICAgICAgICAgICAgICAgcHJldlN0YXRlIHwgbmV4dENoaWxkcmVuLmxhbmVzIHwgbmV4dENoaWxkcmVuLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgICAgIChuZXh0Q2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW4uc2libGluZyk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gcHJldlN0YXRlICYgfm5leHRQcm9wcztcbiAgICAgICAgICB9IGVsc2UgKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSAwKSwgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCk7XG4gICAgICAgICAgcmV0dXJuIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwICE9PSAocmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpKVxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0geyBiYXNlTGFuZXM6IDAsIGNhY2hlUG9vbDogbnVsbCB9KSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgcHVzaFRyYW5zaXRpb24oXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlID8gcHJldlN0YXRlLmNhY2hlUG9vbCA6IG51bGxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgICAgICAgICA/IHB1c2hIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUpXG4gICAgICAgICAgICAgIDogcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gNTM2ODcwOTEyKSxcbiAgICAgICAgICAgIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgICAgICAgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIHwgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICA6IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgPyAocHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZS5jYWNoZVBvb2wpLFxuICAgICAgICAgICAgcHVzaEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZSksXG4gICAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSlcbiAgICAgICAgICA6IChudWxsICE9PSBjdXJyZW50ICYmIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dEJhc2VMYW5lcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcGVla0NhY2hlRnJvbVBvb2woKTtcbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgIG51bGwgPT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBwYXJlbnQ6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlLFxuICAgICAgICAgICAgICBwb29sOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICBiYXNlTGFuZXM6IG5leHRCYXNlTGFuZXMsXG4gICAgICAgIGNhY2hlUG9vbDogSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsICEwKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgaWYgKG51bGwgPT09IHJlZilcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQucmVmICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQ4MTYpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZWYgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHJlZilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24sIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgdW5kZWZpbmVkL251bGwuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCBjdXJyZW50LnJlZiAhPT0gcmVmKVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQ4MTY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclxuICAgICAgKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgJiZcbiAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAodmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgQ29tcG9uZW50LmNvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICgoY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgICAgICgoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIFJlYWN0LnVzZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKSkpKTtcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIENvbXBvbmVudCA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgICAgbmV4dFByb3BzID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIG5leHRQcm9wcyAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgc2Vjb25kQXJnLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgbmV4dFByb3BzID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4oXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgc2Vjb25kQXJnXG4gICAgICApO1xuICAgICAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgQ29tcG9uZW50ID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIENvbXBvbmVudCAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHN3aXRjaCAoc2hvdWxkRXJyb3JJbXBsKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICBjYXNlICExOlxuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyB3b3JrSW5Qcm9ncmVzcy50eXBlKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICBfaW5zdGFuY2UuY29udGV4dFxuICAgICAgICAgICAgKS5zdGF0ZTtcbiAgICAgICAgICBfaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUoX2luc3RhbmNlLCBzdGF0ZSwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgITA6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4O1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY1NTM2O1xuICAgICAgICAgIF9pbnN0YW5jZSA9IEVycm9yKFwiU2ltdWxhdGVkIGVycm9yIGNvbWluZyBmcm9tIERldlRvb2xzXCIpO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVuZGVyTGFuZXMgJiAtcmVuZGVyTGFuZXM7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgfD0gbGFuZTtcbiAgICAgICAgICBzdGF0ZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gc3RhdGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGFuZSA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUobGFuZSk7XG4gICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICBsYW5lLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKF9pbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGxhbmUpO1xuICAgICAgfVxuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICBzdGF0ZSA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgX2luc3RhbmNlID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBcImNvbnRleHRUeXBlXCIgaW4gQ29tcG9uZW50ICYmXG4gICAgICAgICAgbnVsbCAhPT0gX2luc3RhbmNlICYmXG4gICAgICAgICAgKHZvaWQgMCA9PT0gX2luc3RhbmNlIHx8IF9pbnN0YW5jZS4kJHR5cGVvZiAhPT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSAmJlxuICAgICAgICAgICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKENvbXBvbmVudCkgJiZcbiAgICAgICAgICAoZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIChsYW5lID1cbiAgICAgICAgICAgIHZvaWQgMCA9PT0gX2luc3RhbmNlXG4gICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gdHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLlwiXG4gICAgICAgICAgICAgIDogXCJvYmplY3RcIiAhPT0gdHlwZW9mIF9pbnN0YW5jZVxuICAgICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgXCIgKyB0eXBlb2YgX2luc3RhbmNlICsgXCIuXCJcbiAgICAgICAgICAgICAgICA6IF9pbnN0YW5jZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRVxuICAgICAgICAgICAgICAgICAgPyBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/XCJcbiAgICAgICAgICAgICAgICAgIDogXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMge1wiICtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX2luc3RhbmNlKS5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIn0uXCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXNcIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCIsXG4gICAgICAgICAgICBsYW5lXG4gICAgICAgICAgKSk7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfaW5zdGFuY2UgJiZcbiAgICAgICAgICBudWxsICE9PSBfaW5zdGFuY2UgJiZcbiAgICAgICAgICAoc3RhdGUgPSByZWFkQ29udGV4dChfaW5zdGFuY2UpKTtcbiAgICAgICAgX2luc3RhbmNlID0gbmV3IENvbXBvbmVudChuZXh0UHJvcHMsIHN0YXRlKTtcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KG5leHRQcm9wcywgc3RhdGUpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgbnVsbCAhPT0gX2luc3RhbmNlLnN0YXRlICYmIHZvaWQgMCAhPT0gX2luc3RhbmNlLnN0YXRlXG4gICAgICAgICAgICA/IF9pbnN0YW5jZS5zdGF0ZVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBfaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlO1xuICAgICAgICBfaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxzID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIF9pbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gZmFrZUludGVybmFsSW5zdGFuY2U7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICBudWxsID09PSBzdGF0ZSAmJlxuICAgICAgICAgICgoc3RhdGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKHN0YXRlKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoc3RhdGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5IGFzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiBUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuXCIsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBudWxsID09PSBfaW5zdGFuY2Uuc3RhdGUgPyBcIm51bGxcIiA6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICApKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gKGxhbmUgPSBzdGF0ZSA9IG51bGwpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAhMCAhPT0gX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICA/IChzdGF0ZSA9IFwiY29tcG9uZW50V2lsbE1vdW50XCIpXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgIChzdGF0ZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFwiKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICEwICE9PVxuICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgPyAobGFuZSA9IFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKVxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgICAobGFuZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIik7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAhMCAhPT0gX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgPyAoZm91bmRXaWxsVXBkYXRlTmFtZSA9IFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiKVxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlXCIpO1xuICAgICAgICAgIGlmIChudWxsICE9PSBzdGF0ZSB8fCBudWxsICE9PSBsYW5lIHx8IG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWUpIHtcbiAgICAgICAgICAgIF9pbnN0YW5jZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICB2YXIgbmV3QXBpTmFtZSA9XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcbiAgICAgICAgICAgICAgICA/IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKClcIlxuICAgICAgICAgICAgICAgIDogXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfaW5zdGFuY2UpIHx8XG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfaW5zdGFuY2UpLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcblRoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbmh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzXCIsXG4gICAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gc3RhdGUgPyBcIlxcbiAgXCIgKyBzdGF0ZSA6IFwiXCIsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbGFuZSA/IFwiXFxuICBcIiArIGxhbmUgOiBcIlwiLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWUgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogXCJcIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBzdGF0ZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgIF9pbnN0YW5jZS5yZW5kZXIgfHxcbiAgICAgICAgICAoQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyXG4gICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yP1wiLFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIk5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLlwiLFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAhX2luc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fFxuICAgICAgICAgIF9pbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHxcbiAgICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgfHxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD9cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLmdldERlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgICFfaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLmNvbnRleHRUeXBlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgIWRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmhhcyhDb21wb25lbnQpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjaGlsZENvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICkpO1xuICAgICAgICBDb21wb25lbnQuY29udGV4dFR5cGVzICYmXG4gICAgICAgICAgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmhhcyhDb21wb25lbnQpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggc3RhdGljIGNvbnRleHRUeXBlIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlICYmXG4gICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJlxuICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiBQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQSBwdXJlIGNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgdXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgcnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIGxhbmUgPSBfaW5zdGFuY2UucHJvcHMgIT09IG5leHRQcm9wcztcbiAgICAgICAgdm9pZCAwICE9PSBfaW5zdGFuY2UucHJvcHMgJiZcbiAgICAgICAgICBsYW5lICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgdXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuXCIsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoQ29tcG9uZW50KSB8fFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKENvbXBvbmVudCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KVxuICAgICAgICAgICkpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgKGxhbmUgPSBfaW5zdGFuY2Uuc3RhdGUpICYmXG4gICAgICAgICAgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBsYW5lIHx8IGlzQXJyYXlJbXBsKGxhbmUpKSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIlcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGxcIiwgc3RhdGUpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICYmXG4gICAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX2luc3RhbmNlLnJlZnMgPSB7fTtcbiAgICAgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgc3RhdGUgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIF9pbnN0YW5jZS5jb250ZXh0ID1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygc3RhdGUgJiYgbnVsbCAhPT0gc3RhdGVcbiAgICAgICAgICAgID8gcmVhZENvbnRleHQoc3RhdGUpXG4gICAgICAgICAgICA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID09PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgICAoKHN0YXRlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKHN0YXRlKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChzdGF0ZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlIGJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIEluIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgcHJvcHMgZGlyZWN0bHkuXCIsXG4gICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICApKSk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmXG4gICAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIF9pbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIF9pbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBzdGF0ZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHN0YXRlICYmXG4gICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICksXG4gICAgICAgICAgKF9pbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCkgfHxcbiAgICAgICAgICAoKHN0YXRlID0gX2luc3RhbmNlLnN0YXRlKSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgc3RhdGUgIT09IF9pbnN0YW5jZS5zdGF0ZSAmJlxuICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoXG4gICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLnN0YXRlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgX2luc3RhbmNlLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpLFxuICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KTtcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMzQyMTc3MjgpO1xuICAgICAgICBfaW5zdGFuY2UgPSAhMDtcbiAgICAgIH0gZWxzZSBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgICBsYW5lID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCB1bnJlc29sdmVkT2xkUHJvcHMpO1xuICAgICAgICBfaW5zdGFuY2UucHJvcHMgPSBsYW5lO1xuICAgICAgICB2YXIgb2xkQ29udGV4dCA9IF9pbnN0YW5jZS5jb250ZXh0O1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBzdGF0ZSA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGZvdW5kV2lsbFVwZGF0ZU5hbWUgJiZcbiAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lICYmXG4gICAgICAgICAgKHN0YXRlID0gcmVhZENvbnRleHQoZm91bmRXaWxsVXBkYXRlTmFtZSkpO1xuICAgICAgICBuZXdBcGlOYW1lID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3QXBpTmFtZSB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcbiAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzICE9PSB1bnJlc29sdmVkT2xkUHJvcHM7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgfHxcbiAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgfHxcbiAgICAgICAgICAoKHVucmVzb2x2ZWRPbGRQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBzdGF0ZSkgJiZcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICApKTtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICAgICAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBfaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgICAgICBvbGRDb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzIHx8IG9sZFN0YXRlICE9PSBvbGRDb250ZXh0IHx8IGhhc0ZvcmNlVXBkYXRlXG4gICAgICAgICAgPyAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3QXBpTmFtZSAmJlxuICAgICAgICAgICAgICAoYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChvbGRDb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpLFxuICAgICAgICAgICAgKGxhbmUgPVxuICAgICAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgbGFuZSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICAgICAgb2xkQ29udGV4dCxcbiAgICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA/IChmb3VuZFdpbGxVcGRhdGVOYW1lIHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCkgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKSxcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCkpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMzQyMTc3MjgpKVxuICAgICAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTM0MjE3NzI4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBvbGRDb250ZXh0KSksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSBvbGRDb250ZXh0KSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UuY29udGV4dCA9IHN0YXRlKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSBsYW5lKSlcbiAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTM0MjE3NzI4KSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSAhMSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCBzdGF0ZSk7XG4gICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IGZvdW5kV2lsbFVwZGF0ZU5hbWU7XG4gICAgICAgIG5ld0FwaU5hbWUgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIG9sZFN0YXRlID0gX2luc3RhbmNlLmNvbnRleHQ7XG4gICAgICAgIG9sZENvbnRleHQgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIGxhbmUgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvbGRDb250ZXh0ICYmXG4gICAgICAgICAgbnVsbCAhPT0gb2xkQ29udGV4dCAmJlxuICAgICAgICAgIChsYW5lID0gcmVhZENvbnRleHQob2xkQ29udGV4dCkpO1xuICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICAob2xkQ29udGV4dCA9XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdW5yZXNvbHZlZE9sZFByb3BzIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKSB8fFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB8fFxuICAgICAgICAgICgoc3RhdGUgIT09IG5ld0FwaU5hbWUgfHwgb2xkU3RhdGUgIT09IGxhbmUpICYmXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICBsYW5lXG4gICAgICAgICAgICApKTtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICAgICAgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIF9pbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHN0YXRlICE9PSBuZXdBcGlOYW1lIHx8XG4gICAgICAgIG9sZFN0YXRlICE9PSBuZXdTdGF0ZSB8fFxuICAgICAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQuZGVwZW5kZW5jaWVzICYmXG4gICAgICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQuZGVwZW5kZW5jaWVzKSlcbiAgICAgICAgICA/IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1bnJlc29sdmVkT2xkUHJvcHMgJiZcbiAgICAgICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKSxcbiAgICAgICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lID1cbiAgICAgICAgICAgICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgICAgICAgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQuZGVwZW5kZW5jaWVzICYmXG4gICAgICAgICAgICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQuZGVwZW5kZW5jaWVzKSkpXG4gICAgICAgICAgICAgID8gKG9sZENvbnRleHQgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXdTdGF0ZSwgbGFuZSksXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lXG4gICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSlcbiAgICAgICAgICAgICAgOiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGUpKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UuY29udGV4dCA9IGxhbmUpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZSA9IGZvdW5kV2lsbFVwZGF0ZU5hbWUpKVxuICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gITEpKTtcbiAgICAgIH1cbiAgICAgIGxhbmUgPSBfaW5zdGFuY2U7XG4gICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHN0YXRlID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KTtcbiAgICAgIGlmIChsYW5lIHx8IHN0YXRlKSB7XG4gICAgICAgIGxhbmUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmIChzdGF0ZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKVxuICAgICAgICAgIChDb21wb25lbnQgPSBudWxsKSwgKHByb2ZpbGVyU3RhcnRUaW1lID0gLTEpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgQ29tcG9uZW50ID0gY2FsbFJlbmRlckluREVWKGxhbmUpO1xuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2FsbFJlbmRlckluREVWKGxhbmUpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgc3RhdGVcbiAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSkpXG4gICAgICAgICAgOiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBsYW5lLnN0YXRlO1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICB9IGVsc2VcbiAgICAgICAgY3VycmVudCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApO1xuICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBfaW5zdGFuY2UgJiZcbiAgICAgICAgcmVuZGVyTGFuZXMucHJvcHMgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkl0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJhIGNvbXBvbmVudFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMCkpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDI1NjtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAgICAgIENvbXBvbmVudCAmJlxuICAgICAgICBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LlxcbiAgJXMuY2hpbGRDb250ZXh0VHlwZXMgPSAuLi5cIixcbiAgICAgICAgICBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICApO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W3dvcmtJblByb2dyZXNzXSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuXCIsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbd29ya0luUHJvZ3Jlc3NdID1cbiAgICAgICAgICAgICEwKSkpO1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIENvbXBvbmVudC5jb250ZXh0VHlwZSAmJlxuICAgICAgICBudWxsICE9PSBDb21wb25lbnQuY29udGV4dFR5cGUgJiZcbiAgICAgICAgKChDb21wb25lbnQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIlVua25vd25cIiksXG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtDb21wb25lbnRdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLlwiLFxuICAgICAgICAgICAgQ29tcG9uZW50XG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W0NvbXBvbmVudF0gPSAhMCkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG4gICAgICByZXR1cm4geyBiYXNlTGFuZXM6IHJlbmRlckxhbmVzLCBjYWNoZVBvb2w6IGdldFN1c3BlbmRlZENhY2hlKCkgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICBjdXJyZW50LFxuICAgICAgcHJpbWFyeVRyZWVEaWREZWZlcixcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQuY2hpbGRMYW5lcyAmIH5yZW5kZXJMYW5lcyA6IDA7XG4gICAgICBwcmltYXJ5VHJlZURpZERlZmVyICYmIChjdXJyZW50IHw9IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfZGlnZXN0XzI0NDY7XG4gICAgICB2YXIgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDcgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICBzaG91bGRTdXNwZW5kSW1wbCh3b3JrSW5Qcm9ncmVzcykgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCk7XG4gICAgICB2YXIgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzI0NDggPSAhMTtcbiAgICAgIHZhciBkaWRTdXNwZW5kID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KTtcbiAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfZGlnZXN0XzI0NDYgPSBkaWRTdXNwZW5kKSB8fFxuICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yNDQ2ID1cbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyAhMVxuICAgICAgICAgICAgOiAwICE9PSAoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICYgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSk7XG4gICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfZGlnZXN0XzI0NDYgJiZcbiAgICAgICAgKChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OCA9ICEwKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xMjkpKTtcbiAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0NiA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDMyKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0zMztcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4XG4gICAgICAgICAgICA/IHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgIDogcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1ID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAgICAgICBpZiAoIShKU0NvbXBpbGVyX3RlbXAgPSAhSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSkpIHtcbiAgICAgICAgICAgICAgYzoge1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzI0NDU7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IHJvb3RPclNpbmdsZXRvbkNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICA4ICE9PSBpbnN0YW5jZS5ub2RlVHlwZTtcblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFKU0NvbXBpbGVyX3RlbXApIHtcbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoaW5zdGFuY2UubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcFxuICAgICAgICAgICAgICAgID8gKHdhcm5JZk5vdEh5ZHJhdGluZygpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRlaHlkcmF0ZWQ6IEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgICAgICAgICAgICAgdHJlZUNvbnRleHQ6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gdHJlZUNvbnRleHRQcm92aWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGlkOiB0cmVlQ29udGV4dElkLCBvdmVyZmxvdzogdHJlZUNvbnRleHRPdmVyZmxvdyB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJldHJ5TGFuZTogNTM2ODcwOTEyLFxuICAgICAgICAgICAgICAgICAgICBoeWRyYXRpb25FcnJvcnM6IG51bGxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgKGluc3RhbmNlID0gY3JlYXRlRmliZXIoMTgsIG51bGwsIG51bGwsIE5vTW9kZSkpLFxuICAgICAgICAgICAgICAgICAgKGluc3RhbmNlLnN0YXRlTm9kZSA9IEpTQ29tcGlsZXJfdGVtcCksXG4gICAgICAgICAgICAgICAgICAoaW5zdGFuY2UucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSAhMCkpXG4gICAgICAgICAgICAgICAgOiAoSlNDb21waWxlcl90ZW1wID0gITEpO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSAhSlNDb21waWxlcl90ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wICYmXG4gICAgICAgICAgICAgICh3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1ICYmXG4gICAgICAgICAgICAoKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzI0NDUgPVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1LmRlaHlkcmF0ZWQpLFxuICAgICAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1KVxuICAgICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLmxhbmVzID0gMzIpXG4gICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA1MzY4NzA5MTIpLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSA9XG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDcuY2hpbGRyZW47XG4gICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3ID1cbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0Ny5mYWxsYmFjaztcbiAgICAgICAgaWYgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4KVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4ID1cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSA9XG4gICAgICAgICAgICAgIG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBtb2RlOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzI0NDVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3LFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzI0NDUucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3LnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1LnNpYmxpbmcgPVxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0NyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1KSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OCA9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OC5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzI0NDguY2hpbGRMYW5lcyA9XG4gICAgICAgICAgICAgIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yNDQ2LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3XG4gICAgICAgICAgKTtcbiAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlICYmXG4gICAgICAgICgoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkKSxcbiAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSlcbiAgICAgICkge1xuICAgICAgICBpZiAoZGlkU3VzcGVuZClcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NlxuICAgICAgICAgICAgPyAocHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0yNTcpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgOiBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gKHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbnVsbCkpXG4gICAgICAgICAgICAgIDogKHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4ID1cbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3LmZhbGxiYWNrKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0NyA9XG4gICAgICAgICAgICAgICAgICBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInZpc2libGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDcuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4ID1cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OCxcbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OC5mbGFncyB8PSAyKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDcucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OC5yZXR1cm4gPVxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0Ny5zaWJsaW5nID1cbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0NyksXG4gICAgICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0NyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDcubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDcuY2hpbGRMYW5lcyA9XG4gICAgICAgICAgICAgICAgICBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yNDQ2LFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzI0NDgpKTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiV2Ugc2hvdWxkIG5vdCBiZSBoeWRyYXRpbmcgaGVyZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYSBidWcuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSkpXG4gICAgICAgICkge1xuICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0NiA9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1Lm5leHRTaWJsaW5nICYmXG4gICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1Lm5leHRTaWJsaW5nLmRhdGFzZXQ7XG4gICAgICAgICAgaWYgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0Nikge1xuICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID0gSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yNDQ2LmRnc3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0Ni5tc2c7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0Ni5zdGNrO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yNDQ2LmNzdGNrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1ID0gbWVzc2FnZTtcbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfZGlnZXN0XzI0NDYgPSBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDcgPSBpbnN0YW5jZTtcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OCA9XG4gICAgICAgICAgICBjb21wb25lbnRTdGFjaztcbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OCA9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1XG4gICAgICAgICAgICAgID8gRXJyb3IoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSlcbiAgICAgICAgICAgICAgOiBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhlIHNlcnZlciBjb3VsZCBub3QgZmluaXNoIHRoaXMgU3VzcGVuc2UgYm91bmRhcnksIGxpa2VseSBkdWUgdG8gYW4gZXJyb3IgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuIFN3aXRjaGVkIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4LnN0YWNrID1cbiAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3IHx8IFwiXCI7XG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzI0NDguZGlnZXN0ID1cbiAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0NjtcbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfZGlnZXN0XzI0NDYgPVxuICAgICAgICAgICAgdm9pZCAwID09PSBKU0NvbXBpbGVyX3RlbXAgPyBudWxsIDogSlNDb21waWxlcl90ZW1wO1xuICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3ID0ge1xuICAgICAgICAgICAgdmFsdWU6IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4LFxuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgc3RhY2s6IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0NlxuICAgICAgICAgIH07XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0NiAmJlxuICAgICAgICAgICAgQ2FwdHVyZWRTdGFja3Muc2V0KFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OCxcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0Nyk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSB8fFxuICAgICAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0NiA9XG4gICAgICAgICAgICAwICE9PSAocmVuZGVyTGFuZXMgJiBjdXJyZW50LmNoaWxkTGFuZXMpKSxcbiAgICAgICAgICBkaWRSZWNlaXZlVXBkYXRlIHx8IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0NilcbiAgICAgICAgKSB7XG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yNDQ2ID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgIT09IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0NiAmJlxuICAgICAgICAgICAgKChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0NyA9IHJlbmRlckxhbmVzICYgLXJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0NyA9XG4gICAgICAgICAgICAgIDAgIT09IChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0NyAmIDQyKVxuICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgIDogZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbkJ5TGFuZShcbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDdcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3ID1cbiAgICAgICAgICAgICAgMCAhPT1cbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3ICZcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yNDQ2LnN1c3BlbmRlZExhbmVzIHxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzKSlcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3KSxcbiAgICAgICAgICAgIDAgIT09IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3ICYmXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3ICE9PSBwcmV2U3RhdGUucmV0cnlMYW5lKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgKChwcmV2U3RhdGUucmV0cnlMYW5lID0gSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDcpLFxuICAgICAgICAgICAgICBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0N1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yNDQ2LFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDdcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1LmRhdGEgPT09XG4gICAgICAgICAgICBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgfHwgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzI0NDUuZGF0YSA9PT1cbiAgICAgICAgICBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEFcbiAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxOTIpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbnVsbCkpXG4gICAgICAgICAgICA6ICgoY3VycmVudCA9IHByZXZTdGF0ZS50cmVlQ29udGV4dCksXG4gICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NS5uZXh0U2libGluZ1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAoaXNIeWRyYXRpbmcgPSAhMCksXG4gICAgICAgICAgICAgIChoeWRyYXRpb25FcnJvcnMgPSBudWxsKSxcbiAgICAgICAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gITEpLFxuICAgICAgICAgICAgICAoaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsKSxcbiAgICAgICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAod2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZCksXG4gICAgICAgICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdyksXG4gICAgICAgICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlciksXG4gICAgICAgICAgICAgICAgKHRyZWVDb250ZXh0SWQgPSBjdXJyZW50LmlkKSxcbiAgICAgICAgICAgICAgICAodHJlZUNvbnRleHRPdmVyZmxvdyA9IGN1cnJlbnQub3ZlcmZsb3cpLFxuICAgICAgICAgICAgICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3MpKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0Ny5jaGlsZHJlblxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQwOTYpKTtcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4KVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4ID1cbiAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3LmZhbGxiYWNrKSxcbiAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAoaW5zdGFuY2UgPSBKU0NvbXBpbGVyX3RlbXAuc2libGluZyksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoXG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1vZGU6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0Ny5jaGlsZHJlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICkpLFxuICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0Ny5zdWJ0cmVlRmxhZ3MgPVxuICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLnN1YnRyZWVGbGFncyAmIDY1MDExNzEyKSxcbiAgICAgICAgICBudWxsICE9PSBpbnN0YW5jZVxuICAgICAgICAgICAgPyAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzI0NDggPVxuICAgICAgICAgICAgICAgIGNyZWF0ZVdvcmtJblByb2dyZXNzKFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OFxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6ICgoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzI0NDggPVxuICAgICAgICAgICAgICAgIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2NvbXBvbmVudFN0YWNrXzI0NDgsXG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1LFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OC5mbGFncyB8PSAyKSksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4LnJldHVybiA9XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9zdGFja18yNDQ3LnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAoSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDcuc2libGluZyA9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDcpLFxuICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0NyA9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OCksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgIChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1ID0gY3VycmVudC5jaGlsZC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICBudWxsID09PSBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1XG4gICAgICAgICAgICA/IChKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1ID1cbiAgICAgICAgICAgICAgICBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKVxuICAgICAgICAgICAgOiAoKEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NS5jYWNoZVBvb2wpLFxuICAgICAgICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICAgICAgICA/ICgoaW5zdGFuY2UgPSBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLnBhcmVudCAhPT0gaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICA/IHsgcGFyZW50OiBpbnN0YW5jZSwgcG9vbDogaW5zdGFuY2UgfVxuICAgICAgICAgICAgICAgICAgICAgIDogSlNDb21waWxlcl90ZW1wKSlcbiAgICAgICAgICAgICAgICA6IChKU0NvbXBpbGVyX3RlbXAgPSBnZXRTdXNwZW5kZWRDYWNoZSgpKSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9tZXNzYWdlXzI0NDUgPSB7XG4gICAgICAgICAgICAgICAgYmFzZUxhbmVzOlxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICBjYWNoZVBvb2w6IEpTQ29tcGlsZXJfdGVtcFxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4Lm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX21lc3NhZ2VfMjQ0NSksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9jb21wb25lbnRTdGFja18yNDQ4LmNoaWxkTGFuZXMgPVxuICAgICAgICAgICAgZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0NixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgICAgSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDdcbiAgICAgICAgKTtcbiAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZW5kZXJMYW5lcyA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICBjdXJyZW50ID0gcmVuZGVyTGFuZXMuc2libGluZztcbiAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIHtcbiAgICAgICAgbW9kZTogXCJ2aXNpYmxlXCIsXG4gICAgICAgIGNoaWxkcmVuOiBKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfc3RhY2tfMjQ0Ny5jaGlsZHJlblxuICAgICAgfSk7XG4gICAgICByZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAoKEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0NiA9IHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyksXG4gICAgICAgIG51bGwgPT09IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0NlxuICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBbY3VycmVudF0pLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2KSlcbiAgICAgICAgICA6IEpTQ29tcGlsZXJfb2JqZWN0X2lubGluZV9kaWdlc3RfMjQ0Ni5wdXNoKGN1cnJlbnQpKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyTGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIHJldHVybiByZW5kZXJMYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuKSB7XG4gICAgICBwcmltYXJ5Q2hpbGRyZW4gPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgICAgIHsgbW9kZTogXCJ2aXNpYmxlXCIsIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW4gfSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZVxuICAgICAgKTtcbiAgICAgIHByaW1hcnlDaGlsZHJlbi5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRyZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIob2Zmc2NyZWVuUHJvcHMsIG1vZGUpIHtcbiAgICAgIG9mZnNjcmVlblByb3BzID0gY3JlYXRlRmliZXIoMjIsIG9mZnNjcmVlblByb3BzLCBudWxsLCBtb2RlKTtcbiAgICAgIG9mZnNjcmVlblByb3BzLmxhbmVzID0gMDtcbiAgICAgIG9mZnNjcmVlblByb3BzLnN0YXRlTm9kZSA9IHtcbiAgICAgICAgX3Zpc2liaWxpdHk6IE9mZnNjcmVlblZpc2libGUsXG4gICAgICAgIF9wZW5kaW5nTWFya2VyczogbnVsbCxcbiAgICAgICAgX3JldHJ5Q2FjaGU6IG51bGwsXG4gICAgICAgIF90cmFuc2l0aW9uczogbnVsbFxuICAgICAgfTtcbiAgICAgIHJldHVybiBvZmZzY3JlZW5Qcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgICAgIGN1cnJlbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuXG4gICAgICApO1xuICAgICAgY3VycmVudC5mbGFncyB8PSAyO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGZpYmVyLCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KSB7XG4gICAgICBmaWJlci5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5sYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgICBmaWJlci5yZXR1cm4sXG4gICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICBwcm9wYWdhdGlvblJvb3RcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRTbG90LCBpbmRleCkge1xuICAgICAgdmFyIGlzQW5BcnJheSA9IGlzQXJyYXlJbXBsKGNoaWxkU2xvdCk7XG4gICAgICBjaGlsZFNsb3QgPSAhaXNBbkFycmF5ICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldEl0ZXJhdG9yRm4oY2hpbGRTbG90KTtcbiAgICAgIHJldHVybiBpc0FuQXJyYXkgfHwgY2hpbGRTbG90XG4gICAgICAgID8gKChpc0FuQXJyYXkgPSBpc0FuQXJyYXkgPyBcImFycmF5XCIgOiBcIml0ZXJhYmxlXCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkEgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluIGFuIGFkZGl0aW9uYWwgU3VzcGVuc2VMaXN0IHRvIGNvbmZpZ3VyZSBpdHMgcmV2ZWFsT3JkZXI6IDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPiAuLi4gPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gPC9TdXNwZW5zZUxpc3Q+XCIsXG4gICAgICAgICAgICBpc0FuQXJyYXksXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGlzQW5BcnJheVxuICAgICAgICAgICksXG4gICAgICAgICAgITEpXG4gICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgaXNCYWNrd2FyZHMsXG4gICAgICB0YWlsLFxuICAgICAgbGFzdENvbnRlbnRSb3csXG4gICAgICB0YWlsTW9kZVxuICAgICkge1xuICAgICAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIG51bGwgPT09IHJlbmRlclN0YXRlXG4gICAgICAgID8gKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICAgICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICAgICAgICByZW5kZXJpbmdTdGFydFRpbWU6IDAsXG4gICAgICAgICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgICAgICAgIHRhaWw6IHRhaWwsXG4gICAgICAgICAgICB0YWlsTW9kZTogdGFpbE1vZGVcbiAgICAgICAgICB9KVxuICAgICAgICA6ICgocmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcyksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGwpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSAwKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93KSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUudGFpbCA9IHRhaWwpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS50YWlsTW9kZSA9IHRhaWxNb2RlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgIHJldmVhbE9yZGVyID0gbmV4dFByb3BzLnJldmVhbE9yZGVyLFxuICAgICAgICB0YWlsTW9kZSA9IG5leHRQcm9wcy50YWlsO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKFxuICAgICAgICB2b2lkIDAgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwiZm9yd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgXCJiYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgXCJ0b2dldGhlclwiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICAhZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdXG4gICAgICApXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKGRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSA9ICEwKSxcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcmV2ZWFsT3JkZXIpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0b2dldGhlclwiOlxuICAgICAgICAgICAgY2FzZSBcImZvcndhcmRzXCI6XG4gICAgICAgICAgICBjYXNlIFwiYmFja3dhcmRzXCI6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gVXNlIGxvd2VyY2FzZSBcIiVzXCIgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZm9yd2FyZFwiOlxuICAgICAgICAgICAgY2FzZSBcImJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gUmVhY3QgdXNlcyB0aGUgLXMgc3VmZml4IGluIHRoZSBzcGVsbGluZy4gVXNlIFwiJXNzXCIgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIERpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsXG4gICAgICAgICAgICAgICAgcmV2ZWFsT3JkZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJyVzIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JyxcbiAgICAgICAgICAgIHJldmVhbE9yZGVyXG4gICAgICAgICAgKTtcbiAgICAgIHZvaWQgMCA9PT0gdGFpbE1vZGUgfHxcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdIHx8XG4gICAgICAgIChcImNvbGxhcHNlZFwiICE9PSB0YWlsTW9kZSAmJiBcImhpZGRlblwiICE9PSB0YWlsTW9kZVxuICAgICAgICAgID8gKChkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgdGFpbCBvbiA8U3VzcGVuc2VMaXN0IC8+LiBEaWQgeW91IG1lYW4gXCJjb2xsYXBzZWRcIiBvciBcImhpZGRlblwiPycsXG4gICAgICAgICAgICAgIHRhaWxNb2RlXG4gICAgICAgICAgICApKVxuICAgICAgICAgIDogXCJmb3J3YXJkc1wiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICAgICAgXCJiYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgICAgICgoZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJzxTdXNwZW5zZUxpc3QgdGFpbD1cIiVzXCIgLz4gaXMgb25seSB2YWxpZCBpZiByZXZlYWxPcmRlciBpcyBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIi4gRGlkIHlvdSBtZWFuIHRvIHNwZWNpZnkgcmV2ZWFsT3JkZXI9XCJmb3J3YXJkc1wiPycsXG4gICAgICAgICAgICAgIHRhaWxNb2RlXG4gICAgICAgICAgICApKSk7XG4gICAgICBhOiBpZiAoXG4gICAgICAgIChcImZvcndhcmRzXCIgPT09IHJldmVhbE9yZGVyIHx8IFwiYmFja3dhcmRzXCIgPT09IHJldmVhbE9yZGVyKSAmJlxuICAgICAgICB2b2lkIDAgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICBudWxsICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgITEgIT09IG5leHRQcm9wc1xuICAgICAgKVxuICAgICAgICBpZiAoaXNBcnJheUltcGwobmV4dFByb3BzKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKG5leHRQcm9wc1tpXSwgaSkpIGJyZWFrIGE7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKGkgPSBnZXRJdGVyYXRvckZuKG5leHRQcm9wcykpLCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpKSkge1xuICAgICAgICAgIGlmICgoaSA9IGkuY2FsbChuZXh0UHJvcHMpKSlcbiAgICAgICAgICAgIGZvciAodmFyIHN0ZXAgPSBpLm5leHQoKSwgX2kgPSAwOyAhc3RlcC5kb25lOyBzdGVwID0gaS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKHN0ZXAudmFsdWUsIF9pKSkgYnJlYWsgYTtcbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHNpbmdsZSByb3cgd2FzIHBhc3NlZCB0byBhIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9XCIlc1wiIC8+LiBUaGlzIGlzIG5vdCB1c2VmdWwgc2luY2UgaXQgbmVlZHMgbXVsdGlwbGUgcm93cy4gRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JyxcbiAgICAgICAgICAgIHJldmVhbE9yZGVyXG4gICAgICAgICAgKTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIG5leHRQcm9wcyA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgIGlmICgwICE9PSAobmV4dFByb3BzICYgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSlcbiAgICAgICAgKG5leHRQcm9wcyA9XG4gICAgICAgICAgKG5leHRQcm9wcyAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSB8IEZvcmNlU3VzcGVuc2VGYWxsYmFjayksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMjgpKVxuICAgICAgICAgIGE6IGZvciAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBjdXJyZW50OyApIHtcbiAgICAgICAgICAgIGlmICgxMyA9PT0gY3VycmVudC50YWcpXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKDE5ID09PSBjdXJyZW50LnRhZylcbiAgICAgICAgICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGN1cnJlbnQsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBlbHNlIGlmIChudWxsICE9PSBjdXJyZW50LmNoaWxkKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQucmV0dXJuID0gY3VycmVudDtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHdvcmtJblByb2dyZXNzKSBicmVhayBhO1xuICAgICAgICAgICAgZm9yICg7IG51bGwgPT09IGN1cnJlbnQuc2libGluZzsgKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50LnJldHVybiB8fCBjdXJyZW50LnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudC5zaWJsaW5nLnJldHVybiA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIG5leHRQcm9wcyAmPSBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaztcbiAgICAgIH1cbiAgICAgIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgbmV4dFByb3BzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyKSB7XG4gICAgICAgIGNhc2UgXCJmb3J3YXJkc1wiOlxuICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgZm9yIChyZXZlYWxPcmRlciA9IG51bGw7IG51bGwgIT09IHJlbmRlckxhbmVzOyApXG4gICAgICAgICAgICAoY3VycmVudCA9IHJlbmRlckxhbmVzLmFsdGVybmF0ZSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkgJiZcbiAgICAgICAgICAgICAgICAocmV2ZWFsT3JkZXIgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcpO1xuICAgICAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgICAgbnVsbCA9PT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICAgID8gKChyZXZlYWxPcmRlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCkpXG4gICAgICAgICAgICA6ICgocmV2ZWFsT3JkZXIgPSByZW5kZXJMYW5lcy5zaWJsaW5nKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsKSk7XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAhMSxcbiAgICAgICAgICAgIHJldmVhbE9yZGVyLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiYWNrd2FyZHNcIjpcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IG51bGw7XG4gICAgICAgICAgcmV2ZWFsT3JkZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICBmb3IgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDsgbnVsbCAhPT0gcmV2ZWFsT3JkZXI7ICkge1xuICAgICAgICAgICAgY3VycmVudCA9IHJldmVhbE9yZGVyLmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgPT09IGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50KSkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJldmVhbE9yZGVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSByZXZlYWxPcmRlci5zaWJsaW5nO1xuICAgICAgICAgICAgcmV2ZWFsT3JkZXIuc2libGluZyA9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSByZXZlYWxPcmRlcjtcbiAgICAgICAgICAgIHJldmVhbE9yZGVyID0gY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAhMCxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRhaWxNb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvZ2V0aGVyXCI6XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCAhMSwgbnVsbCwgbnVsbCwgdm9pZCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcyk7XG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IHdvcmtJblByb2dyZXNzLmxhbmVzO1xuICAgICAgaWYgKDAgPT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKVxuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIDAgPT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgcmVuZGVyTGFuZXMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBjdXJyZW50LnBlbmRpbmdQcm9wcyk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIGZvciAocmVuZGVyTGFuZXMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7IG51bGwgIT09IGN1cnJlbnQuc2libGluZzsgKVxuICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcgPVxuICAgICAgICAgICAgICBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBjdXJyZW50LnBlbmRpbmdQcm9wcykpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVuZGVyTGFuZXMuc2libGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gICAgICBpZiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykpIHJldHVybiAhMDtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICAgIHJldHVybiBudWxsICE9PSBjdXJyZW50ICYmIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50KSA/ICEwIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICApO1xuICAgICAgICAgIHB1c2hQcm92aWRlcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ2FjaGVDb250ZXh0LFxuICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDg7XG4gICAgICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAtMDtcbiAgICAgICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGVOb2RlKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGVOb2RlLmRlaHlkcmF0ZWQpXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGQuY2hpbGRMYW5lcykpXG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgY3VycmVudCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5zaWJsaW5nIDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KTtcbiAgICAgICAgICBzdGF0ZU5vZGUgPSAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtcbiAgICAgICAgICBzdGF0ZU5vZGUgfHxcbiAgICAgICAgICAgIChwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChzdGF0ZU5vZGUgPSAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSkpO1xuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGVOb2RlKVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlkU3VzcGVuZEJlZm9yZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgbnVsbCAhPT0gZGlkU3VzcGVuZEJlZm9yZSAmJlxuICAgICAgICAgICAgKChkaWRTdXNwZW5kQmVmb3JlLnJlbmRlcmluZyA9IG51bGwpLFxuICAgICAgICAgICAgKGRpZFN1c3BlbmRCZWZvcmUudGFpbCA9IG51bGwpLFxuICAgICAgICAgICAgKGRpZFN1c3BlbmRCZWZvcmUubGFzdEVmZmVjdCA9IG51bGwpKTtcbiAgICAgICAgICBwdXNoKFxuICAgICAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoc3RhdGVOb2RlKSBicmVhaztcbiAgICAgICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwKSxcbiAgICAgICAgICAgIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENhY2hlQ29udGV4dCxcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmVuZGVyTGFuZXMgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5rZXksXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyIHx8IG51bGwsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lc1xuICAgICAgICApO1xuICAgICAgICByZW5kZXJMYW5lcy5fZGVidWdTdGFjayA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1N0YWNrO1xuICAgICAgICByZW5kZXJMYW5lcy5fZGVidWdUYXNrID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnVGFzaztcbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICBpZiAobnVsbCA9PT0gcmV0dXJuRmliZXIpIHRocm93IEVycm9yKFwiQ2Fubm90IHN3YXAgdGhlIHJvb3QgZmliZXIuXCIpO1xuICAgICAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIHJlbmRlckxhbmVzLmluZGV4ID0gd29ya0luUHJvZ3Jlc3MuaW5kZXg7XG4gICAgICAgIHJlbmRlckxhbmVzLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuICAgICAgICByZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIHJlbmRlckxhbmVzLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgICAgcmVuZGVyTGFuZXMuX2RlYnVnSW5mbyA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm87XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gcmV0dXJuRmliZXIuY2hpbGQpXG4gICAgICAgICAgcmV0dXJuRmliZXIuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZTaWJsaW5nID0gcmV0dXJuRmliZXIuY2hpbGQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHByZXZTaWJsaW5nKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCBwYXJlbnQgdG8gaGF2ZSBhIGNoaWxkLlwiKTtcbiAgICAgICAgICBmb3IgKDsgcHJldlNpYmxpbmcuc2libGluZyAhPT0gd29ya0luUHJvZ3Jlc3M7IClcbiAgICAgICAgICAgIGlmICgoKHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuc2libGluZyksIG51bGwgPT09IHByZXZTaWJsaW5nKSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCB0byBmaW5kIHRoZSBwcmV2aW91cyBzaWJsaW5nLlwiKTtcbiAgICAgICAgICBwcmV2U2libGluZy5zaWJsaW5nID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgPyAoKHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjdXJyZW50XSksIChyZXR1cm5GaWJlci5mbGFncyB8PSAxNikpXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICByZW5kZXJMYW5lcy5mbGFncyB8PSAyO1xuICAgICAgICByZXR1cm4gcmVuZGVyTGFuZXM7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudClcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzIHx8XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gY3VycmVudC50eXBlXG4gICAgICAgIClcbiAgICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gITA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykgJiZcbiAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgICAgICAgYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzMTA3MikgPyAhMCA6ICExO1xuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9ICExO1xuICAgICAgICBpZiAoKHJldHVybkZpYmVyID0gaXNIeWRyYXRpbmcpKVxuICAgICAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTA0ODU3NikpO1xuICAgICAgICByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICgocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5pbmRleCksXG4gICAgICAgICAgd2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgdHJlZUZvcmtDb3VudCwgcmV0dXJuRmliZXIpKTtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gMDtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgYTogaWYgKFxuICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAoY3VycmVudCA9IGNhbGxMYXp5SW5pdEluREVWKHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudClcbiAgICAgICAgICApXG4gICAgICAgICAgICBzaG91bGRDb25zdHJ1Y3QoY3VycmVudClcbiAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudGFnID0gMSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50KSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3MudGFnID0gMCksXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQpKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSkpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50KVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IGN1cnJlbnQuJCR0eXBlb2YpLFxuICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxMTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2U2libGluZyA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gMTQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gXCJcIjtcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgY3VycmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgICAgICAgXCIgRGlkIHlvdSB3cmFwIGEgY29tcG9uZW50IGluIFJlYWN0LmxhenkoKSBtb3JlIHRoYW4gb25jZT9cIik7XG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN1cnJlbnQpIHx8IGN1cnJlbnQ7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZC4gUmVjZWl2ZWQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG86IFwiICtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICtcbiAgICAgICAgICAgICAgICBcIi4gTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIgK1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBwcmV2U2libGluZyA9IHByZXZTdGF0ZS5lbGVtZW50O1xuICAgICAgICAgICAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHJldHVybkZpYmVyLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gbmV4dFN0YXRlLmNhY2hlO1xuICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBwcmV2U3RhdGUuY2FjaGUgJiZcbiAgICAgICAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgW0NhY2hlQ29udGV4dF0sXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAocHJldlN0YXRlLmlzRGVoeWRyYXRlZClcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgocHJldlN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBpc0RlaHlkcmF0ZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgY2FjaGU6IG5leHRTdGF0ZS5jYWNoZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBwcmV2U3RhdGUpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlN0YXRlKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0dXJuRmliZXIgIT09IHByZXZTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgcHJldlNpYmxpbmcgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgcm9vdCByZWNlaXZlZCBhbiBlYXJseSB1cGRhdGUsIGJlZm9yZSBhbnl0aGluZyB3YXMgYWJsZSBoeWRyYXRlLiBTd2l0Y2hlZCB0aGUgZW50aXJlIHJvb3QgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKHByZXZTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Lm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICAgICAgXCJIVE1MXCIgPT09IGN1cnJlbnQubm9kZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY3VycmVudC5vd25lckRvY3VtZW50LmJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKGN1cnJlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgICBpc0h5ZHJhdGluZyA9ICEwO1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMTtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGw7XG4gICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICEwO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBtb3VudENoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZm9yICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQ7IGN1cnJlbnQ7IClcbiAgICAgICAgICAgICAgICAgIChjdXJyZW50LmZsYWdzID0gKGN1cnJlbnQuZmxhZ3MgJiAtMykgfCA0MDk2KSxcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgICAgICBpZiAocmV0dXJuRmliZXIgPT09IHByZXZTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAoY3VycmVudCA9IGdldFJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudClcbiAgICAgICAgICAgICAgICA6IGlzSHlkcmF0aW5nIHx8XG4gICAgICAgICAgICAgICAgICAoKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZXF1aXJlZENvbnRleHQoXG4gICAgICAgICAgICAgICAgICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID1cbiAgICAgICAgICAgICAgICAgICAgZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICkuY3JlYXRlRWxlbWVudChjdXJyZW50KSksXG4gICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXJbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXJbaW50ZXJuYWxQcm9wc0tleV0gPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhyZXR1cm5GaWJlciwgY3VycmVudCwgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShyZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gcmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gZ2V0UmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KSksXG4gICAgICAgICAgICAgIChwcmV2U2libGluZyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPVxuICAgICAgICAgICAgICAgIHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgfHxcbiAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKHdvcmtJblByb2dyZXNzLCAwKS5zZXJ2ZXJQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nKSksXG4gICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMCksXG4gICAgICAgICAgICAgIChwcmV2U2libGluZyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgICBpc1NpbmdsZXRvblNjb3BlKHdvcmtJblByb2dyZXNzLnR5cGUpXG4gICAgICAgICAgICAgICAgPyAoKHByZXZpb3VzSHlkcmF0YWJsZU9uRW50ZXJpbmdTY29wZWRTaW5nbGV0b24gPSBwcmV2U2libGluZyksXG4gICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdENoaWxkXG4gICAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgICA6IChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gcHJldlNpYmxpbmcpKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwNCksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgICAoKHByZXZTdGF0ZSA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB2YWxpZGF0ZURPTU5lc3RpbmcoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICBwcmV2U3RhdGUuYW5jZXN0b3JJbmZvXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAocHJldlNpYmxpbmcgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSxcbiAgICAgICAgICAgICAgKG5leHRTdGF0ZSA9ICFwcmV2U2libGluZykgfHxcbiAgICAgICAgICAgICAgICAoKG5leHRTdGF0ZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0U3RhdGVcbiAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXh0U3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViB8fFxuICAgICAgICAgICAgICAgICAgICAgICgocHJldlN0YXRlID0gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2U3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKHdvcmtJblByb2dyZXNzLCAwKS5zZXJ2ZXJQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTdGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmZpcnN0Q2hpbGRcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEpLFxuICAgICAgICAgICAgICAgICAgICAocHJldlN0YXRlID0gITApKVxuICAgICAgICAgICAgICAgICAgOiAocHJldlN0YXRlID0gITEpLFxuICAgICAgICAgICAgICAgIChuZXh0U3RhdGUgPSAhcHJldlN0YXRlKSksXG4gICAgICAgICAgICAgIG5leHRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgICAgICAgd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKSksXG4gICAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgICAgICAocHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIChuZXh0U3RhdGUgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSBwcmV2U3RhdGUuY2hpbGRyZW4pLFxuICAgICAgICAgICAgc2hvdWxkU2V0VGV4dENvbnRlbnQocHJldlNpYmxpbmcsIHByZXZTdGF0ZSlcbiAgICAgICAgICAgICAgPyAocmV0dXJuRmliZXIgPSBudWxsKVxuICAgICAgICAgICAgICA6IG51bGwgIT09IG5leHRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNob3VsZFNldFRleHRDb250ZW50KHByZXZTaWJsaW5nLCBuZXh0U3RhdGUpICYmXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDMyKSxcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIFRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUgPSBwcmV2U2libGluZykpLFxuICAgICAgICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGlzSHlkcmF0aW5nICYmXG4gICAgICAgICAgICAgICgoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZW5kZXJMYW5lcy5hbmNlc3RvckluZm8uY3VycmVudCksXG4gICAgICAgICAgICAgIChjdXJyZW50ID1cbiAgICAgICAgICAgICAgICBudWxsICE9IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICA/IHZhbGlkYXRlVGV4dE5lc3RpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci50YWcsXG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMuYW5jZXN0b3JJbmZvLmltcGxpY2l0Um9vdFNjb3BlXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogITApLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gIXJlbmRlckxhbmVzKSB8fFxuICAgICAgICAgICAgICAgICgocmV0dXJuRmliZXIgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gITApKVxuICAgICAgICAgICAgICAgICAgOiAocmV0dXJuRmliZXIgPSAhMSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gIXJldHVybkZpYmVyKSksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICAgICAgKGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKSkpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyLmVmZmVjdER1cmF0aW9uID0gLTApLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IC0wKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgKHByZXZTdGF0ZSA9IHByZXZTaWJsaW5nLnZhbHVlKSxcbiAgICAgICAgICAgIFwidmFsdWVcIiBpbiBwcmV2U2libGluZyB8fFxuICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciB8fFxuICAgICAgICAgICAgICAoKGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhlIGB2YWx1ZWAgcHJvcCBpcyByZXF1aXJlZCBmb3IgdGhlIGA8Q29udGV4dC5Qcm92aWRlcj5gLiBEaWQgeW91IG1pc3NwZWxsIGl0IG9yIGZvcmdldCB0byBwYXNzIGl0P1wiXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCByZXR1cm5GaWJlciwgcHJldlN0YXRlKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgdGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCB0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC5cIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gcmVhZENvbnRleHQocHJldlNpYmxpbmcpKSxcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGNhbGxDb21wb25lbnRJbkRFVihcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICB2b2lkIDBcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0ge1xuICAgICAgICAgICAgICBtb2RlOiByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogcmV0dXJuRmliZXIuY2hpbGRyZW5cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICA/ICgoY3VycmVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWYpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50KSlcbiAgICAgICAgICAgICAgOiAoKGN1cnJlbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LmNoaWxkLCByZXR1cm5GaWJlcikpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50LnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZiksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudCksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQpKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHJlYWRDb250ZXh0KENhY2hlQ29udGV4dCkpLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICA/ICgocHJldlNpYmxpbmcgPSBwZWVrQ2FjaGVGcm9tUG9vbCgpKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBwcmV2U2libGluZyAmJlxuICAgICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzUm9vdCksXG4gICAgICAgICAgICAgICAgICAocHJldlN0YXRlID0gY3JlYXRlQ2FjaGUoKSksXG4gICAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcucG9vbGVkQ2FjaGUgPSBwcmV2U3RhdGUpLFxuICAgICAgICAgICAgICAgICAgcmV0YWluQ2FjaGUocHJldlN0YXRlKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcucG9vbGVkQ2FjaGVMYW5lcyB8PSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcgPSBwcmV2U3RhdGUpKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudDogcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBjYWNoZTogcHJldlNpYmxpbmdcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBwcmV2U2libGluZykpXG4gICAgICAgICAgICAgIDogKDAgIT09IChjdXJyZW50LmxhbmVzICYgcmVuZGVyTGFuZXMpICYmXG4gICAgICAgICAgICAgICAgICAoY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG51bGwsIG51bGwsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKSksXG4gICAgICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gY3VycmVudC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgICAgICAocHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICAgICAgcHJldlNpYmxpbmcucGFyZW50ICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgPyAoKHByZXZTaWJsaW5nID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gd29ya0luUHJvZ3Jlc3MubGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2U2libGluZyksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCByZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgICAgICA6ICgocmV0dXJuRmliZXIgPSBwcmV2U3RhdGUuY2FjaGUpLFxuICAgICAgICAgICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciAhPT0gcHJldlNpYmxpbmcuY2FjaGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgW0NhY2hlQ29udGV4dF0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgICAgICAgKSkpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgIHRocm93IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgK1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyArXG4gICAgICAgICAgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHR5cGUsXG4gICAgICBvbGRQcm9wcyxcbiAgICAgIG5ld1Byb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmICgodHlwZSA9ICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3VzcGVuc2V5SW1hZ2VzTW9kZSkgIT09IE5vTW9kZSkpXG4gICAgICAgIHR5cGUgPSAhMTtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2Nzc3MjE2KSxcbiAgICAgICAgICAocmVuZGVyTGFuZXMgJiAzMzU1NDQxMjgpID09PSByZW5kZXJMYW5lcylcbiAgICAgICAgKVxuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29tcGxldGUpIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTI7XG4gICAgICAgICAgZWxzZSBpZiAoc2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbigpKSB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgKChzdXNwZW5kZWRUaGVuYWJsZSA9IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSksXG4gICAgICAgICAgICAgIFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICB9IGVsc2Ugd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTE2Nzc3MjE3O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHJlc291cmNlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIFwic3R5bGVzaGVldFwiICE9PSByZXNvdXJjZS50eXBlIHx8XG4gICAgICAgIChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nICYgSW5zZXJ0ZWQpICE9PSBOb3RMb2FkZWRcbiAgICAgIClcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTE2Nzc3MjE3O1xuICAgICAgZWxzZSBpZiAoKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxNjc3NzIxNiksICFwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpKSlcbiAgICAgICAgaWYgKHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSkgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICgoc3VzcGVuZGVkVGhlbmFibGUgPSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUpLFxuICAgICAgICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uKVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJldHJ5UXVldWUpIHtcbiAgICAgIG51bGwgIT09IHJldHJ5UXVldWUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxNjM4NCAmJlxuICAgICAgICAoKHJldHJ5UXVldWUgPVxuICAgICAgICAgIDIyICE9PSB3b3JrSW5Qcm9ncmVzcy50YWcgPyBjbGFpbU5leHRSZXRyeUxhbmUoKSA6IDUzNjg3MDkxMiksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyB8PSByZXRyeVF1ZXVlKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyB8PSByZXRyeVF1ZXVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG4gICAgICBpZiAoIWlzSHlkcmF0aW5nKVxuICAgICAgICBzd2l0Y2ggKHJlbmRlclN0YXRlLnRhaWxNb2RlKSB7XG4gICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgICAgIGZvciAodmFyIGxhc3RUYWlsTm9kZSA9IG51bGw7IG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjazsgKVxuICAgICAgICAgICAgICBudWxsICE9PSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2suYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgKGxhc3RUYWlsTm9kZSA9IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayksXG4gICAgICAgICAgICAgICAgKGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayA9IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5zaWJsaW5nKTtcbiAgICAgICAgICAgIG51bGwgPT09IGxhc3RUYWlsTm9kZVxuICAgICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS50YWlsID0gbnVsbClcbiAgICAgICAgICAgICAgOiAobGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjb2xsYXBzZWRcIjpcbiAgICAgICAgICAgIGxhc3RUYWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGFzdFRhaWxOb2RlID0gbnVsbDsgbnVsbCAhPT0gbGFzdFRhaWxOb2RlOyApXG4gICAgICAgICAgICAgIG51bGwgIT09IGxhc3RUYWlsTm9kZS5hbHRlcm5hdGUgJiYgKF9sYXN0VGFpbE5vZGUgPSBsYXN0VGFpbE5vZGUpLFxuICAgICAgICAgICAgICAgIChsYXN0VGFpbE5vZGUgPSBsYXN0VGFpbE5vZGUuc2libGluZyk7XG4gICAgICAgICAgICBudWxsID09PSBfbGFzdFRhaWxOb2RlXG4gICAgICAgICAgICAgID8gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrIHx8IG51bGwgPT09IHJlbmRlclN0YXRlLnRhaWxcbiAgICAgICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS50YWlsID0gbnVsbClcbiAgICAgICAgICAgICAgICA6IChyZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsKVxuICAgICAgICAgICAgICA6IChfbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBidWJibGVQcm9wZXJ0aWVzKGNvbXBsZXRlZFdvcmspIHtcbiAgICAgIHZhciBkaWRCYWlsb3V0ID1cbiAgICAgICAgICBudWxsICE9PSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkLFxuICAgICAgICBuZXdDaGlsZExhbmVzID0gMCxcbiAgICAgICAgc3VidHJlZUZsYWdzID0gMDtcbiAgICAgIGlmIChkaWRCYWlsb3V0KVxuICAgICAgICBpZiAoKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbixcbiAgICAgICAgICAgICAgX2NoaWxkMiA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG4gICAgICAgICAgICBudWxsICE9PSBfY2hpbGQyO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD0gX2NoaWxkMi5sYW5lcyB8IF9jaGlsZDIuY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkMi5zdWJ0cmVlRmxhZ3MgJiA2NTAxMTcxMiksXG4gICAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkMi5mbGFncyAmIDY1MDExNzEyKSxcbiAgICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uICs9IF9jaGlsZDIudHJlZUJhc2VEdXJhdGlvbiksXG4gICAgICAgICAgICAgIChfY2hpbGQyID0gX2NoaWxkMi5zaWJsaW5nKTtcbiAgICAgICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgICAgICAgICAgIG51bGwgIT09IF90cmVlQmFzZUR1cmF0aW9uO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD1cbiAgICAgICAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24ubGFuZXMgfCBfdHJlZUJhc2VEdXJhdGlvbi5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5zdWJ0cmVlRmxhZ3MgJiA2NTAxMTcxMiksXG4gICAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX3RyZWVCYXNlRHVyYXRpb24uZmxhZ3MgJiA2NTAxMTcxMiksXG4gICAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbi5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrKSxcbiAgICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb24uc2libGluZyk7XG4gICAgICBlbHNlIGlmICgoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICBfY2hpbGQyID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgICBmb3IgKHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7IG51bGwgIT09IGNoaWxkOyApXG4gICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD0gY2hpbGQubGFuZXMgfCBjaGlsZC5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuc3VidHJlZUZsYWdzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuZmxhZ3MpLFxuICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSxcbiAgICAgICAgICAgIChfY2hpbGQyICs9IGNoaWxkLnRyZWVCYXNlRHVyYXRpb24pLFxuICAgICAgICAgICAgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gX2NoaWxkMjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgICAgICAgICBudWxsICE9PSBfdHJlZUJhc2VEdXJhdGlvbjtcblxuICAgICAgICApXG4gICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD1cbiAgICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uLmxhbmVzIHwgX3RyZWVCYXNlRHVyYXRpb24uY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLnN1YnRyZWVGbGFncyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLmZsYWdzKSxcbiAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbi5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrKSxcbiAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uLnNpYmxpbmcpO1xuICAgICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICAgICAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbiAgICAgIHJldHVybiBkaWRCYWlsb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDMxOlxuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgKG5ld1Byb3BzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpO1xuICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJlbmRlckxhbmVzLnBlbmRpbmdDb250ZXh0ICYmXG4gICAgICAgICAgICAoKHJlbmRlckxhbmVzLmNvbnRleHQgPSByZW5kZXJMYW5lcy5wZW5kaW5nQ29udGV4dCksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQgPSBudWxsKSk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgbnVsbCA9PT0gY3VycmVudC5jaGlsZClcbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA/IChlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCksIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKVxuICAgICAgICAgICAgICA6IG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgICAoY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCAmJlxuICAgICAgICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KSkgfHxcbiAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpLFxuICAgICAgICAgICAgICAgIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCkpO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgPyAobWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZVxuICAgICAgICAgICAgICAgID8gKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgIDogbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgID8gbmV4dFJlc291cmNlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgICA/IChtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNykpXG4gICAgICAgICAgICAgIDogKChjdXJyZW50ID0gY3VycmVudC5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50ICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICAgICAgICB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA/IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpXG4gICAgICAgICAgICAgIDogKChjdXJyZW50ID0gcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudCksXG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAocG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKVxuICAgICAgICAgICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBfY3VycmVudEhvc3RDb250ZXh0KTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyh0eXBlLCBfY3VycmVudEhvc3RDb250ZXh0LmFuY2VzdG9ySW5mbyk7XG4gICAgICAgICAgICAgIF9jdXJyZW50SG9zdENvbnRleHQgPSBfY3VycmVudEhvc3RDb250ZXh0LmNvbnRleHQ7XG4gICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihuZXh0UmVzb3VyY2UpO1xuICAgICAgICAgICAgICBzd2l0Y2ggKF9jdXJyZW50SG9zdENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RDb250ZXh0TmFtZXNwYWNlU3ZnOlxuICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlID0gbmV4dFJlc291cmNlLmNyZWF0ZUVsZW1lbnROUyhcbiAgICAgICAgICAgICAgICAgICAgU1ZHX05BTUVTUEFDRSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgSG9zdENvbnRleHROYW1lc3BhY2VNYXRoOlxuICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlID0gbmV4dFJlc291cmNlLmNyZWF0ZUVsZW1lbnROUyhcbiAgICAgICAgICAgICAgICAgICAgTUFUSF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSBuZXh0UmVzb3VyY2UuY3JlYXRlRWxlbWVudE5TKFxuICAgICAgICAgICAgICAgICAgICAgICAgU1ZHX05BTUVTUEFDRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9IG5leHRSZXNvdXJjZS5jcmVhdGVFbGVtZW50TlMoXG4gICAgICAgICAgICAgICAgICAgICAgICBNQVRIX05BTUVTUEFDRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlID0gbmV4dFJlc291cmNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLmlubmVySFRNTCA9IFwiPHNjcmlwdD5cXHgzYy9zY3JpcHQ+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlID0gbmV4dFJlc291cmNlLnJlbW92ZUNoaWxkKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLmZpcnN0Q2hpbGRcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdQcm9wcy5pc1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5leHRSZXNvdXJjZS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzOiBuZXdQcm9wcy5pc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV4dFJlc291cmNlLmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMubXVsdGlwbGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKG5leHRSZXNvdXJjZS5tdWx0aXBsZSA9ICEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXdQcm9wcy5zaXplICYmIChuZXh0UmVzb3VyY2Uuc2l6ZSA9IG5ld1Byb3BzLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld1Byb3BzLmlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV4dFJlc291cmNlLmNyZWF0ZUVsZW1lbnQodHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXM6IG5ld1Byb3BzLmlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXh0UmVzb3VyY2UuY3JlYXRlRWxlbWVudCh0eXBlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAtMSA9PT0gdHlwZS5pbmRleE9mKFwiLVwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSAhPT0gdHlwZS50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuIFVzZSBQYXNjYWxDYXNlIGZvciBSZWFjdCBjb21wb25lbnRzLCBvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF1cIiAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV4dFJlc291cmNlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwod2FybmVkVW5rbm93blRhZ3MsIHR5cGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCBhbiB1cHBlcmNhc2UgbGV0dGVyLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXh0UmVzb3VyY2VbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgbmV4dFJlc291cmNlW2ludGVybmFsUHJvcHNLZXldID0gbmV3UHJvcHM7XG4gICAgICAgICAgICAgIGE6IGZvciAoXG4gICAgICAgICAgICAgICAgX2N1cnJlbnRIb3N0Q29udGV4dCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgIG51bGwgIT09IF9jdXJyZW50SG9zdENvbnRleHQ7XG5cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgNSA9PT0gX2N1cnJlbnRIb3N0Q29udGV4dC50YWcgfHxcbiAgICAgICAgICAgICAgICAgIDYgPT09IF9jdXJyZW50SG9zdENvbnRleHQudGFnXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLmFwcGVuZENoaWxkKF9jdXJyZW50SG9zdENvbnRleHQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgIDQgIT09IF9jdXJyZW50SG9zdENvbnRleHQudGFnICYmXG4gICAgICAgICAgICAgICAgICAyNyAhPT0gX2N1cnJlbnRIb3N0Q29udGV4dC50YWcgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IF9jdXJyZW50SG9zdENvbnRleHQuY2hpbGRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIF9jdXJyZW50SG9zdENvbnRleHQuY2hpbGQucmV0dXJuID0gX2N1cnJlbnRIb3N0Q29udGV4dDtcbiAgICAgICAgICAgICAgICAgIF9jdXJyZW50SG9zdENvbnRleHQgPSBfY3VycmVudEhvc3RDb250ZXh0LmNoaWxkO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfY3VycmVudEhvc3RDb250ZXh0ID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gX2N1cnJlbnRIb3N0Q29udGV4dC5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gX2N1cnJlbnRIb3N0Q29udGV4dC5yZXR1cm4gfHxcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRIb3N0Q29udGV4dC5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICBfY3VycmVudEhvc3RDb250ZXh0ID0gX2N1cnJlbnRIb3N0Q29udGV4dC5yZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jdXJyZW50SG9zdENvbnRleHQuc2libGluZy5yZXR1cm4gPSBfY3VycmVudEhvc3RDb250ZXh0LnJldHVybjtcbiAgICAgICAgICAgICAgICBfY3VycmVudEhvc3RDb250ZXh0ID0gX2N1cnJlbnRIb3N0Q29udGV4dC5zaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5leHRSZXNvdXJjZTtcbiAgICAgICAgICAgICAgYTogc3dpdGNoIChcbiAgICAgICAgICAgICAgICAoc2V0SW5pdGlhbFByb3BlcnRpZXMobmV4dFJlc291cmNlLCB0eXBlLCBuZXdQcm9wcyksIHR5cGUpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgICAgICAgICAgICBuZXdQcm9wcyA9ICEhbmV3UHJvcHMuYXV0b0ZvY3VzO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgICAgICAgICAgICBuZXdQcm9wcyA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSAhMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCA/IG51bGwgOiBjdXJyZW50Lm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50ID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIHR5cGUgPSAhZGlkU3VzcGVuZE9yRXJyb3JERVY7XG4gICAgICAgICAgICAgIG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgICAgbmV4dFJlc291cmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSBuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChuZXh0UmVzb3VyY2UudGFnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoKHR5cGUgPSBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKHdvcmtJblByb2dyZXNzLCAwKS5zZXJ2ZXJQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSBuZXh0UmVzb3VyY2UubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCh0eXBlID0gZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICkuc2VydmVyUHJvcHMgPSB0eXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50W2ludGVybmFsSW5zdGFuY2VLZXldID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgIGN1cnJlbnQubm9kZVZhbHVlID09PSByZW5kZXJMYW5lcyB8fFxuICAgICAgICAgICAgICAgIChudWxsICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgITAgPT09IG5ld1Byb3BzLnN1cHByZXNzSHlkcmF0aW9uV2FybmluZykgfHxcbiAgICAgICAgICAgICAgICBjaGVja0ZvclVubWF0Y2hlZFRleHQoY3VycmVudC5ub2RlVmFsdWUsIHJlbmRlckxhbmVzKVxuICAgICAgICAgICAgICAgICAgPyAhMFxuICAgICAgICAgICAgICAgICAgOiAhMTtcbiAgICAgICAgICAgICAgY3VycmVudCB8fCB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MsICEwKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAodHlwZSA9IHJlbmRlckxhbmVzLmFuY2VzdG9ySW5mby5jdXJyZW50KSxcbiAgICAgICAgICAgICAgICBudWxsICE9IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRlVGV4dE5lc3RpbmcoXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICB0eXBlLnRhZyxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMuYW5jZXN0b3JJbmZvLmltcGxpY2l0Um9vdFNjb3BlXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChjdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihjdXJyZW50KS5jcmVhdGVUZXh0Tm9kZShcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50W2ludGVybmFsSW5zdGFuY2VLZXldID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmRlaHlkcmF0ZWQpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0eXBlID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IG5ld1Byb3BzICYmIG51bGwgIT09IG5ld1Byb3BzLmRlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJBIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IHdhcyBjb21wbGV0ZWQgd2l0aG91dCBhIGh5ZHJhdGVkIG5vZGUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IG51bGwgIT09IHR5cGUgPyB0eXBlLmRlaHlkcmF0ZWQgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0eXBlW2ludGVybmFsSW5zdGFuY2VLZXldID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICgodHlwZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gdHlwZS50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKSxcbiAgICAgICAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSxcbiAgICAgICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAoKHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZS50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgIHR5cGUgPSAhMTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAodHlwZSA9IHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCkpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgKGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5oeWRyYXRpb25FcnJvcnMgPSB0eXBlKSxcbiAgICAgICAgICAgICAgICAodHlwZSA9ICEwKTtcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IG51bGwgIT09IG5ld1Byb3BzO1xuICAgICAgICAgIGN1cnJlbnQgPSBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKChuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICh0eXBlID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgICh0eXBlID0gbmV3UHJvcHMuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgKG5leHRSZXNvdXJjZSA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlID0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICBuZXh0UmVzb3VyY2UgIT09IHR5cGUgJiYgKG5ld1Byb3BzLmZsYWdzIHw9IDIwNDgpKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZC5mbGFncyB8PSA4MTkyKTtcbiAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICgoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdHlwZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHR5cGUpIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgICBuZXdQcm9wcyA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCk7XG4gICAgICAgICAgbmV4dFJlc291cmNlID0gdHlwZS5yZW5kZXJpbmc7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5leHRSZXNvdXJjZSlcbiAgICAgICAgICAgIGlmIChuZXdQcm9wcykgY3V0T2ZmVGFpbElmTmVlZGVkKHR5cGUsICExKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdEluUHJvZ3Jlc3MgfHxcbiAgICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiAwICE9PSAoY3VycmVudC5mbGFncyAmIDEyOCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBmb3IgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gY3VycmVudDsgKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gbmV4dFJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHR5cGUsICExKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHRSZXNvdXJjZS51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXMuc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgICAgICAgICAgICAgICAoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICZcbiAgICAgICAgICAgICAgICAgICAgICAgIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICBGb3JjZVN1c3BlbnNlRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG51bGwgIT09IHR5cGUudGFpbCAmJlxuICAgICAgICAgICAgICAgIG5vdyQxKCkgPiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQodHlwZSwgITEpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDQxOTQzMDQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbmV3UHJvcHMpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKGN1cnJlbnQgPSBmaW5kRmlyc3RTdXNwZW5kZWQobmV4dFJlc291cmNlKSksIG51bGwgIT09IGN1cnJlbnQpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHR5cGUsICEwKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IHR5cGUudGFpbCAmJlxuICAgICAgICAgICAgICAgICAgICBcImhpZGRlblwiID09PSB0eXBlLnRhaWxNb2RlICYmXG4gICAgICAgICAgICAgICAgICAgICFuZXh0UmVzb3VyY2UuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0h5ZHJhdGluZylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIDIgKiBub3ckMSgpIC0gdHlwZS5yZW5kZXJpbmdTdGFydFRpbWUgPlxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSAmJlxuICAgICAgICAgICAgICAgICAgNTM2ODcwOTEyICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgICAgKG5ld1Byb3BzID0gITApLFxuICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHR5cGUsICExKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDQxOTQzMDQpKTtcbiAgICAgICAgICAgIHR5cGUuaXNCYWNrd2FyZHNcbiAgICAgICAgICAgICAgPyAoKG5leHRSZXNvdXJjZS5zaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRSZXNvdXJjZSkpXG4gICAgICAgICAgICAgIDogKChjdXJyZW50ID0gdHlwZS5sYXN0KSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgICA/IChjdXJyZW50LnNpYmxpbmcgPSBuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRSZXNvdXJjZSksXG4gICAgICAgICAgICAgICAgKHR5cGUubGFzdCA9IG5leHRSZXNvdXJjZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVsbCAhPT0gdHlwZS50YWlsKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSB0eXBlLnRhaWwpLFxuICAgICAgICAgICAgICAodHlwZS5yZW5kZXJpbmcgPSBjdXJyZW50KSxcbiAgICAgICAgICAgICAgKHR5cGUudGFpbCA9IGN1cnJlbnQuc2libGluZyksXG4gICAgICAgICAgICAgICh0eXBlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdyQxKCkpLFxuICAgICAgICAgICAgICAoY3VycmVudC5zaWJsaW5nID0gbnVsbCksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgPyAocmVuZGVyTGFuZXMgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfFxuICAgICAgICAgICAgICAgICAgRm9yY2VTdXNwZW5zZUZhbGxiYWNrXG4gICAgICAgICAgICAgICAgOiByZW5kZXJMYW5lcyAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSxcbiAgICAgICAgICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcG9wSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV3UHJvcHMgPSBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAobnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MilcbiAgICAgICAgICAgICAgOiBuZXdQcm9wcyAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MiksXG4gICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICA/IDAgIT09IChyZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikgJiZcbiAgICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyAmIDYgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSlcbiAgICAgICAgICAgICAgOiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLnJldHJ5UXVldWUpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICAobmV3UHJvcHMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICBuZXdQcm9wcyAhPT0gcmVuZGVyTGFuZXMgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwb3AocmVzdW1lZENhY2hlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgK1xuICAgICAgICAgIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgICAgIDAgIT09IChjdXJyZW50ICYgNjU1MzYpICYmIDAgPT09IChjdXJyZW50ICYgMTI4KVxuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQuZGVoeWRyYXRlZCkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaHJldyBpbiBuZXdseSBtb3VudGVkIGRlaHlkcmF0ZWQgY29tcG9uZW50LiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuICAgICAgICAgIHJldHVybiBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHBvcEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwb3AocmVzdW1lZENhY2hlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIGludGVycnVwdGVkV29yaykge1xuICAgICAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrLnR5cGUsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgcG9wSGlkZGVuQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIGludGVycnVwdGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFByb2ZpbGUoY3VycmVudCkge1xuICAgICAgcmV0dXJuIChjdXJyZW50Lm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0xheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCBob29rRmxhZ3MpIHtcbiAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGhvb2tGbGFnc1xuICAgICkge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGZsYWdzLCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSxcbiAgICAgICAgICBsYXN0RWZmZWN0ID0gbnVsbCAhPT0gdXBkYXRlUXVldWUgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IGxhc3RFZmZlY3QpIHtcbiAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPSBmaXJzdEVmZmVjdDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICh1cGRhdGVRdWV1ZS50YWcgJiBmbGFncykgPT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICgoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFnc1xuICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZChcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiAoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZChcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAobGFzdEVmZmVjdCA9IHZvaWQgMCksXG4gICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITApLFxuICAgICAgICAgICAgICAobGFzdEVmZmVjdCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjYWxsQ3JlYXRlSW5ERVYsXG4gICAgICAgICAgICAgICAgdXBkYXRlUXVldWVcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITEpLFxuICAgICAgICAgICAgICAoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFnc1xuICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCAmJlxuICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpXG4gICAgICAgICAgICAgICAgOiAoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpLFxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGxhc3RFZmZlY3QgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgbGFzdEVmZmVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgaG9va05hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGhvb2tOYW1lID1cbiAgICAgICAgICAgICAgICAwICE9PSAodXBkYXRlUXVldWUudGFnICYgTGF5b3V0KVxuICAgICAgICAgICAgICAgICAgPyBcInVzZUxheW91dEVmZmVjdFwiXG4gICAgICAgICAgICAgICAgICA6IDAgIT09ICh1cGRhdGVRdWV1ZS50YWcgJiBJbnNlcnRpb24pXG4gICAgICAgICAgICAgICAgICAgID8gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIlxuICAgICAgICAgICAgICAgICAgICA6IFwidXNlRWZmZWN0XCI7XG4gICAgICAgICAgICAgIHZhciBhZGRlbmR1bSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgYWRkZW5kdW0gPVxuICAgICAgICAgICAgICAgIG51bGwgPT09IGxhc3RFZmZlY3RcbiAgICAgICAgICAgICAgICAgID8gXCIgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gdXAsIHJldHVybiB1bmRlZmluZWQgKG9yIG5vdGhpbmcpLlwiXG4gICAgICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGxhc3RFZmZlY3QudGhlblxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuXFxuSXQgbG9va3MgbGlrZSB5b3Ugd3JvdGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIGhvb2tOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICBcIihhc3luYyAoKSA9PiAuLi4pIG9yIHJldHVybmVkIGEgUHJvbWlzZS4gSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCBhbmQgY2FsbCBpdCBpbW1lZGlhdGVseTpcXG5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgaG9va05hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiKCgpID0+IHtcXG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSgpIHtcXG4gICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbiAgICAvLyAuLi5cXG4gIH1cXG4gIGZldGNoRGF0YSgpO1xcbn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcbkxlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0LmRldi9saW5rL2hvb2tzLWRhdGEtZmV0Y2hpbmdcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiIFlvdSByZXR1cm5lZDogXCIgKyBsYXN0RWZmZWN0O1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKG4sIGEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiJXMgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGJlc2lkZXMgYSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBmb3IgY2xlYW4tdXAuJXNcIixcbiAgICAgICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAgICAgYVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhvb2tOYW1lLFxuICAgICAgICAgICAgICAgIGFkZGVuZHVtXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlLm5leHQ7XG4gICAgICAgICAgfSB3aGlsZSAodXBkYXRlUXVldWUgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgIGZsYWdzLFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlLFxuICAgICAgICAgIGxhc3RFZmZlY3QgPSBudWxsICE9PSB1cGRhdGVRdWV1ZSA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPT0gbGFzdEVmZmVjdCkge1xuICAgICAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA9IGZpcnN0RWZmZWN0O1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICgodXBkYXRlUXVldWUudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuICAgICAgICAgICAgICB2YXIgaW5zdCA9IHVwZGF0ZVF1ZXVlLmluc3QsXG4gICAgICAgICAgICAgICAgZGVzdHJveSA9IGluc3QuZGVzdHJveTtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBkZXN0cm95ICYmXG4gICAgICAgICAgICAgICAgKChpbnN0LmRlc3Ryb3kgPSB2b2lkIDApLFxuICAgICAgICAgICAgICAgIChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzXG4gICAgICAgICAgICAgICAgICA/IG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMCksXG4gICAgICAgICAgICAgICAgKGxhc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgbGFzdEVmZmVjdCxcbiAgICAgICAgICAgICAgICAgIGNhbGxEZXN0cm95SW5ERVYsXG4gICAgICAgICAgICAgICAgICBsYXN0RWZmZWN0LFxuICAgICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICAgIGRlc3Ryb3lcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMSksXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3NcbiAgICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQoKVxuICAgICAgICAgICAgICAgICAgOiAoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUubmV4dDtcbiAgICAgICAgICB9IHdoaWxlICh1cGRhdGVRdWV1ZSAhPT0gZmlyc3RFZmZlY3QpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBob29rRmxhZ3MpIHtcbiAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBob29rRmxhZ3NcbiAgICApIHtcbiAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgaG9va0ZsYWdzLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICBpZiAobnVsbCAhPT0gdXBkYXRlUXVldWUpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICApKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyxcbiAgICAgICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXMoaW5zdGFuY2UsIHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDbGFzc1NuYXBzaG90KGZpbmlzaGVkV29yaywgY3VycmVudCkge1xuICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgY3VycmVudCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgfHxcbiAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgIChjdXJyZW50LnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICksXG4gICAgICAgIGN1cnJlbnQuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgKSk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcmV2UHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZVxuICAgICAgICApO1xuICAgICAgICB2YXIgc25hcHNob3QgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY2FsbEdldFNuYXBzaG90QmVmb3JlVXBkYXRlcyxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHJlc29sdmVkUHJldlByb3BzLFxuICAgICAgICAgIHByZXZTdGF0ZVxuICAgICAgICApO1xuICAgICAgICBwcmV2UHJvcHMgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcbiAgICAgICAgdm9pZCAwICE9PSBzbmFwc2hvdCB8fFxuICAgICAgICAgIHByZXZQcm9wcy5oYXMoZmluaXNoZWRXb3JrLnR5cGUpIHx8XG4gICAgICAgICAgKHByZXZQcm9wcy5hZGQoZmluaXNoZWRXb3JrLnR5cGUpLFxuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpbmlzaGVkV29yaywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIGN1cnJlbnQuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGluc3RhbmNlXG4gICAgKSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgICAgICBjdXJyZW50LnR5cGUsXG4gICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICAgICAgKTtcbiAgICAgIGluc3RhbmNlLnN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgc2hvdWxkUHJvZmlsZShjdXJyZW50KVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50SW5ERVYsXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudEluREVWLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgICAgaWYgKG51bGwgIT09IHJlZikge1xuICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdmFyIGluc3RhbmNlVG9Vc2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgIGluc3RhbmNlVG9Vc2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGluc3RhbmNlVG9Vc2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpXG4gICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRXb3JrLnJlZkNsZWFudXAgPSByZWYoaW5zdGFuY2VUb1VzZSkpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGZpbmlzaGVkV29yay5yZWZDbGVhbnVwID0gcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJlZlxuICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFwiU3RyaW5nIHJlZnMgYXJlIG5vIGxvbmdlciBzdXBwb3J0ZWQuXCIpXG4gICAgICAgICAgICA6IHJlZi5oYXNPd25Qcm9wZXJ0eShcImN1cnJlbnRcIikgfHxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgcmVmIG9iamVjdCBwcm92aWRlZCBmb3IgJXMuIFVzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKHJlZi5jdXJyZW50ID0gaW5zdGFuY2VUb1VzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseUF0dGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCBjb21taXRBdHRhY2hSZWYsIGN1cnJlbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAgICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmLFxuICAgICAgICByZWZDbGVhbnVwID0gY3VycmVudC5yZWZDbGVhbnVwO1xuICAgICAgaWYgKG51bGwgIT09IHJlZilcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZkNsZWFudXApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGN1cnJlbnQpKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RWZmZWN0VGltZXIoKSwgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmQ2xlYW51cCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmQ2xlYW51cCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgKGN1cnJlbnQucmVmQ2xlYW51cCA9IG51bGwpLFxuICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAgICAgbnVsbCAhPSBjdXJyZW50ICYmIChjdXJyZW50LnJlZkNsZWFudXAgPSBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZilcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoY3VycmVudCkpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhcnRFZmZlY3RUaW1lcigpLCBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWYsIG51bGwpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZiwgbnVsbCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IkNykge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IkNyk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UHJvZmlsZXIoXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBjdXJyZW50LFxuICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgZWZmZWN0RHVyYXRpb25cbiAgICApIHtcbiAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgaWQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUuaWQsXG4gICAgICAgIG9uQ29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLm9uQ29tbWl0O1xuICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLm9uUmVuZGVyO1xuICAgICAgY3VycmVudCA9IG51bGwgPT09IGN1cnJlbnQgPyBcIm1vdW50XCIgOiBcInVwZGF0ZVwiO1xuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkICYmIChjdXJyZW50ID0gXCJuZXN0ZWQtdXBkYXRlXCIpO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2ZpbmlzaGVkV29yayRtZW1vaXplICYmXG4gICAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZShcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbixcbiAgICAgICAgICBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbixcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLFxuICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZVxuICAgICAgICApO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb25Db21taXQgJiZcbiAgICAgICAgb25Db21taXQoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBlZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBjb21taXRTdGFydFRpbWVcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UHJvZmlsZXJQb3N0Q29tbWl0SW1wbChcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb25cbiAgICApIHtcbiAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICBmaW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLmlkO1xuICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Qb3N0Q29tbWl0O1xuICAgICAgY3VycmVudCA9IG51bGwgPT09IGN1cnJlbnQgPyBcIm1vdW50XCIgOiBcInVwZGF0ZVwiO1xuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkICYmIChjdXJyZW50ID0gXCJuZXN0ZWQtdXBkYXRlXCIpO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2ZpbmlzaGVkV29yayRtZW1vaXplMiAmJlxuICAgICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUyKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBjb21taXRTdGFydFRpbWVcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdE1vdW50KGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdE1vdW50LFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdFVwZGF0ZShmaW5pc2hlZFdvcmssIG5ld1Byb3BzLCBvbGRQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdFVwZGF0ZSxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLFxuICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgIG9sZFByb3BzLFxuICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgNSA9PT0gZmliZXIudGFnIHx8XG4gICAgICAgIDMgPT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAyNiA9PT0gZmliZXIudGFnIHx8XG4gICAgICAgICgyNyA9PT0gZmliZXIudGFnICYmIGlzU2luZ2xldG9uU2NvcGUoZmliZXIudHlwZSkpIHx8XG4gICAgICAgIDQgPT09IGZpYmVyLnRhZ1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAgIGE6IGZvciAoOzspIHtcbiAgICAgICAgZm9yICg7IG51bGwgPT09IGZpYmVyLnNpYmxpbmc7ICkge1xuICAgICAgICAgIGlmIChudWxsID09PSBmaWJlci5yZXR1cm4gfHwgaXNIb3N0UGFyZW50KGZpYmVyLnJldHVybikpIHJldHVybiBudWxsO1xuICAgICAgICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpYmVyLnNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIGZpYmVyID0gZmliZXIuc2libGluZztcbiAgICAgICAgICA1ICE9PSBmaWJlci50YWcgJiYgNiAhPT0gZmliZXIudGFnICYmIDE4ICE9PSBmaWJlci50YWc7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKDI3ID09PSBmaWJlci50YWcgJiYgaXNTaW5nbGV0b25TY29wZShmaWJlci50eXBlKSkgY29udGludWUgYTtcbiAgICAgICAgICBpZiAoZmliZXIuZmxhZ3MgJiAyKSBjb250aW51ZSBhO1xuICAgICAgICAgIGlmIChudWxsID09PSBmaWJlci5jaGlsZCB8fCA0ID09PSBmaWJlci50YWcpIGNvbnRpbnVlIGE7XG4gICAgICAgICAgZWxzZSAoZmliZXIuY2hpbGQucmV0dXJuID0gZmliZXIpLCAoZmliZXIgPSBmaWJlci5jaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZmliZXIuZmxhZ3MgJiAyKSkgcmV0dXJuIGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgaWYgKDUgPT09IHRhZyB8fCA2ID09PSB0YWcpXG4gICAgICAgIChub2RlID0gbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgIGJlZm9yZVxuICAgICAgICAgICAgPyAod2FybkZvclJlYWN0Q2hpbGRyZW5Db25mbGljdChwYXJlbnQpLFxuICAgICAgICAgICAgICAoOSA9PT0gcGFyZW50Lm5vZGVUeXBlXG4gICAgICAgICAgICAgICAgPyBwYXJlbnQuYm9keVxuICAgICAgICAgICAgICAgIDogXCJIVE1MXCIgPT09IHBhcmVudC5ub2RlTmFtZVxuICAgICAgICAgICAgICAgICAgPyBwYXJlbnQub3duZXJEb2N1bWVudC5ib2R5XG4gICAgICAgICAgICAgICAgICA6IHBhcmVudFxuICAgICAgICAgICAgICApLmluc2VydEJlZm9yZShub2RlLCBiZWZvcmUpKVxuICAgICAgICAgICAgOiAod2FybkZvclJlYWN0Q2hpbGRyZW5Db25mbGljdChwYXJlbnQpLFxuICAgICAgICAgICAgICAoYmVmb3JlID1cbiAgICAgICAgICAgICAgICA5ID09PSBwYXJlbnQubm9kZVR5cGVcbiAgICAgICAgICAgICAgICAgID8gcGFyZW50LmJvZHlcbiAgICAgICAgICAgICAgICAgIDogXCJIVE1MXCIgPT09IHBhcmVudC5ub2RlTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IHBhcmVudC5vd25lckRvY3VtZW50LmJvZHlcbiAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnQpLFxuICAgICAgICAgICAgICBiZWZvcmUuYXBwZW5kQ2hpbGQobm9kZSksXG4gICAgICAgICAgICAgIChwYXJlbnQgPSBwYXJlbnQuX3JlYWN0Um9vdENvbnRhaW5lciksXG4gICAgICAgICAgICAgIChudWxsICE9PSBwYXJlbnQgJiYgdm9pZCAwICE9PSBwYXJlbnQpIHx8XG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gYmVmb3JlLm9uY2xpY2sgfHxcbiAgICAgICAgICAgICAgICAoYmVmb3JlLm9uY2xpY2sgPSBub29wJDEpKTtcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICA0ICE9PSB0YWcgJiZcbiAgICAgICAgKDI3ID09PSB0YWcgJiZcbiAgICAgICAgICBpc1NpbmdsZXRvblNjb3BlKG5vZGUudHlwZSkgJiZcbiAgICAgICAgICAoKHBhcmVudCA9IG5vZGUuc3RhdGVOb2RlKSwgKGJlZm9yZSA9IG51bGwpKSxcbiAgICAgICAgKG5vZGUgPSBub2RlLmNoaWxkKSxcbiAgICAgICAgbnVsbCAhPT0gbm9kZSlcbiAgICAgIClcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgICAgbnVsbCAhPT0gbm9kZTtcblxuICAgICAgICApXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICAobm9kZSA9IG5vZGUuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgaWYgKDUgPT09IHRhZyB8fCA2ID09PSB0YWcpXG4gICAgICAgIChub2RlID0gbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgIGJlZm9yZSA/IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgYmVmb3JlKSA6IHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICA0ICE9PSB0YWcgJiZcbiAgICAgICAgKDI3ID09PSB0YWcgJiYgaXNTaW5nbGV0b25TY29wZShub2RlLnR5cGUpICYmIChwYXJlbnQgPSBub2RlLnN0YXRlTm9kZSksXG4gICAgICAgIChub2RlID0gbm9kZS5jaGlsZCksXG4gICAgICAgIG51bGwgIT09IG5vZGUpXG4gICAgICApXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgICAgbnVsbCAhPT0gbm9kZTtcblxuICAgICAgICApXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIChub2RlID0gbm9kZS5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGhvc3RQYXJlbnRGaWJlciwgcGFyZW50RmliZXIgPSBmaW5pc2hlZFdvcmsucmV0dXJuO1xuICAgICAgICBudWxsICE9PSBwYXJlbnRGaWJlcjtcblxuICAgICAgKSB7XG4gICAgICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50RmliZXIpKSB7XG4gICAgICAgICAgaG9zdFBhcmVudEZpYmVyID0gcGFyZW50RmliZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobnVsbCA9PSBob3N0UGFyZW50RmliZXIpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICBzd2l0Y2ggKGhvc3RQYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBob3N0UGFyZW50RmliZXIgPSBob3N0UGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHBhcmVudEZpYmVyID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgIGhvc3RQYXJlbnRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwYXJlbnRGaWJlciA9IGhvc3RQYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgaG9zdFBhcmVudEZpYmVyLmZsYWdzICYgMzIgJiZcbiAgICAgICAgICAgIChyZXNldFRleHRDb250ZW50KHBhcmVudEZpYmVyKSwgKGhvc3RQYXJlbnRGaWJlci5mbGFncyAmPSAtMzMpKTtcbiAgICAgICAgICBob3N0UGFyZW50RmliZXIgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGhvc3RQYXJlbnRGaWJlcixcbiAgICAgICAgICAgIHBhcmVudEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgaG9zdFBhcmVudEZpYmVyID0gaG9zdFBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHBhcmVudEZpYmVyID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgICBob3N0UGFyZW50RmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdFNpbmdsZXRvbkFjcXVpc2l0aW9uKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHNpbmdsZXRvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsXG4gICAgICAgIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIHNpbmdsZXRvbixcbiAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmlyc3RDaGlsZCkge1xuICAgICAgcm9vdCA9IHJvb3QuY29udGFpbmVySW5mbztcbiAgICAgIGV2ZW50c0VuYWJsZWQgPSBfZW5hYmxlZDtcbiAgICAgIHJvb3QgPSBnZXRBY3RpdmVFbGVtZW50RGVlcChyb290KTtcbiAgICAgIGlmIChoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocm9vdCkpIHtcbiAgICAgICAgaWYgKFwic2VsZWN0aW9uU3RhcnRcIiBpbiByb290KVxuICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXAgPSB7XG4gICAgICAgICAgICBzdGFydDogcm9vdC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgIGVuZDogcm9vdC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICB9O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAgPSByb290Lm93bmVyRG9jdW1lbnQpICYmXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLmRlZmF1bHRWaWV3KSB8fFxuICAgICAgICAgICAgICB3aW5kb3c7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID1cbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLmdldFNlbGVjdGlvbiAmJiBKU0NvbXBpbGVyX3RlbXAuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIDAgIT09IHNlbGVjdGlvbi5yYW5nZUNvdW50KSB7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgICAgICAgICAgICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgICAgICAgICAgICBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLm5vZGVUeXBlLCBmb2N1c05vZGUubm9kZVR5cGU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUkMikge1xuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gMCxcbiAgICAgICAgICAgICAgICBzdGFydCA9IC0xLFxuICAgICAgICAgICAgICAgIGVuZCA9IC0xLFxuICAgICAgICAgICAgICAgIGluZGV4V2l0aGluQW5jaG9yID0gMCxcbiAgICAgICAgICAgICAgICBpbmRleFdpdGhpbkZvY3VzID0gMCxcbiAgICAgICAgICAgICAgICBub2RlID0gcm9vdCxcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgYjogZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHQ7IDsgKSB7XG4gICAgICAgICAgICAgICAgICBub2RlICE9PSBKU0NvbXBpbGVyX3RlbXAgfHxcbiAgICAgICAgICAgICAgICAgICAgKDAgIT09IGFuY2hvck9mZnNldCAmJiAzICE9PSBub2RlLm5vZGVUeXBlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgbm9kZSAhPT0gZm9jdXNOb2RlIHx8XG4gICAgICAgICAgICAgICAgICAgICgwICE9PSBzZWxlY3Rpb24gJiYgMyAhPT0gbm9kZS5ub2RlVHlwZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGVuZCA9IGxlbmd0aCArIHNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAzID09PSBub2RlLm5vZGVUeXBlICYmIChsZW5ndGggKz0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSAobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHJvb3QpIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICBwYXJlbnROb2RlID09PSBKU0NvbXBpbGVyX3RlbXAgJiZcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleFdpdGhpbkFuY2hvciA9PT0gYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIChzdGFydCA9IGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICBwYXJlbnROb2RlID09PSBmb2N1c05vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleFdpdGhpbkZvY3VzID09PSBzZWxlY3Rpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgKGVuZCA9IGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgICAgICAgLTEgPT09IHN0YXJ0IHx8IC0xID09PSBlbmQgPyBudWxsIDogeyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgICAgICAgICB9IGVsc2UgSlNDb21waWxlcl90ZW1wID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IEpTQ29tcGlsZXJfdGVtcCB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgICAgIH0gZWxzZSBKU0NvbXBpbGVyX3RlbXAgPSBudWxsO1xuICAgICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSB7XG4gICAgICAgIGZvY3VzZWRFbGVtOiByb290LFxuICAgICAgICBzZWxlY3Rpb25SYW5nZTogSlNDb21waWxlcl90ZW1wXG4gICAgICB9O1xuICAgICAgX2VuYWJsZWQgPSAhMTtcbiAgICAgIGZvciAobmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7IG51bGwgIT09IG5leHRFZmZlY3Q7IClcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgoZmlyc3RDaGlsZCA9IG5leHRFZmZlY3QpLFxuICAgICAgICAgIChyb290ID0gZmlyc3RDaGlsZC5jaGlsZCksXG4gICAgICAgICAgMCAhPT0gKGZpcnN0Q2hpbGQuc3VidHJlZUZsYWdzICYgMTAyNCkgJiYgbnVsbCAhPT0gcm9vdClcbiAgICAgICAgKVxuICAgICAgICAgIChyb290LnJldHVybiA9IGZpcnN0Q2hpbGQpLCAobmV4dEVmZmVjdCA9IHJvb3QpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICg7IG51bGwgIT09IG5leHRFZmZlY3Q7ICkge1xuICAgICAgICAgICAgcm9vdCA9IGZpcnN0Q2hpbGQgPSBuZXh0RWZmZWN0O1xuICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wID0gcm9vdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBhbmNob3JPZmZzZXQgPSByb290LmZsYWdzO1xuICAgICAgICAgICAgc3dpdGNoIChyb290LnRhZykge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAwICE9PSAoYW5jaG9yT2Zmc2V0ICYgMTAyNCkgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcCAmJlxuICAgICAgICAgICAgICAgICAgY29tbWl0Q2xhc3NTbmFwc2hvdChyb290LCBKU0NvbXBpbGVyX3RlbXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKDAgIT09IChhbmNob3JPZmZzZXQgJiAxMDI0KSlcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKChyb290ID0gcm9vdC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksXG4gICAgICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSByb290Lm5vZGVUeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgOSA9PT0gSlNDb21waWxlcl90ZW1wKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbnRhaW5lclNwYXJpbmdseShyb290KTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKDEgPT09IEpTQ29tcGlsZXJfdGVtcClcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyb290Lm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhFQURcIjpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCT0RZXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckNvbnRhaW5lclNwYXJpbmdseShyb290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByb290LnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICgwICE9PSAoYW5jaG9yT2Zmc2V0ICYgMTAyNCkpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvb3QgPSBmaXJzdENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gcm9vdCkge1xuICAgICAgICAgICAgICByb290LnJldHVybiA9IGZpcnN0Q2hpbGQucmV0dXJuO1xuICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gcm9vdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZC5yZXR1cm47XG4gICAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdFN0YXJ0ID0gcHVzaENvbXBvbmVudEVmZmVjdFN0YXJ0KCksXG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCB8IEhhc0VmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKGZsYWdzICYgNClcbiAgICAgICAgICAgIGlmICgoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpLCBudWxsID09PSBjdXJyZW50KSlcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgICAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRSb290LnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgY29tcG9uZW50RGlkTW91bnQuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3Quc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBjb21wb25lbnREaWRNb3VudC4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgICAgICAgKGZpbmlzaGVkUm9vdC5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIGNvbXBvbmVudERpZFVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIGNvbXBvbmVudERpZFVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJiBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY3VycmVudCA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksIG51bGwgIT09IGZsYWdzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJldlByb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaW5pc2hlZFdvcmsuY2hpbGQpXG4gICAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHByZXZQcm9wcyA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRDYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZmluaXNoZWRSb290LmVmZmVjdER1cmF0aW9uICs9IHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhjdXJyZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdEhvc3RTaW5nbGV0b25BY3F1aXNpdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiYgZmxhZ3MgJiA0ICYmIGNvbW1pdEhvc3RNb3VudChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmIChmbGFncyAmIDQpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5lZmZlY3REdXJhdGlvbiArPSBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMoZmxhZ3MpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFByb2ZpbGVyLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuZWZmZWN0RHVyYXRpb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNjQgJiZcbiAgICAgICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290LmRlaHlkcmF0ZWQpLFxuICAgICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFJvb3QgJiZcbiAgICAgICAgICAgICAgICAoKGZpbmlzaGVkV29yayA9IHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeShmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgZmxhZ3MgPVxuICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgfHwgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIGlmICghZmxhZ3MpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPVxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgICBwcmV2UHJvcHMgPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gZmxhZ3M7XG4gICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IGN1cnJlbnQpICYmXG4gICAgICAgICAgICAhcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW5cbiAgICAgICAgICAgICAgPyByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiA4NzcyKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2UHJvcHM7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICAgIHBvcENvbXBvbmVudEVmZmVjdFN0YXJ0KHByZXZFZmZlY3RTdGFydCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmXG4gICAgICAgICgoZmliZXIuYWx0ZXJuYXRlID0gbnVsbCksIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGFsdGVybmF0ZSkpO1xuICAgICAgZmliZXIuY2hpbGQgPSBudWxsO1xuICAgICAgZmliZXIuZGVsZXRpb25zID0gbnVsbDtcbiAgICAgIGZpYmVyLnNpYmxpbmcgPSBudWxsO1xuICAgICAgNSA9PT0gZmliZXIudGFnICYmXG4gICAgICAgICgoYWx0ZXJuYXRlID0gZmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIGRldGFjaERlbGV0ZWRJbnN0YW5jZShhbHRlcm5hdGUpKTtcbiAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG4gICAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gICAgICBmaWJlci5yZXR1cm4gPSBudWxsO1xuICAgICAgZmliZXIuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDtcbiAgICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBwYXJlbnRcbiAgICApIHtcbiAgICAgIGZvciAocGFyZW50ID0gcGFyZW50LmNoaWxkOyBudWxsICE9PSBwYXJlbnQ7IClcbiAgICAgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICBwYXJlbnRcbiAgICAgICAgKSxcbiAgICAgICAgICAocGFyZW50ID0gcGFyZW50LnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGRlbGV0ZWRGaWJlclxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50XG4gICAgICApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIHZhciBwcmV2RWZmZWN0U3RhcnQgPSBwdXNoQ29tcG9uZW50RWZmZWN0U3RhcnQoKTtcbiAgICAgIHN3aXRjaCAoZGVsZXRlZEZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZS5jb3VudC0tXG4gICAgICAgICAgICA6IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgKChkZWxldGVkRmliZXIgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGVsZXRlZEZpYmVyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgdmFyIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCxcbiAgICAgICAgICAgIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaXNTaW5nbGV0b25TY29wZShkZWxldGVkRmliZXIudHlwZSkgJiZcbiAgICAgICAgICAgICgoaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgKGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExKSk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgcmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICAgICAgICBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgIGhvc3RQYXJlbnQgPSBudWxsO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBob3N0UGFyZW50ID0gcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gaG9zdFBhcmVudClcbiAgICAgICAgICAgIGlmIChob3N0UGFyZW50SXNDb250YWluZXIpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIsXG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50LFxuICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZCxcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQsXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBudWxsICE9PSBob3N0UGFyZW50ICYmXG4gICAgICAgICAgICAoaG9zdFBhcmVudElzQ29udGFpbmVyXG4gICAgICAgICAgICAgID8gKChmaW5pc2hlZFJvb3QgPSBob3N0UGFyZW50KSxcbiAgICAgICAgICAgICAgICBjbGVhclN1c3BlbnNlQm91bmRhcnkoXG4gICAgICAgICAgICAgICAgICA5ID09PSBmaW5pc2hlZFJvb3Qubm9kZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyBmaW5pc2hlZFJvb3QuYm9keVxuICAgICAgICAgICAgICAgICAgICA6IFwiSFRNTFwiID09PSBmaW5pc2hlZFJvb3Qubm9kZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICA/IGZpbmlzaGVkUm9vdC5vd25lckRvY3VtZW50LmJvZHlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJldHJ5SWZCbG9ja2VkT24oZmluaXNoZWRSb290KSlcbiAgICAgICAgICAgICAgOiBjbGVhclN1c3BlbnNlQm91bmRhcnkoaG9zdFBhcmVudCwgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgICAgICAgIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMDtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICAgIEluc2VydGlvbixcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBMYXlvdXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgKHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpLFxuICAgICAgICAgICAgKHByZXZIb3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcmV2SG9zdFBhcmVudC5jb21wb25lbnRXaWxsVW5tb3VudCAmJlxuICAgICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgcHJldkhvc3RQYXJlbnRcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID1cbiAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudCA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHx8XG4gICAgICAgICAgICBudWxsICE9PSBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHBvcENvbXBvbmVudEVmZmVjdFN0YXJ0KHByZXZFZmZlY3RTdGFydCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSksXG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QuZGVoeWRyYXRlZCksIG51bGwgIT09IGZpbmlzaGVkUm9vdCkpKVxuICAgICAgKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgICAgICAgZmluaXNoZWRSb290XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZXRyeUNhY2hlKGZpbmlzaGVkV29yaykge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgPT09IHJldHJ5Q2FjaGUgJiZcbiAgICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKSk7XG4gICAgICAgICAgcmV0dXJuIHJldHJ5Q2FjaGU7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLl9yZXRyeUNhY2hlKSxcbiAgICAgICAgICAgIG51bGwgPT09IHJldHJ5Q2FjaGUgJiZcbiAgICAgICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCkpLFxuICAgICAgICAgICAgcmV0cnlDYWNoZVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuc2UgaGFuZGxlciB0YWcgKFwiICtcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnRhZyArXG4gICAgICAgICAgICAgIFwiKS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCB3YWtlYWJsZXMpIHtcbiAgICAgIHZhciByZXRyeUNhY2hlID0gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspO1xuICAgICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAgIHZhciByZXRyeSA9IHJlc29sdmVSZXRyeVdha2VhYmxlLmJpbmQobnVsbCwgZmluaXNoZWRXb3JrLCB3YWtlYWJsZSk7XG4gICAgICAgIGlmICghcmV0cnlDYWNoZS5oYXMod2FrZWFibGUpKSB7XG4gICAgICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuICAgICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBpblByb2dyZXNzTGFuZXMgJiYgbnVsbCAhPT0gaW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMoaW5Qcm9ncmVzc1Jvb3QsIGluUHJvZ3Jlc3NMYW5lcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgZmluaXNoZWQgcm9vdCBhbmQgbGFuZXMgdG8gYmUgc2V0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgd2FrZWFibGUudGhlbihyZXRyeSwgcmV0cnkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290JGpzY29tcCQwLCBwYXJlbnRGaWJlcikge1xuICAgICAgdmFyIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyLmRlbGV0aW9ucztcbiAgICAgIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSByb290JGpzY29tcCQwLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlciA9IGRlbGV0aW9uc1tpXSxcbiAgICAgICAgICAgIHByZXZFZmZlY3RTdGFydCA9IHB1c2hDb21wb25lbnRFZmZlY3RTdGFydCgpLFxuICAgICAgICAgICAgcGFyZW50ID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgYTogZm9yICg7IG51bGwgIT09IHBhcmVudDsgKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICBpZiAoaXNTaW5nbGV0b25TY29wZShwYXJlbnQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudWxsID09PSBob3N0UGFyZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG4gICAgICAgICAgcG9wQ29tcG9uZW50RWZmZWN0U3RhcnQocHJldkVmZmVjdFN0YXJ0KTtcbiAgICAgICAgICByb290ID0gZGVsZXRlZEZpYmVyO1xuICAgICAgICAgIHJldHVybkZpYmVyID0gcm9vdC5hbHRlcm5hdGU7XG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXIgJiYgKHJldHVybkZpYmVyLnJldHVybiA9IG51bGwpO1xuICAgICAgICAgIHJvb3QucmV0dXJuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEzODc4KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihwYXJlbnRGaWJlciwgcm9vdCRqc2NvbXAkMCksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpIHtcbiAgICAgIHZhciBwcmV2RWZmZWN0U3RhcnQgPSBwdXNoQ29tcG9uZW50RWZmZWN0U3RhcnQoKSxcbiAgICAgICAgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgICBJbnNlcnRpb24gfCBIYXNFZmZlY3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVyblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIExheW91dCB8IEhhc0VmZmVjdFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuICYmXG4gICAgICAgICAgICAoKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsgJiZcbiAgICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay5jYWxsYmFja3MpLFxuICAgICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGZpbmlzaGVkV29yay5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzKSxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRXb3JrLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPVxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCA/IGZsYWdzIDogY3VycmVudC5jb25jYXQoZmxhZ3MpKSkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICB2YXIgaG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHJvb3QgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbCksXG4gICAgICAgICAgICAgIChmbGFncyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGZsYWdzKVxuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290O1xuICAgICAgICAgICAgICAgICAgICBiOiBzd2l0Y2ggKGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290ID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRpdGxlXCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAhaG9pc3RhYmxlUm9vdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290W2ludGVybmFsSG9pc3RhYmxlTWFya2VyXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290W2ludGVybmFsSW5zdGFuY2VLZXldIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QuaGFzQXR0cmlidXRlKFwiaXRlbXByb3BcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGhvaXN0YWJsZVJvb3QgPSByb290LmNyZWF0ZUVsZW1lbnQoZmxhZ3MpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290LmhlYWQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QucXVlcnlTZWxlY3RvcihcImhlYWQgPiB0aXRsZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhob2lzdGFibGVSb290LCBmbGFncywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290W2ludGVybmFsSW5zdGFuY2VLZXldID0gZmluaXNoZWRXb3JrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShob2lzdGFibGVSb290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzID0gaG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXliZU5vZGVzID0gZ2V0SHlkcmF0YWJsZUhvaXN0YWJsZUNhY2hlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpbmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJocmVmXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICkuZ2V0KGZsYWdzICsgKGN1cnJlbnQuaHJlZiB8fCBcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVOb2RlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXliZU5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoaG9pc3RhYmxlUm9vdCA9IG1heWJlTm9kZXNbaV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LmhyZWYgfHwgXCJcIiA9PT0gY3VycmVudC5ocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50LmhyZWYpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QuZ2V0QXR0cmlidXRlKFwicmVsXCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChudWxsID09IGN1cnJlbnQucmVsID8gbnVsbCA6IGN1cnJlbnQucmVsKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LmdldEF0dHJpYnV0ZShcInRpdGxlXCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChudWxsID09IGN1cnJlbnQudGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50LnRpdGxlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LmdldEF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChudWxsID09IGN1cnJlbnQuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50LmNyb3NzT3JpZ2luKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlTm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290ID0gcm9vdC5jcmVhdGVFbGVtZW50KGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGhvaXN0YWJsZVJvb3QsIGZsYWdzLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuaGVhZC5hcHBlbmRDaGlsZChob2lzdGFibGVSb290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChtYXliZU5vZGVzID0gZ2V0SHlkcmF0YWJsZUhvaXN0YWJsZUNhY2hlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWV0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKS5nZXQoZmxhZ3MgKyAoY3VycmVudC5jb250ZW50IHx8IFwiXCIpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1heWJlTm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChob2lzdGFibGVSb290ID0gbWF5YmVOb2Rlc1tpXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIgKyBjdXJyZW50LmNvbnRlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50Lm5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QuZ2V0QXR0cmlidXRlKFwicHJvcGVydHlcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5wcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1cnJlbnQucHJvcGVydHkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QuZ2V0QXR0cmlidXRlKFwiaHR0cC1lcXVpdlwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50Lmh0dHBFcXVpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1cnJlbnQuaHR0cEVxdWl2KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LmdldEF0dHJpYnV0ZShcImNoYXJzZXRcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5jaGFyU2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudC5jaGFyU2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlTm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290ID0gcm9vdC5jcmVhdGVFbGVtZW50KGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGhvaXN0YWJsZVJvb3QsIGZsYWdzLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuaGVhZC5hcHBlbmRDaGlsZChob2lzdGFibGVSb290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dldE5vZGVzRm9yVHlwZSBlbmNvdW50ZXJlZCBhIHR5cGUgaXQgZGlkIG5vdCBleHBlY3Q6IFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBmaW5pc2hlZFdvcms7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaG9pc3RhYmxlUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzID0gaG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBmbGFncztcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIG1vdW50SG9pc3RhYmxlKFxuICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBhY3F1aXJlUmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHJvb3QgIT09IGZsYWdzXG4gICAgICAgICAgICAgICAgPyAobnVsbCA9PT0gcm9vdFxuICAgICAgICAgICAgICAgICAgICA/IG51bGwgIT09IGN1cnJlbnQuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjdXJyZW50KSlcbiAgICAgICAgICAgICAgICAgICAgOiByb290LmNvdW50LS0sXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBmbGFnc1xuICAgICAgICAgICAgICAgICAgICA/IG1vdW50SG9pc3RhYmxlKFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBhY3F1aXJlUmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgOiBudWxsID09PSBmbGFncyAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgY29tbWl0SG9zdFVwZGF0ZShcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdEhvc3RVcGRhdGUoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgMzIpIHtcbiAgICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmluaXNoZWRXb3JrLCByZXNldFRleHRDb250ZW50LCByb290KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIG51bGwgIT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgKChyb290ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgY29tbWl0SG9zdFVwZGF0ZShcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogcm9vdFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgZmxhZ3MgJiAxMDI0ICYmXG4gICAgICAgICAgICAoKG5lZWRzRm9ybVJlc2V0ID0gITApLFxuICAgICAgICAgICAgXCJmb3JtXCIgIT09IGZpbmlzaGVkV29yay50eXBlICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGhvc3QgY29tcG9uZW50IHR5cGUuIEV4cGVjdGVkIGEgZm9ybS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGlzIHNob3VsZCBoYXZlIGEgdGV4dCBub2RlIGluaXRpYWxpemVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgY3VycmVudCA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBmbGFncztcbiAgICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFRleHRVcGRhdGUsXG4gICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGZsYWdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBob2lzdGFibGVSb290ID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHRhZ0NhY2hlcyA9IG51bGw7XG4gICAgICAgICAgbWF5YmVOb2RlcyA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IG1heWJlTm9kZXM7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHJvb3QuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgbmVlZHNGb3JtUmVzZXQgJiZcbiAgICAgICAgICAgICgobmVlZHNGb3JtUmVzZXQgPSAhMSksIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICByb290LmVmZmVjdER1cmF0aW9uICs9IHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhob2lzdGFibGVSb290KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGZsYWdzID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBmbGFncztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLmNoaWxkLmZsYWdzICYgODE5MiAmJlxuICAgICAgICAgICAgKG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSAhPT1cbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSAmJlxuICAgICAgICAgICAgKGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3ckMSgpKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGZsYWdzKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gbnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuLFxuICAgICAgICAgICAgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9XG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIHx8IGhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9XG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fCB3YXNIaWRkZW47XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGlmIChmbGFncyAmIDgxOTIpXG4gICAgICAgICAgICBhOiBmb3IgKFxuICAgICAgICAgICAgICByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgICByb290Ll92aXNpYmlsaXR5ID0gaG9pc3RhYmxlUm9vdFxuICAgICAgICAgICAgICAgICAgPyByb290Ll92aXNpYmlsaXR5ICYgfk9mZnNjcmVlblZpc2libGVcbiAgICAgICAgICAgICAgICAgIDogcm9vdC5fdmlzaWJpbGl0eSB8IE9mZnNjcmVlblZpc2libGUsXG4gICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgICAgICAgICAgKG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiB8fFxuICAgICAgICAgICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaykpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsLFxuICAgICAgICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICg1ID09PSByb290LnRhZyB8fCAyNiA9PT0gcm9vdC50YWcpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuID0gY3VycmVudCA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAobWF5YmVOb2RlcyA9IHdhc0hpZGRlbi5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcnVuV2l0aEZpYmVySW5ERVYod2FzSGlkZGVuLCBoaWRlSW5zdGFuY2UsIG1heWJlTm9kZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhpZGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4uc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcih3YXNIaWRkZW4sIHdhc0hpZGRlbi5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoNiA9PT0gcm9vdC50YWcpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuID0gcm9vdDtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIChpID0gd2FzSGlkZGVuLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVih3YXNIaWRkZW4sIGhpZGVUZXh0SW5zdGFuY2UsIGkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4ubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3Iod2FzSGlkZGVuLCB3YXNIaWRkZW4ucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICgoMjIgIT09IHJvb3QudGFnICYmIDIzICE9PSByb290LnRhZykgfHxcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJvb3QubWVtb2l6ZWRTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgcm9vdCA9PT0gZmluaXNoZWRXb3JrKSAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHJvb3QuY2hpbGRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5jaGlsZC5yZXR1cm4gPSByb290O1xuICAgICAgICAgICAgICAgIHJvb3QgPSByb290LmNoaWxkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyb290ID09PSBmaW5pc2hlZFdvcmspIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGZvciAoOyBudWxsID09PSByb290LnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSByb290LnJldHVybiB8fCByb290LnJldHVybiA9PT0gZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID09PSByb290ICYmIChjdXJyZW50ID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnQgPT09IHJvb3QgJiYgKGN1cnJlbnQgPSBudWxsKTtcbiAgICAgICAgICAgICAgcm9vdC5zaWJsaW5nLnJldHVybiA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICByb290ID0gcm9vdC5zaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGN1cnJlbnQgPSBmbGFncy5yZXRyeVF1ZXVlKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICgoZmxhZ3MucmV0cnlRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCBjdXJyZW50KSkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICgoZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCBmbGFncykpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICAgIHBvcENvbXBvbmVudEVmZmVjdFN0YXJ0KHByZXZFZmZlY3RTdGFydCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIGNvbW1pdFBsYWNlbWVudCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gLTM7XG4gICAgICB9XG4gICAgICBmbGFncyAmIDQwOTYgJiYgKGZpbmlzaGVkV29yay5mbGFncyAmPSAtNDA5Nyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhwYXJlbnRGaWJlcikge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjQpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgICAgICAgIHZhciBmaWJlciA9IHBhcmVudEZpYmVyO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhmaWJlcik7XG4gICAgICAgICAgNSA9PT0gZmliZXIudGFnICYmIGZpYmVyLmZsYWdzICYgMTAyNCAmJiBmaWJlci5zdGF0ZU5vZGUucmVzZXQoKTtcbiAgICAgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMocm9vdCwgcGFyZW50RmliZXIpIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiA4NzcyKVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBwYXJlbnRGaWJlci5hbHRlcm5hdGUsIHBhcmVudEZpYmVyKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHByZXZFZmZlY3RTdGFydCA9IHB1c2hDb21wb25lbnRFZmZlY3RTdGFydCgpO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgTGF5b3V0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCAmJlxuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICByZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgfVxuICAgICAgcG9wQ29tcG9uZW50RWZmZWN0U3RhcnQocHJldkVmZmVjdFN0YXJ0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhwYXJlbnRGaWJlciksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdFN0YXJ0ID0gcHVzaENvbXBvbmVudEVmZmVjdFN0YXJ0KCksXG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29tbWl0SG9va0xheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCBMYXlvdXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGN1cnJlbnQuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY3VycmVudCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRIaWRkZW5DYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgICAgICBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGNvbW1pdEhvc3RTaW5nbGV0b25BY3F1aXNpdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgY29tbWl0SG9zdE1vdW50KGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgaWYgKGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzLmVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICAgIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhmbGFncyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0UHJvZmlsZXIsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMuZWZmZWN0RHVyYXRpb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBwb3BDb21wb25lbnRFZmZlY3RTdGFydChwcmV2RWZmZWN0U3RhcnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgcGFyZW50RmliZXIsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID1cbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiAwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgODc3Mik7XG4gICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgcGFyZW50RmliZXIuYWx0ZXJuYXRlLFxuICAgICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKSxcbiAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciBwcmV2aW91c0NhY2hlID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgKHByZXZpb3VzQ2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpO1xuICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCk7XG4gICAgICBjdXJyZW50ICE9PSBwcmV2aW91c0NhY2hlICYmXG4gICAgICAgIChudWxsICE9IGN1cnJlbnQgJiYgcmV0YWluQ2FjaGUoY3VycmVudCksXG4gICAgICAgIG51bGwgIT0gcHJldmlvdXNDYWNoZSAmJiByZWxlYXNlQ2FjaGUocHJldmlvdXNDYWNoZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAoY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICBmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICAgIGZpbmlzaGVkV29yayAhPT0gY3VycmVudCAmJlxuICAgICAgICAocmV0YWluQ2FjaGUoZmluaXNoZWRXb3JrKSwgbnVsbCAhPSBjdXJyZW50ICYmIHJlbGVhc2VDYWNoZShjdXJyZW50KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICkge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdFN0YXJ0ID0gcHVzaENvbXBvbmVudEVmZmVjdFN0YXJ0KCksXG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBQYXNzaXZlIHwgSGFzRWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB2YXIgcHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgICgoY29tbWl0dGVkTGFuZXMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgKGNvbW1pdHRlZExhbmVzID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsgIT09IGNvbW1pdHRlZExhbmVzICYmXG4gICAgICAgICAgICAgIChyZXRhaW5DYWNoZShmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICBudWxsICE9IGNvbW1pdHRlZExhbmVzICYmIHJlbGVhc2VDYWNoZShjb21taXR0ZWRMYW5lcykpKTtcbiAgICAgICAgICBmaW5pc2hlZFJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhcbiAgICAgICAgICAgIHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoZmxhZ3MgJiAyMDQ4KSB7XG4gICAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRQcm9maWxlclBvc3RDb21taXRJbXBsLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBfY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gcHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJlxuICAgICAgICAgICAgICBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZFxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5ICZcbiAgICAgICAgICAgICAgICBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZFxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiAoKHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5IHw9XG4gICAgICAgICAgICAgICAgICBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCksXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTAyNTYpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKF9jdXJyZW50LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBwb3BDb21wb25lbnRFZmZlY3RTdGFydChwcmV2RWZmZWN0U3RhcnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBwYXJlbnRGaWJlcixcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID1cbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYpO1xuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdFN0YXJ0ID0gcHVzaENvbXBvbmVudEVmZmVjdFN0YXJ0KCksXG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBQYXNzaXZlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICB2YXIgX2luc3RhbmNlMiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gX2luc3RhbmNlMi5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkXG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiAoKF9pbnN0YW5jZTIuX3Zpc2liaWxpdHkgfD0gT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcG9wQ29tcG9uZW50RWZmZWN0U3RhcnQocHJldkVmZmVjdFN0YXJ0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290JGpzY29tcCQwLFxuICAgICAgcGFyZW50RmliZXJcbiAgICApIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgICAgICAgdmFyIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayA9IHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICAgICAgY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KHBhcmVudEZpYmVyKSB7XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgc3VzcGVuc2V5Q29tbWl0RmxhZylcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKHBhcmVudEZpYmVyKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICAgIGZpYmVyLmZsYWdzICYgc3VzcGVuc2V5Q29tbWl0RmxhZyAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgc3VzcGVuZFJlc291cmNlKFxuICAgICAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgICAgZmliZXIubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHZhciBwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3QoXG4gICAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IHByZXZpb3VzSG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBudWxsID09PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAoKHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGZpYmVyLmFsdGVybmF0ZSksXG4gICAgICAgICAgICBudWxsICE9PSBwcmV2aW91c0hvaXN0YWJsZVJvb3QgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZpb3VzSG9pc3RhYmxlUm9vdC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gKChwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBzdXNwZW5zZXlDb21taXRGbGFnKSxcbiAgICAgICAgICAgICAgICAoc3VzcGVuc2V5Q29tbWl0RmxhZyA9IDE2Nzc3MjE2KSxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpLFxuICAgICAgICAgICAgICAgIChzdXNwZW5zZXlDb21taXRGbGFnID0gcHJldmlvdXNIb2lzdGFibGVSb290KSlcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcikge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHByZXZpb3VzRmliZXIgJiZcbiAgICAgICAgKChwYXJlbnRGaWJlciA9IHByZXZpb3VzRmliZXIuY2hpbGQpLCBudWxsICE9PSBwYXJlbnRGaWJlcilcbiAgICAgICkge1xuICAgICAgICBwcmV2aW91c0ZpYmVyLmNoaWxkID0gbnVsbDtcbiAgICAgICAgZG9cbiAgICAgICAgICAocHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyLnNpYmxpbmcgPSBudWxsKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHByZXZpb3VzRmliZXIpO1xuICAgICAgICB3aGlsZSAobnVsbCAhPT0gcGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICAgICAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5mbGFncyAmIDE2KSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXSxcbiAgICAgICAgICAgICAgcHJldkVmZmVjdFN0YXJ0ID0gcHVzaENvbXBvbmVudEVmZmVjdFN0YXJ0KCk7XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oXG4gICAgICAgICAgICAgIGNoaWxkVG9EZWxldGUsXG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcG9wQ29tcG9uZW50RWZmZWN0U3RhcnQocHJldkVmZmVjdFN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihwYXJlbnRGaWJlciksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHByZXZFZmZlY3RTdGFydCA9IHB1c2hDb21wb25lbnRFZmZlY3RTdGFydCgpO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICBQYXNzaXZlIHwgSGFzRWZmZWN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdmFyIHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZQcm9maWxlckVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBwcmV2UHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2UHJvZmlsZXJFZmZlY3REdXJhdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgcHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJlxuICAgICAgICAgICAgT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQgJiZcbiAgICAgICAgICAobnVsbCA9PT0gZmluaXNoZWRXb3JrLnJldHVybiB8fCAxMyAhPT0gZmluaXNoZWRXb3JrLnJldHVybi50YWcpXG4gICAgICAgICAgICA/ICgocHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJj1cbiAgICAgICAgICAgICAgICB+T2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykpXG4gICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgICBwb3BDb21wb25lbnRFZmZlY3RTdGFydChwcmV2RWZmZWN0U3RhcnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICAgICAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5mbGFncyAmIDE2KSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXSxcbiAgICAgICAgICAgICAgcHJldkVmZmVjdFN0YXJ0ID0gcHVzaENvbXBvbmVudEVmZmVjdFN0YXJ0KCk7XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oXG4gICAgICAgICAgICAgIGNoaWxkVG9EZWxldGUsXG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcG9wQ29tcG9uZW50RWZmZWN0U3RhcnQocHJldkVmZmVjdFN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QocGFyZW50RmliZXIpLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciBwcmV2RWZmZWN0U3RhcnQgPSBwdXNoQ29tcG9uZW50RWZmZWN0U3RhcnQoKTtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICBQYXNzaXZlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkICYmXG4gICAgICAgICAgICAoKGluc3RhbmNlLl92aXNpYmlsaXR5ICY9IH5PZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCksXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICAgIHBvcENvbXBvbmVudEVmZmVjdFN0YXJ0KHByZXZFZmZlY3RTdGFydCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oXG4gICAgICBkZWxldGVkU3VidHJlZVJvb3QsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yJGpzY29tcCQwXG4gICAgKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3QsXG4gICAgICAgICAgY3VycmVudCA9IGZpYmVyLFxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yJGpzY29tcCQwLFxuICAgICAgICAgIHByZXZFZmZlY3RTdGFydCA9IHB1c2hDb21wb25lbnRFZmZlY3RTdGFydCgpO1xuICAgICAgICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIFBhc3NpdmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgICBudWxsICE9IGN1cnJlbnQgJiYgcmV0YWluQ2FjaGUoY3VycmVudCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIHJlbGVhc2VDYWNoZShjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIHBvcENvbXBvbmVudEVmZmVjdFN0YXJ0KHByZXZFZmZlY3RTdGFydCk7XG4gICAgICAgIHByZXZFZmZlY3RTdGFydCA9IGZpYmVyLmNoaWxkO1xuICAgICAgICBpZiAobnVsbCAhPT0gcHJldkVmZmVjdFN0YXJ0KVxuICAgICAgICAgIChwcmV2RWZmZWN0U3RhcnQucmV0dXJuID0gZmliZXIpLCAobmV4dEVmZmVjdCA9IHByZXZFZmZlY3RTdGFydCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBhOiBmb3IgKGZpYmVyID0gZGVsZXRlZFN1YnRyZWVSb290OyBudWxsICE9PSBuZXh0RWZmZWN0OyApIHtcbiAgICAgICAgICAgIHByZXZFZmZlY3RTdGFydCA9IG5leHRFZmZlY3Q7XG4gICAgICAgICAgICBjdXJyZW50ID0gcHJldkVmZmVjdFN0YXJ0LnNpYmxpbmc7XG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yID0gcHJldkVmZmVjdFN0YXJ0LnJldHVybjtcbiAgICAgICAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKHByZXZFZmZlY3RTdGFydCk7XG4gICAgICAgICAgICBpZiAocHJldkVmZmVjdFN0YXJ0ID09PSBmaWJlcikge1xuICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQucmV0dXJuID0gbmVhcmVzdE1vdW50ZWRBbmNlc3RvcjtcbiAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gbmVhcmVzdE1vdW50ZWRBbmNlc3RvcjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQ29tbWl0Um9vdCgpIHtcbiAgICAgIGNvbW1pdEhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1pdEhvb2spIHtcbiAgICAgICAgcmV0dXJuIGNvbW1pdEhvb2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpIHtcbiAgICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UXG4gICAgICAgICAgPyBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlRcbiAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCB8fFxuICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIGN1cnJlbnQgdGVzdGluZyBlbnZpcm9ubWVudCBpcyBub3QgY29uZmlndXJlZCB0byBzdXBwb3J0IGFjdCguLi4pXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJlxuICAgICAgICAwICE9PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgKVxuICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiAtd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gdHJhbnNpdGlvblxuICAgICAgICA/ICh0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzIHx8ICh0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpKSxcbiAgICAgICAgICB0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmFkZChmaWJlciksXG4gICAgICAgICAgKGZpYmVyID0gY3VycmVudEVudGFuZ2xlZExhbmUpLFxuICAgICAgICAgIDAgIT09IGZpYmVyID8gZmliZXIgOiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSlcbiAgICAgICAgOiByZXNvbHZlVXBkYXRlUHJpb3JpdHkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdERlZmVycmVkTGFuZSgpIHtcbiAgICAgIDAgPT09IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9XG4gICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSB8fCBpc0h5ZHJhdGluZ1xuICAgICAgICAgICAgPyBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpXG4gICAgICAgICAgICA6IDUzNjg3MDkxMik7XG4gICAgICB2YXIgc3VzcGVuc2VIYW5kbGVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlSGFuZGxlciAmJiAoc3VzcGVuc2VIYW5kbGVyLmZsYWdzIHw9IDMyKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gICAgICBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcInVzZUluc2VydGlvbkVmZmVjdCBtdXN0IG5vdCBzY2hlZHVsZSB1cGRhdGVzLlwiKTtcbiAgICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyAmJiAoZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9ICEwKTtcbiAgICAgIGlmIChcbiAgICAgICAgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhIHx8XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25BY3Rpb24pKSB8fFxuICAgICAgICBudWxsICE9PSByb290LmNhbmNlbFBlbmRpbmdDb21taXRcbiAgICAgIClcbiAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgMCksXG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICExXG4gICAgICAgICAgKTtcbiAgICAgIG1hcmtSb290VXBkYXRlZCQxKHJvb3QsIGxhbmUpO1xuICAgICAgaWYgKFxuICAgICAgICAwICE9PSAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICYmXG4gICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdFxuICAgICAgKSB7XG4gICAgICAgIGlmIChpc1JlbmRlcmluZylcbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIHJvb3QgPVxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyAmJiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSkgfHxcbiAgICAgICAgICAgICAgICBcIlVua25vd25cIjtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50Lmhhcyhyb290KSB8fFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuYWRkKHJvb3QpLFxuICAgICAgICAgICAgICAgIChmaWJlciA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDYW5ub3QgdXBkYXRlIGEgY29tcG9uZW50IChgJXNgKSB3aGlsZSByZW5kZXJpbmcgYSBkaWZmZXJlbnQgY29tcG9uZW50IChgJXNgKS4gVG8gbG9jYXRlIHRoZSBiYWQgc2V0U3RhdGUoKSBjYWxsIGluc2lkZSBgJXNgLCBmb2xsb3cgdGhlIHN0YWNrIHRyYWNlIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL3JlYWN0LmRldi9saW5rL3NldHN0YXRlLWluLXJlbmRlclwiLFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgcm9vdFxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgfHxcbiAgICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyB3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS5cIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gITApKTtcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIGZpYmVyLCBsYW5lKSxcbiAgICAgICAgICB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpLFxuICAgICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgICAgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgPT09IE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgfD0gbGFuZSksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5ICYmXG4gICAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtV29ya09uUm9vdChyb290LCBsYW5lcywgZm9yY2VTeW5jKSB7XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KVxuICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiKTtcbiAgICAgIHZhciBzaG91bGRUaW1lU2xpY2UgPVxuICAgICAgICAgICghZm9yY2VTeW5jICYmXG4gICAgICAgICAgICAwID09PSAobGFuZXMgJiAxMjQpICYmXG4gICAgICAgICAgICAwID09PSAobGFuZXMgJiByb290LmV4cGlyZWRMYW5lcykpIHx8XG4gICAgICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBsYW5lcyksXG4gICAgICAgIGV4aXRTdGF0dXMgPSBzaG91bGRUaW1lU2xpY2VcbiAgICAgICAgICA/IHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKVxuICAgICAgICAgIDogcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMsICEwKSxcbiAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IHNob3VsZFRpbWVTbGljZTtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgJiZcbiAgICAgICAgICAgICFzaG91bGRUaW1lU2xpY2UgJiZcbiAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCAwLCAhMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yY2VTeW5jID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ICYmXG4gICAgICAgICAgICAhaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZvcmNlU3luYylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcywgITEpO1xuICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9ICExO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IGxhbmVzO1xuICAgICAgICAgICAgaWYgKHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgJiByZW5kZXJXYXNDb25jdXJyZW50KVxuICAgICAgICAgICAgICB2YXIgZXJyb3JSZXRyeUxhbmVzID0gMDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKGVycm9yUmV0cnlMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgLTUzNjg3MDkxMyksXG4gICAgICAgICAgICAgICAgKGVycm9yUmV0cnlMYW5lcyA9XG4gICAgICAgICAgICAgICAgICAwICE9PSBlcnJvclJldHJ5TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgPyBlcnJvclJldHJ5TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgOiBlcnJvclJldHJ5TGFuZXMgJiA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgICAgICA/IDUzNjg3MDkxMlxuICAgICAgICAgICAgICAgICAgICAgIDogMCk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gZXJyb3JSZXRyeUxhbmVzKSB7XG4gICAgICAgICAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgICAgICBlcnJvclJldHJ5TGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzO1xuICAgICAgICAgICAgICAgIHZhciB3YXNSb290RGVoeWRyYXRlZCA9XG4gICAgICAgICAgICAgICAgICBleGl0U3RhdHVzLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG4gICAgICAgICAgICAgICAgd2FzUm9vdERlaHlkcmF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIChwcmVwYXJlRnJlc2hTdGFjayhcbiAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICApLmZsYWdzIHw9IDI1Nik7XG4gICAgICAgICAgICAgICAgZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwID0gcmVuZGVyUm9vdFN5bmMoXG4gICAgICAgICAgICAgICAgICBleGl0U3RhdHVzLFxuICAgICAgICAgICAgICAgICAgZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvclJldHJ5TGFuZXMkanNjb21wJDAgIT09IFJvb3RFcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciAmJlxuICAgICAgICAgICAgICAgICAgICAhd2FzUm9vdERlaHlkcmF0ZWRcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBleGl0U3RhdHVzLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzIHw9XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgfD1cbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycztcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZXhpdFN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGV4aXRTdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMgPSBlcnJvclJldHJ5TGFuZXMkanNjb21wJDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9ICExO1xuICAgICAgICAgICAgICBpZiAoZXhpdFN0YXR1cyAhPT0gUm9vdEVycm9yZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgICAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgMCk7XG4gICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgMCwgITApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSA9IHJvb3Q7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4aXRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgY2FzZSBSb290SW5Qcm9ncmVzczpcbiAgICAgICAgICAgICAgY2FzZSBSb290RmF0YWxFcnJvcmVkOlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgICAgICAgICAgY2FzZSBSb290U3VzcGVuZGVkV2l0aERlbGF5OlxuICAgICAgICAgICAgICAgIGlmICgobGFuZXMgJiA0MTk0MDQ4KSAhPT0gbGFuZXMpIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RTdXNwZW5kZWRBdFRoZVNoZWxsOlxuICAgICAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAgICF3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RTdXNwZW5kZWQ6XG4gICAgICAgICAgICAgIGNhc2UgUm9vdENvbXBsZXRlZDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gcm9vdCBleGl0IHN0YXR1cy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUpXG4gICAgICAgICAgICAgIGNvbW1pdFJvb3QoXG4gICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICAgIGZvcmNlU3luYyxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChsYW5lcyAmIDYyOTE0NTYwKSA9PT0gbGFuZXMgJiZcbiAgICAgICAgICAgICAgICAoKHJlbmRlcldhc0NvbmN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSArXG4gICAgICAgICAgICAgICAgICBGQUxMQkFDS19USFJPVFRMRV9NUyAtXG4gICAgICAgICAgICAgICAgICBub3ckMSgpKSxcbiAgICAgICAgICAgICAgICAxMCA8IHJlbmRlcldhc0NvbmN1cnJlbnQpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAgICF3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICgwICE9PSBnZXROZXh0TGFuZXMoc2hvdWxkVGltZVNsaWNlLCAwLCAhMCkpIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICBjb21taXRSb290V2hlblJlYWR5LmJpbmQoXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gICAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIFRIUk9UVExFRF9DT01NSVQsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMsXG4gICAgICAgICAgICAgICAgSU1NRURJQVRFX0NPTU1JVCxcbiAgICAgICAgICAgICAgICByZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSb290V2hlblJlYWR5KFxuICAgICAgcm9vdCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICBsYW5lcyxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgIGRpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyxcbiAgICAgIGV4aXRTdGF0dXMsXG4gICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgKSB7XG4gICAgICByb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7XG4gICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24gPSBmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzO1xuICAgICAgaWYgKFxuICAgICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24gJiA4MTkyIHx8XG4gICAgICAgIDE2Nzg1NDA4ID09PSAoc3VzcGVuZGVkQ29tbWl0UmVhc29uICYgMTY3ODU0MDgpXG4gICAgICApXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKHN1c3BlbmRlZFN0YXRlID0geyBzdHlsZXNoZWV0czogbnVsbCwgY291bnQ6IDAsIHVuc3VzcGVuZDogbm9vcCB9KSxcbiAgICAgICAgICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIChzdXNwZW5kZWRDb21taXRSZWFzb24gPSB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5KCkpLFxuICAgICAgICAgIG51bGwgIT09IHN1c3BlbmRlZENvbW1pdFJlYXNvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gc3VzcGVuZGVkQ29tbWl0UmVhc29uKFxuICAgICAgICAgICAgY29tbWl0Um9vdC5iaW5kKFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgICAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgZXhpdFN0YXR1cyxcbiAgICAgICAgICAgICAgU1VTUEVOREVEX0NPTU1JVCxcbiAgICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICAgICAgIWRpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjb21taXRSb290KFxuICAgICAgICByb290LFxuICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgIGxhbmVzLFxuICAgICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykge1xuICAgICAgZm9yICh2YXIgbm9kZSA9IGZpbmlzaGVkV29yazsgOyApIHtcbiAgICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKDAgPT09IHRhZyB8fCAxMSA9PT0gdGFnIHx8IDE1ID09PSB0YWcpICYmXG4gICAgICAgICAgbm9kZS5mbGFncyAmIDE2Mzg0ICYmXG4gICAgICAgICAgKCh0YWcgPSBub2RlLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICBudWxsICE9PSB0YWcgJiYgKCh0YWcgPSB0YWcuc3RvcmVzKSwgbnVsbCAhPT0gdGFnKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2sgPSB0YWdbaV0sXG4gICAgICAgICAgICAgIGdldFNuYXBzaG90ID0gY2hlY2suZ2V0U25hcHNob3Q7XG4gICAgICAgICAgICBjaGVjayA9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFvYmplY3RJcyhnZXRTbmFwc2hvdCgpLCBjaGVjaykpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHRhZyA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGlmIChub2RlLnN1YnRyZWVGbGFncyAmIDE2Mzg0ICYmIG51bGwgIT09IHRhZylcbiAgICAgICAgICAodGFnLnJldHVybiA9IG5vZGUpLCAobm9kZSA9IHRhZyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IG5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBmaW5pc2hlZFdvcmspIHJldHVybiAhMDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICByb290LFxuICAgICAgc3VzcGVuZGVkTGFuZXMsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlXG4gICAgKSB7XG4gICAgICBzdXNwZW5kZWRMYW5lcyAmPSB+d29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXM7XG4gICAgICBzdXNwZW5kZWRMYW5lcyAmPSB+d29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXM7XG4gICAgICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICAgICAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7XG4gICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZSAmJiAocm9vdC53YXJtTGFuZXMgfD0gc3VzcGVuZGVkTGFuZXMpO1xuICAgICAgZGlkQXR0ZW1wdEVudGlyZVRyZWUgPSByb290LmV4cGlyYXRpb25UaW1lcztcbiAgICAgIGZvciAodmFyIGxhbmVzID0gc3VzcGVuZGVkTGFuZXM7IDAgPCBsYW5lczsgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZVtpbmRleF0gPSAtMTtcbiAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICAwICE9PSBzcGF3bmVkTGFuZSAmJlxuICAgICAgICBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgc3VzcGVuZGVkTGFuZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN5bmNXb3JrJDEoKSB7XG4gICAgICByZXR1cm4gKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0XG4gICAgICAgID8gKGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKSwgITEpXG4gICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpIHtcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IE5vdFN1c3BlbmRlZClcbiAgICAgICAgICB2YXIgaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgKGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpLFxuICAgICAgICAgICAgcmVzZXRIb29rc09uVW53aW5kKGludGVycnVwdGVkV29yayksXG4gICAgICAgICAgICAodGhlbmFibGVTdGF0ZSQxID0gbnVsbCksXG4gICAgICAgICAgICAodGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDApLFxuICAgICAgICAgICAgKGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZm9yICg7IG51bGwgIT09IGludGVycnVwdGVkV29yazsgKVxuICAgICAgICAgIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmsuYWx0ZXJuYXRlLCBpbnRlcnJ1cHRlZFdvcmspLFxuICAgICAgICAgICAgKGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm4pO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKSB7XG4gICAgICB2YXIgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcbiAgICAgIHRpbWVvdXRIYW5kbGUgIT09IG5vVGltZW91dCAmJlxuICAgICAgICAoKHJvb3QudGltZW91dEhhbmRsZSA9IG5vVGltZW91dCksIGNhbmNlbFRpbWVvdXQodGltZW91dEhhbmRsZSkpO1xuICAgICAgdGltZW91dEhhbmRsZSA9IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdDtcbiAgICAgIG51bGwgIT09IHRpbWVvdXRIYW5kbGUgJiZcbiAgICAgICAgKChyb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsKSwgdGltZW91dEhhbmRsZSgpKTtcbiAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gdGltZW91dEhhbmRsZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJvb3QuY3VycmVudCwgbnVsbCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IGxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIGxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJblByb2dyZXNzO1xuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID1cbiAgICAgICAgICAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID1cbiAgICAgICAgbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSAhMTtcbiAgICAgIDAgIT09IChsYW5lcyAmIDgpICYmIChsYW5lcyB8PSBsYW5lcyAmIDMyKTtcbiAgICAgIHZhciBhbGxFbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG4gICAgICBpZiAoMCAhPT0gYWxsRW50YW5nbGVkTGFuZXMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgcm9vdCA9IHJvb3QuZW50YW5nbGVtZW50cywgYWxsRW50YW5nbGVkTGFuZXMgJj0gbGFuZXM7XG4gICAgICAgICAgMCA8IGFsbEVudGFuZ2xlZExhbmVzO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIoYWxsRW50YW5nbGVkTGFuZXMpLFxuICAgICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgICAgbGFuZXMgfD0gcm9vdFtpbmRleF07XG4gICAgICAgICAgYWxsRW50YW5nbGVkTGFuZXMgJj0gfmxhbmU7XG4gICAgICAgIH1cbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gbGFuZXM7XG4gICAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG4gICAgICBsYW5lcyA9IGdldEN1cnJlbnRUaW1lKCk7XG4gICAgICAxZTMgPCBsYW5lcyAtIGxhc3RSZXNldFRpbWUgJiZcbiAgICAgICAgKChSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcyA9IDApLFxuICAgICAgICAobGFzdFJlc2V0VGltZSA9IGxhbmVzKSk7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gICAgICByZXR1cm4gdGltZW91dEhhbmRsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgICAgaXNSZW5kZXJpbmcgPSAhMTtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uIHx8XG4gICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VBY3Rpb25FeGNlcHRpb25cbiAgICAgICAgPyAoKHRocm93blZhbHVlID0gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkT25JbW1lZGlhdGUpKVxuICAgICAgICA6IHRocm93blZhbHVlID09PSBTdXNwZW5zZXlDb21taXRFeGNlcHRpb25cbiAgICAgICAgICA/ICgodGhyb3duVmFsdWUgPSBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZE9uSW5zdGFuY2UpKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvblxuICAgICAgICAgICAgICAgID8gU3VzcGVuZGVkT25IeWRyYXRpb25cbiAgICAgICAgICAgICAgICA6IG51bGwgIT09IHRocm93blZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0aHJvd25WYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0aHJvd25WYWx1ZS50aGVuXG4gICAgICAgICAgICAgICAgICA/IFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZVxuICAgICAgICAgICAgICAgICAgOiBTdXNwZW5kZWRPbkVycm9yKTtcbiAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSB0aHJvd25WYWx1ZTtcbiAgICAgIHZhciBlcnJvcmVkV29yayA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgaWYgKG51bGwgPT09IGVycm9yZWRXb3JrKVxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQpLFxuICAgICAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICAgICAgICApO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChlcnJvcmVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUgJiZcbiAgICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24oZXJyb3JlZFdvcmspLFxuICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCksXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25FcnJvcjpcbiAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkICYmXG4gICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudEVycm9yZWQoXG4gICAgICAgICAgICAgICAgZXJyb3JlZFdvcmssXG4gICAgICAgICAgICAgICAgdGhyb3duVmFsdWUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25BY3Rpb246XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZTpcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQgJiZcbiAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgIGVycm9yZWRXb3JrLFxuICAgICAgICAgICAgICAgIHRocm93blZhbHVlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbigpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgIHJldHVybiBudWxsID09PSBoYW5kbGVyXG4gICAgICAgID8gITBcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA0MTk0MDQ4KSA9PT1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgPyBudWxsID09PSBzaGVsbEJvdW5kYXJ5XG4gICAgICAgICAgICA/ICEwXG4gICAgICAgICAgICA6ICExXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA2MjkxNDU2MCkgPT09XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgfHxcbiAgICAgICAgICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKVxuICAgICAgICAgICAgPyBoYW5kbGVyID09PSBzaGVsbEJvdW5kYXJ5XG4gICAgICAgICAgICA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRGlzcGF0Y2hlcigpIHtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICAgICAgcmV0dXJuIG51bGwgPT09IHByZXZEaXNwYXRjaGVyID8gQ29udGV4dE9ubHlEaXNwYXRjaGVyIDogcHJldkRpc3BhdGNoZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBc3luY0Rpc3BhdGNoZXIoKSB7XG4gICAgICB2YXIgcHJldkFzeW5jRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gRGVmYXVsdEFzeW5jRGlzcGF0Y2hlcjtcbiAgICAgIHJldHVybiBwcmV2QXN5bmNEaXNwYXRjaGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgfHxcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDQxOTQwNDgpICE9PVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYmXG4gICAgICAgICAgbnVsbCAhPT0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCkgfHxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gITApO1xuICAgICAgKDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgJiAxMzQyMTc3MjcpICYmXG4gICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyAmIDEzNDIxNzcyNykpIHx8XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdCB8fFxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMsIHNob3VsZFlpZWxkRm9yUHJlcmVuZGVyaW5nKSB7XG4gICAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZW5kZXJDb250ZXh0O1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKSxcbiAgICAgICAgcHJldkFzeW5jRGlzcGF0Y2hlciA9IHB1c2hBc3luY0Rpc3BhdGNoZXIoKTtcbiAgICAgIGlmIChcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290ICE9PSByb290IHx8XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBsYW5lc1xuICAgICAgKSB7XG4gICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAgIHZhciBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuICAgICAgICAgIDAgPCBtZW1vaXplZFVwZGF0ZXJzLnNpemUgJiZcbiAgICAgICAgICAgIChyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKSk7XG4gICAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gbnVsbDtcbiAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgICAgbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICAgICAgbGFuZXMgPSAhMTtcbiAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICAgICAgYTogZG9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiAhPT0gTm90U3VzcGVuZGVkICYmXG4gICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPSB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbikge1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSHlkcmF0aW9uOlxuICAgICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSBSb290U3VzcGVuZGVkQXRUaGVTaGVsbDtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkFjdGlvbjpcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCAmJiAobGFuZXMgPSAhMCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmcgJiZcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gUm9vdEluUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAocmVhc29uID0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkOCkge1xuICAgICAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlJDgpO1xuICAgICAgICB9XG4gICAgICB3aGlsZSAoMSk7XG4gICAgICBsYW5lcyAmJiByb290LnNoZWxsU3VzcGVuZENvdW50ZXIrKztcbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCksXG4gICAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRVcGRhdGVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHdvcmtJblByb2dyZXNzOyApIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIHtcbiAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpO1xuICAgICAgaWYgKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IG1lbW9pemVkVXBkYXRlcnMuc2l6ZSAmJlxuICAgICAgICAgICAgKHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpKTtcbiAgICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TO1xuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgKTtcbiAgICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgICAgIGE6IGRvXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IE5vdFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApXG4gICAgICAgICAgICBiOiBzd2l0Y2ggKFxuICAgICAgICAgICAgICAoKGxhbmVzID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAobWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRXJyb3I6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25BY3Rpb246XG4gICAgICAgICAgICAgICAgaWYgKGlzVGhlbmFibGVSZXNvbHZlZChtZW1vaXplZFVwZGF0ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICE9PSBTdXNwZW5kZWRPbkRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IFN1c3BlbmRlZE9uQWN0aW9uKSB8fFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICAgICAgICAgICAgICBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUpO1xuICAgICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy50aGVuKGxhbmVzLCBsYW5lcyk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2U6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgICAgICBpc1RoZW5hYmxlUmVzb2x2ZWQobWVtb2l6ZWRVcGRhdGVycylcbiAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpKVxuICAgICAgICAgICAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcHJlbG9hZFJlc291cmNlKHJlc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBob3N0RmliZXIuc3RhdGVOb2RlLmNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gaG9zdEZpYmVyLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHNpYmxpbmcpIHdvcmtJblByb2dyZXNzID0gc2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5GaWJlciA9IGhvc3RGaWJlci5yZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVVbml0T2ZXb3JrKHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MgPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHR5cGUgb2YgZmliZXIgdHJpZ2dlcmVkIGEgc3VzcGVuc2V5IGNvbW1pdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyxcbiAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZTpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyxcbiAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25IeWRyYXRpb246XG4gICAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRBdFRoZVNoZWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuZGVkUmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZVxuICAgICAgICAgICAgPyB3b3JrTG9vcFN5bmMoKVxuICAgICAgICAgICAgOiB3b3JrTG9vcENvbmN1cnJlbnRCeVNjaGVkdWxlcigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQ5KSB7XG4gICAgICAgICAgaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUkOSk7XG4gICAgICAgIH1cbiAgICAgIHdoaWxlICgxKTtcbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCgpLFxuICAgICAgICAgIFJvb3RJblByb2dyZXNzXG4gICAgICAgICk7XG4gICAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMDtcbiAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3b3JrTG9vcENvbmN1cnJlbnRCeVNjaGVkdWxlcigpIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcyAmJiAhc2hvdWxkWWllbGQoKTsgKVxuICAgICAgICBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gICAgICAodW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGVcbiAgICAgICAgPyAoc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspLFxuICAgICAgICAgIChjdXJyZW50ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgYmVnaW5Xb3JrLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24odW5pdE9mV29yaykpXG4gICAgICAgIDogKGN1cnJlbnQgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBiZWdpbldvcmssXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzXG4gICAgICAgICAgKSk7XG4gICAgICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgPyBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaylcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgbmV4dCA9IHJ1bldpdGhGaWJlckluREVWKHVuaXRPZldvcmssIHJlcGxheUJlZ2luV29yaywgdW5pdE9mV29yayk7XG4gICAgICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgICAgIG51bGwgPT09IG5leHQgPyBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykgOiAod29ya0luUHJvZ3Jlc3MgPSBuZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5QmVnaW5Xb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGUsXG4gICAgICAgIGlzUHJvZmlsaW5nTW9kZSA9ICh1bml0T2ZXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZTtcbiAgICAgIGlzUHJvZmlsaW5nTW9kZSAmJiBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICBzd2l0Y2ggKHVuaXRPZldvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjdXJyZW50ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIHVuaXRPZldvcmsucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgdW5pdE9mV29yay50eXBlLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGN1cnJlbnQgPSByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgdW5pdE9mV29yay5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnR5cGUucmVuZGVyLFxuICAgICAgICAgICAgdW5pdE9mV29yay5yZWYsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXNldEhvb2tzT25VbndpbmQodW5pdE9mV29yayk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIHVuaXRPZldvcmspLFxuICAgICAgICAgICAgKHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3ModW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKSk7XG4gICAgICB9XG4gICAgICBpc1Byb2ZpbGluZ01vZGUgJiZcbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbih1bml0T2ZXb3JrKTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgcm9vdCxcbiAgICAgIHVuaXRPZldvcmssXG4gICAgICB0aHJvd25WYWx1ZSxcbiAgICAgIHN1c3BlbmRlZFJlYXNvblxuICAgICkge1xuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICByZXNldEhvb2tzT25VbndpbmQodW5pdE9mV29yayk7XG4gICAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB1bml0T2ZXb3JrLnJldHVybjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aHJvd0V4Y2VwdGlvbihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICB0aHJvd25WYWx1ZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICAgICAgICBsb2dVbmNhdWdodEVycm9yKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAobnVsbCAhPT0gcmV0dXJuRmliZXIpIHRocm93ICgod29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlciksIGVycm9yKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gICAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICAgICApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1bml0T2ZXb3JrLmZsYWdzICYgMzI3NjgpIHtcbiAgICAgICAgaWYgKGlzSHlkcmF0aW5nIHx8IHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25FcnJvcikgcm9vdCA9ICEwO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyB8fFxuICAgICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMilcbiAgICAgICAgKVxuICAgICAgICAgIHJvb3QgPSAhMTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSByb290ID0gITApLFxuICAgICAgICAgIHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhIHx8XG4gICAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uQWN0aW9uIHx8XG4gICAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uSW1tZWRpYXRlIHx8XG4gICAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSlcbiAgICAgICAgKVxuICAgICAgICAgIChzdXNwZW5kZWRSZWFzb24gPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICAgIG51bGwgIT09IHN1c3BlbmRlZFJlYXNvbiAmJlxuICAgICAgICAgICAgICAxMyA9PT0gc3VzcGVuZGVkUmVhc29uLnRhZyAmJlxuICAgICAgICAgICAgICAoc3VzcGVuZGVkUmVhc29uLmZsYWdzIHw9IDE2Mzg0KTtcbiAgICAgICAgdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrLCByb290KTtcbiAgICAgIH0gZWxzZSBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgY29tcGxldGVkV29yayA9IHVuaXRPZldvcms7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgwICE9PSAoY29tcGxldGVkV29yay5mbGFncyAmIDMyNzY4KSkge1xuICAgICAgICAgIHVud2luZFVuaXRPZldvcmsoXG4gICAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgdW5pdE9mV29yayA9IGNvbXBsZXRlZFdvcmsucmV0dXJuO1xuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIoY29tcGxldGVkV29yayk7XG4gICAgICAgIGN1cnJlbnQgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgIGNvbXBsZXRlV29yayxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGNvbXBsZXRlZFdvcmssXG4gICAgICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmRJbmNvbXBsZXRlRHVyYXRpb24oY29tcGxldGVkV29yayk7XG4gICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb21wbGV0ZWRXb3JrID0gY29tcGxldGVkV29yay5zaWJsaW5nO1xuICAgICAgICBpZiAobnVsbCAhPT0gY29tcGxldGVkV29yaykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gY29tcGxldGVkV29yaztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcbiAgICAgIH0gd2hpbGUgKG51bGwgIT09IGNvbXBsZXRlZFdvcmspO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290Q29tcGxldGVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrLCBza2lwU2libGluZ3MpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIG5leHQgPSB1bndpbmRXb3JrKHVuaXRPZldvcmsuYWx0ZXJuYXRlLCB1bml0T2ZXb3JrKTtcbiAgICAgICAgaWYgKG51bGwgIT09IG5leHQpIHtcbiAgICAgICAgICBuZXh0LmZsYWdzICY9IDMyNzY3O1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh1bml0T2ZXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uKHVuaXRPZldvcmspO1xuICAgICAgICAgIG5leHQgPSB1bml0T2ZXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgIGZvciAodmFyIGNoaWxkID0gdW5pdE9mV29yay5jaGlsZDsgbnVsbCAhPT0gY2hpbGQ7IClcbiAgICAgICAgICAgIChuZXh0ICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSwgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdW5pdE9mV29yay5hY3R1YWxEdXJhdGlvbiA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IHVuaXRPZldvcmsucmV0dXJuO1xuICAgICAgICBudWxsICE9PSBuZXh0ICYmXG4gICAgICAgICAgKChuZXh0LmZsYWdzIHw9IDMyNzY4KSxcbiAgICAgICAgICAobmV4dC5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAobmV4dC5kZWxldGlvbnMgPSBudWxsKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhc2tpcFNpYmxpbmdzICYmXG4gICAgICAgICAgKCh1bml0T2ZXb3JrID0gdW5pdE9mV29yay5zaWJsaW5nKSwgbnVsbCAhPT0gdW5pdE9mV29yaylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1bml0T2ZXb3JrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVuaXRPZldvcmsgPSBuZXh0O1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gdW5pdE9mV29yayk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZEF0VGhlU2hlbGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFJvb3QoXG4gICAgICByb290LFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgbGFuZXMsXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgc3Bhd25lZExhbmUsXG4gICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4gICAgKSB7XG4gICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsO1xuICAgICAgZG8gZmx1c2hQZW5kaW5nRWZmZWN0cygpO1xuICAgICAgd2hpbGUgKHBlbmRpbmdFZmZlY3RzU3RhdHVzICE9PSBOT19QRU5ESU5HX0VGRkVDVFMpO1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpXG4gICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuXCIpO1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdGFydGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpO1xuICAgICAgaWYgKG51bGwgPT09IGZpbmlzaGVkV29yaykgbWFya0NvbW1pdFN0b3BwZWQoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICAwID09PSBsYW5lcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImZpbmlzaGVkTGFuZXMgc2hvdWxkIG5vdCBiZSBlbXB0eSBkdXJpbmcgYSBjb21taXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoZmluaXNoZWRXb3JrID09PSByb290LmN1cnJlbnQpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBjb21taXQgdGhlIHNhbWUgdHJlZSBhcyBiZWZvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgPVxuICAgICAgICAgIGZpbmlzaGVkV29yay5sYW5lcyB8IGZpbmlzaGVkV29yay5jaGlsZExhbmVzO1xuICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgfD0gY29uY3VycmVudGx5VXBkYXRlZExhbmVzO1xuICAgICAgICBtYXJrUm9vdEZpbmlzaGVkKFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4gICAgICAgICk7XG4gICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwKSk7XG4gICAgICAgIHBlbmRpbmdGaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIHBlbmRpbmdFZmZlY3RzUm9vdCA9IHJvb3Q7XG4gICAgICAgIHBlbmRpbmdFZmZlY3RzTGFuZXMgPSBsYW5lcztcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNSZW1haW5pbmdMYW5lcyA9IGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZTtcbiAgICAgICAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuICAgICAgICBwZW5kaW5nUmVjb3ZlcmFibGVFcnJvcnMgPSByZWNvdmVyYWJsZUVycm9ycztcbiAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxMDI1NikgfHxcbiAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5mbGFncyAmIDEwMjU2KVxuICAgICAgICAgID8gKChyb290LmNhbGxiYWNrTm9kZSA9IG51bGwpLFxuICAgICAgICAgICAgKHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDApLFxuICAgICAgICAgICAgc2NoZWR1bGVDYWxsYmFjayQxKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cyghMCk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgOiAoKHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbCksIChyb290LmNhbGxiYWNrUHJpb3JpdHkgPSAwKSk7XG4gICAgICAgIGNvbW1pdFN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgICByZWNvdmVyYWJsZUVycm9ycyA9IDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxMzg3OCk7XG4gICAgICAgIGlmICgwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDEzODc4KSB8fCByZWNvdmVyYWJsZUVycm9ycykge1xuICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3JzID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICAgICAgICB0cmFuc2l0aW9ucyA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnA7XG4gICAgICAgICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICAgICAgICBzcGF3bmVkTGFuZSA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBsYW5lcyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ID0gc3Bhd25lZExhbmUpLFxuICAgICAgICAgICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHRyYW5zaXRpb25zKSxcbiAgICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSByZWNvdmVyYWJsZUVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdFZmZlY3RzU3RhdHVzID0gUEVORElOR19NVVRBVElPTl9QSEFTRTtcbiAgICAgICAgZmx1c2hNdXRhdGlvbkVmZmVjdHMoKTtcbiAgICAgICAgZmx1c2hMYXlvdXRFZmZlY3RzKCk7XG4gICAgICAgIGZsdXNoU3Bhd25lZFdvcmsoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hNdXRhdGlvbkVmZmVjdHMoKSB7XG4gICAgICBpZiAocGVuZGluZ0VmZmVjdHNTdGF0dXMgPT09IFBFTkRJTkdfTVVUQVRJT05fUEhBU0UpIHtcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgPSBOT19QRU5ESU5HX0VGRkVDVFM7XG4gICAgICAgIHZhciByb290ID0gcGVuZGluZ0VmZmVjdHNSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayA9IHBlbmRpbmdGaW5pc2hlZFdvcmssXG4gICAgICAgICAgbGFuZXMgPSBwZW5kaW5nRWZmZWN0c0xhbmVzLFxuICAgICAgICAgIHJvb3RNdXRhdGlvbkhhc0VmZmVjdCA9IDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxMzg3OCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDEzODc4KSB8fFxuICAgICAgICAgIHJvb3RNdXRhdGlvbkhhc0VmZmVjdFxuICAgICAgICApIHtcbiAgICAgICAgICByb290TXV0YXRpb25IYXNFZmZlY3QgPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgICAgICAgICBSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gRGlzY3JldGVFdmVudFByaW9yaXR5O1xuICAgICAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpblByb2dyZXNzTGFuZXMgPSBsYW5lcztcbiAgICAgICAgICAgIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgICAgICAgICAgIGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSA9IC0xLjE7XG4gICAgICAgICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkV29yaywgcm9vdCk7XG4gICAgICAgICAgICBpblByb2dyZXNzUm9vdCA9IGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG4gICAgICAgICAgICBsYW5lcyA9IHNlbGVjdGlvbkluZm9ybWF0aW9uO1xuICAgICAgICAgICAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudERlZXAocm9vdC5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAgICAgcHJpb3JGb2N1c2VkRWxlbSA9IGxhbmVzLmZvY3VzZWRFbGVtLFxuICAgICAgICAgICAgICBwcmlvclNlbGVjdGlvblJhbmdlID0gbGFuZXMuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmXG4gICAgICAgICAgICAgIHByaW9yRm9jdXNlZEVsZW0gJiZcbiAgICAgICAgICAgICAgcHJpb3JGb2N1c2VkRWxlbS5vd25lckRvY3VtZW50ICYmXG4gICAgICAgICAgICAgIGNvbnRhaW5zTm9kZShcbiAgICAgICAgICAgICAgICBwcmlvckZvY3VzZWRFbGVtLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIHByaW9yRm9jdXNlZEVsZW1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBudWxsICE9PSBwcmlvclNlbGVjdGlvblJhbmdlICYmXG4gICAgICAgICAgICAgICAgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHByaW9yU2VsZWN0aW9uUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICBlbmQgPSBwcmlvclNlbGVjdGlvblJhbmdlLmVuZDtcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGVuZCAmJiAoZW5kID0gc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChcInNlbGVjdGlvblN0YXJ0XCIgaW4gcHJpb3JGb2N1c2VkRWxlbSlcbiAgICAgICAgICAgICAgICAgIChwcmlvckZvY3VzZWRFbGVtLnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICAocHJpb3JGb2N1c2VkRWxlbS5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgcHJpb3JGb2N1c2VkRWxlbS52YWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZG9jID0gcHJpb3JGb2N1c2VkRWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICB3aW4gPSAoZG9jICYmIGRvYy5kZWZhdWx0VmlldykgfHwgd2luZG93O1xuICAgICAgICAgICAgICAgICAgaWYgKHdpbi5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBwcmlvckZvY3VzZWRFbGVtLnRleHRDb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydCRqc2NvbXAkMCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JTZWxlY3Rpb25SYW5nZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgZW5kJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gcHJpb3JTZWxlY3Rpb25SYW5nZS5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzdGFydCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKHByaW9yU2VsZWN0aW9uUmFuZ2UuZW5kLCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAhc2VsZWN0aW9uLmV4dGVuZCAmJlxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0JGpzY29tcCQwID4gZW5kJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICAgICAgKChjdXJGb2N1c2VkRWxlbSA9IGVuZCRqc2NvbXAkMCksXG4gICAgICAgICAgICAgICAgICAgICAgKGVuZCRqc2NvbXAkMCA9IHN0YXJ0JGpzY29tcCQwKSxcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhcnQkanNjb21wJDAgPSBjdXJGb2N1c2VkRWxlbSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JGb2N1c2VkRWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0JGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JGb2N1c2VkRWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydE1hcmtlciAmJlxuICAgICAgICAgICAgICAgICAgICAgIGVuZE1hcmtlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICgxICE9PSBzZWxlY3Rpb24ucmFuZ2VDb3VudCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFuY2hvck5vZGUgIT09IHN0YXJ0TWFya2VyLm5vZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgIT09IHN0YXJ0TWFya2VyLm9mZnNldCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmZvY3VzTm9kZSAhPT0gZW5kTWFya2VyLm5vZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5mb2N1c09mZnNldCAhPT0gZW5kTWFya2VyLm9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQkanNjb21wJDAgPiBlbmQkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAocmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG9jID0gW107XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gcHJpb3JGb2N1c2VkRWxlbTtcbiAgICAgICAgICAgICAgICAoc2VsZWN0aW9uID0gc2VsZWN0aW9uLnBhcmVudE5vZGUpO1xuXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAxID09PSBzZWxlY3Rpb24ubm9kZVR5cGUgJiZcbiAgICAgICAgICAgICAgICAgIGRvYy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxlY3Rpb24uc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBzZWxlY3Rpb24uc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJpb3JGb2N1c2VkRWxlbS5mb2N1cyAmJlxuICAgICAgICAgICAgICAgIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBwcmlvckZvY3VzZWRFbGVtID0gMDtcbiAgICAgICAgICAgICAgICBwcmlvckZvY3VzZWRFbGVtIDwgZG9jLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwcmlvckZvY3VzZWRFbGVtKytcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBkb2NbcHJpb3JGb2N1c2VkRWxlbV07XG4gICAgICAgICAgICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICAgICAgICAgICAgaW5mby5lbGVtZW50LnNjcm9sbFRvcCA9IGluZm8udG9wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZW5hYmxlZCA9ICEhZXZlbnRzRW5hYmxlZDtcbiAgICAgICAgICAgIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQpLFxuICAgICAgICAgICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHJvb3RNdXRhdGlvbkhhc0VmZmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgPSBQRU5ESU5HX0xBWU9VVF9QSEFTRTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hMYXlvdXRFZmZlY3RzKCkge1xuICAgICAgaWYgKHBlbmRpbmdFZmZlY3RzU3RhdHVzID09PSBQRU5ESU5HX0xBWU9VVF9QSEFTRSkge1xuICAgICAgICBwZW5kaW5nRWZmZWN0c1N0YXR1cyA9IE5PX1BFTkRJTkdfRUZGRUNUUztcbiAgICAgICAgdmFyIHJvb3QgPSBwZW5kaW5nRWZmZWN0c1Jvb3QsXG4gICAgICAgICAgZmluaXNoZWRXb3JrID0gcGVuZGluZ0ZpbmlzaGVkV29yayxcbiAgICAgICAgICBsYW5lcyA9IHBlbmRpbmdFZmZlY3RzTGFuZXMsXG4gICAgICAgICAgcm9vdEhhc0xheW91dEVmZmVjdCA9IDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiA4NzcyKTtcbiAgICAgICAgaWYgKDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgODc3MikgfHwgcm9vdEhhc0xheW91dEVmZmVjdCkge1xuICAgICAgICAgIHJvb3RIYXNMYXlvdXRFZmZlY3QgPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgICAgICAgICBSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gRGlzY3JldGVFdmVudFByaW9yaXR5O1xuICAgICAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpLFxuICAgICAgICAgICAgICAoaW5Qcm9ncmVzc0xhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICAoaW5Qcm9ncmVzc1Jvb3QgPSByb290KSxcbiAgICAgICAgICAgICAgKGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSA9IC0xLjEpLFxuICAgICAgICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKFxuICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGluUHJvZ3Jlc3NSb290ID0gaW5Qcm9ncmVzc0xhbmVzID0gbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0KSxcbiAgICAgICAgICAgICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSByb290SGFzTGF5b3V0RWZmZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgPSBQRU5ESU5HX0FGVEVSX01VVEFUSU9OX1BIQVNFO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFNwYXduZWRXb3JrKCkge1xuICAgICAgaWYgKFxuICAgICAgICBwZW5kaW5nRWZmZWN0c1N0YXR1cyA9PT0gUEVORElOR19TUEFXTkVEX1dPUksgfHxcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgPT09IFBFTkRJTkdfQUZURVJfTVVUQVRJT05fUEhBU0VcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nRWZmZWN0c1N0YXR1cyA9IE5PX1BFTkRJTkdfRUZGRUNUUztcbiAgICAgICAgcmVxdWVzdFBhaW50KCk7XG4gICAgICAgIHZhciByb290ID0gcGVuZGluZ0VmZmVjdHNSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayA9IHBlbmRpbmdGaW5pc2hlZFdvcmssXG4gICAgICAgICAgbGFuZXMgPSBwZW5kaW5nRWZmZWN0c0xhbmVzLFxuICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3JzID0gcGVuZGluZ1JlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMgPVxuICAgICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxMDI1NikgfHxcbiAgICAgICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxMDI1Nik7XG4gICAgICAgIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHNcbiAgICAgICAgICA/IChwZW5kaW5nRWZmZWN0c1N0YXR1cyA9IFBFTkRJTkdfUEFTU0lWRV9QSEFTRSlcbiAgICAgICAgICA6ICgocGVuZGluZ0VmZmVjdHNTdGF0dXMgPSBOT19QRU5ESU5HX0VGRkVDVFMpLFxuICAgICAgICAgICAgKHBlbmRpbmdGaW5pc2hlZFdvcmsgPSBwZW5kaW5nRWZmZWN0c1Jvb3QgPSBudWxsKSxcbiAgICAgICAgICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcm9vdC5wZW5kaW5nTGFuZXMpLFxuICAgICAgICAgICAgKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsKSk7XG4gICAgICAgIHZhciByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgICAwID09PSByZW1haW5pbmdMYW5lcyAmJiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsKTtcbiAgICAgICAgcm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cyB8fCBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCk7XG4gICAgICAgIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShsYW5lcyk7XG4gICAgICAgIGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3RcbiAgICAgICAgKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZGlkRXJyb3IgPSAxMjggPT09IChmaW5pc2hlZFdvcmsuY3VycmVudC5mbGFncyAmIDEyOCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgY2FzZSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICAgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQ29udGludW91c0V2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBEZWZhdWx0RXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSWRsZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290KFxuICAgICAgICAgICAgICByZW5kZXJlcklELFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5LFxuICAgICAgICAgICAgICBkaWRFcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgcm9vdC5tZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIG9uQ29tbWl0Um9vdCgpO1xuICAgICAgICBpZiAobnVsbCAhPT0gcmVjb3ZlcmFibGVFcnJvcnMpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICAgICAgICAgIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBvblJlY292ZXJhYmxlRXJyb3IgPSByb290Lm9uUmVjb3ZlcmFibGVFcnJvcjtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayA9IDA7XG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayA8IHJlY292ZXJhYmxlRXJyb3JzLmxlbmd0aDtcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrKytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3ZlcmFibGVFcnJvciA9IHJlY292ZXJhYmxlRXJyb3JzW2ZpbmlzaGVkV29ya10sXG4gICAgICAgICAgICAgICAgZXJyb3JJbmZvID0gbWFrZUVycm9ySW5mbyhyZWNvdmVyYWJsZUVycm9yLnN0YWNrKTtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgcmVjb3ZlcmFibGVFcnJvci5zb3VyY2UsXG4gICAgICAgICAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3IudmFsdWUsXG4gICAgICAgICAgICAgICAgZXJyb3JJbmZvXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gZGlkRXJyb3IpLFxuICAgICAgICAgICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHNjaGVkdWxlclByaW9yaXR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgMCAhPT0gKHBlbmRpbmdFZmZlY3RzTGFuZXMgJiAzKSAmJiBmbHVzaFBlbmRpbmdFZmZlY3RzKCk7XG4gICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICAgICAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgICAgMCAhPT0gKGxhbmVzICYgNDE5NDA5MCkgJiYgMCAhPT0gKHJlbWFpbmluZ0xhbmVzICYgNDIpXG4gICAgICAgICAgPyAoKG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgICAgIHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlc1xuICAgICAgICAgICAgICA/IG5lc3RlZFVwZGF0ZUNvdW50KytcbiAgICAgICAgICAgICAgOiAoKG5lc3RlZFVwZGF0ZUNvdW50ID0gMCksIChyb290V2l0aE5lc3RlZFVwZGF0ZXMgPSByb290KSkpXG4gICAgICAgICAgOiAobmVzdGVkVXBkYXRlQ291bnQgPSAwKTtcbiAgICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpO1xuICAgICAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlRXJyb3JJbmZvKGNvbXBvbmVudFN0YWNrKSB7XG4gICAgICBjb21wb25lbnRTdGFjayA9IHsgY29tcG9uZW50U3RhY2s6IGNvbXBvbmVudFN0YWNrIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29tcG9uZW50U3RhY2ssIFwiZGlnZXN0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdZb3UgYXJlIGFjY2Vzc2luZyBcImRpZ2VzdFwiIGZyb20gdGhlIGVycm9ySW5mbyBvYmplY3QgcGFzc2VkIHRvIG9uUmVjb3ZlcmFibGVFcnJvci4gVGhpcyBwcm9wZXJ0eSBpcyBubyBsb25nZXIgcHJvdmlkZWQgYXMgcGFydCBvZiBlcnJvckluZm8gYnV0IGNhbiBiZSBhY2Nlc3NlZCBhcyBhIHByb3BlcnR5IG9mIHRoZSBFcnJvciBpbnN0YW5jZSBpdHNlbGYuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudFN0YWNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSB7XG4gICAgICAwID09PSAocm9vdC5wb29sZWRDYWNoZUxhbmVzICY9IHJlbWFpbmluZ0xhbmVzKSAmJlxuICAgICAgICAoKHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wb29sZWRDYWNoZSksXG4gICAgICAgIG51bGwgIT0gcmVtYWluaW5nTGFuZXMgJiZcbiAgICAgICAgICAoKHJvb3QucG9vbGVkQ2FjaGUgPSBudWxsKSwgcmVsZWFzZUNhY2hlKHJlbWFpbmluZ0xhbmVzKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFBlbmRpbmdFZmZlY3RzKHdhc0RlbGF5ZWRDb21taXQpIHtcbiAgICAgIGZsdXNoTXV0YXRpb25FZmZlY3RzKCk7XG4gICAgICBmbHVzaExheW91dEVmZmVjdHMoKTtcbiAgICAgIGZsdXNoU3Bhd25lZFdvcmsoKTtcbiAgICAgIHJldHVybiBmbHVzaFBhc3NpdmVFZmZlY3RzKHdhc0RlbGF5ZWRDb21taXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICAgICAgaWYgKHBlbmRpbmdFZmZlY3RzU3RhdHVzICE9PSBQRU5ESU5HX1BBU1NJVkVfUEhBU0UpIHJldHVybiAhMTtcbiAgICAgIHZhciByb290ID0gcGVuZGluZ0VmZmVjdHNSb290LFxuICAgICAgICByZW1haW5pbmdMYW5lcyA9IHBlbmRpbmdFZmZlY3RzUmVtYWluaW5nTGFuZXM7XG4gICAgICBwZW5kaW5nRWZmZWN0c1JlbWFpbmluZ0xhbmVzID0gMDtcbiAgICAgIHZhciByZW5kZXJQcmlvcml0eSA9IGxhbmVzVG9FdmVudFByaW9yaXR5KHBlbmRpbmdFZmZlY3RzTGFuZXMpLFxuICAgICAgICBwcmlvcml0eSA9XG4gICAgICAgICAgMCA9PT0gRGVmYXVsdEV2ZW50UHJpb3JpdHkgfHwgRGVmYXVsdEV2ZW50UHJpb3JpdHkgPiByZW5kZXJQcmlvcml0eVxuICAgICAgICAgICAgPyBEZWZhdWx0RXZlbnRQcmlvcml0eVxuICAgICAgICAgICAgOiByZW5kZXJQcmlvcml0eTtcbiAgICAgIHJlbmRlclByaW9yaXR5ID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgICAgIHRyeSB7XG4gICAgICAgIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmlvcml0eTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgICAgIHByaW9yaXR5ID0gcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucztcbiAgICAgICAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IG51bGw7XG4gICAgICAgIHZhciByb290JGpzY29tcCQwID0gcGVuZGluZ0VmZmVjdHNSb290LFxuICAgICAgICAgIGxhbmVzID0gcGVuZGluZ0VmZmVjdHNMYW5lcztcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgPSBOT19QRU5ESU5HX0VGRkVDVFM7XG4gICAgICAgIHBlbmRpbmdGaW5pc2hlZFdvcmsgPSBwZW5kaW5nRWZmZWN0c1Jvb3QgPSBudWxsO1xuICAgICAgICBwZW5kaW5nRWZmZWN0c0xhbmVzID0gMDtcbiAgICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgd2hpbGUgYWxyZWFkeSByZW5kZXJpbmcuXCIpO1xuICAgICAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMDtcbiAgICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9ICExO1xuICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCAmJlxuICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gICAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QkanNjb21wJDAuY3VycmVudDtcbiAgICAgICAgY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lID0gLTEuMTtcbiAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHZhciBmaW5pc2hlZFdvcmskanNjb21wJDAgPSByb290JGpzY29tcCQwLmN1cnJlbnQ7XG4gICAgICAgIGNvbXBvbmVudEVmZmVjdFN0YXJ0VGltZSA9IC0xLjE7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICAgICAgcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmskanNjb21wJDAsXG4gICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgcHJpb3JpdHlcbiAgICAgICAgKTtcbiAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQgJiZcbiAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgICAgICAgY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QkanNjb21wJDApO1xuICAgICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKTtcbiAgICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0c1xuICAgICAgICAgID8gcm9vdCRqc2NvbXAkMCA9PT0gcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlc1xuICAgICAgICAgICAgPyBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQrK1xuICAgICAgICAgICAgOiAoKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgICAgICAocm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IHJvb3QkanNjb21wJDApKVxuICAgICAgICAgIDogKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApO1xuICAgICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gITE7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290XG4gICAgICAgIClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290JGpzY29tcCQwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlTm9kZSA9IHJvb3QkanNjb21wJDAuY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcmVuZGVyUHJpb3JpdHkpLFxuICAgICAgICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChyb290RmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcikge1xuICAgICAgc291cmNlRmliZXIgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgc291cmNlRmliZXIpO1xuICAgICAgc291cmNlRmliZXIgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLnN0YXRlTm9kZSwgc291cmNlRmliZXIsIDIpO1xuICAgICAgcm9vdEZpYmVyID0gZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHNvdXJjZUZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHJvb3RGaWJlciAmJlxuICAgICAgICAobWFya1Jvb3RVcGRhdGVkJDEocm9vdEZpYmVyLCAyKSwgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3RGaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGVycm9yXG4gICAgKSB7XG4gICAgICBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMTtcbiAgICAgIGlmICgzID09PSBzb3VyY2VGaWJlci50YWcpXG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoOyBudWxsICE9PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yOyApIHtcbiAgICAgICAgICBpZiAoMyA9PT0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50YWcpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgxID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgfHxcbiAgICAgICAgICAgICAgICAgICFsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICAgICAgICAgIGVycm9yID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSgyKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSBlbnF1ZXVlVXBkYXRlKG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yLCAyKTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgICAoaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBtYXJrUm9vdFVwZGF0ZWQkMShpbnN0YW5jZSwgMiksXG4gICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGluc3RhbmNlKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciA9IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJJbnRlcm5hbCBSZWFjdCBlcnJvcjogQXR0ZW1wdGVkIHRvIGNhcHR1cmUgYSBjb21taXQgcGhhc2UgZXJyb3IgaW5zaWRlIGEgZGV0YWNoZWQgdHJlZS4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuIFBvdGVudGlhbCBjYXVzZXMgaW5jbHVkZSBkZWxldGluZyB0aGUgc2FtZSBmaWJlciBtb3JlIHRoYW4gb25jZSwgY29tbWl0dGluZyBhbiBhbHJlYWR5LWZpbmlzaGVkIHRyZWUsIG9yIGFuIGluY29uc2lzdGVudCByZXR1cm4gcG9pbnRlci5cXG5cXG5FcnJvciBtZXNzYWdlOlxcblxcbiVzXCIsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICAgICAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuICAgICAgaWYgKG51bGwgPT09IHBpbmdDYWNoZSkge1xuICAgICAgICBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbiAgICAgICAgdmFyIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAodGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSkpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gdGhyZWFkSURzICYmXG4gICAgICAgICAgICAoKHRocmVhZElEcyA9IG5ldyBTZXQoKSksIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcykpO1xuICAgICAgdGhyZWFkSURzLmhhcyhsYW5lcykgfHxcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMCksXG4gICAgICAgIHRocmVhZElEcy5hZGQobGFuZXMpLFxuICAgICAgICAocGluZ0NhY2hlID0gcGluZ1N1c3BlbmRlZFJvb3QuYmluZChudWxsLCByb290LCB3YWtlYWJsZSwgbGFuZXMpKSxcbiAgICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcyksXG4gICAgICAgIHdha2VhYmxlLnRoZW4ocGluZ0NhY2hlLCBwaW5nQ2FjaGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ1N1c3BlbmRlZFJvb3Qocm9vdCwgd2FrZWFibGUsIHBpbmdlZExhbmVzKSB7XG4gICAgICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gICAgICBudWxsICE9PSBwaW5nQ2FjaGUgJiYgcGluZ0NhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gICAgICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbiAgICAgIHJvb3Qud2FybUxhbmVzICY9IH5waW5nZWRMYW5lcztcbiAgICAgIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiZcbiAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkEgc3VzcGVuZGVkIHJlc291cmNlIGZpbmlzaGVkIGxvYWRpbmcgaW5zaWRlIGEgdGVzdCwgYnV0IHRoZSBldmVudCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgcmVzb2x2ZXMgc3VzcGVuZGVkIGRhdGEgc2hvdWxkIGJlIHdyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG5hY3QoKCkgPT4ge1xcbiAgLyogZmluaXNoIGxvYWRpbmcgc3VzcGVuZGVkIGRhdGEgKi9cXG59KTtcXG4vKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcblRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgaW4gdGhlIGJyb3dzZXIuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0XCJcbiAgICAgICAgKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9PT0gcm9vdCAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiBwaW5nZWRMYW5lcykgPT09IHBpbmdlZExhbmVzICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjI5MTQ1NjApID09PVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICBub3ckMSgpIC0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA8IEZBTExCQUNLX1RIUk9UVExFX01TKVxuICAgICAgICAgID8gKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIHw9IHBpbmdlZExhbmVzKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPSAwKSk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgICAgIDAgPT09IHJldHJ5TGFuZSAmJiAocmV0cnlMYW5lID0gY2xhaW1OZXh0UmV0cnlMYW5lKCkpO1xuICAgICAgYm91bmRhcnlGaWJlciA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgICAgbnVsbCAhPT0gYm91bmRhcnlGaWJlciAmJlxuICAgICAgICAobWFya1Jvb3RVcGRhdGVkJDEoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKSxcbiAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGJvdW5kYXJ5RmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShib3VuZGFyeUZpYmVyKSB7XG4gICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgcmV0cnlMYW5lID0gMDtcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlU3RhdGUgJiYgKHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKTtcbiAgICAgIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLCB3YWtlYWJsZSkge1xuICAgICAgdmFyIHJldHJ5TGFuZSA9IDA7XG4gICAgICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBudWxsICE9PSBzdXNwZW5zZVN0YXRlICYmIChyZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZS5fcmV0cnlDYWNoZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUGluZ2VkIHVua25vd24gc3VzcGVuc2UgYm91bmRhcnkgdHlwZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBudWxsICE9PSByZXRyeUNhY2hlICYmIHJldHJ5Q2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgICAgIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKFxuICAgICAgcm9vdCRqc2NvbXAkMCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgaXNJblN0cmljdE1vZGVcbiAgICApIHtcbiAgICAgIGlmICgwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgNjcxMTcwNTYpKVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICBmaWJlciA9IHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXIgPSBmaWJlci50eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyID0gaXNJblN0cmljdE1vZGUgfHwgaXNTdHJpY3RNb2RlRmliZXI7XG4gICAgICAgICAgMjIgIT09IGZpYmVyLnRhZ1xuICAgICAgICAgICAgPyBmaWJlci5mbGFncyAmIDY3MTA4ODY0XG4gICAgICAgICAgICAgID8gaXNTdHJpY3RNb2RlRmliZXIgJiZcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIsXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAoZmliZXIubW9kZSAmIE5vU3RyaWN0UGFzc2l2ZUVmZmVjdHNNb2RlKSA9PT0gTm9Nb2RlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICBpc1N0cmljdE1vZGVGaWJlclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogbnVsbCA9PT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAoaXNTdHJpY3RNb2RlRmliZXIgJiYgZmliZXIuZmxhZ3MgJiA4MTkyXG4gICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICBmaWJlclxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogZmliZXIuc3VidHJlZUZsYWdzICYgNjcxMDg4NjQgJiZcbiAgICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVixcbiAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIocm9vdCwgZmliZXIpIHtcbiAgICAgIHZhciBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyA9XG4gICAgICAgIDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogITA7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICB0cnkge1xuICAgICAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpYmVyKSxcbiAgICAgICAgICBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyAmJiBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaWJlciksXG4gICAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzKHJvb3QsIGZpYmVyLmFsdGVybmF0ZSwgZmliZXIsICExKSxcbiAgICAgICAgICBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyAmJlxuICAgICAgICAgICAgcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMocm9vdCwgZmliZXIsIDAsIG51bGwsICExLCAwKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QpIHtcbiAgICAgIHZhciBkb3VibGVJbnZva2VFZmZlY3RzID0gITA7XG4gICAgICByb290LmN1cnJlbnQubW9kZSAmIChTdHJpY3RMZWdhY3lNb2RlIHwgU3RyaWN0RWZmZWN0c01vZGUpIHx8XG4gICAgICAgIChkb3VibGVJbnZva2VFZmZlY3RzID0gITEpO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdC5jdXJyZW50LFxuICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAzID09PSB0YWcgfHxcbiAgICAgICAgICAxID09PSB0YWcgfHxcbiAgICAgICAgICAwID09PSB0YWcgfHxcbiAgICAgICAgICAxMSA9PT0gdGFnIHx8XG4gICAgICAgICAgMTQgPT09IHRhZyB8fFxuICAgICAgICAgIDE1ID09PSB0YWdcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGFnID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJSZWFjdENvbXBvbmVudFwiO1xuICAgICAgICAgIGlmIChudWxsICE9PSBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5oYXModGFnKSkgcmV0dXJuO1xuICAgICAgICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQodGFnKTtcbiAgICAgICAgICB9IGVsc2UgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG5ldyBTZXQoW3RhZ10pO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkNhbid0IHBlcmZvcm0gYSBSZWFjdCBzdGF0ZSB1cGRhdGUgb24gYSBjb21wb25lbnQgdGhhdCBoYXNuJ3QgbW91bnRlZCB5ZXQuIFRoaXMgaW5kaWNhdGVzIHRoYXQgeW91IGhhdmUgYSBzaWRlLWVmZmVjdCBpbiB5b3VyIHJlbmRlciBmdW5jdGlvbiB0aGF0IGFzeW5jaHJvbm91c2x5IGxhdGVyIGNhbGxzIHRyaWVzIHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50LiBNb3ZlIHRoaXMgd29yayB0byB1c2VFZmZlY3QgaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIGxhbmVzKSB7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJlxuICAgICAgICByb290Lm1lbW9pemVkVXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZWR1bGluZ0ZpYmVyKSB7XG4gICAgICAgICAgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIHNjaGVkdWxpbmdGaWJlciwgbGFuZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayQxKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgYWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZTtcbiAgICAgIHJldHVybiBudWxsICE9PSBhY3RRdWV1ZVxuICAgICAgICA/IChhY3RRdWV1ZS5wdXNoKGNhbGxiYWNrKSwgZmFrZUFjdENhbGxiYWNrTm9kZSQxKVxuICAgICAgICA6IHNjaGVkdWxlQ2FsbGJhY2skMyhwcmlvcml0eUxldmVsLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlcikge1xuICAgICAgaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSAmJlxuICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkFuIHVwZGF0ZSB0byAlcyBpbnNpZGUgYSB0ZXN0IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG5XaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbmFjdCgoKSA9PiB7XFxuICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbn0pO1xcbi8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBpbiB0aGUgYnJvd3Nlci4gTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0LmRldi9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3RcIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KSB7XG4gICAgICByb290ICE9PSBsYXN0U2NoZWR1bGVkUm9vdCAmJlxuICAgICAgICBudWxsID09PSByb290Lm5leHQgJiZcbiAgICAgICAgKG51bGwgPT09IGxhc3RTY2hlZHVsZWRSb290XG4gICAgICAgICAgPyAoZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290KVxuICAgICAgICAgIDogKGxhc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QubmV4dCA9IHJvb3QpKTtcbiAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICEwO1xuICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWVcbiAgICAgICAgPyBkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgfHxcbiAgICAgICAgICAoKGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9ICEwKSwgc2NoZWR1bGVJbW1lZGlhdGVSb290U2NoZWR1bGVUYXNrKCkpXG4gICAgICAgIDogZGlkU2NoZWR1bGVNaWNyb3Rhc2sgfHxcbiAgICAgICAgICAoKGRpZFNjaGVkdWxlTWljcm90YXNrID0gITApLCBzY2hlZHVsZUltbWVkaWF0ZVJvb3RTY2hlZHVsZVRhc2soKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKHN5bmNUcmFuc2l0aW9uTGFuZXMsIG9ubHlMZWdhY3kpIHtcbiAgICAgIGlmICghaXNGbHVzaGluZ1dvcmsgJiYgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrKSB7XG4gICAgICAgIGlzRmx1c2hpbmdXb3JrID0gITA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgZGlkUGVyZm9ybVNvbWVXb3JrID0gITE7XG4gICAgICAgICAgZm9yICh2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDsgbnVsbCAhPT0gcm9vdDsgKSB7XG4gICAgICAgICAgICBpZiAoIW9ubHlMZWdhY3kpXG4gICAgICAgICAgICAgIGlmICgwICE9PSBzeW5jVHJhbnNpdGlvbkxhbmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBwZW5kaW5nTGFuZXMpIHZhciBuZXh0TGFuZXMgPSAwO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzO1xuICAgICAgICAgICAgICAgICAgbmV4dExhbmVzID1cbiAgICAgICAgICAgICAgICAgICAgKDEgPDwgKDMxIC0gY2x6MzIoNDIgfCBzeW5jVHJhbnNpdGlvbkxhbmVzKSArIDEpKSAtIDE7XG4gICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgJj0gcGVuZGluZ0xhbmVzICYgfihzdXNwZW5kZWRMYW5lcyAmIH5waW5nZWRMYW5lcyk7XG4gICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgPVxuICAgICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgJiAyMDEzMjY3NDFcbiAgICAgICAgICAgICAgICAgICAgICA/IChuZXh0TGFuZXMgJiAyMDEzMjY3NDEpIHwgMVxuICAgICAgICAgICAgICAgICAgICAgIDogbmV4dExhbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5leHRMYW5lcyB8IDJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgMCAhPT0gbmV4dExhbmVzICYmXG4gICAgICAgICAgICAgICAgICAoKGRpZFBlcmZvcm1Tb21lV29yayA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBuZXh0TGFuZXMpKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIChuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMoXG4gICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IG5leHRMYW5lcyA6IDAsXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCB8fFxuICAgICAgICAgICAgICAgICAgICAgIHJvb3QudGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0XG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgIDAgPT09IChuZXh0TGFuZXMgJiAzKSB8fFxuICAgICAgICAgICAgICAgICAgICBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIG5leHRMYW5lcykgfHxcbiAgICAgICAgICAgICAgICAgICAgKChkaWRQZXJmb3JtU29tZVdvcmsgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBuZXh0TGFuZXMpKTtcbiAgICAgICAgICAgIHJvb3QgPSByb290Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaWRQZXJmb3JtU29tZVdvcmspO1xuICAgICAgICBpc0ZsdXNoaW5nV29yayA9ICExO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzUm9vdFNjaGVkdWxlSW5JbW1lZGlhdGVUYXNrKCkge1xuICAgICAgcHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaygpIHtcbiAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9XG4gICAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9XG4gICAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrID1cbiAgICAgICAgICAhMTtcbiAgICAgIHZhciBzeW5jVHJhbnNpdGlvbkxhbmVzID0gMDtcbiAgICAgIDAgIT09IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lICYmXG4gICAgICAgIChzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uKCkgJiZcbiAgICAgICAgICAoc3luY1RyYW5zaXRpb25MYW5lcyA9IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lKSxcbiAgICAgICAgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gMCkpO1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbm93JDEoKSwgcHJldiA9IG51bGwsIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIG51bGwgIT09IHJvb3Q7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dCxcbiAgICAgICAgICBuZXh0TGFuZXMgPSBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgaWYgKDAgPT09IG5leHRMYW5lcylcbiAgICAgICAgICAocm9vdC5uZXh0ID0gbnVsbCksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2ID8gKGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQpIDogKHByZXYubmV4dCA9IG5leHQpLFxuICAgICAgICAgICAgbnVsbCA9PT0gbmV4dCAmJiAobGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2KTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKChwcmV2ID0gcm9vdCksIDAgIT09IHN5bmNUcmFuc2l0aW9uTGFuZXMgfHwgMCAhPT0gKG5leHRMYW5lcyAmIDMpKVxuICAgICAgICApXG4gICAgICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITA7XG4gICAgICAgIHJvb3QgPSBuZXh0O1xuICAgICAgfVxuICAgICAgKHBlbmRpbmdFZmZlY3RzU3RhdHVzICE9PSBOT19QRU5ESU5HX0VGRkVDVFMgJiZcbiAgICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgIT09IFBFTkRJTkdfUEFTU0lWRV9QSEFTRSkgfHxcbiAgICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoc3luY1RyYW5zaXRpb25MYW5lcywgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzLFxuICAgICAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcyxcbiAgICAgICAgICBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lcyxcbiAgICAgICAgICBsYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgLTYyOTE0NTYxO1xuICAgICAgICAwIDwgbGFuZXM7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKSxcbiAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleCxcbiAgICAgICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lc1tpbmRleF07XG4gICAgICAgIGlmICgtMSA9PT0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICBpZiAoMCA9PT0gKGxhbmUgJiBzdXNwZW5kZWRMYW5lcykgfHwgMCAhPT0gKGxhbmUgJiBwaW5nZWRMYW5lcykpXG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfSBlbHNlIGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lICYmIChyb290LmV4cGlyZWRMYW5lcyB8PSBsYW5lKTtcbiAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICBjdXJyZW50VGltZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgIHN1c3BlbmRlZExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgICBzdXNwZW5kZWRMYW5lcyA9IGdldE5leHRMYW5lcyhcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdCA9PT0gY3VycmVudFRpbWUgPyBzdXNwZW5kZWRMYW5lcyA6IDAsXG4gICAgICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCB8fCByb290LnRpbWVvdXRIYW5kbGUgIT09IG5vVGltZW91dFxuICAgICAgKTtcbiAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5jYWxsYmFja05vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIDAgPT09IHN1c3BlbmRlZExhbmVzIHx8XG4gICAgICAgIChyb290ID09PSBjdXJyZW50VGltZSAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhIHx8XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25BY3Rpb24pKSB8fFxuICAgICAgICBudWxsICE9PSByb290LmNhbmNlbFBlbmRpbmdDb21taXRcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBjYW5jZWxDYWxsYmFjayhwaW5nZWRMYW5lcyksXG4gICAgICAgICAgKHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbCksXG4gICAgICAgICAgKHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDApXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIDAgPT09IChzdXNwZW5kZWRMYW5lcyAmIDMpIHx8XG4gICAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgc3VzcGVuZGVkTGFuZXMpXG4gICAgICApIHtcbiAgICAgICAgY3VycmVudFRpbWUgPSBzdXNwZW5kZWRMYW5lcyAmIC1zdXNwZW5kZWRMYW5lcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGN1cnJlbnRUaW1lICE9PSByb290LmNhbGxiYWNrUHJpb3JpdHkgfHxcbiAgICAgICAgICAobnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgICAgIHBpbmdlZExhbmVzICE9PSBmYWtlQWN0Q2FsbGJhY2tOb2RlKVxuICAgICAgICApXG4gICAgICAgICAgY2FuY2VsQ2FsbGJhY2socGluZ2VkTGFuZXMpO1xuICAgICAgICBlbHNlIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgICAgc3dpdGNoIChsYW5lc1RvRXZlbnRQcmlvcml0eShzdXNwZW5kZWRMYW5lcykpIHtcbiAgICAgICAgICBjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICBjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIElkbGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICB9XG4gICAgICAgIHBpbmdlZExhbmVzID0gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrLmJpbmQobnVsbCwgcm9vdCk7XG4gICAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlXG4gICAgICAgICAgPyAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUucHVzaChwaW5nZWRMYW5lcyksXG4gICAgICAgICAgICAoc3VzcGVuZGVkTGFuZXMgPSBmYWtlQWN0Q2FsbGJhY2tOb2RlKSlcbiAgICAgICAgICA6IChzdXNwZW5kZWRMYW5lcyA9IHNjaGVkdWxlQ2FsbGJhY2skMyhzdXNwZW5kZWRMYW5lcywgcGluZ2VkTGFuZXMpKTtcbiAgICAgICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gY3VycmVudFRpbWU7XG4gICAgICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gc3VzcGVuZGVkTGFuZXM7XG4gICAgICAgIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IHBpbmdlZExhbmVzICYmIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKTtcbiAgICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDI7XG4gICAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrKHJvb3QsIGRpZFRpbWVvdXQpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9ICExO1xuICAgICAgaWYgKFxuICAgICAgICBwZW5kaW5nRWZmZWN0c1N0YXR1cyAhPT0gTk9fUEVORElOR19FRkZFQ1RTICYmXG4gICAgICAgIHBlbmRpbmdFZmZlY3RzU3RhdHVzICE9PSBQRU5ESU5HX1BBU1NJVkVfUEhBU0VcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChyb290LmNhbGxiYWNrTm9kZSA9IG51bGwpLCAocm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gMCksIG51bGw7XG4gICAgICB2YXIgb3JpZ2luYWxDYWxsYmFja05vZGUgPSByb290LmNhbGxiYWNrTm9kZTtcbiAgICAgIGlmIChmbHVzaFBlbmRpbmdFZmZlY3RzKCEwKSAmJiByb290LmNhbGxiYWNrTm9kZSAhPT0gb3JpZ2luYWxDYWxsYmFja05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCA9IGdldE5leHRMYW5lcyhcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290XG4gICAgICAgICAgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMFxuICAgICAgICAgIDogMCxcbiAgICAgICAgbnVsbCAhPT0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0IHx8IHJvb3QudGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0XG4gICAgICApO1xuICAgICAgaWYgKDAgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwKSByZXR1cm4gbnVsbDtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KFxuICAgICAgICByb290LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCxcbiAgICAgICAgZGlkVGltZW91dFxuICAgICAgKTtcbiAgICAgIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgbm93JDEoKSk7XG4gICAgICByZXR1cm4gbnVsbCAhPSByb290LmNhbGxiYWNrTm9kZSAmJlxuICAgICAgICByb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGVcbiAgICAgICAgPyBwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2suYmluZChudWxsLCByb290KVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBsYW5lcykge1xuICAgICAgaWYgKGZsdXNoUGVuZGluZ0VmZmVjdHMoKSkgcmV0dXJuIG51bGw7XG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQ7XG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSAhMTtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGxhbmVzLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbENhbGxiYWNrKGNhbGxiYWNrTm9kZSkge1xuICAgICAgY2FsbGJhY2tOb2RlICE9PSBmYWtlQWN0Q2FsbGJhY2tOb2RlICYmXG4gICAgICAgIG51bGwgIT09IGNhbGxiYWNrTm9kZSAmJlxuICAgICAgICBjYW5jZWxDYWxsYmFjayQxKGNhbGxiYWNrTm9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlSW1tZWRpYXRlUm9vdFNjaGVkdWxlVGFzaygpIHtcbiAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaygpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0XG4gICAgICAgICAgPyBzY2hlZHVsZUNhbGxiYWNrJDMoXG4gICAgICAgICAgICAgIEltbWVkaWF0ZVByaW9yaXR5LFxuICAgICAgICAgICAgICBwcm9jZXNzUm9vdFNjaGVkdWxlSW5JbW1lZGlhdGVUYXNrXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSB7XG4gICAgICAwID09PSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSAmJlxuICAgICAgICAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpKTtcbiAgICAgIHJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29lcmNlRm9ybUFjdGlvblByb3AoYWN0aW9uUHJvcCkge1xuICAgICAgaWYgKFxuICAgICAgICBudWxsID09IGFjdGlvblByb3AgfHxcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIGFjdGlvblByb3AgfHxcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBhY3Rpb25Qcm9wXG4gICAgICApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvblByb3ApIHJldHVybiBhY3Rpb25Qcm9wO1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihhY3Rpb25Qcm9wLCBcImFjdGlvblwiKTtcbiAgICAgIHJldHVybiBzYW5pdGl6ZVVSTChcIlwiICsgYWN0aW9uUHJvcCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvcm1EYXRhV2l0aFN1Ym1pdHRlcihmb3JtLCBzdWJtaXR0ZXIpIHtcbiAgICAgIHZhciB0ZW1wID0gc3VibWl0dGVyLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgdGVtcC5uYW1lID0gc3VibWl0dGVyLm5hbWU7XG4gICAgICB0ZW1wLnZhbHVlID0gc3VibWl0dGVyLnZhbHVlO1xuICAgICAgZm9ybS5pZCAmJiB0ZW1wLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgZm9ybS5pZCk7XG4gICAgICBzdWJtaXR0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGVtcCwgc3VibWl0dGVyKTtcbiAgICAgIGZvcm0gPSBuZXcgRm9ybURhdGEoZm9ybSk7XG4gICAgICB0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGVtcCk7XG4gICAgICByZXR1cm4gZm9ybTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQxKFxuICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgIG1heWJlVGFyZ2V0SW5zdCxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdWJtaXRcIiA9PT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgIG1heWJlVGFyZ2V0SW5zdCAmJlxuICAgICAgICBtYXliZVRhcmdldEluc3Quc3RhdGVOb2RlID09PSBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBjb2VyY2VGb3JtQWN0aW9uUHJvcChcbiAgICAgICAgICAgIChuYXRpdmVFdmVudFRhcmdldFtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsKS5hY3Rpb25cbiAgICAgICAgICApLFxuICAgICAgICAgIHN1Ym1pdHRlciA9IG5hdGl2ZUV2ZW50LnN1Ym1pdHRlcjtcbiAgICAgICAgc3VibWl0dGVyICYmXG4gICAgICAgICAgKChkb21FdmVudE5hbWUgPSAoZG9tRXZlbnROYW1lID0gc3VibWl0dGVyW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGwpXG4gICAgICAgICAgICA/IGNvZXJjZUZvcm1BY3Rpb25Qcm9wKGRvbUV2ZW50TmFtZS5mb3JtQWN0aW9uKVxuICAgICAgICAgICAgOiBzdWJtaXR0ZXIuZ2V0QXR0cmlidXRlKFwiZm9ybUFjdGlvblwiKSksXG4gICAgICAgICAgbnVsbCAhPT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgICAgICAoKGFjdGlvbiA9IGRvbUV2ZW50TmFtZSksIChzdWJtaXR0ZXIgPSBudWxsKSkpO1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoXG4gICAgICAgICAgXCJhY3Rpb25cIixcbiAgICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgKTtcbiAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgbGlzdGVuZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgICBsaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoMCAhPT0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gc3VibWl0dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZvcm1EYXRhV2l0aFN1Ym1pdHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgRm9ybURhdGEobmF0aXZlRXZlbnRUYXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmc6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShwZW5kaW5nU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydEhvc3RUcmFuc2l0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgIG1heWJlVGFyZ2V0SW5zdCxcbiAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgIChldmVudC5wcmV2ZW50RGVmYXVsdCgpLFxuICAgICAgICAgICAgICAgICAgICAoZm9ybURhdGEgPSBzdWJtaXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZvcm1EYXRhV2l0aFN1Ym1pdHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pdHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIDogbmV3IEZvcm1EYXRhKG5hdGl2ZUV2ZW50VGFyZ2V0KSksXG4gICAgICAgICAgICAgICAgICAgIChwZW5kaW5nU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVuZGluZzogITAsXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBuYXRpdmVFdmVudFRhcmdldC5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUocGVuZGluZ1N0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRIb3N0VHJhbnNpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICBtYXliZVRhcmdldEluc3QsXG4gICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKSB7XG4gICAgICBldmVudFN5c3RlbUZsYWdzID0gMCAhPT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiA0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2Rpc3BhdGNoUXVldWUkaSA9IGRpc3BhdGNoUXVldWVbaV07XG4gICAgICAgIGE6IHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNJbnN0YW5jZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIGV2ZW50ID0gX2Rpc3BhdGNoUXVldWUkaS5ldmVudDtcbiAgICAgICAgICBfZGlzcGF0Y2hRdWV1ZSRpID0gX2Rpc3BhdGNoUXVldWUkaS5saXN0ZW5lcnM7XG4gICAgICAgICAgaWYgKGV2ZW50U3lzdGVtRmxhZ3MpXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgaSRqc2NvbXAkMCA9IF9kaXNwYXRjaFF1ZXVlJGkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgMCA8PSBpJGpzY29tcCQwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwLS1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgX2Rpc3BhdGNoTGlzdGVuZXJzJGkgPSBfZGlzcGF0Y2hRdWV1ZSRpW2kkanNjb21wJDBdLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgIF9kaXNwYXRjaExpc3RlbmVycyRpID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkubGlzdGVuZXI7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gcHJldmlvdXNJbnN0YW5jZSAmJiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVEaXNwYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIF9kaXNwYXRjaExpc3RlbmVycyRpLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIF9kaXNwYXRjaExpc3RlbmVycyRpLCBjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgX2Rpc3BhdGNoUXVldWUkaS5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIF9kaXNwYXRjaExpc3RlbmVycyRpID0gX2Rpc3BhdGNoUXVldWUkaVtpJGpzY29tcCQwXTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgIF9kaXNwYXRjaExpc3RlbmVycyRpID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkubGlzdGVuZXI7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gcHJldmlvdXNJbnN0YW5jZSAmJiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVEaXNwYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIF9kaXNwYXRjaExpc3RlbmVycyRpLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIF9kaXNwYXRjaExpc3RlbmVycyRpLCBjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRFbGVtZW50KSB7XG4gICAgICBub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnRGlkIG5vdCBleHBlY3QgYSBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCkgY2FsbCBmb3IgXCIlc1wiLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICAgICAgIGRvbUV2ZW50TmFtZVxuICAgICAgICApO1xuICAgICAgdmFyIGxpc3RlbmVyU2V0ID0gdGFyZ2V0RWxlbWVudFtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldO1xuICAgICAgdm9pZCAwID09PSBsaXN0ZW5lclNldCAmJlxuICAgICAgICAobGlzdGVuZXJTZXQgPSB0YXJnZXRFbGVtZW50W2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBuZXcgU2V0KCkpO1xuICAgICAgdmFyIGxpc3RlbmVyU2V0S2V5ID0gZG9tRXZlbnROYW1lICsgXCJfX2J1YmJsZVwiO1xuICAgICAgbGlzdGVuZXJTZXQuaGFzKGxpc3RlbmVyU2V0S2V5KSB8fFxuICAgICAgICAoYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgZG9tRXZlbnROYW1lLCAyLCAhMSksXG4gICAgICAgIGxpc3RlbmVyU2V0LmFkZChsaXN0ZW5lclNldEtleSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSwgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciwgdGFyZ2V0KSB7XG4gICAgICBub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkgJiZcbiAgICAgICAgIWlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnRGlkIG5vdCBleHBlY3QgYSBsaXN0ZW5Ub05hdGl2ZUV2ZW50KCkgY2FsbCBmb3IgXCIlc1wiIGluIHRoZSBidWJibGUgcGhhc2UuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gICAgICAgICAgZG9tRXZlbnROYW1lXG4gICAgICAgICk7XG4gICAgICB2YXIgZXZlbnRTeXN0ZW1GbGFncyA9IDA7XG4gICAgICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyICYmIChldmVudFN5c3RlbUZsYWdzIHw9IDQpO1xuICAgICAgYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhyb290Q29udGFpbmVyRWxlbWVudCkge1xuICAgICAgaWYgKCFyb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdKSB7XG4gICAgICAgIHJvb3RDb250YWluZXJFbGVtZW50W2xpc3RlbmluZ01hcmtlcl0gPSAhMDtcbiAgICAgICAgYWxsTmF0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICAgIFwic2VsZWN0aW9uY2hhbmdlXCIgIT09IGRvbUV2ZW50TmFtZSAmJlxuICAgICAgICAgICAgKG5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSB8fFxuICAgICAgICAgICAgICBsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSwgITEsIHJvb3RDb250YWluZXJFbGVtZW50KSxcbiAgICAgICAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCAhMCwgcm9vdENvbnRhaW5lckVsZW1lbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvd25lckRvY3VtZW50ID1cbiAgICAgICAgICA5ID09PSByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZVxuICAgICAgICAgICAgPyByb290Q29udGFpbmVyRWxlbWVudFxuICAgICAgICAgICAgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgICAgICBudWxsID09PSBvd25lckRvY3VtZW50IHx8XG4gICAgICAgICAgb3duZXJEb2N1bWVudFtsaXN0ZW5pbmdNYXJrZXJdIHx8XG4gICAgICAgICAgKChvd25lckRvY3VtZW50W2xpc3RlbmluZ01hcmtlcl0gPSAhMCksXG4gICAgICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudChcInNlbGVjdGlvbmNoYW5nZVwiLCAhMSwgb3duZXJEb2N1bWVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcihcbiAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKGdldEV2ZW50UHJpb3JpdHkoZG9tRXZlbnROYW1lKSkge1xuICAgICAgICBjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICB2YXIgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OlxuICAgICAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoQ29udGludW91c0V2ZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRXZlbnQ7XG4gICAgICB9XG4gICAgICBldmVudFN5c3RlbUZsYWdzID0gbGlzdGVuZXJXcmFwcGVyLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgdGFyZ2V0Q29udGFpbmVyXG4gICAgICApO1xuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gdm9pZCAwO1xuICAgICAgIXBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkIHx8XG4gICAgICAgIChcInRvdWNoc3RhcnRcIiAhPT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgICAgXCJ0b3VjaG1vdmVcIiAhPT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgICAgXCJ3aGVlbFwiICE9PSBkb21FdmVudE5hbWUpIHx8XG4gICAgICAgIChsaXN0ZW5lcldyYXBwZXIgPSAhMCk7XG4gICAgICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyXG4gICAgICAgID8gdm9pZCAwICE9PSBsaXN0ZW5lcldyYXBwZXJcbiAgICAgICAgICA/IHRhcmdldENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywge1xuICAgICAgICAgICAgICBjYXB0dXJlOiAhMCxcbiAgICAgICAgICAgICAgcGFzc2l2ZTogbGlzdGVuZXJXcmFwcGVyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogdGFyZ2V0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCAhMClcbiAgICAgICAgOiB2b2lkIDAgIT09IGxpc3RlbmVyV3JhcHBlclxuICAgICAgICAgID8gdGFyZ2V0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB7XG4gICAgICAgICAgICAgIHBhc3NpdmU6IGxpc3RlbmVyV3JhcHBlclxuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IHRhcmdldENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICAgICExXG4gICAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oXG4gICAgICBkb21FdmVudE5hbWUsXG4gICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICB0YXJnZXRJbnN0JGpzY29tcCQwLFxuICAgICAgdGFyZ2V0Q29udGFpbmVyXG4gICAgKSB7XG4gICAgICB2YXIgYW5jZXN0b3JJbnN0ID0gdGFyZ2V0SW5zdCRqc2NvbXAkMDtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiAxKSAmJlxuICAgICAgICAwID09PSAoZXZlbnRTeXN0ZW1GbGFncyAmIDIpICYmXG4gICAgICAgIG51bGwgIT09IHRhcmdldEluc3QkanNjb21wJDBcbiAgICAgIClcbiAgICAgICAgYTogZm9yICg7Oykge1xuICAgICAgICAgIGlmIChudWxsID09PSB0YXJnZXRJbnN0JGpzY29tcCQwKSByZXR1cm47XG4gICAgICAgICAgdmFyIG5vZGVUYWcgPSB0YXJnZXRJbnN0JGpzY29tcCQwLnRhZztcbiAgICAgICAgICBpZiAoMyA9PT0gbm9kZVRhZyB8fCA0ID09PSBub2RlVGFnKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGFyZ2V0SW5zdCRqc2NvbXAkMC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGlmIChjb250YWluZXIgPT09IHRhcmdldENvbnRhaW5lcikgYnJlYWs7XG4gICAgICAgICAgICBpZiAoNCA9PT0gbm9kZVRhZylcbiAgICAgICAgICAgICAgZm9yIChub2RlVGFnID0gdGFyZ2V0SW5zdCRqc2NvbXAkMC5yZXR1cm47IG51bGwgIT09IG5vZGVUYWc7ICkge1xuICAgICAgICAgICAgICAgIHZhciBncmFuZFRhZyA9IG5vZGVUYWcudGFnO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICgzID09PSBncmFuZFRhZyB8fCA0ID09PSBncmFuZFRhZykgJiZcbiAgICAgICAgICAgICAgICAgIG5vZGVUYWcuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHRhcmdldENvbnRhaW5lclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBub2RlVGFnID0gbm9kZVRhZy5yZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyBudWxsICE9PSBjb250YWluZXI7ICkge1xuICAgICAgICAgICAgICBub2RlVGFnID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IG5vZGVUYWcpIHJldHVybjtcbiAgICAgICAgICAgICAgZ3JhbmRUYWcgPSBub2RlVGFnLnRhZztcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDUgPT09IGdyYW5kVGFnIHx8XG4gICAgICAgICAgICAgICAgNiA9PT0gZ3JhbmRUYWcgfHxcbiAgICAgICAgICAgICAgICAyNiA9PT0gZ3JhbmRUYWcgfHxcbiAgICAgICAgICAgICAgICAyNyA9PT0gZ3JhbmRUYWdcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SW5zdCRqc2NvbXAkMCA9IGFuY2VzdG9ySW5zdCA9IG5vZGVUYWc7XG4gICAgICAgICAgICAgICAgY29udGludWUgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0SW5zdCRqc2NvbXAkMCA9IHRhcmdldEluc3QkanNjb21wJDAucmV0dXJuO1xuICAgICAgICB9XG4gICAgICBiYXRjaGVkVXBkYXRlcyQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRhcmdldEluc3QgPSBhbmNlc3Rvckluc3QsXG4gICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCksXG4gICAgICAgICAgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICAgICAgICBhOiB7XG4gICAgICAgICAgdmFyIHJlYWN0TmFtZSA9IHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLmdldChkb21FdmVudE5hbWUpO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IHJlYWN0TmFtZSkge1xuICAgICAgICAgICAgdmFyIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0V2ZW50LFxuICAgICAgICAgICAgICByZWFjdEV2ZW50VHlwZSA9IGRvbUV2ZW50TmFtZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJrZXlwcmVzc1wiOlxuICAgICAgICAgICAgICAgIGlmICgwID09PSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSkgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBcImtleWRvd25cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImtleXVwXCI6XG4gICAgICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImZvY3VzaW5cIjpcbiAgICAgICAgICAgICAgICByZWFjdEV2ZW50VHlwZSA9IFwiZm9jdXNcIjtcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgICAgICAgICAgICByZWFjdEV2ZW50VHlwZSA9IFwiYmx1clwiO1xuICAgICAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJiZWZvcmVibHVyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJhZnRlcmJsdXJcIjpcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiY2xpY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAoMiA9PT0gbmF0aXZlRXZlbnQuYnV0dG9uKSBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFwiYXV4Y2xpY2tcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRibGNsaWNrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm1vdXNlbW92ZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwibW91c2V1cFwiOlxuICAgICAgICAgICAgICBjYXNlIFwibW91c2VvdXRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiY29udGV4dG1lbnVcIjpcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZHJhZ1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiZHJhZ2VuZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZHJhZ2VudGVyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkcmFnZXhpdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZHJhZ2xlYXZlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkcmFnb3ZlclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZHJhZ3N0YXJ0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJkcm9wXCI6XG4gICAgICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidG91Y2hjYW5jZWxcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInRvdWNoZW5kXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ0b3VjaG1vdmVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInRvdWNoc3RhcnRcIjpcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEFOSU1BVElPTl9FTkQ6XG4gICAgICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX0lURVJBVElPTjpcbiAgICAgICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RBUlQ6XG4gICAgICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgVFJBTlNJVElPTl9FTkQ6XG4gICAgICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzY3JvbGxlbmRcIjpcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwid2hlZWxcIjpcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiY29weVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiY3V0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJwYXN0ZVwiOlxuICAgICAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZ290cG9pbnRlcmNhcHR1cmVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImxvc3Rwb2ludGVyY2FwdHVyZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicG9pbnRlcmNhbmNlbFwiOlxuICAgICAgICAgICAgICBjYXNlIFwicG9pbnRlcmRvd25cIjpcbiAgICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJtb3ZlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJwb2ludGVyb3V0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJwb2ludGVyb3ZlclwiOlxuICAgICAgICAgICAgICBjYXNlIFwicG9pbnRlcnVwXCI6XG4gICAgICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidG9nZ2xlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJiZWZvcmV0b2dnbGVcIjpcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUb2dnbGVFdmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbkNhcHR1cmVQaGFzZSA9IDAgIT09IChldmVudFN5c3RlbUZsYWdzICYgNCksXG4gICAgICAgICAgICAgIGFjY3VtdWxhdGVUYXJnZXRPbmx5ID1cbiAgICAgICAgICAgICAgICAhaW5DYXB0dXJlUGhhc2UgJiZcbiAgICAgICAgICAgICAgICAoXCJzY3JvbGxcIiA9PT0gZG9tRXZlbnROYW1lIHx8IFwic2Nyb2xsZW5kXCIgPT09IGRvbUV2ZW50TmFtZSksXG4gICAgICAgICAgICAgIHJlYWN0RXZlbnROYW1lID0gaW5DYXB0dXJlUGhhc2VcbiAgICAgICAgICAgICAgICA/IG51bGwgIT09IHJlYWN0TmFtZVxuICAgICAgICAgICAgICAgICAgPyByZWFjdE5hbWUgKyBcIkNhcHR1cmVcIlxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiByZWFjdE5hbWU7XG4gICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGFyZ2V0SW5zdCwgbGFzdEhvc3RDb21wb25lbnQ7XG4gICAgICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlO1xuXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQgPSBfaW5zdGFuY2UyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgX2luc3RhbmNlMiA9IF9pbnN0YW5jZTIudGFnO1xuICAgICAgICAgICAgICAoNSAhPT0gX2luc3RhbmNlMiAmJiAyNiAhPT0gX2luc3RhbmNlMiAmJiAyNyAhPT0gX2luc3RhbmNlMikgfHxcbiAgICAgICAgICAgICAgICBudWxsID09PSBsYXN0SG9zdENvbXBvbmVudCB8fFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHJlYWN0RXZlbnROYW1lIHx8XG4gICAgICAgICAgICAgICAgKChfaW5zdGFuY2UyID0gZ2V0TGlzdGVuZXIoaW5zdGFuY2UsIHJlYWN0RXZlbnROYW1lKSksXG4gICAgICAgICAgICAgICAgbnVsbCAhPSBfaW5zdGFuY2UyICYmXG4gICAgICAgICAgICAgICAgICBpbkNhcHR1cmVQaGFzZS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZTIsXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIGlmIChhY2N1bXVsYXRlVGFyZ2V0T25seSkgYnJlYWs7XG4gICAgICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgMCA8IGluQ2FwdHVyZVBoYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAoKHJlYWN0TmFtZSA9IG5ldyBTeW50aGV0aWNFdmVudEN0b3IoXG4gICAgICAgICAgICAgICAgcmVhY3ROYW1lLFxuICAgICAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IHJlYWN0TmFtZSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IGluQ2FwdHVyZVBoYXNlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgPT09IChldmVudFN5c3RlbUZsYWdzICYgNykpIHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICByZWFjdE5hbWUgPVxuICAgICAgICAgICAgICBcIm1vdXNlb3ZlclwiID09PSBkb21FdmVudE5hbWUgfHwgXCJwb2ludGVyb3ZlclwiID09PSBkb21FdmVudE5hbWU7XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPVxuICAgICAgICAgICAgICBcIm1vdXNlb3V0XCIgPT09IGRvbUV2ZW50TmFtZSB8fCBcInBvaW50ZXJvdXRcIiA9PT0gZG9tRXZlbnROYW1lO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICByZWFjdE5hbWUgJiZcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnQgIT09IGN1cnJlbnRSZXBsYXlpbmdFdmVudCAmJlxuICAgICAgICAgICAgICAocmVhY3RFdmVudFR5cGUgPVxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpICYmXG4gICAgICAgICAgICAgIChnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWFjdEV2ZW50VHlwZSkgfHxcbiAgICAgICAgICAgICAgICByZWFjdEV2ZW50VHlwZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIGlmIChTeW50aGV0aWNFdmVudEN0b3IgfHwgcmVhY3ROYW1lKSB7XG4gICAgICAgICAgICAgIHJlYWN0TmFtZSA9XG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgICAgICAgPyBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgICAgICAgOiAocmVhY3ROYW1lID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudClcbiAgICAgICAgICAgICAgICAgICAgPyByZWFjdE5hbWUuZGVmYXVsdFZpZXcgfHwgcmVhY3ROYW1lLnBhcmVudFdpbmRvd1xuICAgICAgICAgICAgICAgICAgICA6IHdpbmRvdztcbiAgICAgICAgICAgICAgaWYgKFN5bnRoZXRpY0V2ZW50Q3Rvcikge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICgocmVhY3RFdmVudFR5cGUgPVxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAoU3ludGhldGljRXZlbnRDdG9yID0gdGFyZ2V0SW5zdCksXG4gICAgICAgICAgICAgICAgICAocmVhY3RFdmVudFR5cGUgPSByZWFjdEV2ZW50VHlwZVxuICAgICAgICAgICAgICAgICAgICA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlYWN0RXZlbnRUeXBlKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwpLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVhY3RFdmVudFR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKChhY2N1bXVsYXRlVGFyZ2V0T25seSA9XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihyZWFjdEV2ZW50VHlwZSkpLFxuICAgICAgICAgICAgICAgICAgICAoaW5DYXB0dXJlUGhhc2UgPSByZWFjdEV2ZW50VHlwZS50YWcpLFxuICAgICAgICAgICAgICAgICAgICByZWFjdEV2ZW50VHlwZSAhPT0gYWNjdW11bGF0ZVRhcmdldE9ubHkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoNSAhPT0gaW5DYXB0dXJlUGhhc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIDI3ICE9PSBpbkNhcHR1cmVQaGFzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgNiAhPT0gaW5DYXB0dXJlUGhhc2UpKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICByZWFjdEV2ZW50VHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSAoU3ludGhldGljRXZlbnRDdG9yID0gbnVsbCksIChyZWFjdEV2ZW50VHlwZSA9IHRhcmdldEluc3QpO1xuICAgICAgICAgICAgICBpZiAoU3ludGhldGljRXZlbnRDdG9yICE9PSByZWFjdEV2ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2UyID0gXCJvbk1vdXNlTGVhdmVcIjtcbiAgICAgICAgICAgICAgICByZWFjdEV2ZW50TmFtZSA9IFwib25Nb3VzZUVudGVyXCI7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBcIm1vdXNlXCI7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgXCJwb2ludGVyb3V0XCIgPT09IGRvbUV2ZW50TmFtZSB8fFxuICAgICAgICAgICAgICAgICAgXCJwb2ludGVyb3ZlclwiID09PSBkb21FdmVudE5hbWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAoaW5DYXB0dXJlUGhhc2UgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQpLFxuICAgICAgICAgICAgICAgICAgICAoX2luc3RhbmNlMiA9IFwib25Qb2ludGVyTGVhdmVcIiksXG4gICAgICAgICAgICAgICAgICAgIChyZWFjdEV2ZW50TmFtZSA9IFwib25Qb2ludGVyRW50ZXJcIiksXG4gICAgICAgICAgICAgICAgICAgIChpbnN0YW5jZSA9IFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlVGFyZ2V0T25seSA9XG4gICAgICAgICAgICAgICAgICBudWxsID09IFN5bnRoZXRpY0V2ZW50Q3RvclxuICAgICAgICAgICAgICAgICAgICA/IHJlYWN0TmFtZVxuICAgICAgICAgICAgICAgICAgICA6IGdldE5vZGVGcm9tSW5zdGFuY2UoU3ludGhldGljRXZlbnRDdG9yKTtcbiAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCA9XG4gICAgICAgICAgICAgICAgICBudWxsID09IHJlYWN0RXZlbnRUeXBlXG4gICAgICAgICAgICAgICAgICAgID8gcmVhY3ROYW1lXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0Tm9kZUZyb21JbnN0YW5jZShyZWFjdEV2ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgcmVhY3ROYW1lID0gbmV3IGluQ2FwdHVyZVBoYXNlKFxuICAgICAgICAgICAgICAgICAgX2luc3RhbmNlMixcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlICsgXCJsZWF2ZVwiLFxuICAgICAgICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yLFxuICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmVhY3ROYW1lLnRhcmdldCA9IGFjY3VtdWxhdGVUYXJnZXRPbmx5O1xuICAgICAgICAgICAgICAgIHJlYWN0TmFtZS5yZWxhdGVkVGFyZ2V0ID0gbGFzdEhvc3RDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgX2luc3RhbmNlMiA9IG51bGw7XG4gICAgICAgICAgICAgICAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpID09PSB0YXJnZXRJbnN0ICYmXG4gICAgICAgICAgICAgICAgICAoKGluQ2FwdHVyZVBoYXNlID0gbmV3IGluQ2FwdHVyZVBoYXNlKFxuICAgICAgICAgICAgICAgICAgICByZWFjdEV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgKyBcImVudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgKGluQ2FwdHVyZVBoYXNlLnRhcmdldCA9IGxhc3RIb3N0Q29tcG9uZW50KSxcbiAgICAgICAgICAgICAgICAgIChpbkNhcHR1cmVQaGFzZS5yZWxhdGVkVGFyZ2V0ID0gYWNjdW11bGF0ZVRhcmdldE9ubHkpLFxuICAgICAgICAgICAgICAgICAgKF9pbnN0YW5jZTIgPSBpbkNhcHR1cmVQaGFzZSkpO1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVUYXJnZXRPbmx5ID0gX2luc3RhbmNlMjtcbiAgICAgICAgICAgICAgICBpZiAoU3ludGhldGljRXZlbnRDdG9yICYmIHJlYWN0RXZlbnRUeXBlKVxuICAgICAgICAgICAgICAgICAgYjoge1xuICAgICAgICAgICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSA9IFN5bnRoZXRpY0V2ZW50Q3RvcjtcbiAgICAgICAgICAgICAgICAgICAgcmVhY3RFdmVudE5hbWUgPSByZWFjdEV2ZW50VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgIGxhc3RIb3N0Q29tcG9uZW50ID0gaW5DYXB0dXJlUGhhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQgPSBnZXRQYXJlbnQobGFzdEhvc3RDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSsrO1xuICAgICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlMiA9IHJlYWN0RXZlbnROYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZTI7XG4gICAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlMiA9IGdldFBhcmVudChfaW5zdGFuY2UyKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQrKztcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDAgPCBpbnN0YW5jZSAtIGxhc3RIb3N0Q29tcG9uZW50OyApXG4gICAgICAgICAgICAgICAgICAgICAgKGluQ2FwdHVyZVBoYXNlID0gZ2V0UGFyZW50KGluQ2FwdHVyZVBoYXNlKSksIGluc3RhbmNlLS07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyAwIDwgbGFzdEhvc3RDb21wb25lbnQgLSBpbnN0YW5jZTsgKVxuICAgICAgICAgICAgICAgICAgICAgIChyZWFjdEV2ZW50TmFtZSA9IGdldFBhcmVudChyZWFjdEV2ZW50TmFtZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQtLTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGluc3RhbmNlLS07ICkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID09PSByZWFjdEV2ZW50TmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgIT09IHJlYWN0RXZlbnROYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID09PSByZWFjdEV2ZW50TmFtZS5hbHRlcm5hdGUpXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSA9IGdldFBhcmVudChpbkNhcHR1cmVQaGFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVhY3RFdmVudE5hbWUgPSBnZXRQYXJlbnQocmVhY3RFdmVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGluQ2FwdHVyZVBoYXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBudWxsICE9PSBTeW50aGV0aWNFdmVudEN0b3IgJiZcbiAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICAgICAgICAgICAgICAgIHJlYWN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yLFxuICAgICAgICAgICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSxcbiAgICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVhY3RFdmVudFR5cGUgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGFjY3VtdWxhdGVUYXJnZXRPbmx5ICYmXG4gICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KFxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLFxuICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlVGFyZ2V0T25seSxcbiAgICAgICAgICAgICAgICAgICAgcmVhY3RFdmVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlLFxuICAgICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICByZWFjdE5hbWUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9XG4gICAgICAgICAgICAgIHJlYWN0TmFtZS5ub2RlTmFtZSAmJiByZWFjdE5hbWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJzZWxlY3RcIiA9PT0gU3ludGhldGljRXZlbnRDdG9yIHx8XG4gICAgICAgICAgICAgIChcImlucHV0XCIgPT09IFN5bnRoZXRpY0V2ZW50Q3RvciAmJiBcImZpbGVcIiA9PT0gcmVhY3ROYW1lLnR5cGUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudChyZWFjdE5hbWUpKVxuICAgICAgICAgICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKVxuICAgICAgICAgICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudDtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKFN5bnRoZXRpY0V2ZW50Q3RvciA9IHJlYWN0TmFtZS5ub2RlTmFtZSksXG4gICAgICAgICAgICAgICAgIVN5bnRoZXRpY0V2ZW50Q3RvciB8fFxuICAgICAgICAgICAgICAgIFwiaW5wdXRcIiAhPT0gU3ludGhldGljRXZlbnRDdG9yLnRvTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgICAgICAgICAoXCJjaGVja2JveFwiICE9PSByZWFjdE5hbWUudHlwZSAmJiBcInJhZGlvXCIgIT09IHJlYWN0TmFtZS50eXBlKVxuICAgICAgICAgICAgICAgICAgPyB0YXJnZXRJbnN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCh0YXJnZXRJbnN0LmVsZW1lbnRUeXBlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQpXG4gICAgICAgICAgICAgICAgICA6IChnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgJiZcbiAgICAgICAgICAgICAgKGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZ1bmMoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlRXZlbnRGdW5jICYmXG4gICAgICAgICAgICAgIGhhbmRsZUV2ZW50RnVuYyhkb21FdmVudE5hbWUsIHJlYWN0TmFtZSwgdGFyZ2V0SW5zdCk7XG4gICAgICAgICAgICBcImZvY3Vzb3V0XCIgPT09IGRvbUV2ZW50TmFtZSAmJlxuICAgICAgICAgICAgICB0YXJnZXRJbnN0ICYmXG4gICAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHJlYWN0TmFtZS50eXBlICYmXG4gICAgICAgICAgICAgIG51bGwgIT0gdGFyZ2V0SW5zdC5tZW1vaXplZFByb3BzLnZhbHVlICYmXG4gICAgICAgICAgICAgIHNldERlZmF1bHRWYWx1ZShyZWFjdE5hbWUsIFwibnVtYmVyXCIsIHJlYWN0TmFtZS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IHRhcmdldEluc3RcbiAgICAgICAgICAgID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KVxuICAgICAgICAgICAgOiB3aW5kb3c7XG4gICAgICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc1RleHRJbnB1dEVsZW1lbnQoaGFuZGxlRXZlbnRGdW5jKSB8fFxuICAgICAgICAgICAgICAgIFwidHJ1ZVwiID09PSBoYW5kbGVFdmVudEZ1bmMuY29udGVudEVkaXRhYmxlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAoYWN0aXZlRWxlbWVudCA9IGhhbmRsZUV2ZW50RnVuYyksXG4gICAgICAgICAgICAgICAgICAoYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0KSxcbiAgICAgICAgICAgICAgICAgIChsYXN0U2VsZWN0aW9uID0gbnVsbCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBhY3RpdmVFbGVtZW50SW5zdCA9IGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICAgICAgICAgICAgbW91c2VEb3duID0gITA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbnRleHRtZW51XCI6XG4gICAgICAgICAgICBjYXNlIFwibW91c2V1cFwiOlxuICAgICAgICAgICAgY2FzZSBcImRyYWdlbmRcIjpcbiAgICAgICAgICAgICAgbW91c2VEb3duID0gITE7XG4gICAgICAgICAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KFxuICAgICAgICAgICAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2VsZWN0aW9uY2hhbmdlXCI6XG4gICAgICAgICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImtleWRvd25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJrZXl1cFwiOlxuICAgICAgICAgICAgICBjb25zdHJ1Y3RTZWxlY3RFdmVudChcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBmYWxsYmFja0RhdGE7XG4gICAgICAgICAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpXG4gICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9uc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSBcIm9uQ29tcG9zaXRpb25TdGFydFwiO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpcbiAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IFwib25Db21wb3NpdGlvbkVuZFwiO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjpcbiAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IFwib25Db21wb3NpdGlvblVwZGF0ZVwiO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBldmVudFR5cGUgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaXNDb21wb3NpbmdcbiAgICAgICAgICAgICAgPyBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkgJiZcbiAgICAgICAgICAgICAgICAoZXZlbnRUeXBlID0gXCJvbkNvbXBvc2l0aW9uRW5kXCIpXG4gICAgICAgICAgICAgIDogXCJrZXlkb3duXCIgPT09IGRvbUV2ZW50TmFtZSAmJlxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREUgJiZcbiAgICAgICAgICAgICAgICAoZXZlbnRUeXBlID0gXCJvbkNvbXBvc2l0aW9uU3RhcnRcIik7XG4gICAgICAgICAgZXZlbnRUeXBlICYmXG4gICAgICAgICAgICAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiZcbiAgICAgICAgICAgICAgXCJrb1wiICE9PSBuYXRpdmVFdmVudC5sb2NhbGUgJiZcbiAgICAgICAgICAgICAgKGlzQ29tcG9zaW5nIHx8IFwib25Db21wb3NpdGlvblN0YXJ0XCIgIT09IGV2ZW50VHlwZVxuICAgICAgICAgICAgICAgID8gXCJvbkNvbXBvc2l0aW9uRW5kXCIgPT09IGV2ZW50VHlwZSAmJlxuICAgICAgICAgICAgICAgICAgaXNDb21wb3NpbmcgJiZcbiAgICAgICAgICAgICAgICAgIChmYWxsYmFja0RhdGEgPSBnZXREYXRhKCkpXG4gICAgICAgICAgICAgICAgOiAoKHJvb3QgPSBuYXRpdmVFdmVudFRhcmdldCksXG4gICAgICAgICAgICAgICAgICAoc3RhcnRUZXh0ID0gXCJ2YWx1ZVwiIGluIHJvb3QgPyByb290LnZhbHVlIDogcm9vdC50ZXh0Q29udGVudCksXG4gICAgICAgICAgICAgICAgICAoaXNDb21wb3NpbmcgPSAhMCkpKSxcbiAgICAgICAgICAgIChoYW5kbGVFdmVudEZ1bmMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoXG4gICAgICAgICAgICAgIHRhcmdldEluc3QsXG4gICAgICAgICAgICAgIGV2ZW50VHlwZVxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAwIDwgaGFuZGxlRXZlbnRGdW5jLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAoKGV2ZW50VHlwZSA9IG5ldyBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KFxuICAgICAgICAgICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRUeXBlLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogaGFuZGxlRXZlbnRGdW5jXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBmYWxsYmFja0RhdGFcbiAgICAgICAgICAgICAgICA/IChldmVudFR5cGUuZGF0YSA9IGZhbGxiYWNrRGF0YSlcbiAgICAgICAgICAgICAgICA6ICgoZmFsbGJhY2tEYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkpLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZmFsbGJhY2tEYXRhICYmIChldmVudFR5cGUuZGF0YSA9IGZhbGxiYWNrRGF0YSkpKSk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGZhbGxiYWNrRGF0YSA9IGNhblVzZVRleHRJbnB1dEV2ZW50XG4gICAgICAgICAgICAgID8gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KVxuICAgICAgICAgICAgICA6IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSlcbiAgICAgICAgICApXG4gICAgICAgICAgICAoZXZlbnRUeXBlID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKFxuICAgICAgICAgICAgICB0YXJnZXRJbnN0LFxuICAgICAgICAgICAgICBcIm9uQmVmb3JlSW5wdXRcIlxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIDAgPCBldmVudFR5cGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKChoYW5kbGVFdmVudEZ1bmMgPSBuZXcgU3ludGhldGljSW5wdXRFdmVudChcbiAgICAgICAgICAgICAgICAgIFwib25CZWZvcmVJbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgXCJiZWZvcmVpbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgZXZlbnQ6IGhhbmRsZUV2ZW50RnVuYyxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyczogZXZlbnRUeXBlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKGhhbmRsZUV2ZW50RnVuYy5kYXRhID0gZmFsbGJhY2tEYXRhKSk7XG4gICAgICAgICAgZXh0cmFjdEV2ZW50cyQxKFxuICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICAgIHRhcmdldEluc3QsXG4gICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgIGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXRcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRGaWJlciwgcmVhY3ROYW1lKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgY2FwdHVyZU5hbWUgPSByZWFjdE5hbWUgKyBcIkNhcHR1cmVcIiwgbGlzdGVuZXJzID0gW107XG4gICAgICAgIG51bGwgIT09IHRhcmdldEZpYmVyO1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIF9pbnN0YW5jZTMgPSB0YXJnZXRGaWJlcixcbiAgICAgICAgICBzdGF0ZU5vZGUgPSBfaW5zdGFuY2UzLnN0YXRlTm9kZTtcbiAgICAgICAgX2luc3RhbmNlMyA9IF9pbnN0YW5jZTMudGFnO1xuICAgICAgICAoNSAhPT0gX2luc3RhbmNlMyAmJiAyNiAhPT0gX2luc3RhbmNlMyAmJiAyNyAhPT0gX2luc3RhbmNlMykgfHxcbiAgICAgICAgICBudWxsID09PSBzdGF0ZU5vZGUgfHxcbiAgICAgICAgICAoKF9pbnN0YW5jZTMgPSBnZXRMaXN0ZW5lcih0YXJnZXRGaWJlciwgY2FwdHVyZU5hbWUpKSxcbiAgICAgICAgICBudWxsICE9IF9pbnN0YW5jZTMgJiZcbiAgICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KFxuICAgICAgICAgICAgICBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKHRhcmdldEZpYmVyLCBfaW5zdGFuY2UzLCBzdGF0ZU5vZGUpXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChfaW5zdGFuY2UzID0gZ2V0TGlzdGVuZXIodGFyZ2V0RmliZXIsIHJlYWN0TmFtZSkpLFxuICAgICAgICAgIG51bGwgIT0gX2luc3RhbmNlMyAmJlxuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goXG4gICAgICAgICAgICAgIGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIodGFyZ2V0RmliZXIsIF9pbnN0YW5jZTMsIHN0YXRlTm9kZSlcbiAgICAgICAgICAgICkpO1xuICAgICAgICBpZiAoMyA9PT0gdGFyZ2V0RmliZXIudGFnKSByZXR1cm4gbGlzdGVuZXJzO1xuICAgICAgICB0YXJnZXRGaWJlciA9IHRhcmdldEZpYmVyLnJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgICAgIGlmIChudWxsID09PSBpbnN0KSByZXR1cm4gbnVsbDtcbiAgICAgIGRvIGluc3QgPSBpbnN0LnJldHVybjtcbiAgICAgIHdoaWxlIChpbnN0ICYmIDUgIT09IGluc3QudGFnICYmIDI3ICE9PSBpbnN0LnRhZyk7XG4gICAgICByZXR1cm4gaW5zdCA/IGluc3QgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KFxuICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgIGV2ZW50LFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29tbW9uLFxuICAgICAgaW5DYXB0dXJlUGhhc2VcbiAgICApIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuX3JlYWN0TmFtZSwgbGlzdGVuZXJzID0gW107XG4gICAgICAgIG51bGwgIT09IHRhcmdldCAmJiB0YXJnZXQgIT09IGNvbW1vbjtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBfaW5zdGFuY2U0ID0gdGFyZ2V0LFxuICAgICAgICAgIGFsdGVybmF0ZSA9IF9pbnN0YW5jZTQuYWx0ZXJuYXRlLFxuICAgICAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTQuc3RhdGVOb2RlO1xuICAgICAgICBfaW5zdGFuY2U0ID0gX2luc3RhbmNlNC50YWc7XG4gICAgICAgIGlmIChudWxsICE9PSBhbHRlcm5hdGUgJiYgYWx0ZXJuYXRlID09PSBjb21tb24pIGJyZWFrO1xuICAgICAgICAoNSAhPT0gX2luc3RhbmNlNCAmJiAyNiAhPT0gX2luc3RhbmNlNCAmJiAyNyAhPT0gX2luc3RhbmNlNCkgfHxcbiAgICAgICAgICBudWxsID09PSBzdGF0ZU5vZGUgfHxcbiAgICAgICAgICAoKGFsdGVybmF0ZSA9IHN0YXRlTm9kZSksXG4gICAgICAgICAgaW5DYXB0dXJlUGhhc2VcbiAgICAgICAgICAgID8gKChzdGF0ZU5vZGUgPSBnZXRMaXN0ZW5lcih0YXJnZXQsIHJlZ2lzdHJhdGlvbk5hbWUpKSxcbiAgICAgICAgICAgICAgbnVsbCAhPSBzdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIodGFyZ2V0LCBzdGF0ZU5vZGUsIGFsdGVybmF0ZSlcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgOiBpbkNhcHR1cmVQaGFzZSB8fFxuICAgICAgICAgICAgICAoKHN0YXRlTm9kZSA9IGdldExpc3RlbmVyKHRhcmdldCwgcmVnaXN0cmF0aW9uTmFtZSkpLFxuICAgICAgICAgICAgICBudWxsICE9IHN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcih0YXJnZXQsIHN0YXRlTm9kZSwgYWx0ZXJuYXRlKVxuICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnJldHVybjtcbiAgICAgIH1cbiAgICAgIDAgIT09IGxpc3RlbmVycy5sZW5ndGggJiZcbiAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgZXZlbnQ6IGV2ZW50LCBsaXN0ZW5lcnM6IGxpc3RlbmVycyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0eXBlLCBwcm9wcykge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpO1xuICAgICAgKFwiaW5wdXRcIiAhPT0gdHlwZSAmJiBcInRleHRhcmVhXCIgIT09IHR5cGUgJiYgXCJzZWxlY3RcIiAhPT0gdHlwZSkgfHxcbiAgICAgICAgbnVsbCA9PSBwcm9wcyB8fFxuICAgICAgICBudWxsICE9PSBwcm9wcy52YWx1ZSB8fFxuICAgICAgICBkaWRXYXJuVmFsdWVOdWxsIHx8XG4gICAgICAgICgoZGlkV2FyblZhbHVlTnVsbCA9ICEwKSxcbiAgICAgICAgXCJzZWxlY3RcIiA9PT0gdHlwZSAmJiBwcm9wcy5tdWx0aXBsZVxuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuIENvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImB2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApKTtcbiAgICAgIHZhciBldmVudFJlZ2lzdHJ5ID0ge1xuICAgICAgICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOiBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzXG4gICAgICB9O1xuICAgICAgaXNDdXN0b21FbGVtZW50KHR5cGUpIHx8XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5pcyB8fFxuICAgICAgICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpO1xuICAgICAgcHJvcHMuY29udGVudEVkaXRhYmxlICYmXG4gICAgICAgICFwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgJiZcbiAgICAgICAgbnVsbCAhPSBwcm9wcy5jaGlsZHJlbiAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSBSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiB0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgcHJvYmFibHkgbm90IGludGVudGlvbmFsLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShcbiAgICAgIHByb3BOYW1lLFxuICAgICAgc2VydmVyVmFsdWUsXG4gICAgICBjbGllbnRWYWx1ZSxcbiAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgKSB7XG4gICAgICBzZXJ2ZXJWYWx1ZSAhPT0gY2xpZW50VmFsdWUgJiZcbiAgICAgICAgKChjbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSkpLFxuICAgICAgICBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpICE9PSBjbGllbnRWYWx1ZSAmJlxuICAgICAgICAgIChzZXJ2ZXJEaWZmZXJlbmNlc1twcm9wTmFtZV0gPSBzZXJ2ZXJWYWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKFxuICAgICAgZG9tRWxlbWVudCxcbiAgICAgIGF0dHJpYnV0ZU5hbWVzLFxuICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICApIHtcbiAgICAgIGF0dHJpYnV0ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNbZ2V0UHJvcE5hbWVGcm9tQXR0cmlidXRlTmFtZShhdHRyaWJ1dGVOYW1lKV0gPVxuICAgICAgICAgIFwic3R5bGVcIiA9PT0gYXR0cmlidXRlTmFtZVxuICAgICAgICAgICAgPyBnZXRTdHlsZXNPYmplY3RGcm9tRWxlbWVudChkb21FbGVtZW50KVxuICAgICAgICAgICAgOiBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICExID09PSBsaXN0ZW5lclxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYGZhbHNlYC5cXG5cXG5JZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgcGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuXCIsXG4gICAgICAgICAgICByZWdpc3RyYXRpb25OYW1lLFxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uTmFtZSxcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbk5hbWVcbiAgICAgICAgICApXG4gICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS5cIixcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgICAgICAgICB0eXBlb2YgbGlzdGVuZXJcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVIVE1MKHBhcmVudCwgaHRtbCkge1xuICAgICAgcGFyZW50ID1cbiAgICAgICAgcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSF9OQU1FU1BBQ0UgfHxcbiAgICAgICAgcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRVxuICAgICAgICAgID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFxuICAgICAgICAgICAgICBwYXJlbnQubmFtZXNwYWNlVVJJLFxuICAgICAgICAgICAgICBwYXJlbnQudGFnTmFtZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSk7XG4gICAgICBwYXJlbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiBwYXJlbnQuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUobWFya3VwKSB7XG4gICAgICB3aWxsQ29lcmNpb25UaHJvdyhtYXJrdXApICYmXG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIEhUTUwgbWFya3VwIHVzZXMgYSB2YWx1ZSBvZiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICB0eXBlTmFtZShtYXJrdXApXG4gICAgICAgICksXG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbihtYXJrdXApKTtcbiAgICAgIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG1hcmt1cCA/IG1hcmt1cCA6IFwiXCIgKyBtYXJrdXApXG4gICAgICAgIC5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgXCJcXG5cIilcbiAgICAgICAgLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCBcIlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tGb3JVbm1hdGNoZWRUZXh0KHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICAgIGNsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgICByZXR1cm4gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpID09PSBjbGllbnRUZXh0XG4gICAgICAgID8gITBcbiAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCQxKCkge31cbiAgICBmdW5jdGlvbiBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywga2V5LCB2YWx1ZSwgcHJvcHMsIHByZXZWYWx1ZSkge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZSlcbiAgICAgICAgICAgIHZhbGlkYXRlVGV4dE5lc3RpbmcodmFsdWUsIHRhZywgITEpLFxuICAgICAgICAgICAgICBcImJvZHlcIiA9PT0gdGFnIHx8XG4gICAgICAgICAgICAgICAgKFwidGV4dGFyZWFcIiA9PT0gdGFnICYmIFwiXCIgPT09IHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIHZhbHVlKTtcbiAgICAgICAgICBlbHNlIGlmIChcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgfHwgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHZhbHVlKVxuICAgICAgICAgICAgdmFsaWRhdGVUZXh0TmVzdGluZyhcIlwiICsgdmFsdWUsIHRhZywgITEpLFxuICAgICAgICAgICAgICBcImJvZHlcIiAhPT0gdGFnICYmIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjbGFzc05hbWVcIjpcbiAgICAgICAgICBzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlKGRvbUVsZW1lbnQsIFwiY2xhc3NcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGFiSW5kZXhcIjpcbiAgICAgICAgICBzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlKGRvbUVsZW1lbnQsIFwidGFiaW5kZXhcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGlyXCI6XG4gICAgICAgIGNhc2UgXCJyb2xlXCI6XG4gICAgICAgIGNhc2UgXCJ2aWV3Qm94XCI6XG4gICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgICAgc2V0VmFsdWVGb3JLbm93bkF0dHJpYnV0ZShkb21FbGVtZW50LCBrZXksIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgdmFsdWUsIHByZXZWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHRhZykge1xuICAgICAgICAgICAgc2V0VmFsdWVGb3JLbm93bkF0dHJpYnV0ZShkb21FbGVtZW50LCBcImRhdGFcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3JjXCI6XG4gICAgICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICAgICAgaWYgKFwiXCIgPT09IHZhbHVlICYmIChcImFcIiAhPT0gdGFnIHx8IFwiaHJlZlwiICE9PSBrZXkpKSB7XG4gICAgICAgICAgICBcInNyY1wiID09PSBrZXlcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0FuIGVtcHR5IHN0cmluZyAoXCJcIikgd2FzIHBhc3NlZCB0byB0aGUgJXMgYXR0cmlidXRlLiBUaGlzIG1heSBjYXVzZSB0aGUgYnJvd3NlciB0byBkb3dubG9hZCB0aGUgd2hvbGUgcGFnZSBhZ2FpbiBvdmVyIHRoZSBuZXR3b3JrLiBUbyBmaXggdGhpcywgZWl0aGVyIGRvIG5vdCByZW5kZXIgdGhlIGVsZW1lbnQgYXQgYWxsIG9yIHBhc3MgbnVsbCB0byAlcyBpbnN0ZWFkIG9mIGFuIGVtcHR5IHN0cmluZy4nLFxuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsID09IHZhbHVlIHx8XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGtleSk7XG4gICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJmb3JtQWN0aW9uXCI6XG4gICAgICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAgICAgKFwiZm9ybVwiID09PSB0YWdcbiAgICAgICAgICAgICAgPyBcImZvcm1BY3Rpb25cIiA9PT0ga2V5XG4gICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIllvdSBjYW4gb25seSBwYXNzIHRoZSBmb3JtQWN0aW9uIHByb3AgdG8gPGlucHV0PiBvciA8YnV0dG9uPi4gVXNlIHRoZSBhY3Rpb24gcHJvcCBvbiA8Zm9ybT4uXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAoKG51bGwgPT0gcHJvcHMuZW5jVHlwZSAmJiBudWxsID09IHByb3BzLm1ldGhvZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgfHxcbiAgICAgICAgICAgICAgICAgICAgKChkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIkNhbm5vdCBzcGVjaWZ5IGEgZW5jVHlwZSBvciBtZXRob2QgZm9yIGEgZm9ybSB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIHRoZSBhY3Rpb24uIFJlYWN0IHByb3ZpZGVzIHRob3NlIGF1dG9tYXRpY2FsbHkuIFRoZXkgd2lsbCBnZXQgb3ZlcnJpZGRlbi5cIlxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgPT0gcHJvcHMudGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIHRhcmdldCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgdGhlIGFjdGlvbi4gVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy5cIlxuICAgICAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgOiBcImlucHV0XCIgPT09IHRhZyB8fCBcImJ1dHRvblwiID09PSB0YWdcbiAgICAgICAgICAgICAgICA/IFwiYWN0aW9uXCIgPT09IGtleVxuICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiWW91IGNhbiBvbmx5IHBhc3MgdGhlIGFjdGlvbiBwcm9wIHRvIDxmb3JtPi4gVXNlIHRoZSBmb3JtQWN0aW9uIHByb3Agb24gPGlucHV0PiBvciA8YnV0dG9uPi5cIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IFwiaW5wdXRcIiAhPT0gdGFnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgXCJzdWJtaXRcIiA9PT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgICAgICAgICAgIFwiaW1hZ2VcIiA9PT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZVxuICAgICAgICAgICAgICAgICAgICA/IFwiYnV0dG9uXCIgIT09IHRhZyB8fFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgPT0gcHJvcHMudHlwZSB8fFxuICAgICAgICAgICAgICAgICAgICAgIFwic3VibWl0XCIgPT09IHByb3BzLnR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblR5cGVcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBwcm9wcy5uYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHNwZWNpZnkgYSBcIm5hbWVcIiBwcm9wIGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gUmVhY3QgbmVlZHMgaXQgdG8gZW5jb2RlIHdoaWNoIGFjdGlvbiBzaG91bGQgYmUgaW52b2tlZC4gSXQgd2lsbCBnZXQgb3ZlcnJpZGRlbi4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gcHJvcHMuZm9ybUVuY1R5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA9PSBwcm9wcy5mb3JtTWV0aG9kKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYSBmb3JtRW5jVHlwZSBvciBmb3JtTWV0aG9kIGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gUmVhY3QgcHJvdmlkZXMgdGhvc2UgYXV0b21hdGljYWxseS4gVGhleSB3aWxsIGdldCBvdmVycmlkZGVuLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA9PSBwcm9wcy5mb3JtVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgoZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDYW5ub3Qgc3BlY2lmeSBhIGZvcm1UYXJnZXQgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBUaGUgZnVuY3Rpb24gd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgd2luZG93LlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICAgICAgICAgIDogKChkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnQSBidXR0b24gY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3Igbm8gdHlwZS4nXG4gICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICA6ICgoZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gITApLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnQW4gaW5wdXQgY2FuIG9ubHkgc3BlY2lmeSBhIGZvcm1BY3Rpb24gYWxvbmcgd2l0aCB0eXBlPVwic3VibWl0XCIgb3IgdHlwZT1cImltYWdlXCIuJ1xuICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgOiBcImFjdGlvblwiID09PSBrZXlcbiAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIllvdSBjYW4gb25seSBwYXNzIHRoZSBhY3Rpb24gcHJvcCB0byA8Zm9ybT4uXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiWW91IGNhbiBvbmx5IHBhc3MgdGhlIGZvcm1BY3Rpb24gcHJvcCB0byA8aW5wdXQ+IG9yIDxidXR0b24+LlwiXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignQSBSZWFjdCBmb3JtIHdhcyB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLiBJZiB5b3UgY2FsbGVkIGZvcm0uc3VibWl0KCkgbWFudWFsbHksIGNvbnNpZGVyIHVzaW5nIGZvcm0ucmVxdWVzdFN1Ym1pdCgpIGluc3RlYWQuIElmIHlvdVxcXFwncmUgdHJ5aW5nIHRvIHVzZSBldmVudC5zdG9wUHJvcGFnYXRpb24oKSBpbiBhIHN1Ym1pdCBldmVudCBoYW5kbGVyLCBjb25zaWRlciBhbHNvIGNhbGxpbmcgZXZlbnQucHJldmVudERlZmF1bHQoKS4nKVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcmV2VmFsdWUgJiZcbiAgICAgICAgICAgICAgKFwiZm9ybUFjdGlvblwiID09PSBrZXlcbiAgICAgICAgICAgICAgICA/IChcImlucHV0XCIgIT09IHRhZyAmJlxuICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgXCJuYW1lXCIsIHByb3BzLm5hbWUsIHByb3BzLCBudWxsKSxcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgXCJmb3JtRW5jVHlwZVwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5mb3JtRW5jVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgIFwiZm9ybU1ldGhvZFwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5mb3JtTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgXCJmb3JtVGFyZ2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmZvcm1UYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogKHNldFByb3AoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgXCJlbmNUeXBlXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmVuY1R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIFwibWV0aG9kXCIsIHByb3BzLm1ldGhvZCwgcHJvcHMsIG51bGwpLFxuICAgICAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgICBcInRhcmdldFwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCA9PSB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGtleSk7XG4gICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib25DbGlja1wiOlxuICAgICAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIoa2V5LCB2YWx1ZSksXG4gICAgICAgICAgICAoZG9tRWxlbWVudC5vbmNsaWNrID0gbm9vcCQxKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvblNjcm9sbFwiOlxuICAgICAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIoa2V5LCB2YWx1ZSksXG4gICAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwic2Nyb2xsXCIsIGRvbUVsZW1lbnQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9uU2Nyb2xsRW5kXCI6XG4gICAgICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihrZXksIHZhbHVlKSxcbiAgICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJzY3JvbGxlbmRcIiwgZG9tRWxlbWVudCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICBpZiAobnVsbCAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiB2YWx1ZSB8fCAhKFwiX19odG1sXCIgaW4gdmFsdWUpKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0LmRldi9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBrZXkgPSB2YWx1ZS5fX2h0bWw7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcHMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZG9tRWxlbWVudC5pbm5lckhUTUwgPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICBkb21FbGVtZW50Lm11bHRpcGxlID1cbiAgICAgICAgICAgIHZhbHVlICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm11dGVkXCI6XG4gICAgICAgICAgZG9tRWxlbWVudC5tdXRlZCA9XG4gICAgICAgICAgICB2YWx1ZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJiBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgICAgIGNhc2UgXCJyZWZcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImF1dG9Gb2N1c1wiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtIcmVmXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCA9PSB2YWx1ZSB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ4bGluazpocmVmXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGtleSk7XG4gICAgICAgICAga2V5ID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZU5TKHhsaW5rTmFtZXNwYWNlLCBcInhsaW5rOmhyZWZcIiwga2V5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNvbnRlbnRFZGl0YWJsZVwiOlxuICAgICAgICBjYXNlIFwic3BlbGxDaGVja1wiOlxuICAgICAgICBjYXNlIFwiZHJhZ2dhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICBjYXNlIFwiYXV0b1JldmVyc2VcIjpcbiAgICAgICAgY2FzZSBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIjpcbiAgICAgICAgY2FzZSBcImZvY3VzYWJsZVwiOlxuICAgICAgICBjYXNlIFwicHJlc2VydmVBbHBoYVwiOlxuICAgICAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICAgPyAoY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwga2V5KSxcbiAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiICsgdmFsdWUpKVxuICAgICAgICAgICAgOiBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICAgICAgICBcIlwiICE9PSB2YWx1ZSB8fFxuICAgICAgICAgICAgZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlW2tleV0gfHxcbiAgICAgICAgICAgICgoZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlW2tleV0gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIGVtcHR5IHN0cmluZyBmb3IgYSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiBUaGlzIHdpbGwgdHJlYXQgdGhlIGF0dHJpYnV0ZSBhcyBpZiBpdCB3ZXJlIGZhbHNlLiBFaXRoZXIgcGFzcyBgZmFsc2VgIHRvIHNpbGVuY2UgdGhpcyB3YXJuaW5nLCBvciBwYXNzIGB0cnVlYCBpZiB5b3UgdXNlZCBhbiBlbXB0eSBzdHJpbmcgaW4gZWFybGllciB2ZXJzaW9ucyBvZiBSZWFjdCB0byBpbmRpY2F0ZSB0aGlzIGF0dHJpYnV0ZSBpcyB0cnVlLlwiLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICkpO1xuICAgICAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgICAgIGNhc2UgXCJhc3luY1wiOlxuICAgICAgICBjYXNlIFwiYXV0b1BsYXlcIjpcbiAgICAgICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgIGNhc2UgXCJkZWZlclwiOlxuICAgICAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICAgICAgY2FzZSBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIjpcbiAgICAgICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgICAgIGNhc2UgXCJub1ZhbGlkYXRlXCI6XG4gICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgICAgICBjYXNlIFwicmVhZE9ubHlcIjpcbiAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgICAgICBjYXNlIFwic2NvcGVkXCI6XG4gICAgICAgIGNhc2UgXCJzZWFtbGVzc1wiOlxuICAgICAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICAgICAgdmFsdWUgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiYgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgICA/IGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgXCJcIilcbiAgICAgICAgICAgIDogZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhcHR1cmVcIjpcbiAgICAgICAgY2FzZSBcImRvd25sb2FkXCI6XG4gICAgICAgICAgITAgPT09IHZhbHVlXG4gICAgICAgICAgICA/IGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgXCJcIilcbiAgICAgICAgICAgIDogITEgIT09IHZhbHVlICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgICAgID8gKGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGtleSksXG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNvbHNcIjpcbiAgICAgICAgY2FzZSBcInJvd3NcIjpcbiAgICAgICAgY2FzZSBcInNpemVcIjpcbiAgICAgICAgY2FzZSBcInNwYW5cIjpcbiAgICAgICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAhaXNOYU4odmFsdWUpICYmXG4gICAgICAgICAgMSA8PSB2YWx1ZVxuICAgICAgICAgICAgPyAoY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwga2V5KSxcbiAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkpXG4gICAgICAgICAgICA6IGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyb3dTcGFuXCI6XG4gICAgICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgIGlzTmFOKHZhbHVlKVxuICAgICAgICAgICAgPyBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgICAgICAgICA6IChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBrZXkpLFxuICAgICAgICAgICAgICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb3BvdmVyXCI6XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImJlZm9yZXRvZ2dsZVwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwidG9nZ2xlXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIFwicG9wb3ZlclwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua0FjdHVhdGVcIjpcbiAgICAgICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgeGxpbmtOYW1lc3BhY2UsXG4gICAgICAgICAgICBcInhsaW5rOmFjdHVhdGVcIixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rQXJjcm9sZVwiOlxuICAgICAgICAgIHNldFZhbHVlRm9yTmFtZXNwYWNlZEF0dHJpYnV0ZShcbiAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICB4bGlua05hbWVzcGFjZSxcbiAgICAgICAgICAgIFwieGxpbms6YXJjcm9sZVwiLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieGxpbmtSb2xlXCI6XG4gICAgICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgIHhsaW5rTmFtZXNwYWNlLFxuICAgICAgICAgICAgXCJ4bGluazpyb2xlXCIsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1Nob3dcIjpcbiAgICAgICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgeGxpbmtOYW1lc3BhY2UsXG4gICAgICAgICAgICBcInhsaW5rOnNob3dcIixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhsaW5rVGl0bGVcIjpcbiAgICAgICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgeGxpbmtOYW1lc3BhY2UsXG4gICAgICAgICAgICBcInhsaW5rOnRpdGxlXCIsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bGlua1R5cGVcIjpcbiAgICAgICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgeGxpbmtOYW1lc3BhY2UsXG4gICAgICAgICAgICBcInhsaW5rOnR5cGVcIixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInhtbEJhc2VcIjpcbiAgICAgICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgeG1sTmFtZXNwYWNlLFxuICAgICAgICAgICAgXCJ4bWw6YmFzZVwiLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieG1sTGFuZ1wiOlxuICAgICAgICAgIHNldFZhbHVlRm9yTmFtZXNwYWNlZEF0dHJpYnV0ZShcbiAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICB4bWxOYW1lc3BhY2UsXG4gICAgICAgICAgICBcInhtbDpsYW5nXCIsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bWxTcGFjZVwiOlxuICAgICAgICAgIHNldFZhbHVlRm9yTmFtZXNwYWNlZEF0dHJpYnV0ZShcbiAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICB4bWxOYW1lc3BhY2UsXG4gICAgICAgICAgICBcInhtbDpzcGFjZVwiLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaXNcIjpcbiAgICAgICAgICBudWxsICE9IHByZXZWYWx1ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgdGhlIFwiaXNcIiBwcm9wIGFmdGVyIGl0IGhhcyBiZWVuIGluaXRpYWxpemVkLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgXCJpc1wiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbm5lclRleHRcIjpcbiAgICAgICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb3BvdmVyVGFyZ2V0XCI6XG4gICAgICAgICAgZGlkV2FyblBvcG92ZXJUYXJnZXRPYmplY3QgfHxcbiAgICAgICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuUG9wb3ZlclRhcmdldE9iamVjdCA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIGBwb3BvdmVyVGFyZ2V0YCBwcm9wIGV4cGVjdHMgdGhlIElEIG9mIGFuIEVsZW1lbnQgYXMgYSBzdHJpbmcuIFJlY2VpdmVkICVzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAhKDIgPCBrZXkubGVuZ3RoKSB8fFxuICAgICAgICAgIChcIm9cIiAhPT0ga2V5WzBdICYmIFwiT1wiICE9PSBrZXlbMF0pIHx8XG4gICAgICAgICAgKFwiblwiICE9PSBrZXlbMV0gJiYgXCJOXCIgIT09IGtleVsxXSlcbiAgICAgICAgICAgID8gKChrZXkgPSBnZXRBdHRyaWJ1dGVBbGlhcyhrZXkpKSxcbiAgICAgICAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwga2V5LCB2YWx1ZSkpXG4gICAgICAgICAgICA6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UHJvcE9uQ3VzdG9tRWxlbWVudChcbiAgICAgIGRvbUVsZW1lbnQsXG4gICAgICB0YWcsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIHByb3BzLFxuICAgICAgcHJldlZhbHVlXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCB2YWx1ZSwgcHJldlZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgaWYgKG51bGwgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgdmFsdWUgfHwgIShcIl9faHRtbFwiIGluIHZhbHVlKSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAga2V5ID0gdmFsdWUuX19odG1sO1xuICAgICAgICAgICAgaWYgKG51bGwgIT0ga2V5KSB7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQuaW5uZXJIVE1MID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgICA/IHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIHZhbHVlKVxuICAgICAgICAgICAgOiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHZhbHVlIHx8IFwiYmlnaW50XCIgPT09IHR5cGVvZiB2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9uU2Nyb2xsXCI6XG4gICAgICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihrZXksIHZhbHVlKSxcbiAgICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJzY3JvbGxcIiwgZG9tRWxlbWVudCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib25TY3JvbGxFbmRcIjpcbiAgICAgICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKGtleSwgdmFsdWUpLFxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbGVuZFwiLCBkb21FbGVtZW50KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvbkNsaWNrXCI6XG4gICAgICAgICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihrZXksIHZhbHVlKSxcbiAgICAgICAgICAgIChkb21FbGVtZW50Lm9uY2xpY2sgPSBub29wJDEpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihrZXksIHZhbHVlKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9cIiA9PT0ga2V5WzBdICYmXG4gICAgICAgICAgICAgICAgXCJuXCIgPT09IGtleVsxXSAmJlxuICAgICAgICAgICAgICAgICgocHJvcHMgPSBrZXkuZW5kc1dpdGgoXCJDYXB0dXJlXCIpKSxcbiAgICAgICAgICAgICAgICAodGFnID0ga2V5LnNsaWNlKDIsIHByb3BzID8ga2V5Lmxlbmd0aCAtIDcgOiB2b2lkIDApKSxcbiAgICAgICAgICAgICAgICAocHJldlZhbHVlID0gZG9tRWxlbWVudFtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICAocHJldlZhbHVlID0gbnVsbCAhPSBwcmV2VmFsdWUgPyBwcmV2VmFsdWVba2V5XSA6IG51bGwpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHByZXZWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRhZywgcHJldlZhbHVlLCBwcm9wcyksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByZXZWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAoa2V5IGluIGRvbUVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgPyAoZG9tRWxlbWVudFtrZXldID0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgOiBkb21FbGVtZW50Lmhhc0F0dHJpYnV0ZShrZXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KSk7XG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRhZywgdmFsdWUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGtleSBpbiBkb21FbGVtZW50XG4gICAgICAgICAgICAgICAgPyAoZG9tRWxlbWVudFtrZXldID0gdmFsdWUpXG4gICAgICAgICAgICAgICAgOiAhMCA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgID8gZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiKVxuICAgICAgICAgICAgICAgICAgOiBzZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCBwcm9wcykge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHByb3BzKTtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgXCJkaXZcIjpcbiAgICAgICAgY2FzZSBcInNwYW5cIjpcbiAgICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICBjYXNlIFwicGF0aFwiOlxuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBjYXNlIFwibGlcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImltZ1wiOlxuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwibG9hZFwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICB2YXIgaGFzU3JjID0gITEsXG4gICAgICAgICAgICBoYXNTcmNTZXQgPSAhMSxcbiAgICAgICAgICAgIHByb3BLZXk7XG4gICAgICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInNyY1wiOlxuICAgICAgICAgICAgICAgICAgICBoYXNTcmMgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwic3JjU2V0XCI6XG4gICAgICAgICAgICAgICAgICAgIGhhc1NyY1NldCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgcHJvcEtleSwgcHJvcFZhbHVlLCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGhhc1NyY1NldCAmJlxuICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIFwic3JjU2V0XCIsIHByb3BzLnNyY1NldCwgcHJvcHMsIG51bGwpO1xuICAgICAgICAgIGhhc1NyYyAmJiBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgXCJzcmNcIiwgcHJvcHMuc3JjLCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwiaW5wdXRcIiwgcHJvcHMpO1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJpbnZhbGlkXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSAocHJvcEtleSA9IHByb3BWYWx1ZSA9IGhhc1NyY1NldCA9IG51bGwpLFxuICAgICAgICAgICAgY2hlY2tlZCA9IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IG51bGw7XG4gICAgICAgICAgZm9yIChoYXNTcmMgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoaGFzU3JjKSkge1xuICAgICAgICAgICAgICB2YXIgX3Byb3BWYWx1ZSA9IHByb3BzW2hhc1NyY107XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IF9wcm9wVmFsdWUpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChoYXNTcmMpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIGhhc1NyY1NldCA9IF9wcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gX3Byb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gX3Byb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBfcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5ID0gX3Byb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IF9wcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gX3Byb3BWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBoYXNTcmMsIF9wcm9wVmFsdWUsIHByb3BzLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdmFsaWRhdGVJbnB1dFByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgICAgICBpbml0SW5wdXQoXG4gICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCxcbiAgICAgICAgICAgIHByb3BWYWx1ZSxcbiAgICAgICAgICAgIGhhc1NyY1NldCxcbiAgICAgICAgICAgICExXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwic2VsZWN0XCIsIHByb3BzKTtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiaW52YWxpZFwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBoYXNTcmMgPSBwcm9wVmFsdWUgPSBwcm9wS2V5ID0gbnVsbDtcbiAgICAgICAgICBmb3IgKGhhc1NyY1NldCBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkoaGFzU3JjU2V0KSAmJlxuICAgICAgICAgICAgICAoKGRlZmF1bHRWYWx1ZSA9IHByb3BzW2hhc1NyY1NldF0pLCBudWxsICE9IGRlZmF1bHRWYWx1ZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgc3dpdGNoIChoYXNTcmNTZXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIHByb3BLZXkgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgICAgICAgIGhhc1NyYyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgICBoYXNTcmNTZXQsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB2YWxpZGF0ZVNlbGVjdFByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgICAgICB0YWcgPSBwcm9wS2V5O1xuICAgICAgICAgIHByb3BzID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGRvbUVsZW1lbnQubXVsdGlwbGUgPSAhIWhhc1NyYztcbiAgICAgICAgICBudWxsICE9IHRhZ1xuICAgICAgICAgICAgPyB1cGRhdGVPcHRpb25zKGRvbUVsZW1lbnQsICEhaGFzU3JjLCB0YWcsICExKVxuICAgICAgICAgICAgOiBudWxsICE9IHByb3BzICYmIHVwZGF0ZU9wdGlvbnMoZG9tRWxlbWVudCwgISFoYXNTcmMsIHByb3BzLCAhMCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKFwidGV4dGFyZWFcIiwgcHJvcHMpO1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJpbnZhbGlkXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgICAgIHByb3BLZXkgPSBoYXNTcmNTZXQgPSBoYXNTcmMgPSBudWxsO1xuICAgICAgICAgIGZvciAocHJvcFZhbHVlIGluIHByb3BzKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wVmFsdWUpICYmXG4gICAgICAgICAgICAgICgoZGVmYXVsdFZhbHVlID0gcHJvcHNbcHJvcFZhbHVlXSksIG51bGwgIT0gZGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgaGFzU3JjID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgaGFzU3JjU2V0ID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAgICBwcm9wS2V5ID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBkZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIHZhbGlkYXRlVGV4dGFyZWFQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICAgICAgaW5pdFRleHRhcmVhKGRvbUVsZW1lbnQsIGhhc1NyYywgaGFzU3JjU2V0LCBwcm9wS2V5KTtcbiAgICAgICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICB2YWxpZGF0ZU9wdGlvblByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgICAgICBmb3IgKGNoZWNrZWQgaW4gcHJvcHMpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KGNoZWNrZWQpICYmXG4gICAgICAgICAgICAgICgoaGFzU3JjID0gcHJvcHNbY2hlY2tlZF0pLCBudWxsICE9IGhhc1NyYylcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgc3dpdGNoIChjaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgICAgICBkb21FbGVtZW50LnNlbGVjdGVkID1cbiAgICAgICAgICAgICAgICAgICAgaGFzU3JjICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGhhc1NyYyAmJlxuICAgICAgICAgICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgaGFzU3JjO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBjaGVja2VkLCBoYXNTcmMsIHByb3BzLCBudWxsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcImRpYWxvZ1wiOlxuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJiZWZvcmV0b2dnbGVcIiwgZG9tRWxlbWVudCk7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInRvZ2dsZVwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiY2FuY2VsXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJjbG9zZVwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlmcmFtZVwiOlxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImxvYWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2aWRlb1wiOlxuICAgICAgICBjYXNlIFwiYXVkaW9cIjpcbiAgICAgICAgICBmb3IgKGhhc1NyYyA9IDA7IGhhc1NyYyA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGhhc1NyYysrKVxuICAgICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbaGFzU3JjXSwgZG9tRWxlbWVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwibG9hZFwiLCBkb21FbGVtZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRldGFpbHNcIjpcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwidG9nZ2xlXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBkb21FbGVtZW50KSxcbiAgICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJsb2FkXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgICBjYXNlIFwiYXJlYVwiOlxuICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICBjYXNlIFwicGFyYW1cIjpcbiAgICAgICAgY2FzZSBcInRyYWNrXCI6XG4gICAgICAgIGNhc2UgXCJ3YnJcIjpcbiAgICAgICAgY2FzZSBcIm1lbnVpdGVtXCI6XG4gICAgICAgICAgZm9yIChkZWZhdWx0Q2hlY2tlZCBpbiBwcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdENoZWNrZWQpICYmXG4gICAgICAgICAgICAgICgoaGFzU3JjID0gcHJvcHNbZGVmYXVsdENoZWNrZWRdKSwgbnVsbCAhPSBoYXNTcmMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAoZGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICB0YWcgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBkZWZhdWx0Q2hlY2tlZCwgaGFzU3JjLCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XG4gICAgICAgICAgICBmb3IgKF9wcm9wVmFsdWUgaW4gcHJvcHMpXG4gICAgICAgICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KF9wcm9wVmFsdWUpICYmXG4gICAgICAgICAgICAgICAgKChoYXNTcmMgPSBwcm9wc1tfcHJvcFZhbHVlXSksXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBoYXNTcmMgJiZcbiAgICAgICAgICAgICAgICAgIHNldFByb3BPbkN1c3RvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaGFzU3JjLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGRlZmF1bHRWYWx1ZSBpbiBwcm9wcylcbiAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdFZhbHVlKSAmJlxuICAgICAgICAgICgoaGFzU3JjID0gcHJvcHNbZGVmYXVsdFZhbHVlXSksXG4gICAgICAgICAgbnVsbCAhPSBoYXNTcmMgJiZcbiAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBkZWZhdWx0VmFsdWUsIGhhc1NyYywgcHJvcHMsIG51bGwpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIGxhc3RQcm9wcywgbmV4dFByb3BzKSB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFByb3BzKTtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgXCJkaXZcIjpcbiAgICAgICAgY2FzZSBcInNwYW5cIjpcbiAgICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICBjYXNlIFwicGF0aFwiOlxuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBjYXNlIFwibGlcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgdmFyIG5hbWUgPSBudWxsLFxuICAgICAgICAgICAgdHlwZSA9IG51bGwsXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBudWxsLFxuICAgICAgICAgICAgbGFzdERlZmF1bHRWYWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBjaGVja2VkID0gbnVsbCxcbiAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgICBpZiAobGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpICYmIG51bGwgIT0gbGFzdFByb3ApXG4gICAgICAgICAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGxhc3REZWZhdWx0VmFsdWUgPSBsYXN0UHJvcDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8XG4gICAgICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvcFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIF9wcm9wS2V5OCBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBwcm9wS2V5ID0gbmV4dFByb3BzW19wcm9wS2V5OF07XG4gICAgICAgICAgICBsYXN0UHJvcCA9IGxhc3RQcm9wc1tfcHJvcEtleThdO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BLZXk4KSAmJlxuICAgICAgICAgICAgICAobnVsbCAhPSBwcm9wS2V5IHx8IG51bGwgIT0gbGFzdFByb3ApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAoX3Byb3BLZXk4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgICAgICAgICAgIHR5cGUgPSBwcm9wS2V5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9wS2V5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBwcm9wS2V5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHByb3BLZXk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcEtleTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BLZXk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BLZXkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcHJvcEtleSAhPT0gbGFzdFByb3AgJiZcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgICBfcHJvcEtleTgsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdFByb3BcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YWcgPVxuICAgICAgICAgICAgXCJjaGVja2JveFwiID09PSBsYXN0UHJvcHMudHlwZSB8fCBcInJhZGlvXCIgPT09IGxhc3RQcm9wcy50eXBlXG4gICAgICAgICAgICAgID8gbnVsbCAhPSBsYXN0UHJvcHMuY2hlY2tlZFxuICAgICAgICAgICAgICA6IG51bGwgIT0gbGFzdFByb3BzLnZhbHVlO1xuICAgICAgICAgIG5leHRQcm9wcyA9XG4gICAgICAgICAgICBcImNoZWNrYm94XCIgPT09IG5leHRQcm9wcy50eXBlIHx8IFwicmFkaW9cIiA9PT0gbmV4dFByb3BzLnR5cGVcbiAgICAgICAgICAgICAgPyBudWxsICE9IG5leHRQcm9wcy5jaGVja2VkXG4gICAgICAgICAgICAgIDogbnVsbCAhPSBuZXh0UHJvcHMudmFsdWU7XG4gICAgICAgICAgdGFnIHx8XG4gICAgICAgICAgICAhbmV4dFByb3BzIHx8XG4gICAgICAgICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgdG8gYmUgY29udHJvbGxlZC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IHRoZSB2YWx1ZSBjaGFuZ2luZyBmcm9tIHVuZGVmaW5lZCB0byBhIGRlZmluZWQgdmFsdWUsIHdoaWNoIHNob3VsZCBub3QgaGFwcGVuLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0IGVsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9ICEwKSk7XG4gICAgICAgICAgIXRhZyB8fFxuICAgICAgICAgICAgbmV4dFByb3BzIHx8XG4gICAgICAgICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgdG8gYmUgdW5jb250cm9sbGVkLiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdGhlIHZhbHVlIGNoYW5naW5nIGZyb20gYSBkZWZpbmVkIHRvIHVuZGVmaW5lZCwgd2hpY2ggc2hvdWxkIG5vdCBoYXBwZW4uIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gITApKTtcbiAgICAgICAgICB1cGRhdGVJbnB1dChcbiAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgIGxhc3REZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgcHJvcEtleSA9IHZhbHVlID0gZGVmYXVsdFZhbHVlID0gX3Byb3BLZXk4ID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHR5cGUgaW4gbGFzdFByb3BzKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKGxhc3REZWZhdWx0VmFsdWUgPSBsYXN0UHJvcHNbdHlwZV0pLFxuICAgICAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkodHlwZSkgJiYgbnVsbCAhPSBsYXN0RGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICAgICAgcHJvcEtleSA9IGxhc3REZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSB8fFxuICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdERlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChuYW1lIGluIG5leHRQcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKCh0eXBlID0gbmV4dFByb3BzW25hbWVdKSxcbiAgICAgICAgICAgICAgKGxhc3REZWZhdWx0VmFsdWUgPSBsYXN0UHJvcHNbbmFtZV0pLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAobnVsbCAhPSB0eXBlIHx8IG51bGwgIT0gbGFzdERlZmF1bHRWYWx1ZSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgX3Byb3BLZXk4ID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHlwZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gbGFzdERlZmF1bHRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdERlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3BzID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgIHRhZyA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RQcm9wcyA9IHByb3BLZXk7XG4gICAgICAgICAgbnVsbCAhPSBfcHJvcEtleThcbiAgICAgICAgICAgID8gdXBkYXRlT3B0aW9ucyhkb21FbGVtZW50LCAhIXRhZywgX3Byb3BLZXk4LCAhMSlcbiAgICAgICAgICAgIDogISFsYXN0UHJvcHMgIT09ICEhdGFnICYmXG4gICAgICAgICAgICAgIChudWxsICE9IG5leHRQcm9wc1xuICAgICAgICAgICAgICAgID8gdXBkYXRlT3B0aW9ucyhkb21FbGVtZW50LCAhIXRhZywgbmV4dFByb3BzLCAhMClcbiAgICAgICAgICAgICAgICA6IHVwZGF0ZU9wdGlvbnMoZG9tRWxlbWVudCwgISF0YWcsIHRhZyA/IFtdIDogXCJcIiwgITEpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICAgIHByb3BLZXkgPSBfcHJvcEtleTggPSBudWxsO1xuICAgICAgICAgIGZvciAoZGVmYXVsdFZhbHVlIGluIGxhc3RQcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChuYW1lID0gbGFzdFByb3BzW2RlZmF1bHRWYWx1ZV0pLFxuICAgICAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdFZhbHVlKSAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT0gbmFtZSAmJlxuICAgICAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgc3dpdGNoIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBkZWZhdWx0VmFsdWUsIG51bGwsIG5leHRQcm9wcywgbmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhbHVlIGluIG5leHRQcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChuYW1lID0gbmV4dFByb3BzW3ZhbHVlXSksXG4gICAgICAgICAgICAgICh0eXBlID0gbGFzdFByb3BzW3ZhbHVlXSksXG4gICAgICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgKG51bGwgIT0gbmFtZSB8fCBudWxsICE9IHR5cGUpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICBfcHJvcEtleTggPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgcHJvcEtleSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIG5hbWUgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIHZhbHVlLCBuYW1lLCBuZXh0UHJvcHMsIHR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlVGV4dGFyZWEoZG9tRWxlbWVudCwgX3Byb3BLZXk4LCBwcm9wS2V5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICBmb3IgKHZhciBfcHJvcEtleTEzIGluIGxhc3RQcm9wcylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChfcHJvcEtleTggPSBsYXN0UHJvcHNbX3Byb3BLZXkxM10pLFxuICAgICAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BLZXkxMykgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9IF9wcm9wS2V5OCAmJlxuICAgICAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BLZXkxMykpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAoX3Byb3BLZXkxMykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZWxlY3RlZCA9ICExO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BLZXkxMyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICBfcHJvcEtleThcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxhc3REZWZhdWx0VmFsdWUgaW4gbmV4dFByb3BzKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKF9wcm9wS2V5OCA9IG5leHRQcm9wc1tsYXN0RGVmYXVsdFZhbHVlXSksXG4gICAgICAgICAgICAgIChwcm9wS2V5ID0gbGFzdFByb3BzW2xhc3REZWZhdWx0VmFsdWVdKSxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KGxhc3REZWZhdWx0VmFsdWUpICYmXG4gICAgICAgICAgICAgICAgX3Byb3BLZXk4ICE9PSBwcm9wS2V5ICYmXG4gICAgICAgICAgICAgICAgKG51bGwgIT0gX3Byb3BLZXk4IHx8IG51bGwgIT0gcHJvcEtleSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAobGFzdERlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZWxlY3RlZCA9XG4gICAgICAgICAgICAgICAgICAgIF9wcm9wS2V5OCAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfcHJvcEtleTggJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIF9wcm9wS2V5ODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgIGxhc3REZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wS2V5OCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICBjYXNlIFwiY29sXCI6XG4gICAgICAgIGNhc2UgXCJlbWJlZFwiOlxuICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICBjYXNlIFwicGFyYW1cIjpcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjYXNlIFwidHJhY2tcIjpcbiAgICAgICAgY2FzZSBcIndiclwiOlxuICAgICAgICBjYXNlIFwibWVudWl0ZW1cIjpcbiAgICAgICAgICBmb3IgKHZhciBfcHJvcEtleTE1IGluIGxhc3RQcm9wcylcbiAgICAgICAgICAgIChfcHJvcEtleTggPSBsYXN0UHJvcHNbX3Byb3BLZXkxNV0pLFxuICAgICAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BLZXkxNSkgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9IF9wcm9wS2V5OCAmJlxuICAgICAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BLZXkxNSkgJiZcbiAgICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgIF9wcm9wS2V5MTUsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgX3Byb3BLZXk4XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgKGNoZWNrZWQgaW4gbmV4dFByb3BzKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKF9wcm9wS2V5OCA9IG5leHRQcm9wc1tjaGVja2VkXSksXG4gICAgICAgICAgICAgIChwcm9wS2V5ID0gbGFzdFByb3BzW2NoZWNrZWRdKSxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KGNoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgX3Byb3BLZXk4ICE9PSBwcm9wS2V5ICYmXG4gICAgICAgICAgICAgICAgKG51bGwgIT0gX3Byb3BLZXk4IHx8IG51bGwgIT0gcHJvcEtleSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gX3Byb3BLZXk4KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICB0YWcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BLZXk4LFxuICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfcHJvcEtleTE3IGluIGxhc3RQcm9wcylcbiAgICAgICAgICAgICAgKF9wcm9wS2V5OCA9IGxhc3RQcm9wc1tfcHJvcEtleTE3XSksXG4gICAgICAgICAgICAgICAgbGFzdFByb3BzLmhhc093blByb3BlcnR5KF9wcm9wS2V5MTcpICYmXG4gICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IF9wcm9wS2V5OCAmJlxuICAgICAgICAgICAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShfcHJvcEtleTE3KSAmJlxuICAgICAgICAgICAgICAgICAgc2V0UHJvcE9uQ3VzdG9tRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgICBfcHJvcEtleTE3LFxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BLZXk4XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZm9yIChkZWZhdWx0Q2hlY2tlZCBpbiBuZXh0UHJvcHMpXG4gICAgICAgICAgICAgIChfcHJvcEtleTggPSBuZXh0UHJvcHNbZGVmYXVsdENoZWNrZWRdKSxcbiAgICAgICAgICAgICAgICAocHJvcEtleSA9IGxhc3RQcm9wc1tkZWZhdWx0Q2hlY2tlZF0pLFxuICAgICAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkoZGVmYXVsdENoZWNrZWQpIHx8XG4gICAgICAgICAgICAgICAgICBfcHJvcEtleTggPT09IHByb3BLZXkgfHxcbiAgICAgICAgICAgICAgICAgICh2b2lkIDAgPT09IF9wcm9wS2V5OCAmJiB2b2lkIDAgPT09IHByb3BLZXkpIHx8XG4gICAgICAgICAgICAgICAgICBzZXRQcm9wT25DdXN0b21FbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICBfcHJvcEtleTgsXG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcEtleTE5IGluIGxhc3RQcm9wcylcbiAgICAgICAgKF9wcm9wS2V5OCA9IGxhc3RQcm9wc1tfcHJvcEtleTE5XSksXG4gICAgICAgICAgbGFzdFByb3BzLmhhc093blByb3BlcnR5KF9wcm9wS2V5MTkpICYmXG4gICAgICAgICAgICBudWxsICE9IF9wcm9wS2V5OCAmJlxuICAgICAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShfcHJvcEtleTE5KSAmJlxuICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIF9wcm9wS2V5MTksIG51bGwsIG5leHRQcm9wcywgX3Byb3BLZXk4KTtcbiAgICAgIGZvciAobGFzdFByb3AgaW4gbmV4dFByb3BzKVxuICAgICAgICAoX3Byb3BLZXk4ID0gbmV4dFByb3BzW2xhc3RQcm9wXSksXG4gICAgICAgICAgKHByb3BLZXkgPSBsYXN0UHJvcHNbbGFzdFByb3BdKSxcbiAgICAgICAgICAhbmV4dFByb3BzLmhhc093blByb3BlcnR5KGxhc3RQcm9wKSB8fFxuICAgICAgICAgICAgX3Byb3BLZXk4ID09PSBwcm9wS2V5IHx8XG4gICAgICAgICAgICAobnVsbCA9PSBfcHJvcEtleTggJiYgbnVsbCA9PSBwcm9wS2V5KSB8fFxuICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIGxhc3RQcm9wLCBfcHJvcEtleTgsIG5leHRQcm9wcywgcHJvcEtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFByb3BOYW1lRnJvbUF0dHJpYnV0ZU5hbWUoYXR0ck5hbWUpIHtcbiAgICAgIHN3aXRjaCAoYXR0ck5hbWUpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgcmV0dXJuIFwiY2xhc3NOYW1lXCI7XG4gICAgICAgIGNhc2UgXCJmb3JcIjpcbiAgICAgICAgICByZXR1cm4gXCJodG1sRm9yXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGF0dHJOYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdHlsZXNPYmplY3RGcm9tRWxlbWVudChkb21FbGVtZW50KSB7XG4gICAgICB2YXIgc2VydmVyVmFsdWVJbk9iamVjdEZvcm0gPSB7fTtcbiAgICAgIGRvbUVsZW1lbnQgPSBkb21FbGVtZW50LnN0eWxlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21FbGVtZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdHlsZU5hbWUgPSBkb21FbGVtZW50W2ldO1xuICAgICAgICBzZXJ2ZXJWYWx1ZUluT2JqZWN0Rm9ybVtzdHlsZU5hbWVdID1cbiAgICAgICAgICBkb21FbGVtZW50LmdldFByb3BlcnR5VmFsdWUoc3R5bGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJ2ZXJWYWx1ZUluT2JqZWN0Rm9ybTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlmZkh5ZHJhdGVkU3R5bGVzKGRvbUVsZW1lbnQsIHZhbHVlJGpzY29tcCQwLCBzZXJ2ZXJEaWZmZXJlbmNlcykge1xuICAgICAgaWYgKG51bGwgIT0gdmFsdWUkanNjb21wJDAgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHZhbHVlJGpzY29tcCQwKVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gdXNpbmcgSlNYLlwiXG4gICAgICAgICk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGNsaWVudFZhbHVlO1xuICAgICAgICB2YXIgZGVsaW1pdGVyID0gKGNsaWVudFZhbHVlID0gXCJcIiksXG4gICAgICAgICAgc3R5bGVOYW1lO1xuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiB2YWx1ZSRqc2NvbXAkMClcbiAgICAgICAgICBpZiAodmFsdWUkanNjb21wJDAuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWUkanNjb21wJDBbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgXCJib29sZWFuXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgICBcIlwiICE9PSB2YWx1ZSAmJlxuICAgICAgICAgICAgICAoMCA9PT0gc3R5bGVOYW1lLmluZGV4T2YoXCItLVwiKVxuICAgICAgICAgICAgICAgID8gKGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbih2YWx1ZSwgc3R5bGVOYW1lKSxcbiAgICAgICAgICAgICAgICAgIChjbGllbnRWYWx1ZSArPVxuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgKyBzdHlsZU5hbWUgKyBcIjpcIiArIChcIlwiICsgdmFsdWUpLnRyaW0oKSkpXG4gICAgICAgICAgICAgICAgOiBcIm51bWJlclwiICE9PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gdmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgdW5pdGxlc3NOdW1iZXJzLmhhcyhzdHlsZU5hbWUpXG4gICAgICAgICAgICAgICAgICA/IChjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsIHN0eWxlTmFtZSksXG4gICAgICAgICAgICAgICAgICAgIChjbGllbnRWYWx1ZSArPVxuICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciArXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGVOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCBcIi0kMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG1zUGF0dGVybiQxLCBcIi1tcy1cIikgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAoXCJcIiArIHZhbHVlKS50cmltKCkpKVxuICAgICAgICAgICAgICAgICAgOiAoY2xpZW50VmFsdWUgKz1cbiAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgK1xuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgXCItJDFcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShtc1BhdHRlcm4kMSwgXCItbXMtXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICAgIFwicHhcIiksXG4gICAgICAgICAgICAgIChkZWxpbWl0ZXIgPSBcIjtcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgY2xpZW50VmFsdWUgPSBjbGllbnRWYWx1ZSB8fCBudWxsO1xuICAgICAgICB2YWx1ZSRqc2NvbXAkMCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgICAgIHZhbHVlJGpzY29tcCQwICE9PSBjbGllbnRWYWx1ZSAmJlxuICAgICAgICAgICgoY2xpZW50VmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VmFsdWUpKSxcbiAgICAgICAgICBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUodmFsdWUkanNjb21wJDApICE9PSBjbGllbnRWYWx1ZSAmJlxuICAgICAgICAgICAgKHNlcnZlckRpZmZlcmVuY2VzLnN0eWxlID0gZ2V0U3R5bGVzT2JqZWN0RnJvbUVsZW1lbnQoZG9tRWxlbWVudCkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaHlkcmF0ZUF0dHJpYnV0ZShcbiAgICAgIGRvbUVsZW1lbnQsXG4gICAgICBwcm9wS2V5LFxuICAgICAgYXR0cmlidXRlTmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICApIHtcbiAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICBkb21FbGVtZW50ID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICBpZiAobnVsbCA9PT0gZG9tRWxlbWVudClcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bGwgIT0gdmFsdWUpXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgcHJvcEtleSksXG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQgPT09IFwiXCIgKyB2YWx1ZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgZG9tRWxlbWVudCwgdmFsdWUsIHNlcnZlckRpZmZlcmVuY2VzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHlkcmF0ZUJvb2xlYW5BdHRyaWJ1dGUoXG4gICAgICBkb21FbGVtZW50LFxuICAgICAgcHJvcEtleSxcbiAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgKSB7XG4gICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgaWYgKG51bGwgPT09IGRvbUVsZW1lbnQpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICh2YWx1ZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgZG9tRWxlbWVudCwgdmFsdWUsIHNlcnZlckRpZmZlcmVuY2VzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHlkcmF0ZUJvb2xlYW5pc2hBdHRyaWJ1dGUoXG4gICAgICBkb21FbGVtZW50LFxuICAgICAgcHJvcEtleSxcbiAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgKSB7XG4gICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgaWYgKG51bGwgPT09IGRvbUVsZW1lbnQpXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVsbCAhPSB2YWx1ZSlcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSksXG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQgPT09IFwiXCIgKyB2YWx1ZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgZG9tRWxlbWVudCwgdmFsdWUsIHNlcnZlckRpZmZlcmVuY2VzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHlkcmF0ZU51bWVyaWNBdHRyaWJ1dGUoXG4gICAgICBkb21FbGVtZW50LFxuICAgICAgcHJvcEtleSxcbiAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgKSB7XG4gICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgaWYgKG51bGwgPT09IGRvbUVsZW1lbnQpXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bGwgIT0gdmFsdWUpXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhaXNOYU4odmFsdWUpICYmXG4gICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wS2V5KSxcbiAgICAgICAgICAgICAgZG9tRWxlbWVudCA9PT0gXCJcIiArIHZhbHVlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBkb21FbGVtZW50LCB2YWx1ZSwgc2VydmVyRGlmZmVyZW5jZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoeWRyYXRlU2FuaXRpemVkQXR0cmlidXRlKFxuICAgICAgZG9tRWxlbWVudCxcbiAgICAgIHByb3BLZXksXG4gICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICkge1xuICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGRvbUVsZW1lbnQgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGlmIChudWxsID09PSBkb21FbGVtZW50KVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVsbCAhPSB2YWx1ZSlcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wS2V5KSxcbiAgICAgICAgICAgICAgKGF0dHJpYnV0ZU5hbWUgPSBzYW5pdGl6ZVVSTChcIlwiICsgdmFsdWUpKSxcbiAgICAgICAgICAgICAgZG9tRWxlbWVudCA9PT0gYXR0cmlidXRlTmFtZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgZG9tRWxlbWVudCwgdmFsdWUsIHNlcnZlckRpZmZlcmVuY2VzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIHByb3BzLCBob3N0Q29udGV4dCkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIHNlcnZlckRpZmZlcmVuY2VzID0ge30sXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzID0gbmV3IFNldCgpLFxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBkb21FbGVtZW50LmF0dHJpYnV0ZXMsXG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgIGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgICAgaSsrXG4gICAgICApXG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlc1tpXS5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjaGVja2VkXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuYWRkKGF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIGlmIChpc0N1c3RvbUVsZW1lbnQodGFnKSlcbiAgICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgICBpZiAobnVsbCAhPSB2YWx1ZSlcbiAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKCEwICE9PSBwcm9wcy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiB2YWx1ZSAmJiBcIm51bWJlclwiICE9PSB0eXBlb2YgdmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC50ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImlubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPyB2YWx1ZS5fX2h0bWwgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoKHZhbHVlID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCB2YWx1ZSkpLFxuICAgICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKHByb3BLZXkpO1xuICAgICAgICAgICAgICAgICAgICBkaWZmSHlkcmF0ZWRTdHlsZXMoZG9tRWxlbWVudCwgdmFsdWUsIHNlcnZlckRpZmZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwib2Zmc2V0UGFyZW50XCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwib2Zmc2V0VG9wXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwib2Zmc2V0TGVmdFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIm9mZnNldFdpZHRoXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwib2Zmc2V0SGVpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiaXNDb250ZW50RWRpdGFibGVcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdXRlclRleHRcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdXRlckhUTUxcIjpcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiQXNzaWdubWVudCB0byByZWFkLW9ubHkgcHJvcGVydHkgd2lsbCByZXN1bHQgaW4gYSBuby1vcDogYCVzYFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUoXCJjbGFzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IGdldFZhbHVlRm9yQXR0cmlidXRlT25DdXN0b21Db21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICAgIFwiY2xhc3NOYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGhvc3RDb250ZXh0LmNvbnRleHQgPT09IEhvc3RDb250ZXh0TmFtZXNwYWNlTm9uZSAmJlxuICAgICAgICAgICAgICAgICAgICBcInN2Z1wiICE9PSB0YWcgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJtYXRoXCIgIT09IHRhZ1xuICAgICAgICAgICAgICAgICAgICAgID8gZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgOiBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKHByb3BLZXkpLFxuICAgICAgICAgICAgICAgICAgICAgIChhdHRyaWJ1dGVzID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGVPbkN1c3RvbUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgZm9yICh2YWx1ZSBpbiBwcm9wcylcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiZcbiAgICAgICAgICAgICgocHJvcEtleSA9IHByb3BzW3ZhbHVlXSksIG51bGwgIT0gcHJvcEtleSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb3BLZXkgJiZcbiAgICAgICAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIodmFsdWUsIHByb3BLZXkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoITAgIT09IHByb3BzLnN1cHByZXNzSHlkcmF0aW9uV2FybmluZylcbiAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICAgICAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcm9wS2V5ICYmXG4gICAgICAgICAgICAgICAgICAgIFwibnVtYmVyXCIgIT09IHR5cGVvZiBwcm9wS2V5KSB8fFxuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiLFxuICAgICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQudGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlZlwiOlxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgICBwcm9wS2V5ID0gcHJvcEtleSA/IHByb3BLZXkuX19odG1sIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPSBwcm9wS2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICgocHJvcEtleSA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcHJvcEtleSkpLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzICE9PSBwcm9wS2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHNlcnZlckRpZmZlcmVuY2VzW3ZhbHVlXSA9IHsgX19odG1sOiBhdHRyaWJ1dGVzIH0pKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjbGFzc05hbWVcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwidGFiSW5kZXhcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcInRhYmluZGV4XCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgZGlmZkh5ZHJhdGVkU3R5bGVzKGRvbUVsZW1lbnQsIHByb3BLZXksIHNlcnZlckRpZmZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50Lm11bHRpcGxlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50Lm11dGVkLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhdXRvRm9jdXNcIjpcbiAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUoXCJhdXRvZm9jdXNcIik7XG4gICAgICAgICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LmF1dG9mb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHRhZykge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwic3JjXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImhyZWZcIjpcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgICBcIlwiICE9PSBwcm9wS2V5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgKFwiYVwiID09PSB0YWcgJiYgXCJocmVmXCIgPT09IHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0YWcgJiYgXCJkYXRhXCIgPT09IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgXCJzcmNcIiA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdBbiBlbXB0eSBzdHJpbmcgKFwiXCIpIHdhcyBwYXNzZWQgdG8gdGhlICVzIGF0dHJpYnV0ZS4gVGhpcyBtYXkgY2F1c2UgdGhlIGJyb3dzZXIgdG8gZG93bmxvYWQgdGhlIHdob2xlIHBhZ2UgYWdhaW4gb3ZlciB0aGUgbmV0d29yay4gVG8gZml4IHRoaXMsIGVpdGhlciBkbyBub3QgcmVuZGVyIHRoZSBlbGVtZW50IGF0IGFsbCBvciBwYXNzIG51bGwgdG8gJXMgaW5zdGVhZCBvZiBhbiBlbXB0eSBzdHJpbmcuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnQW4gZW1wdHkgc3RyaW5nIChcIlwiKSB3YXMgcGFzc2VkIHRvIHRoZSAlcyBhdHRyaWJ1dGUuIFRvIGZpeCB0aGlzLCBlaXRoZXIgZG8gbm90IHJlbmRlciB0aGUgZWxlbWVudCBhdCBhbGwgb3IgcGFzcyBudWxsIHRvICVzIGluc3RlYWQgb2YgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlU2FuaXRpemVkQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImZvcm1BY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKHZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICBcImZvcm1BY3Rpb25cIiA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICA/IChleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKFwibmFtZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUoXCJmb3JtZW5jdHlwZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUoXCJmb3JtbWV0aG9kXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShcImZvcm10YXJnZXRcIikpXG4gICAgICAgICAgICAgICAgICAgICAgOiAoZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShcImVuY3R5cGVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKFwibWV0aG9kXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShcInRhcmdldFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzID09PSBFWFBFQ1RFRF9GT1JNX0FDVElPTl9VUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZSh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaHlkcmF0ZVNhbml0aXplZEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwieGxpbmtIcmVmXCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlU2FuaXRpemVkQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ4bGluazpocmVmXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29udGVudEVkaXRhYmxlXCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQm9vbGVhbmlzaEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udGVudGVkaXRhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3BlbGxDaGVja1wiOlxuICAgICAgICAgICAgICAgICAgaHlkcmF0ZUJvb2xlYW5pc2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcInNwZWxsY2hlY2tcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkcmFnZ2FibGVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXV0b1JldmVyc2VcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmb2N1c2FibGVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicHJlc2VydmVBbHBoYVwiOlxuICAgICAgICAgICAgICAgICAgaHlkcmF0ZUJvb2xlYW5pc2hBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbGxvd0Z1bGxTY3JlZW5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXN5bmNcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXV0b1BsYXlcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29udHJvbHNcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWZlclwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybU5vVmFsaWRhdGVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibm9Nb2R1bGVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibm9WYWxpZGF0ZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInBsYXlzSW5saW5lXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlYWRPbmx5XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJldmVyc2VkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInNjb3BlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWFtbGVzc1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJpdGVtU2NvcGVcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVCb29sZWFuQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjYXB0dXJlXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImRvd25sb2FkXCI6XG4gICAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBkb21FbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IChhdHRyaWJ1dGVzID0gdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzJGpzY29tcCQwID0gc2VydmVyRGlmZmVyZW5jZXM7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBpLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGkpXG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgcHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgPT09IHByb3BLZXkpIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChudWxsICE9IHByb3BLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgcHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSBwcm9wS2V5ICYmIFwiXCIgPT09IGkpIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHByb3BLZXksIGF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPT09IFwiXCIgKyBwcm9wS2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlcyRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbHNcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicm93c1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInNwYW5cIjpcbiAgICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGRvbUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzJGpzY29tcCQwID0gc2VydmVyRGlmZmVyZW5jZXM7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcy5kZWxldGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBpLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGkpXG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgcHJvcEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHByb3BLZXkpIHx8IDEgPiBwcm9wS2V5KSBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobnVsbCAhPSBwcm9wS2V5KVxuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShpc05hTihwcm9wS2V5KSB8fCAxID4gcHJvcEtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihwcm9wS2V5LCBhdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID09PSBcIlwiICsgcHJvcEtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXMkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyb3dTcGFuXCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlTnVtZXJpY0F0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIFwicm93c3BhblwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlTnVtZXJpY0F0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcInhIZWlnaHRcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcIngtaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwieGxpbmtBY3R1YXRlXCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ4bGluazphY3R1YXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwieGxpbmtBcmNyb2xlXCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ4bGluazphcmNyb2xlXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwieGxpbmtSb2xlXCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ4bGluazpyb2xlXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwieGxpbmtTaG93XCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ4bGluazpzaG93XCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwieGxpbmtUaXRsZVwiOlxuICAgICAgICAgICAgICAgICAgaHlkcmF0ZUF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIFwieGxpbms6dGl0bGVcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ4bGlua1R5cGVcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcInhsaW5rOnR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ4bWxCYXNlXCI6XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ4bWw6YmFzZVwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcInhtbExhbmdcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcInhtbDpsYW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwieG1sU3BhY2VcIjpcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBcInhtbDpzcGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcImluZXJ0XCI6XG4gICAgICAgICAgICAgICAgICBcIlwiICE9PSBwcm9wS2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIGRpZFdhcm5Gb3JOZXdCb29sZWFuUHJvcHNXaXRoRW1wdHlWYWx1ZVt2YWx1ZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgKChkaWRXYXJuRm9yTmV3Qm9vbGVhblByb3BzV2l0aEVtcHR5VmFsdWVbdmFsdWVdID0gITApLFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gZW1wdHkgc3RyaW5nIGZvciBhIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuIFRoaXMgd2lsbCB0cmVhdCB0aGUgYXR0cmlidXRlIGFzIGlmIGl0IHdlcmUgZmFsc2UuIEVpdGhlciBwYXNzIGBmYWxzZWAgdG8gc2lsZW5jZSB0aGlzIHdhcm5pbmcsIG9yIHBhc3MgYHRydWVgIGlmIHlvdSB1c2VkIGFuIGVtcHR5IHN0cmluZyBpbiBlYXJsaWVyIHZlcnNpb25zIG9mIFJlYWN0IHRvIGluZGljYXRlIHRoaXMgYXR0cmlidXRlIGlzIHRydWUuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICBoeWRyYXRlQm9vbGVhbkF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wS2V5LFxuICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgISgyIDwgdmFsdWUubGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAgICAgICAoXCJvXCIgIT09IHZhbHVlWzBdICYmIFwiT1wiICE9PSB2YWx1ZVswXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKFwiblwiICE9PSB2YWx1ZVsxXSAmJiBcIk5cIiAhPT0gdmFsdWVbMV0pXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGdldEF0dHJpYnV0ZUFsaWFzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9ICExO1xuICAgICAgICAgICAgICAgICAgICBob3N0Q29udGV4dC5jb250ZXh0ID09PSBIb3N0Q29udGV4dE5hbWVzcGFjZU5vbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdmdcIiAhPT0gdGFnICYmXG4gICAgICAgICAgICAgICAgICAgIFwibWF0aFwiICE9PSB0YWdcbiAgICAgICAgICAgICAgICAgICAgICA/IGV4dHJhQXR0cmlidXRlcy5kZWxldGUoaS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICAgICAgIDogKChhdHRyaWJ1dGVOYW1lID0gdmFsdWUudG9Mb3dlckNhc2UoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAoYXR0cmlidXRlTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBvc3NpYmxlU3RhbmRhcmROYW1lc1thdHRyaWJ1dGVOYW1lXSB8fCBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBhdHRyaWJ1dGVOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgIT09IHZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgoYXR0cmlidXRlcyA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVzLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZXMuZGVsZXRlKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgYTogaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICgoYXR0cmlidXRlTmFtZSA9IGRvbUVsZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICAgIChzZXJ2ZXJEaWZmZXJlbmNlcyRqc2NvbXAkMCA9IGkpLFxuICAgICAgICAgICAgICAgICAgICAgIChpID0gcHJvcEtleSksXG4gICAgICAgICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGVOYW1lU2FmZShzZXJ2ZXJEaWZmZXJlbmNlcyRqc2NvbXAkMCkpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lLmhhc0F0dHJpYnV0ZShzZXJ2ZXJEaWZmZXJlbmNlcyRqc2NvbXAkMClcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAoYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWUuZ2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlcyRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJEaWZmZXJlbmNlcyRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoaSA9IGF0dHJpYnV0ZU5hbWUgPT09IFwiXCIgKyBpID8gaSA6IGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChhdHRyaWJ1dGVOYW1lID0gc2VydmVyRGlmZmVyZW5jZXMkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIDUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YS1cIiAhPT0gYXR0cmlidXRlTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFyaWEtXCIgIT09IGF0dHJpYnV0ZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB2b2lkIDAgPT09IGkgPyB2b2lkIDAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgMCA8IGV4dHJhQXR0cmlidXRlcy5zaXplICYmXG4gICAgICAgICEwICE9PSBwcm9wcy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgJiZcbiAgICAgICAgd2FybkZvckV4dHJhQXR0cmlidXRlcyhkb21FbGVtZW50LCBleHRyYUF0dHJpYnV0ZXMsIHNlcnZlckRpZmZlcmVuY2VzKTtcbiAgICAgIHJldHVybiAwID09PSBPYmplY3Qua2V5cyhzZXJ2ZXJEaWZmZXJlbmNlcykubGVuZ3RoXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHNlcnZlckRpZmZlcmVuY2VzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wTmFtZXNMaXN0Sm9pbihsaXN0LCBjb21iaW5hdG9yKSB7XG4gICAgICBzd2l0Y2ggKGxpc3QubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBsaXN0WzBdO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIGxpc3RbMF0gKyBcIiBcIiArIGNvbWJpbmF0b3IgKyBcIiBcIiArIGxpc3RbMV07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGxpc3Quc2xpY2UoMCwgLTEpLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICBcIiwgXCIgK1xuICAgICAgICAgICAgY29tYmluYXRvciArXG4gICAgICAgICAgICBcIiBcIiArXG4gICAgICAgICAgICBsaXN0W2xpc3QubGVuZ3RoIC0gMV1cbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgIHJldHVybiA5ID09PSByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZVxuICAgICAgICA/IHJvb3RDb250YWluZXJFbGVtZW50XG4gICAgICAgIDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duSG9zdENvbnRleHQobmFtZXNwYWNlVVJJKSB7XG4gICAgICBzd2l0Y2ggKG5hbWVzcGFjZVVSSSkge1xuICAgICAgICBjYXNlIFNWR19OQU1FU1BBQ0U6XG4gICAgICAgICAgcmV0dXJuIEhvc3RDb250ZXh0TmFtZXNwYWNlU3ZnO1xuICAgICAgICBjYXNlIE1BVEhfTkFNRVNQQUNFOlxuICAgICAgICAgIHJldHVybiBIb3N0Q29udGV4dE5hbWVzcGFjZU1hdGg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIEhvc3RDb250ZXh0TmFtZXNwYWNlTm9uZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q2hpbGRIb3N0Q29udGV4dFByb2QocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gICAgICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBIb3N0Q29udGV4dE5hbWVzcGFjZU5vbmUpXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgICAgIHJldHVybiBIb3N0Q29udGV4dE5hbWVzcGFjZVN2ZztcbiAgICAgICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIEhvc3RDb250ZXh0TmFtZXNwYWNlTWF0aDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIEhvc3RDb250ZXh0TmFtZXNwYWNlTm9uZTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudE5hbWVzcGFjZSA9PT0gSG9zdENvbnRleHROYW1lc3BhY2VTdmcgJiZcbiAgICAgICAgXCJmb3JlaWduT2JqZWN0XCIgPT09IHR5cGVcbiAgICAgICAgPyBIb3N0Q29udGV4dE5hbWVzcGFjZU5vbmVcbiAgICAgICAgOiBwYXJlbnROYW1lc3BhY2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByb3BzKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcInRleHRhcmVhXCIgPT09IHR5cGUgfHxcbiAgICAgICAgXCJub3NjcmlwdFwiID09PSB0eXBlIHx8XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiB8fFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHByb3BzLmNoaWxkcmVuIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiZcbiAgICAgICAgICBudWxsICE9PSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJlxuICAgICAgICAgIG51bGwgIT0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciBldmVudCA9IHdpbmRvdy5ldmVudDtcbiAgICAgIGlmIChldmVudCAmJiBcInBvcHN0YXRlXCIgPT09IGV2ZW50LnR5cGUpIHtcbiAgICAgICAgaWYgKGV2ZW50ID09PSBjdXJyZW50UG9wc3RhdGVUcmFuc2l0aW9uRXZlbnQpIHJldHVybiAhMTtcbiAgICAgICAgY3VycmVudFBvcHN0YXRlVHJhbnNpdGlvbkV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRQb3BzdGF0ZVRyYW5zaXRpb25FdmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9ySW5OZXh0VGljayhlcnJvcikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdE1vdW50KGRvbUVsZW1lbnQsIHR5cGUsIG5ld1Byb3BzKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgICBuZXdQcm9wcy5hdXRvRm9jdXMgJiYgZG9tRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICAgICAgbmV3UHJvcHMuc3JjXG4gICAgICAgICAgICA/IChkb21FbGVtZW50LnNyYyA9IG5ld1Byb3BzLnNyYylcbiAgICAgICAgICAgIDogbmV3UHJvcHMuc3JjU2V0ICYmIChkb21FbGVtZW50LnNyY3NldCA9IG5ld1Byb3BzLnNyY1NldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFVwZGF0ZShkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAgIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICAgIGRvbUVsZW1lbnRbaW50ZXJuYWxQcm9wc0tleV0gPSBuZXdQcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRUZXh0Q29udGVudChkb21FbGVtZW50KSB7XG4gICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBcIlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSBuZXdUZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuRm9yUmVhY3RDaGlsZHJlbkNvbmZsaWN0KGNvbnRhaW5lcikge1xuICAgICAgaWYgKCFjb250YWluZXIuX19yZWFjdFdhcm5lZEFib3V0Q2hpbGRyZW5Db25mbGljdCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBjb250YWluZXJbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IHByb3BzKSB7XG4gICAgICAgICAgdmFyIGZpYmVyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIpO1xuICAgICAgICAgIG51bGwgIT09IGZpYmVyICYmXG4gICAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmNoaWxkcmVuIHx8XG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgPyAoKGNvbnRhaW5lci5fX3JlYWN0V2FybmVkQWJvdXRDaGlsZHJlbkNvbmZsaWN0ID0gITApLFxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHVzZSBhIHJlZiBvbiBhIFJlYWN0IGVsZW1lbnQgYXMgYSBjb250YWluZXIgdG8gYGNyZWF0ZVJvb3RgIG9yIGBjcmVhdGVQb3J0YWxgIGlmIHRoYXQgZWxlbWVudCBhbHNvIHNldHMgXCJjaGlsZHJlblwiIHRleHQgY29udGVudCB1c2luZyBSZWFjdC4gSXQgc2hvdWxkIGJlIGEgbGVhZiB3aXRoIG5vIGNoaWxkcmVuLiBPdGhlcndpc2UgaXRcXCdzIGFtYmlndW91cyB3aGljaCBjaGlsZHJlbiBzaG91bGQgYmUgdXNlZC4nXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICA6IG51bGwgIT0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiZcbiAgICAgICAgICAgICAgICAoKGNvbnRhaW5lci5fX3JlYWN0V2FybmVkQWJvdXRDaGlsZHJlbkNvbmZsaWN0ID0gITApLFxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHVzZSBhIHJlZiBvbiBhIFJlYWN0IGVsZW1lbnQgYXMgYSBjb250YWluZXIgdG8gYGNyZWF0ZVJvb3RgIG9yIGBjcmVhdGVQb3J0YWxgIGlmIHRoYXQgZWxlbWVudCBhbHNvIHNldHMgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiIHVzaW5nIFJlYWN0LiBJdCBzaG91bGQgYmUgYSBsZWFmIHdpdGggbm8gY2hpbGRyZW4uIE90aGVyd2lzZSBpdFxcJ3MgYW1iaWd1b3VzIHdoaWNoIGNoaWxkcmVuIHNob3VsZCBiZSB1c2VkLidcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1NpbmdsZXRvblNjb3BlKHR5cGUpIHtcbiAgICAgIHJldHVybiBcImhlYWRcIiA9PT0gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICAoOSA9PT0gY29udGFpbmVyLm5vZGVUeXBlXG4gICAgICAgID8gY29udGFpbmVyLmJvZHlcbiAgICAgICAgOiBcIkhUTUxcIiA9PT0gY29udGFpbmVyLm5vZGVOYW1lXG4gICAgICAgICAgPyBjb250YWluZXIub3duZXJEb2N1bWVudC5ib2R5XG4gICAgICAgICAgOiBjb250YWluZXJcbiAgICAgICkucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhclN1c3BlbnNlQm91bmRhcnkocGFyZW50SW5zdGFuY2UsIHN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgICAgIHZhciBub2RlID0gc3VzcGVuc2VJbnN0YW5jZSxcbiAgICAgICAgcG9zc2libGVQcmVhbWJsZUNvbnRyaWJ1dGlvbiA9IDAsXG4gICAgICAgIGRlcHRoID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIGlmIChuZXh0Tm9kZSAmJiA4ID09PSBuZXh0Tm9kZS5ub2RlVHlwZSlcbiAgICAgICAgICBpZiAoKChub2RlID0gbmV4dE5vZGUuZGF0YSksIG5vZGUgPT09IFNVU1BFTlNFX0VORF9EQVRBKSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAwIDwgcG9zc2libGVQcmVhbWJsZUNvbnRyaWJ1dGlvbiAmJlxuICAgICAgICAgICAgICA4ID4gcG9zc2libGVQcmVhbWJsZUNvbnRyaWJ1dGlvblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBwb3NzaWJsZVByZWFtYmxlQ29udHJpYnV0aW9uO1xuICAgICAgICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IHBhcmVudEluc3RhbmNlLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICAgIG5vZGUgJiBQUkVBTUJMRV9DT05UUklCVVRJT05fSFRNTCAmJlxuICAgICAgICAgICAgICAgIHJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZShvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgIG5vZGUgJiBQUkVBTUJMRV9DT05UUklCVVRJT05fQk9EWSAmJlxuICAgICAgICAgICAgICAgIHJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZShvd25lckRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICBpZiAobm9kZSAmIFBSRUFNQkxFX0NPTlRSSUJVVElPTl9IRUFEKVxuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBub2RlID0gb3duZXJEb2N1bWVudC5oZWFkLFxuICAgICAgICAgICAgICAgICAgICByZWxlYXNlU2luZ2xldG9uSW5zdGFuY2Uobm9kZSksXG4gICAgICAgICAgICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICBvd25lckRvY3VtZW50O1xuXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmV4dE5vZGUkanNjb21wJDAgPSBvd25lckRvY3VtZW50Lm5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICBub2RlTmFtZSA9IG93bmVyRG9jdW1lbnQubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgICBvd25lckRvY3VtZW50W2ludGVybmFsSG9pc3RhYmxlTWFya2VyXSB8fFxuICAgICAgICAgICAgICAgICAgICBcIlNDUklQVFwiID09PSBub2RlTmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICBcIlNUWUxFXCIgPT09IG5vZGVOYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgIChcIkxJTktcIiA9PT0gbm9kZU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBcInN0eWxlc2hlZXRcIiA9PT0gb3duZXJEb2N1bWVudC5yZWwudG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChvd25lckRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBuZXh0Tm9kZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMCA9PT0gZGVwdGgpIHtcbiAgICAgICAgICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQobmV4dE5vZGUpO1xuICAgICAgICAgICAgICByZXRyeUlmQmxvY2tlZE9uKHN1c3BlbnNlSW5zdGFuY2UpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgbm9kZSA9PT0gU1VTUEVOU0VfU1RBUlRfREFUQSB8fFxuICAgICAgICAgICAgbm9kZSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBIHx8XG4gICAgICAgICAgICBub2RlID09PSBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBXG4gICAgICAgICAgICAgID8gZGVwdGgrK1xuICAgICAgICAgICAgICA6IChwb3NzaWJsZVByZWFtYmxlQ29udHJpYnV0aW9uID0gbm9kZS5jaGFyQ29kZUF0KDApIC0gNDgpO1xuICAgICAgICBlbHNlIHBvc3NpYmxlUHJlYW1ibGVDb250cmlidXRpb24gPSAwO1xuICAgICAgICBub2RlID0gbmV4dE5vZGU7XG4gICAgICB9IHdoaWxlIChub2RlKTtcbiAgICAgIHJldHJ5SWZCbG9ja2VkT24oc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5zdHlsZTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLnNldFByb3BlcnR5XG4gICAgICAgID8gaW5zdGFuY2Uuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsIFwibm9uZVwiLCBcImltcG9ydGFudFwiKVxuICAgICAgICA6IChpbnN0YW5jZS5kaXNwbGF5ID0gXCJub25lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSkge1xuICAgICAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlLCBwcm9wcykge1xuICAgICAgcHJvcHMgPSBwcm9wc1tTVFlMRV07XG4gICAgICBwcm9wcyA9XG4gICAgICAgIHZvaWQgMCAhPT0gcHJvcHMgJiYgbnVsbCAhPT0gcHJvcHMgJiYgcHJvcHMuaGFzT3duUHJvcGVydHkoXCJkaXNwbGF5XCIpXG4gICAgICAgICAgPyBwcm9wcy5kaXNwbGF5XG4gICAgICAgICAgOiBudWxsO1xuICAgICAgaW5zdGFuY2Uuc3R5bGUuZGlzcGxheSA9XG4gICAgICAgIG51bGwgPT0gcHJvcHMgfHwgXCJib29sZWFuXCIgPT09IHR5cGVvZiBwcm9wcyA/IFwiXCIgOiAoXCJcIiArIHByb3BzKS50cmltKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuaGlkZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhckNvbnRhaW5lclNwYXJpbmdseShjb250YWluZXIpIHtcbiAgICAgIHZhciBuZXh0Tm9kZSA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgbmV4dE5vZGUgJiYgMTAgPT09IG5leHROb2RlLm5vZGVUeXBlICYmIChuZXh0Tm9kZSA9IG5leHROb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgIGZvciAoOyBuZXh0Tm9kZTsgKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV4dE5vZGU7XG4gICAgICAgIG5leHROb2RlID0gbmV4dE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIHN3aXRjaCAobm9kZS5ub2RlTmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJIVE1MXCI6XG4gICAgICAgICAgY2FzZSBcIkhFQURcIjpcbiAgICAgICAgICBjYXNlIFwiQk9EWVwiOlxuICAgICAgICAgICAgY2xlYXJDb250YWluZXJTcGFyaW5nbHkobm9kZSk7XG4gICAgICAgICAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2Uobm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwiU0NSSVBUXCI6XG4gICAgICAgICAgY2FzZSBcIlNUWUxFXCI6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwiTElOS1wiOlxuICAgICAgICAgICAgaWYgKFwic3R5bGVzaGVldFwiID09PSBub2RlLnJlbC50b0xvd2VyQ2FzZSgpKSBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbkh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIGluUm9vdE9yU2luZ2xldG9uKSB7XG4gICAgICBmb3IgKDsgMSA9PT0gaW5zdGFuY2Uubm9kZVR5cGU7ICkge1xuICAgICAgICB2YXIgYW55UHJvcHMgPSBwcm9wcztcbiAgICAgICAgaWYgKGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFpblJvb3RPclNpbmdsZXRvbiAmJlxuICAgICAgICAgICAgKFwiSU5QVVRcIiAhPT0gaW5zdGFuY2Uubm9kZU5hbWUgfHwgXCJoaWRkZW5cIiAhPT0gaW5zdGFuY2UudHlwZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICghaW5Sb290T3JTaW5nbGV0b24pXG4gICAgICAgICAgaWYgKFwiaW5wdXRcIiA9PT0gdHlwZSAmJiBcImhpZGRlblwiID09PSBpbnN0YW5jZS50eXBlKSB7XG4gICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGFueVByb3BzLm5hbWUsIFwibmFtZVwiKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbnVsbCA9PSBhbnlQcm9wcy5uYW1lID8gbnVsbCA6IFwiXCIgKyBhbnlQcm9wcy5uYW1lO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcImhpZGRlblwiID09PSBhbnlQcm9wcy50eXBlICYmXG4gICAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT09IG5hbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgIH0gZWxzZSByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIGVsc2UgaWYgKCFpbnN0YW5jZVtpbnRlcm5hbEhvaXN0YWJsZU1hcmtlcl0pXG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlLmhhc0F0dHJpYnV0ZShcIml0ZW1wcm9wXCIpKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgbmFtZSA9IGluc3RhbmNlLmdldEF0dHJpYnV0ZShcInJlbFwiKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwic3R5bGVzaGVldFwiID09PSBuYW1lICYmXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaGFzQXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgbmFtZSAhPT0gYW55UHJvcHMucmVsIHx8XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSAhPT1cbiAgICAgICAgICAgICAgICAgIChudWxsID09IGFueVByb3BzLmhyZWYgfHwgXCJcIiA9PT0gYW55UHJvcHMuaHJlZlxuICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiBhbnlQcm9wcy5ocmVmKSB8fFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIpICE9PVxuICAgICAgICAgICAgICAgICAgKG51bGwgPT0gYW55UHJvcHMuY3Jvc3NPcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogYW55UHJvcHMuY3Jvc3NPcmlnaW4pIHx8XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZ2V0QXR0cmlidXRlKFwidGl0bGVcIikgIT09XG4gICAgICAgICAgICAgICAgICAobnVsbCA9PSBhbnlQcm9wcy50aXRsZSA/IG51bGwgOiBhbnlQcm9wcy50aXRsZSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmhhc0F0dHJpYnV0ZShcImRhdGEtcHJlY2VkZW5jZVwiKSkgYnJlYWs7XG4gICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgbmFtZSA9IGluc3RhbmNlLmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChuYW1lICE9PSAobnVsbCA9PSBhbnlQcm9wcy5zcmMgPyBudWxsIDogYW55UHJvcHMuc3JjKSB8fFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gYW55UHJvcHMudHlwZSA/IG51bGwgOiBhbnlQcm9wcy50eXBlKSB8fFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuZ2V0QXR0cmlidXRlKFwiY3Jvc3NvcmlnaW5cIikgIT09XG4gICAgICAgICAgICAgICAgICAgIChudWxsID09IGFueVByb3BzLmNyb3NzT3JpZ2luXG4gICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgOiBhbnlQcm9wcy5jcm9zc09yaWdpbikpICYmXG4gICAgICAgICAgICAgICAgbmFtZSAmJlxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmhhc0F0dHJpYnV0ZShcImFzeW5jXCIpICYmXG4gICAgICAgICAgICAgICAgIWluc3RhbmNlLmhhc0F0dHJpYnV0ZShcIml0ZW1wcm9wXCIpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShpbnN0YW5jZS5uZXh0U2libGluZyk7XG4gICAgICAgIGlmIChudWxsID09PSBpbnN0YW5jZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShpbnN0YW5jZSwgdGV4dCwgaW5Sb290T3JTaW5nbGV0b24pIHtcbiAgICAgIGlmIChcIlwiID09PSB0ZXh0KSByZXR1cm4gbnVsbDtcbiAgICAgIGZvciAoOyAzICE9PSBpbnN0YW5jZS5ub2RlVHlwZTsgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoMSAhPT0gaW5zdGFuY2Uubm9kZVR5cGUgfHxcbiAgICAgICAgICAgIFwiSU5QVVRcIiAhPT0gaW5zdGFuY2Uubm9kZU5hbWUgfHxcbiAgICAgICAgICAgIFwiaGlkZGVuXCIgIT09IGluc3RhbmNlLnR5cGUpICYmXG4gICAgICAgICAgIWluUm9vdE9yU2luZ2xldG9uXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShpbnN0YW5jZS5uZXh0U2libGluZyk7XG4gICAgICAgIGlmIChudWxsID09PSBpbnN0YW5jZSkgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpbnN0YW5jZS5kYXRhID09PSBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBIHx8XG4gICAgICAgIChpbnN0YW5jZS5kYXRhID09PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgJiZcbiAgICAgICAgICBpbnN0YW5jZS5vd25lckRvY3VtZW50LnJlYWR5U3RhdGUgPT09IERPQ1VNRU5UX1JFQURZX1NUQVRFX0NPTVBMRVRFKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkoaW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGluc3RhbmNlLm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoXG4gICAgICAgIGluc3RhbmNlLmRhdGEgIT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSB8fFxuICAgICAgICBvd25lckRvY3VtZW50LnJlYWR5U3RhdGUgPT09IERPQ1VNRU5UX1JFQURZX1NUQVRFX0NPTVBMRVRFXG4gICAgICApXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICAgIG93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgbGlzdGVuZXIpO1xuICAgICAgICBpbnN0YW5jZS5fcmVhY3RSZXRyeSA9IGxpc3RlbmVyO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZShub2RlKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPSBub2RlOyBub2RlID0gbm9kZS5uZXh0U2libGluZykge1xuICAgICAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgICAgICBpZiAoMSA9PT0gbm9kZVR5cGUgfHwgMyA9PT0gbm9kZVR5cGUpIGJyZWFrO1xuICAgICAgICBpZiAoOCA9PT0gbm9kZVR5cGUpIHtcbiAgICAgICAgICBub2RlVHlwZSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBub2RlVHlwZSA9PT0gU1VTUEVOU0VfU1RBUlRfREFUQSB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHxcbiAgICAgICAgICAgIG5vZGVUeXBlID09PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgfHxcbiAgICAgICAgICAgIG5vZGVUeXBlID09PSBGT1JNX1NUQVRFX0lTX01BVENISU5HIHx8XG4gICAgICAgICAgICBub2RlVHlwZSA9PT0gRk9STV9TVEFURV9JU19OT1RfTUFUQ0hJTkdcbiAgICAgICAgICApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IFNVU1BFTlNFX0VORF9EQVRBKSByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MoaW5zdGFuY2UpIHtcbiAgICAgIGlmICgxID09PSBpbnN0YW5jZS5ub2RlVHlwZSkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbnN0YW5jZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXMgPSB7fSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBpbnN0YW5jZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICAgIGkrK1xuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgc2VydmVyRGlmZmVyZW5jZXNbZ2V0UHJvcE5hbWVGcm9tQXR0cmlidXRlTmFtZShhdHRyLm5hbWUpXSA9XG4gICAgICAgICAgICBcInN0eWxlXCIgPT09IGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgID8gZ2V0U3R5bGVzT2JqZWN0RnJvbUVsZW1lbnQoaW5zdGFuY2UpXG4gICAgICAgICAgICAgIDogYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiBKU0NvbXBpbGVyX3RlbXBfY29uc3QsIHByb3BzOiBzZXJ2ZXJEaWZmZXJlbmNlcyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDggPT09IGluc3RhbmNlLm5vZGVUeXBlXG4gICAgICAgID8geyB0eXBlOiBcIlN1c3BlbnNlXCIsIHByb3BzOiB7fSB9XG4gICAgICAgIDogaW5zdGFuY2Uubm9kZVZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3ModGV4dEluc3RhbmNlLCB0ZXh0LCBwYXJlbnRQcm9wcykge1xuICAgICAgcmV0dXJuIG51bGwgPT09IHBhcmVudFByb3BzIHx8XG4gICAgICAgICEwICE9PSBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR11cbiAgICAgICAgPyAodGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9PT0gdGV4dFxuICAgICAgICAgICAgPyAodGV4dEluc3RhbmNlID0gbnVsbClcbiAgICAgICAgICAgIDogKCh0ZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHRleHQpKSxcbiAgICAgICAgICAgICAgKHRleHRJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHRleHRJbnN0YW5jZS5ub2RlVmFsdWUpID09PVxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgOiB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlKSksXG4gICAgICAgICAgdGV4dEluc3RhbmNlKVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSkge1xuICAgICAgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlSW5zdGFuY2UubmV4dFNpYmxpbmc7XG4gICAgICBmb3IgKHZhciBkZXB0aCA9IDA7IHN1c3BlbnNlSW5zdGFuY2U7ICkge1xuICAgICAgICBpZiAoOCA9PT0gc3VzcGVuc2VJbnN0YW5jZS5ub2RlVHlwZSkge1xuICAgICAgICAgIHZhciBkYXRhID0gc3VzcGVuc2VJbnN0YW5jZS5kYXRhO1xuICAgICAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuICAgICAgICAgICAgaWYgKDAgPT09IGRlcHRoKVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGUoc3VzcGVuc2VJbnN0YW5jZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKGRhdGEgIT09IFNVU1BFTlNFX1NUQVJUX0RBVEEgJiZcbiAgICAgICAgICAgICAgZGF0YSAhPT0gU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSAmJlxuICAgICAgICAgICAgICBkYXRhICE9PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEpIHx8XG4gICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICAgICAgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlSW5zdGFuY2UubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXRJbnN0YW5jZSkge1xuICAgICAgdGFyZ2V0SW5zdGFuY2UgPSB0YXJnZXRJbnN0YW5jZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICBmb3IgKHZhciBkZXB0aCA9IDA7IHRhcmdldEluc3RhbmNlOyApIHtcbiAgICAgICAgaWYgKDggPT09IHRhcmdldEluc3RhbmNlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0YXJnZXRJbnN0YW5jZS5kYXRhO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGRhdGEgPT09IFNVU1BFTlNFX1NUQVJUX0RBVEEgfHxcbiAgICAgICAgICAgIGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHxcbiAgICAgICAgICAgIGRhdGEgPT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKDAgPT09IGRlcHRoKSByZXR1cm4gdGFyZ2V0SW5zdGFuY2U7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgIH0gZWxzZSBkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSAmJiBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldEluc3RhbmNlID0gdGFyZ2V0SW5zdGFuY2UucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgcmV0cnlJZkJsb2NrZWRPbihjb250YWluZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSkge1xuICAgICAgcmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgICAgaG9zdENvbnRleHQsXG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmdEZXZcbiAgICApIHtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZ0RldiAmJlxuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodHlwZSwgaG9zdENvbnRleHQuYW5jZXN0b3JJbmZvKTtcbiAgICAgIHByb3BzID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICB0eXBlID0gcHJvcHMuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdGVkIGFuIDxodG1sPiBlbGVtZW50IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHRvIGV4aXN0IGluIHRoZSBEb2N1bWVudCBidXQgb25lIHdhcyBub3QgZm91bmQuIFJlYWN0IG5ldmVyIHJlbW92ZXMgdGhlIGRvY3VtZW50RWxlbWVudCBmb3IgYW55IERvY3VtZW50IGl0IHJlbmRlcnMgaW50byBzbyB0aGUgY2F1c2UgaXMgbGlrZWx5IGluIHNvbWUgb3RoZXIgc2NyaXB0IHJ1bm5pbmcgb24gdGhpcyBwYWdlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICAgIHR5cGUgPSBwcm9wcy5oZWFkO1xuICAgICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGV4cGVjdGVkIGEgPGhlYWQ+IGVsZW1lbnQgKGRvY3VtZW50LmhlYWQpIHRvIGV4aXN0IGluIHRoZSBEb2N1bWVudCBidXQgb25lIHdhcyBub3QgZm91bmQuIFJlYWN0IG5ldmVyIHJlbW92ZXMgdGhlIGhlYWQgZm9yIGFueSBEb2N1bWVudCBpdCByZW5kZXJzIGludG8gc28gdGhlIGNhdXNlIGlzIGxpa2VseSBpbiBzb21lIG90aGVyIHNjcmlwdCBydW5uaW5nIG9uIHRoaXMgcGFnZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICB0eXBlID0gcHJvcHMuYm9keTtcbiAgICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBleHBlY3RlZCBhIDxib2R5PiBlbGVtZW50IChkb2N1bWVudC5ib2R5KSB0byBleGlzdCBpbiB0aGUgRG9jdW1lbnQgYnV0IG9uZSB3YXMgbm90IGZvdW5kLiBSZWFjdCBuZXZlciByZW1vdmVzIHRoZSBib2R5IGZvciBhbnkgRG9jdW1lbnQgaXQgcmVuZGVycyBpbnRvIHNvIHRoZSBjYXVzZSBpcyBsaWtlbHkgaW4gc29tZSBvdGhlciBzY3JpcHQgcnVubmluZyBvbiB0aGlzIHBhZ2UuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcInJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSB3YXMgY2FsbGVkIHdpdGggYW4gZWxlbWVudCB0eXBlIHRoYXQgaXMgbm90IHN1cHBvcnRlZC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZVxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICAhaW5zdGFuY2VbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gJiZcbiAgICAgICAgZ2V0SW5zdGFuY2VGcm9tTm9kZShpbnN0YW5jZSlcbiAgICAgICkge1xuICAgICAgICB2YXIgdGFnTmFtZSA9IGluc3RhbmNlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIllvdSBhcmUgbW91bnRpbmcgYSBuZXcgJXMgY29tcG9uZW50IHdoZW4gYSBwcmV2aW91cyBvbmUgaGFzIG5vdCBmaXJzdCB1bm1vdW50ZWQuIEl0IGlzIGFuIGVycm9yIHRvIHJlbmRlciBtb3JlIHRoYW4gb25lICVzIGNvbXBvbmVudCBhdCBhIHRpbWUgYW5kIGF0dHJpYnV0ZXMgYW5kIGNoaWxkcmVuIG9mIHRoZXNlIGNvbXBvbmVudHMgd2lsbCBsaWtlbHkgZmFpbCBpbiB1bnByZWRpY3RhYmxlIHdheXMuIFBsZWFzZSBvbmx5IHJlbmRlciBhIHNpbmdsZSBpbnN0YW5jZSBvZiA8JXM+IGFuZCBpZiB5b3UgbmVlZCB0byBtb3VudCBhIG5ldyBvbmUsIGVuc3VyZSBhbnkgcHJldmlvdXMgb25lcyBoYXZlIHVubW91bnRlZCBmaXJzdC5cIixcbiAgICAgICAgICB0YWdOYW1lLFxuICAgICAgICAgIHRhZ05hbWUsXG4gICAgICAgICAgdGFnTmFtZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlIHdhcyBjYWxsZWQgd2l0aCBhbiBlbGVtZW50IHR5cGUgdGhhdCBpcyBub3Qgc3VwcG9ydGVkLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZvciAodGFnTmFtZSA9IGluc3RhbmNlLmF0dHJpYnV0ZXM7IHRhZ05hbWUubGVuZ3RoOyApXG4gICAgICAgIGluc3RhbmNlLnJlbW92ZUF0dHJpYnV0ZU5vZGUodGFnTmFtZVswXSk7XG4gICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgaW5zdGFuY2VbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBpbnRlcm5hbEluc3RhbmNlSGFuZGxlO1xuICAgICAgaW5zdGFuY2VbaW50ZXJuYWxQcm9wc0tleV0gPSBwcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICBmb3IgKHZhciBhdHRyaWJ1dGVzID0gaW5zdGFuY2UuYXR0cmlidXRlczsgYXR0cmlidXRlcy5sZW5ndGg7IClcbiAgICAgICAgaW5zdGFuY2UucmVtb3ZlQXR0cmlidXRlTm9kZShhdHRyaWJ1dGVzWzBdKTtcbiAgICAgIGRldGFjaERlbGV0ZWRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhvaXN0YWJsZVJvb3QoY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGFpbmVyLmdldFJvb3ROb2RlXG4gICAgICAgID8gY29udGFpbmVyLmdldFJvb3ROb2RlKClcbiAgICAgICAgOiA5ID09PSBjb250YWluZXIubm9kZVR5cGVcbiAgICAgICAgICA/IGNvbnRhaW5lclxuICAgICAgICAgIDogY29udGFpbmVyLm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWNvbm5lY3RBcyhyZWwsIGhyZWYsIGNyb3NzT3JpZ2luKSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICAgICAgaWYgKG93bmVyRG9jdW1lbnQgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikge1xuICAgICAgICB2YXIgbGltaXRlZEVzY2FwZWRIcmVmID1cbiAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGhyZWYpO1xuICAgICAgICBsaW1pdGVkRXNjYXBlZEhyZWYgPVxuICAgICAgICAgICdsaW5rW3JlbD1cIicgKyByZWwgKyAnXCJdW2hyZWY9XCInICsgbGltaXRlZEVzY2FwZWRIcmVmICsgJ1wiXSc7XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjcm9zc09yaWdpbiAmJlxuICAgICAgICAgIChsaW1pdGVkRXNjYXBlZEhyZWYgKz0gJ1tjcm9zc29yaWdpbj1cIicgKyBjcm9zc09yaWdpbiArICdcIl0nKTtcbiAgICAgICAgcHJlY29ubmVjdHNTZXQuaGFzKGxpbWl0ZWRFc2NhcGVkSHJlZikgfHxcbiAgICAgICAgICAocHJlY29ubmVjdHNTZXQuYWRkKGxpbWl0ZWRFc2NhcGVkSHJlZiksXG4gICAgICAgICAgKHJlbCA9IHsgcmVsOiByZWwsIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbiwgaHJlZjogaHJlZiB9KSxcbiAgICAgICAgICBudWxsID09PSBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobGltaXRlZEVzY2FwZWRIcmVmKSAmJlxuICAgICAgICAgICAgKChocmVmID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKSksXG4gICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhocmVmLCBcImxpbmtcIiwgcmVsKSxcbiAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaHJlZiksXG4gICAgICAgICAgICBvd25lckRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoaHJlZikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmVzb3VyY2UodHlwZSwgY3VycmVudFByb3BzLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnRSZXNvdXJjZSkge1xuICAgICAgdmFyIHJlc291cmNlUm9vdCA9IChyZXNvdXJjZVJvb3QgPSByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KVxuICAgICAgICA/IGdldEhvaXN0YWJsZVJvb3QocmVzb3VyY2VSb290KVxuICAgICAgICA6IG51bGw7XG4gICAgICBpZiAoIXJlc291cmNlUm9vdClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ1wicmVzb3VyY2VSb290XCIgd2FzIGV4cGVjdGVkIHRvIGV4aXN0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LidcbiAgICAgICAgKTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwZW5kaW5nUHJvcHMucHJlY2VkZW5jZSAmJlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHBlbmRpbmdQcm9wcy5ocmVmXG4gICAgICAgICAgICA/ICgocGVuZGluZ1Byb3BzID0gZ2V0U3R5bGVLZXkocGVuZGluZ1Byb3BzLmhyZWYpKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRQcm9wcyA9XG4gICAgICAgICAgICAgICAgZ2V0UmVzb3VyY2VzRnJvbVJvb3QocmVzb3VyY2VSb290KS5ob2lzdGFibGVTdHlsZXMpLFxuICAgICAgICAgICAgICAoY3VycmVudFJlc291cmNlID0gY3VycmVudFByb3BzLmdldChwZW5kaW5nUHJvcHMpKSxcbiAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlIHx8XG4gICAgICAgICAgICAgICAgKChjdXJyZW50UmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IG51bGxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvcHMuc2V0KHBlbmRpbmdQcm9wcywgY3VycmVudFJlc291cmNlKSksXG4gICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSlcbiAgICAgICAgICAgIDogeyB0eXBlOiBcInZvaWRcIiwgaW5zdGFuY2U6IG51bGwsIGNvdW50OiAwLCBzdGF0ZTogbnVsbCB9O1xuICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIFwic3R5bGVzaGVldFwiID09PSBwZW5kaW5nUHJvcHMucmVsICYmXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcGVuZGluZ1Byb3BzLmhyZWYgJiZcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwZW5kaW5nUHJvcHMucHJlY2VkZW5jZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHlwZSA9IGdldFN0eWxlS2V5KHBlbmRpbmdQcm9wcy5ocmVmKTtcbiAgICAgICAgICAgIHZhciBfc3R5bGVzID0gZ2V0UmVzb3VyY2VzRnJvbVJvb3QocmVzb3VyY2VSb290KS5ob2lzdGFibGVTdHlsZXMsXG4gICAgICAgICAgICAgIF9yZXNvdXJjZSA9IF9zdHlsZXMuZ2V0KHR5cGUpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhX3Jlc291cmNlICYmXG4gICAgICAgICAgICAgICgocmVzb3VyY2VSb290ID0gcmVzb3VyY2VSb290Lm93bmVyRG9jdW1lbnQgfHwgcmVzb3VyY2VSb290KSxcbiAgICAgICAgICAgICAgKF9yZXNvdXJjZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0eWxlc2hlZXRcIixcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogeyBsb2FkaW5nOiBOb3RMb2FkZWQsIHByZWxvYWQ6IG51bGwgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgX3N0eWxlcy5zZXQodHlwZSwgX3Jlc291cmNlKSxcbiAgICAgICAgICAgICAgKF9zdHlsZXMgPSByZXNvdXJjZVJvb3QucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgICBnZXRTdHlsZXNoZWV0U2VsZWN0b3JGcm9tS2V5KHR5cGUpXG4gICAgICAgICAgICAgICkpICYmXG4gICAgICAgICAgICAgICAgIV9zdHlsZXMuX3AgJiZcbiAgICAgICAgICAgICAgICAoKF9yZXNvdXJjZS5pbnN0YW5jZSA9IF9zdHlsZXMpLFxuICAgICAgICAgICAgICAgIChfcmVzb3VyY2Uuc3RhdGUubG9hZGluZyA9IExvYWRlZCB8IEluc2VydGVkKSksXG4gICAgICAgICAgICAgICFwcmVsb2FkUHJvcHNNYXAuaGFzKHR5cGUpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBwcmVsb2FkUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgICAgICAgICBhczogXCJzdHlsZVwiLFxuICAgICAgICAgICAgICAgIGhyZWY6IHBlbmRpbmdQcm9wcy5ocmVmLFxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBwZW5kaW5nUHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwZW5kaW5nUHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgIG1lZGlhOiBwZW5kaW5nUHJvcHMubWVkaWEsXG4gICAgICAgICAgICAgICAgaHJlZkxhbmc6IHBlbmRpbmdQcm9wcy5ocmVmTGFuZyxcbiAgICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcGVuZGluZ1Byb3BzLnJlZmVycmVyUG9saWN5XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHByZWxvYWRQcm9wc01hcC5zZXQodHlwZSwgcHJlbG9hZFByb3BzKTtcbiAgICAgICAgICAgICAgX3N0eWxlcyB8fFxuICAgICAgICAgICAgICAgIHByZWxvYWRTdHlsZXNoZWV0KFxuICAgICAgICAgICAgICAgICAgcmVzb3VyY2VSb290LFxuICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgIHByZWxvYWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIF9yZXNvdXJjZS5zdGF0ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFByb3BzICYmIG51bGwgPT09IGN1cnJlbnRSZXNvdXJjZSlcbiAgICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAgICgocGVuZGluZ1Byb3BzID1cbiAgICAgICAgICAgICAgICAgIFwiXFxuXFxuICAtIFwiICtcbiAgICAgICAgICAgICAgICAgIGRlc2NyaWJlTGlua0ZvclJlc291cmNlRXJyb3JERVYoY3VycmVudFByb3BzKSArXG4gICAgICAgICAgICAgICAgICBcIlxcbiAgKyBcIiArXG4gICAgICAgICAgICAgICAgICBkZXNjcmliZUxpbmtGb3JSZXNvdXJjZUVycm9yREVWKHBlbmRpbmdQcm9wcykpLFxuICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCA8bGluaz4gbm90IHRvIHVwZGF0ZSB0byBiZSB1cGRhdGVkIHRvIGEgc3R5bGVzaGVldCB3aXRoIHByZWNlZGVuY2UuIENoZWNrIHRoZSBgcmVsYCwgYGhyZWZgLCBhbmQgYHByZWNlZGVuY2VgIHByb3BzIG9mIHRoaXMgY29tcG9uZW50LiBBbHRlcm5hdGl2ZWx5LCBjaGVjayB3aGV0aGVyIHR3byBkaWZmZXJlbnQgPGxpbms+IGNvbXBvbmVudHMgcmVuZGVyIGluIHRoZSBzYW1lIHNsb3Qgb3Igc2hhcmUgdGhlIHNhbWUga2V5LlwiICtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1Byb3BzXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBfcmVzb3VyY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50UHJvcHMgJiYgbnVsbCAhPT0gY3VycmVudFJlc291cmNlKVxuICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAoKHBlbmRpbmdQcm9wcyA9XG4gICAgICAgICAgICAgICAgXCJcXG5cXG4gIC0gXCIgK1xuICAgICAgICAgICAgICAgIGRlc2NyaWJlTGlua0ZvclJlc291cmNlRXJyb3JERVYoY3VycmVudFByb3BzKSArXG4gICAgICAgICAgICAgICAgXCJcXG4gICsgXCIgK1xuICAgICAgICAgICAgICAgIGRlc2NyaWJlTGlua0ZvclJlc291cmNlRXJyb3JERVYocGVuZGluZ1Byb3BzKSksXG4gICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgc3R5bGVzaGVldCB3aXRoIHByZWNlZGVuY2UgdG8gbm90IGJlIHVwZGF0ZWQgdG8gYSBkaWZmZXJlbnQga2luZCBvZiA8bGluaz4uIENoZWNrIHRoZSBgcmVsYCwgYGhyZWZgLCBhbmQgYHByZWNlZGVuY2VgIHByb3BzIG9mIHRoaXMgY29tcG9uZW50LiBBbHRlcm5hdGl2ZWx5LCBjaGVjayB3aGV0aGVyIHR3byBkaWZmZXJlbnQgPGxpbms+IGNvbXBvbmVudHMgcmVuZGVyIGluIHRoZSBzYW1lIHNsb3Qgb3Igc2hhcmUgdGhlIHNhbWUga2V5LlwiICtcbiAgICAgICAgICAgICAgICAgIHBlbmRpbmdQcm9wc1xuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudFByb3BzID0gcGVuZGluZ1Byb3BzLmFzeW5jKSxcbiAgICAgICAgICAgIChwZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHMuc3JjKSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwZW5kaW5nUHJvcHMgJiZcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY3VycmVudFByb3BzICYmXG4gICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgY3VycmVudFByb3BzXG4gICAgICAgICAgICAgID8gKChwZW5kaW5nUHJvcHMgPSBnZXRTY3JpcHRLZXkocGVuZGluZ1Byb3BzKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRQcm9wcyA9XG4gICAgICAgICAgICAgICAgICBnZXRSZXNvdXJjZXNGcm9tUm9vdChyZXNvdXJjZVJvb3QpLmhvaXN0YWJsZVNjcmlwdHMpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50UmVzb3VyY2UgPSBjdXJyZW50UHJvcHMuZ2V0KHBlbmRpbmdQcm9wcykpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSB8fFxuICAgICAgICAgICAgICAgICAgKChjdXJyZW50UmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IG51bGxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BzLnNldChwZW5kaW5nUHJvcHMsIGN1cnJlbnRSZXNvdXJjZSkpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSlcbiAgICAgICAgICAgICAgOiB7IHR5cGU6IFwidm9pZFwiLCBpbnN0YW5jZTogbnVsbCwgY291bnQ6IDAsIHN0YXRlOiBudWxsIH1cbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgJ2dldFJlc291cmNlIGVuY291bnRlcmVkIGEgdHlwZSBpdCBkaWQgbm90IGV4cGVjdDogXCInICtcbiAgICAgICAgICAgICAgdHlwZSArXG4gICAgICAgICAgICAgICdcIi4gdGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVMaW5rRm9yUmVzb3VyY2VFcnJvckRFVihwcm9wcykge1xuICAgICAgdmFyIGRlc2NyaWJlZFByb3BzID0gMCxcbiAgICAgICAgZGVzY3JpcHRpb24gPSBcIjxsaW5rXCI7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMucmVsXG4gICAgICAgID8gKGRlc2NyaWJlZFByb3BzKyssIChkZXNjcmlwdGlvbiArPSAnIHJlbD1cIicgKyBwcm9wcy5yZWwgKyAnXCInKSlcbiAgICAgICAgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBcInJlbFwiKSAmJlxuICAgICAgICAgIChkZXNjcmliZWRQcm9wcysrLFxuICAgICAgICAgIChkZXNjcmlwdGlvbiArPVxuICAgICAgICAgICAgJyByZWw9XCInICtcbiAgICAgICAgICAgIChudWxsID09PSBwcm9wcy5yZWwgPyBcIm51bGxcIiA6IFwiaW52YWxpZCB0eXBlIFwiICsgdHlwZW9mIHByb3BzLnJlbCkgK1xuICAgICAgICAgICAgJ1wiJykpO1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmhyZWZcbiAgICAgICAgPyAoZGVzY3JpYmVkUHJvcHMrKywgKGRlc2NyaXB0aW9uICs9ICcgaHJlZj1cIicgKyBwcm9wcy5ocmVmICsgJ1wiJykpXG4gICAgICAgIDogaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgXCJocmVmXCIpICYmXG4gICAgICAgICAgKGRlc2NyaWJlZFByb3BzKyssXG4gICAgICAgICAgKGRlc2NyaXB0aW9uICs9XG4gICAgICAgICAgICAnIGhyZWY9XCInICtcbiAgICAgICAgICAgIChudWxsID09PSBwcm9wcy5ocmVmXG4gICAgICAgICAgICAgID8gXCJudWxsXCJcbiAgICAgICAgICAgICAgOiBcImludmFsaWQgdHlwZSBcIiArIHR5cGVvZiBwcm9wcy5ocmVmKSArXG4gICAgICAgICAgICAnXCInKSk7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJvcHMucHJlY2VkZW5jZVxuICAgICAgICA/IChkZXNjcmliZWRQcm9wcysrLFxuICAgICAgICAgIChkZXNjcmlwdGlvbiArPSAnIHByZWNlZGVuY2U9XCInICsgcHJvcHMucHJlY2VkZW5jZSArICdcIicpKVxuICAgICAgICA6IGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIFwicHJlY2VkZW5jZVwiKSAmJlxuICAgICAgICAgIChkZXNjcmliZWRQcm9wcysrLFxuICAgICAgICAgIChkZXNjcmlwdGlvbiArPVxuICAgICAgICAgICAgXCIgcHJlY2VkZW5jZT17XCIgK1xuICAgICAgICAgICAgKG51bGwgPT09IHByb3BzLnByZWNlZGVuY2VcbiAgICAgICAgICAgICAgPyBcIm51bGxcIlxuICAgICAgICAgICAgICA6IFwiaW52YWxpZCB0eXBlIFwiICsgdHlwZW9mIHByb3BzLnByZWNlZGVuY2UpICtcbiAgICAgICAgICAgIFwifVwiKSk7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wcykubGVuZ3RoID4gZGVzY3JpYmVkUHJvcHMgJiZcbiAgICAgICAgKGRlc2NyaXB0aW9uICs9IFwiIC4uLlwiKTtcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbiArIFwiIC8+XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0eWxlS2V5KGhyZWYpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICdocmVmPVwiJyArIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoaHJlZikgKyAnXCInXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdHlsZXNoZWV0U2VsZWN0b3JGcm9tS2V5KGtleSkge1xuICAgICAgcmV0dXJuICdsaW5rW3JlbD1cInN0eWxlc2hlZXRcIl1bJyArIGtleSArIFwiXVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZXNoZWV0UHJvcHNGcm9tUmF3UHJvcHMocmF3UHJvcHMpIHtcbiAgICAgIHJldHVybiBhc3NpZ24oe30sIHJhd1Byb3BzLCB7XG4gICAgICAgIFwiZGF0YS1wcmVjZWRlbmNlXCI6IHJhd1Byb3BzLnByZWNlZGVuY2UsXG4gICAgICAgIHByZWNlZGVuY2U6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkU3R5bGVzaGVldChvd25lckRvY3VtZW50LCBrZXksIHByZWxvYWRQcm9wcywgc3RhdGUpIHtcbiAgICAgIG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgJ2xpbmtbcmVsPVwicHJlbG9hZFwiXVthcz1cInN0eWxlXCJdWycgKyBrZXkgKyBcIl1cIlxuICAgICAgKVxuICAgICAgICA/IChzdGF0ZS5sb2FkaW5nID0gTG9hZGVkKVxuICAgICAgICA6ICgoa2V5ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKSksXG4gICAgICAgICAgKHN0YXRlLnByZWxvYWQgPSBrZXkpLFxuICAgICAgICAgIGtleS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHN0YXRlLmxvYWRpbmcgfD0gTG9hZGVkKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBrZXkuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoc3RhdGUubG9hZGluZyB8PSBFcnJvcmVkKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhrZXksIFwibGlua1wiLCBwcmVsb2FkUHJvcHMpLFxuICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoa2V5KSxcbiAgICAgICAgICBvd25lckRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoa2V5KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNjcmlwdEtleShzcmMpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICdbc3JjPVwiJyArIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoc3JjKSArICdcIl0nXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTY3JpcHRTZWxlY3RvckZyb21LZXkoa2V5KSB7XG4gICAgICByZXR1cm4gXCJzY3JpcHRbYXN5bmNdXCIgKyBrZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjcXVpcmVSZXNvdXJjZShob2lzdGFibGVSb290LCByZXNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHJlc291cmNlLmNvdW50Kys7XG4gICAgICBpZiAobnVsbCA9PT0gcmVzb3VyY2UuaW5zdGFuY2UpXG4gICAgICAgIHN3aXRjaCAocmVzb3VyY2UudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAnc3R5bGVbZGF0YS1ocmVmfj1cIicgK1xuICAgICAgICAgICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMocHJvcHMuaHJlZikgK1xuICAgICAgICAgICAgICAgICdcIl0nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChyZXNvdXJjZS5pbnN0YW5jZSA9IGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHN0eWxlUHJvcHMgPSBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgIFwiZGF0YS1ocmVmXCI6IHByb3BzLmhyZWYsXG4gICAgICAgICAgICAgIFwiZGF0YS1wcmVjZWRlbmNlXCI6IHByb3BzLnByZWNlZGVuY2UsXG4gICAgICAgICAgICAgIGhyZWY6IG51bGwsXG4gICAgICAgICAgICAgIHByZWNlZGVuY2U6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5zdGFuY2UgPSAoXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290XG4gICAgICAgICAgICApLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoaW5zdGFuY2UsIFwic3R5bGVcIiwgc3R5bGVQcm9wcyk7XG4gICAgICAgICAgICBpbnNlcnRTdHlsZXNoZWV0KGluc3RhbmNlLCBwcm9wcy5wcmVjZWRlbmNlLCBob2lzdGFibGVSb290KTtcbiAgICAgICAgICAgIHJldHVybiAocmVzb3VyY2UuaW5zdGFuY2UgPSBpbnN0YW5jZSk7XG4gICAgICAgICAgY2FzZSBcInN0eWxlc2hlZXRcIjpcbiAgICAgICAgICAgIHN0eWxlUHJvcHMgPSBnZXRTdHlsZUtleShwcm9wcy5ocmVmKTtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBob2lzdGFibGVSb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoc3R5bGVQcm9wcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nIHw9IEluc2VydGVkKSxcbiAgICAgICAgICAgICAgICAocmVzb3VyY2UuaW5zdGFuY2UgPSBfaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoX2luc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2VcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluc3RhbmNlID0gc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHByb3BzKTtcbiAgICAgICAgICAgIChzdHlsZVByb3BzID0gcHJlbG9hZFByb3BzTWFwLmdldChzdHlsZVByb3BzKSkgJiZcbiAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0KGluc3RhbmNlLCBzdHlsZVByb3BzKTtcbiAgICAgICAgICAgIF9pbnN0YW5jZSA9IChcbiAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5vd25lckRvY3VtZW50IHx8IGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICkuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKF9pbnN0YW5jZSk7XG4gICAgICAgICAgICB2YXIgbGlua0luc3RhbmNlID0gX2luc3RhbmNlO1xuICAgICAgICAgICAgbGlua0luc3RhbmNlLl9wID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICBsaW5rSW5zdGFuY2Uub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgbGlua0luc3RhbmNlLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKF9pbnN0YW5jZSwgXCJsaW5rXCIsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIHJlc291cmNlLnN0YXRlLmxvYWRpbmcgfD0gSW5zZXJ0ZWQ7XG4gICAgICAgICAgICBpbnNlcnRTdHlsZXNoZWV0KF9pbnN0YW5jZSwgcHJvcHMucHJlY2VkZW5jZSwgaG9pc3RhYmxlUm9vdCk7XG4gICAgICAgICAgICByZXR1cm4gKHJlc291cmNlLmluc3RhbmNlID0gX2luc3RhbmNlKTtcbiAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRTY3JpcHRLZXkocHJvcHMuc3JjKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKHN0eWxlUHJvcHMgPSBob2lzdGFibGVSb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgZ2V0U2NyaXB0U2VsZWN0b3JGcm9tS2V5KF9pbnN0YW5jZSlcbiAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAocmVzb3VyY2UuaW5zdGFuY2UgPSBzdHlsZVByb3BzKSxcbiAgICAgICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKHN0eWxlUHJvcHMpLFxuICAgICAgICAgICAgICAgIHN0eWxlUHJvcHNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluc3RhbmNlID0gcHJvcHM7XG4gICAgICAgICAgICBpZiAoKHN0eWxlUHJvcHMgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KF9pbnN0YW5jZSkpKVxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBhc3NpZ24oe30sIHByb3BzKSksXG4gICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTY3JpcHQoaW5zdGFuY2UsIHN0eWxlUHJvcHMpO1xuICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290O1xuICAgICAgICAgICAgc3R5bGVQcm9wcyA9IGhvaXN0YWJsZVJvb3QuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoc3R5bGVQcm9wcyk7XG4gICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhzdHlsZVByb3BzLCBcImxpbmtcIiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIChyZXNvdXJjZS5pbnN0YW5jZSA9IHN0eWxlUHJvcHMpO1xuICAgICAgICAgIGNhc2UgXCJ2b2lkXCI6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICdhY3F1aXJlUmVzb3VyY2UgZW5jb3VudGVyZWQgYSByZXNvdXJjZSB0eXBlIGl0IGRpZCBub3QgZXhwZWN0OiBcIicgK1xuICAgICAgICAgICAgICAgIHJlc291cmNlLnR5cGUgK1xuICAgICAgICAgICAgICAgICdcIi4gdGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIFwic3R5bGVzaGVldFwiID09PSByZXNvdXJjZS50eXBlICYmXG4gICAgICAgICAgKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgJiBJbnNlcnRlZCkgPT09IE5vdExvYWRlZCAmJlxuICAgICAgICAgICgoaW5zdGFuY2UgPSByZXNvdXJjZS5pbnN0YW5jZSksXG4gICAgICAgICAgKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgfD0gSW5zZXJ0ZWQpLFxuICAgICAgICAgIGluc2VydFN0eWxlc2hlZXQoaW5zdGFuY2UsIHByb3BzLnByZWNlZGVuY2UsIGhvaXN0YWJsZVJvb3QpKTtcbiAgICAgIHJldHVybiByZXNvdXJjZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0U3R5bGVzaGVldChpbnN0YW5jZSwgcHJlY2VkZW5jZSwgcm9vdCkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIG5vZGVzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgJ2xpbmtbcmVsPVwic3R5bGVzaGVldFwiXVtkYXRhLXByZWNlZGVuY2VdLHN0eWxlW2RhdGEtcHJlY2VkZW5jZV0nXG4gICAgICAgICAgKSxcbiAgICAgICAgICBsYXN0ID0gbm9kZXMubGVuZ3RoID8gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsLFxuICAgICAgICAgIHByaW9yID0gbGFzdCxcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgaSA8IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgaSsrXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuZGF0YXNldC5wcmVjZWRlbmNlID09PSBwcmVjZWRlbmNlKSBwcmlvciA9IG5vZGU7XG4gICAgICAgIGVsc2UgaWYgKHByaW9yICE9PSBsYXN0KSBicmVhaztcbiAgICAgIH1cbiAgICAgIHByaW9yXG4gICAgICAgID8gcHJpb3IucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zdGFuY2UsIHByaW9yLm5leHRTaWJsaW5nKVxuICAgICAgICA6ICgocHJlY2VkZW5jZSA9IDkgPT09IHJvb3Qubm9kZVR5cGUgPyByb290LmhlYWQgOiByb290KSxcbiAgICAgICAgICBwcmVjZWRlbmNlLmluc2VydEJlZm9yZShpbnN0YW5jZSwgcHJlY2VkZW5jZS5maXJzdENoaWxkKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkb3B0UHJlbG9hZFByb3BzRm9yU3R5bGVzaGVldChzdHlsZXNoZWV0UHJvcHMsIHByZWxvYWRQcm9wcykge1xuICAgICAgbnVsbCA9PSBzdHlsZXNoZWV0UHJvcHMuY3Jvc3NPcmlnaW4gJiZcbiAgICAgICAgKHN0eWxlc2hlZXRQcm9wcy5jcm9zc09yaWdpbiA9IHByZWxvYWRQcm9wcy5jcm9zc09yaWdpbik7XG4gICAgICBudWxsID09IHN0eWxlc2hlZXRQcm9wcy5yZWZlcnJlclBvbGljeSAmJlxuICAgICAgICAoc3R5bGVzaGVldFByb3BzLnJlZmVycmVyUG9saWN5ID0gcHJlbG9hZFByb3BzLnJlZmVycmVyUG9saWN5KTtcbiAgICAgIG51bGwgPT0gc3R5bGVzaGVldFByb3BzLnRpdGxlICYmXG4gICAgICAgIChzdHlsZXNoZWV0UHJvcHMudGl0bGUgPSBwcmVsb2FkUHJvcHMudGl0bGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZG9wdFByZWxvYWRQcm9wc0ZvclNjcmlwdChzY3JpcHRQcm9wcywgcHJlbG9hZFByb3BzKSB7XG4gICAgICBudWxsID09IHNjcmlwdFByb3BzLmNyb3NzT3JpZ2luICYmXG4gICAgICAgIChzY3JpcHRQcm9wcy5jcm9zc09yaWdpbiA9IHByZWxvYWRQcm9wcy5jcm9zc09yaWdpbik7XG4gICAgICBudWxsID09IHNjcmlwdFByb3BzLnJlZmVycmVyUG9saWN5ICYmXG4gICAgICAgIChzY3JpcHRQcm9wcy5yZWZlcnJlclBvbGljeSA9IHByZWxvYWRQcm9wcy5yZWZlcnJlclBvbGljeSk7XG4gICAgICBudWxsID09IHNjcmlwdFByb3BzLmludGVncml0eSAmJlxuICAgICAgICAoc2NyaXB0UHJvcHMuaW50ZWdyaXR5ID0gcHJlbG9hZFByb3BzLmludGVncml0eSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEh5ZHJhdGFibGVIb2lzdGFibGVDYWNoZSh0eXBlLCBrZXlBdHRyaWJ1dGUsIG93bmVyRG9jdW1lbnQpIHtcbiAgICAgIGlmIChudWxsID09PSB0YWdDYWNoZXMpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgY2FjaGVzID0gKHRhZ0NhY2hlcyA9IG5ldyBNYXAoKSk7XG4gICAgICAgIGNhY2hlcy5zZXQob3duZXJEb2N1bWVudCwgY2FjaGUpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIChjYWNoZXMgPSB0YWdDYWNoZXMpLFxuICAgICAgICAgIChjYWNoZSA9IGNhY2hlcy5nZXQob3duZXJEb2N1bWVudCkpLFxuICAgICAgICAgIGNhY2hlIHx8ICgoY2FjaGUgPSBuZXcgTWFwKCkpLCBjYWNoZXMuc2V0KG93bmVyRG9jdW1lbnQsIGNhY2hlKSk7XG4gICAgICBpZiAoY2FjaGUuaGFzKHR5cGUpKSByZXR1cm4gY2FjaGU7XG4gICAgICBjYWNoZS5zZXQodHlwZSwgbnVsbCk7XG4gICAgICBvd25lckRvY3VtZW50ID0gb3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0eXBlKTtcbiAgICAgIGZvciAoY2FjaGVzID0gMDsgY2FjaGVzIDwgb3duZXJEb2N1bWVudC5sZW5ndGg7IGNhY2hlcysrKSB7XG4gICAgICAgIHZhciBub2RlID0gb3duZXJEb2N1bWVudFtjYWNoZXNdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIShcbiAgICAgICAgICAgIG5vZGVbaW50ZXJuYWxIb2lzdGFibGVNYXJrZXJdIHx8XG4gICAgICAgICAgICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldIHx8XG4gICAgICAgICAgICAoXCJsaW5rXCIgPT09IHR5cGUgJiYgXCJzdHlsZXNoZWV0XCIgPT09IG5vZGUuZ2V0QXR0cmlidXRlKFwicmVsXCIpKVxuICAgICAgICAgICkgJiZcbiAgICAgICAgICBub2RlLm5hbWVzcGFjZVVSSSAhPT0gU1ZHX05BTUVTUEFDRVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgbm9kZUtleSA9IG5vZGUuZ2V0QXR0cmlidXRlKGtleUF0dHJpYnV0ZSkgfHwgXCJcIjtcbiAgICAgICAgICBub2RlS2V5ID0gdHlwZSArIG5vZGVLZXk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gY2FjaGUuZ2V0KG5vZGVLZXkpO1xuICAgICAgICAgIGV4aXN0aW5nID8gZXhpc3RpbmcucHVzaChub2RlKSA6IGNhY2hlLnNldChub2RlS2V5LCBbbm9kZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SG9pc3RhYmxlKGhvaXN0YWJsZVJvb3QsIHR5cGUsIGluc3RhbmNlKSB7XG4gICAgICBob2lzdGFibGVSb290ID0gaG9pc3RhYmxlUm9vdC5vd25lckRvY3VtZW50IHx8IGhvaXN0YWJsZVJvb3Q7XG4gICAgICBob2lzdGFibGVSb290LmhlYWQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgXCJ0aXRsZVwiID09PSB0eXBlID8gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFwiaGVhZCA+IHRpdGxlXCIpIDogbnVsbFxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwcm9wcywgaG9zdENvbnRleHQpIHtcbiAgICAgIHZhciBvdXRzaWRlSG9zdENvbnRhaW5lckNvbnRleHQgPVxuICAgICAgICAhaG9zdENvbnRleHQuYW5jZXN0b3JJbmZvLmNvbnRhaW5lclRhZ0luU2NvcGU7XG4gICAgICBpZiAoXG4gICAgICAgIGhvc3RDb250ZXh0LmNvbnRleHQgPT09IEhvc3RDb250ZXh0TmFtZXNwYWNlU3ZnIHx8XG4gICAgICAgIG51bGwgIT0gcHJvcHMuaXRlbVByb3BcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAhb3V0c2lkZUhvc3RDb250YWluZXJDb250ZXh0IHx8XG4gICAgICAgICAgICBudWxsID09IHByb3BzLml0ZW1Qcm9wIHx8XG4gICAgICAgICAgICAoXCJtZXRhXCIgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgXCJ0aXRsZVwiICE9PSB0eXBlICYmXG4gICAgICAgICAgICAgIFwic3R5bGVcIiAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICBcImxpbmtcIiAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICBcInNjcmlwdFwiICE9PSB0eXBlKSB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJDYW5ub3QgcmVuZGVyIGEgPCVzPiBvdXRzaWRlIHRoZSBtYWluIGRvY3VtZW50IGlmIGl0IGhhcyBhbiBgaXRlbVByb3BgIHByb3AuIGBpdGVtUHJvcGAgc3VnZ2VzdHMgdGhlIHRhZyBiZWxvbmdzIHRvIGFuIGBpdGVtU2NvcGVgIHdoaWNoIGNhbiBhcHBlYXIgYW55d2hlcmUgaW4gdGhlIERPTS4gSWYgeW91IHdlcmUgaW50ZW5kaW5nIGZvciBSZWFjdCB0byBob2lzdCB0aGlzIDwlcz4gcmVtb3ZlIHRoZSBgaXRlbVByb3BgIHByb3AuIE90aGVyd2lzZSwgdHJ5IG1vdmluZyB0aGlzIHRhZyBpbnRvIHRoZSA8aGVhZD4gb3IgPGJvZHk+IG9mIHRoZSBEb2N1bWVudC5cIixcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgfHxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcm9wcy5ocmVmIHx8XG4gICAgICAgICAgICBcIlwiID09PSBwcm9wcy5ocmVmXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXRzaWRlSG9zdENvbnRhaW5lckNvbnRleHQgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnQ2Fubm90IHJlbmRlciBhIDxzdHlsZT4gb3V0c2lkZSB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGtub3dpbmcgaXRzIHByZWNlZGVuY2UgYW5kIGEgdW5pcXVlIGhyZWYga2V5LiBSZWFjdCBjYW4gaG9pc3QgYW5kIGRlZHVwbGljYXRlIDxzdHlsZT4gdGFncyBpZiB5b3UgcHJvdmlkZSBhIGBwcmVjZWRlbmNlYCBwcm9wIGFsb25nIHdpdGggYW4gYGhyZWZgIHByb3AgdGhhdCBkb2VzIG5vdCBjb25mbGljdCB3aXRoIHRoZSBgaHJlZmAgdmFsdWVzIHVzZWQgaW4gYW55IG90aGVyIGhvaXN0ZWQgPHN0eWxlPiBvciA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uPiB0YWdzLiAgTm90ZSB0aGF0IGhvaXN0aW5nIDxzdHlsZT4gdGFncyBpcyBjb25zaWRlcmVkIGFuIGFkdmFuY2VkIGZlYXR1cmUgdGhhdCBtb3N0IHdpbGwgbm90IHVzZSBkaXJlY3RseS4gQ29uc2lkZXIgbW92aW5nIHRoZSA8c3R5bGU+IHRhZyB0byB0aGUgPGhlYWQ+IG9yIGNvbnNpZGVyIGFkZGluZyBhIGBwcmVjZWRlbmNlPVwiZGVmYXVsdFwiYCBhbmQgYGhyZWY9XCJzb21lIHVuaXF1ZSByZXNvdXJjZSBpZGVudGlmaWVyXCJgLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnJlbCB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLmhyZWYgfHxcbiAgICAgICAgICAgIFwiXCIgPT09IHByb3BzLmhyZWYgfHxcbiAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgcHJvcHMub25FcnJvclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0eWxlc2hlZXRcIiA9PT0gcHJvcHMucmVsICYmXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcy5wcmVjZWRlbmNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdHlwZSA9IHByb3BzLmhyZWY7XG4gICAgICAgICAgICAgIHZhciBvbkVycm9yID0gcHJvcHMub25FcnJvcixcbiAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkO1xuICAgICAgICAgICAgICBob3N0Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICBwcm9wcy5vbkxvYWQgJiYgaG9zdENvbnRleHQucHVzaChcImBvbkxvYWRgXCIpO1xuICAgICAgICAgICAgICBvbkVycm9yICYmIGhvc3RDb250ZXh0LnB1c2goXCJgb25FcnJvcmBcIik7XG4gICAgICAgICAgICAgIG51bGwgIT0gZGlzYWJsZWQgJiYgaG9zdENvbnRleHQucHVzaChcImBkaXNhYmxlZGBcIik7XG4gICAgICAgICAgICAgIG9uRXJyb3IgPSBwcm9wTmFtZXNMaXN0Sm9pbihob3N0Q29udGV4dCwgXCJhbmRcIik7XG4gICAgICAgICAgICAgIG9uRXJyb3IgKz0gMSA9PT0gaG9zdENvbnRleHQubGVuZ3RoID8gXCIgcHJvcFwiIDogXCIgcHJvcHNcIjtcbiAgICAgICAgICAgICAgZGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgIDEgPT09IGhvc3RDb250ZXh0Lmxlbmd0aCA/IFwiYW4gXCIgKyBvbkVycm9yIDogXCJ0aGUgXCIgKyBvbkVycm9yO1xuICAgICAgICAgICAgICBob3N0Q29udGV4dC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1JlYWN0IGVuY291bnRlcmVkIGEgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCIlc1wiIC4uLiAvPiB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgdGhhdCBhbHNvIGluY2x1ZGVkICVzLiBUaGUgcHJlc2VuY2Ugb2YgbG9hZGluZyBhbmQgZXJyb3IgaGFuZGxlcnMgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgJXMsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsXG4gICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICBvbkVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHNpZGVIb3N0Q29udGFpbmVyQ29udGV4dCAmJlxuICAgICAgICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnJlbCB8fFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMuaHJlZiB8fFxuICAgICAgICAgICAgICBcIlwiID09PSBwcm9wcy5ocmVmXG4gICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkNhbm5vdCByZW5kZXIgYSA8bGluaz4gb3V0c2lkZSB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGEgYHJlbGAgYW5kIGBocmVmYCBwcm9wLiBUcnkgYWRkaW5nIGEgYHJlbGAgYW5kL29yIGBocmVmYCBwcm9wIHRvIHRoaXMgPGxpbms+IG9yIG1vdmluZyB0aGUgbGluayBpbnRvIHRoZSA8aGVhZD4gdGFnXCJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IChwcm9wcy5vbkVycm9yIHx8IHByb3BzLm9uTG9hZCkgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHJlbmRlciBhIDxsaW5rPiB3aXRoIG9uTG9hZCBvciBvbkVycm9yIGxpc3RlbmVycyBvdXRzaWRlIHRoZSBtYWluIGRvY3VtZW50LiBUcnkgcmVtb3Zpbmcgb25Mb2FkPXsuLi59IGFuZCBvbkVycm9yPXsuLi59IG9yIG1vdmluZyBpdCBpbnRvIHRoZSByb290IDxoZWFkPiB0YWcgb3Igc29tZXdoZXJlIGluIHRoZSA8Ym9keT4uXCJcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAocHJvcHMucmVsKSB7XG4gICAgICAgICAgICBjYXNlIFwic3R5bGVzaGVldFwiOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICh0eXBlID0gcHJvcHMucHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgICAgKHByb3BzID0gcHJvcHMuZGlzYWJsZWQpLFxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICAgICAgICBvdXRzaWRlSG9zdENvbnRhaW5lckNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdDYW5ub3QgcmVuZGVyIGEgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC8+IG91dHNpZGUgdGhlIG1haW4gZG9jdW1lbnQgd2l0aG91dCBrbm93aW5nIGl0cyBwcmVjZWRlbmNlLiBDb25zaWRlciBhZGRpbmcgcHJlY2VkZW5jZT1cImRlZmF1bHRcIiBvciBtb3ZpbmcgaXQgaW50byB0aGUgcm9vdCA8aGVhZD4gdGFnLidcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUgJiYgbnVsbCA9PSBwcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgIHR5cGUgPVxuICAgICAgICAgICAgcHJvcHMuYXN5bmMgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb3BzLmFzeW5jICYmXG4gICAgICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgcHJvcHMuYXN5bmM7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXR5cGUgfHxcbiAgICAgICAgICAgIHByb3BzLm9uTG9hZCB8fFxuICAgICAgICAgICAgcHJvcHMub25FcnJvciB8fFxuICAgICAgICAgICAgIXByb3BzLnNyYyB8fFxuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLnNyY1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgb3V0c2lkZUhvc3RDb250YWluZXJDb250ZXh0ICYmXG4gICAgICAgICAgICAgICh0eXBlXG4gICAgICAgICAgICAgICAgPyBwcm9wcy5vbkxvYWQgfHwgcHJvcHMub25FcnJvclxuICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHJlbmRlciBhIDxzY3JpcHQ+IHdpdGggb25Mb2FkIG9yIG9uRXJyb3IgbGlzdGVuZXJzIG91dHNpZGUgdGhlIG1haW4gZG9jdW1lbnQuIFRyeSByZW1vdmluZyBvbkxvYWQ9ey4uLn0gYW5kIG9uRXJyb3I9ey4uLn0gb3IgbW92aW5nIGl0IGludG8gdGhlIHJvb3QgPGhlYWQ+IHRhZyBvciBzb21ld2hlcmUgaW4gdGhlIDxib2R5Pi5cIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJDYW5ub3QgcmVuZGVyIGEgPHNjcmlwdD4gb3V0c2lkZSB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGBhc3luYz17dHJ1ZX1gIGFuZCBhIG5vbi1lbXB0eSBgc3JjYCBwcm9wLiBFbnN1cmUgdGhlcmUgaXMgYSB2YWxpZCBgc3JjYCBhbmQgZWl0aGVyIG1ha2UgdGhlIHNjcmlwdCBhc3luYyBvciBtb3ZlIGl0IGludG8gdGhlIHJvb3QgPGhlYWQ+IHRhZyBvciBzb21ld2hlcmUgaW4gdGhlIDxib2R5Pi5cIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHJlbmRlciBhIHN5bmMgb3IgZGVmZXIgPHNjcmlwdD4gb3V0c2lkZSB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGtub3dpbmcgaXRzIG9yZGVyLiBUcnkgYWRkaW5nIGFzeW5jPVwiXCIgb3IgbW92aW5nIGl0IGludG8gdGhlIHJvb3QgPGhlYWQ+IHRhZy4nXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGNhc2UgXCJub3NjcmlwdFwiOlxuICAgICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgICBvdXRzaWRlSG9zdENvbnRhaW5lckNvbnRleHQgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHJlbmRlciA8JXM+IG91dHNpZGUgdGhlIG1haW4gZG9jdW1lbnQuIFRyeSBtb3ZpbmcgaXQgaW50byB0aGUgcm9vdCA8aGVhZD4gdGFnLlwiLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcInN0eWxlc2hlZXRcIiA9PT0gcmVzb3VyY2UudHlwZSAmJlxuICAgICAgICAocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIFNldHRsZWQpID09PSBOb3RMb2FkZWRcbiAgICAgICAgPyAhMVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICBmdW5jdGlvbiBzdXNwZW5kUmVzb3VyY2UoaG9pc3RhYmxlUm9vdCwgcmVzb3VyY2UsIHByb3BzKSB7XG4gICAgICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkU3RhdGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiSW50ZXJuYWwgUmVhY3QgRXJyb3I6IHN1c3BlbmRlZFN0YXRlIG51bGwgd2hlbiBpdCB3YXMgZXhwZWN0ZWQgdG8gZXhpc3RzLiBQbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBSZWFjdCBidWcuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBzdGF0ZSA9IHN1c3BlbmRlZFN0YXRlO1xuICAgICAgaWYgKFxuICAgICAgICBcInN0eWxlc2hlZXRcIiA9PT0gcmVzb3VyY2UudHlwZSAmJlxuICAgICAgICAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLm1lZGlhIHx8XG4gICAgICAgICAgITEgIT09IG1hdGNoTWVkaWEocHJvcHMubWVkaWEpLm1hdGNoZXMpICYmXG4gICAgICAgIChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nICYgSW5zZXJ0ZWQpID09PSBOb3RMb2FkZWRcbiAgICAgICkge1xuICAgICAgICBpZiAobnVsbCA9PT0gcmVzb3VyY2UuaW5zdGFuY2UpIHtcbiAgICAgICAgICB2YXIga2V5ID0gZ2V0U3R5bGVLZXkocHJvcHMuaHJlZiksXG4gICAgICAgICAgICBpbnN0YW5jZSA9IGhvaXN0YWJsZVJvb3QucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgZ2V0U3R5bGVzaGVldFNlbGVjdG9yRnJvbUtleShrZXkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGluc3RhbmNlLl9wO1xuICAgICAgICAgICAgbnVsbCAhPT0gaG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgaG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBob2lzdGFibGVSb290LnRoZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmNvdW50KyssXG4gICAgICAgICAgICAgIChzdGF0ZSA9IG9uVW5zdXNwZW5kLmJpbmQoc3RhdGUpKSxcbiAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC50aGVuKHN0YXRlLCBzdGF0ZSkpO1xuICAgICAgICAgICAgcmVzb3VyY2Uuc3RhdGUubG9hZGluZyB8PSBJbnNlcnRlZDtcbiAgICAgICAgICAgIHJlc291cmNlLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGluc3RhbmNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdGFuY2UgPSBob2lzdGFibGVSb290Lm93bmVyRG9jdW1lbnQgfHwgaG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICBwcm9wcyA9IHN0eWxlc2hlZXRQcm9wc0Zyb21SYXdQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgKGtleSA9IHByZWxvYWRQcm9wc01hcC5nZXQoa2V5KSkgJiZcbiAgICAgICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU3R5bGVzaGVldChwcm9wcywga2V5KTtcbiAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaW5zdGFuY2UpO1xuICAgICAgICAgIHZhciBsaW5rSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgICBsaW5rSW5zdGFuY2UuX3AgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBsaW5rSW5zdGFuY2Uub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGxpbmtJbnN0YW5jZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGluc3RhbmNlLCBcImxpbmtcIiwgcHJvcHMpO1xuICAgICAgICAgIHJlc291cmNlLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgbnVsbCA9PT0gc3RhdGUuc3R5bGVzaGVldHMgJiYgKHN0YXRlLnN0eWxlc2hlZXRzID0gbmV3IE1hcCgpKTtcbiAgICAgICAgc3RhdGUuc3R5bGVzaGVldHMuc2V0KHJlc291cmNlLCBob2lzdGFibGVSb290KTtcbiAgICAgICAgKGhvaXN0YWJsZVJvb3QgPSByZXNvdXJjZS5zdGF0ZS5wcmVsb2FkKSAmJlxuICAgICAgICAgIChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nICYgU2V0dGxlZCkgPT09IE5vdExvYWRlZCAmJlxuICAgICAgICAgIChzdGF0ZS5jb3VudCsrLFxuICAgICAgICAgIChyZXNvdXJjZSA9IG9uVW5zdXNwZW5kLmJpbmQoc3RhdGUpKSxcbiAgICAgICAgICBob2lzdGFibGVSb290LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlc291cmNlKSxcbiAgICAgICAgICBob2lzdGFibGVSb290LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZXNvdXJjZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5KCkge1xuICAgICAgaWYgKG51bGwgPT09IHN1c3BlbmRlZFN0YXRlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkludGVybmFsIFJlYWN0IEVycm9yOiBzdXNwZW5kZWRTdGF0ZSBudWxsIHdoZW4gaXQgd2FzIGV4cGVjdGVkIHRvIGV4aXN0cy4gUGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgUmVhY3QgYnVnLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgc3RhdGUgPSBzdXNwZW5kZWRTdGF0ZTtcbiAgICAgIHN0YXRlLnN0eWxlc2hlZXRzICYmXG4gICAgICAgIDAgPT09IHN0YXRlLmNvdW50ICYmXG4gICAgICAgIGluc2VydFN1c3BlbmRlZFN0eWxlc2hlZXRzKHN0YXRlLCBzdGF0ZS5zdHlsZXNoZWV0cyk7XG4gICAgICByZXR1cm4gMCA8IHN0YXRlLmNvdW50XG4gICAgICAgID8gZnVuY3Rpb24gKGNvbW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlc2hlZXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzdGF0ZS5zdHlsZXNoZWV0cyAmJlxuICAgICAgICAgICAgICAgIGluc2VydFN1c3BlbmRlZFN0eWxlc2hlZXRzKHN0YXRlLCBzdGF0ZS5zdHlsZXNoZWV0cyk7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS51bnN1c3BlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdW5zdXNwZW5kID0gc3RhdGUudW5zdXNwZW5kO1xuICAgICAgICAgICAgICAgIHN0YXRlLnVuc3VzcGVuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdW5zdXNwZW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDZlNCk7XG4gICAgICAgICAgICBzdGF0ZS51bnN1c3BlbmQgPSBjb21taXQ7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzdGF0ZS51bnN1c3BlbmQgPSBudWxsO1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc3R5bGVzaGVldFRpbWVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVW5zdXNwZW5kKCkge1xuICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgaWYgKDAgPT09IHRoaXMuY291bnQpXG4gICAgICAgIGlmICh0aGlzLnN0eWxlc2hlZXRzKVxuICAgICAgICAgIGluc2VydFN1c3BlbmRlZFN0eWxlc2hlZXRzKHRoaXMsIHRoaXMuc3R5bGVzaGVldHMpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnVuc3VzcGVuZCkge1xuICAgICAgICAgIHZhciB1bnN1c3BlbmQgPSB0aGlzLnVuc3VzcGVuZDtcbiAgICAgICAgICB0aGlzLnVuc3VzcGVuZCA9IG51bGw7XG4gICAgICAgICAgdW5zdXNwZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0U3VzcGVuZGVkU3R5bGVzaGVldHMoc3RhdGUsIHJlc291cmNlcykge1xuICAgICAgc3RhdGUuc3R5bGVzaGVldHMgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gc3RhdGUudW5zdXNwZW5kICYmXG4gICAgICAgIChzdGF0ZS5jb3VudCsrLFxuICAgICAgICAocHJlY2VkZW5jZXNCeVJvb3QgPSBuZXcgTWFwKCkpLFxuICAgICAgICByZXNvdXJjZXMuZm9yRWFjaChpbnNlcnRTdHlsZXNoZWV0SW50b1Jvb3QsIHN0YXRlKSxcbiAgICAgICAgKHByZWNlZGVuY2VzQnlSb290ID0gbnVsbCksXG4gICAgICAgIG9uVW5zdXNwZW5kLmNhbGwoc3RhdGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0U3R5bGVzaGVldEludG9Sb290KHJvb3QsIHJlc291cmNlKSB7XG4gICAgICBpZiAoIShyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nICYgSW5zZXJ0ZWQpKSB7XG4gICAgICAgIHZhciBwcmVjZWRlbmNlcyA9IHByZWNlZGVuY2VzQnlSb290LmdldChyb290KTtcbiAgICAgICAgaWYgKHByZWNlZGVuY2VzKSB2YXIgbGFzdCA9IHByZWNlZGVuY2VzLmdldChMQVNUX1BSRUNFREVOQ0UpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBwcmVjZWRlbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBwcmVjZWRlbmNlc0J5Um9vdC5zZXQocm9vdCwgcHJlY2VkZW5jZXMpO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgXCJsaW5rW2RhdGEtcHJlY2VkZW5jZV0sc3R5bGVbZGF0YS1wcmVjZWRlbmNlXVwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgaSA8IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJMSU5LXCIgPT09IG5vZGUubm9kZU5hbWUgfHxcbiAgICAgICAgICAgICAgXCJub3QgYWxsXCIgIT09IG5vZGUuZ2V0QXR0cmlidXRlKFwibWVkaWFcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcHJlY2VkZW5jZXMuc2V0KG5vZGUuZGF0YXNldC5wcmVjZWRlbmNlLCBub2RlKSwgKGxhc3QgPSBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdCAmJiBwcmVjZWRlbmNlcy5zZXQoTEFTVF9QUkVDRURFTkNFLCBsYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlcyA9IHJlc291cmNlLmluc3RhbmNlO1xuICAgICAgICBub2RlID0gbm9kZXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpO1xuICAgICAgICBpID0gcHJlY2VkZW5jZXMuZ2V0KG5vZGUpIHx8IGxhc3Q7XG4gICAgICAgIGkgPT09IGxhc3QgJiYgcHJlY2VkZW5jZXMuc2V0KExBU1RfUFJFQ0VERU5DRSwgbm9kZXMpO1xuICAgICAgICBwcmVjZWRlbmNlcy5zZXQobm9kZSwgbm9kZXMpO1xuICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIGxhc3QgPSBvblVuc3VzcGVuZC5iaW5kKHRoaXMpO1xuICAgICAgICBub2Rlcy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsYXN0KTtcbiAgICAgICAgbm9kZXMuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGxhc3QpO1xuICAgICAgICBpXG4gICAgICAgICAgPyBpLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVzLCBpLm5leHRTaWJsaW5nKVxuICAgICAgICAgIDogKChyb290ID0gOSA9PT0gcm9vdC5ub2RlVHlwZSA/IHJvb3QuaGVhZCA6IHJvb3QpLFxuICAgICAgICAgICAgcm9vdC5pbnNlcnRCZWZvcmUobm9kZXMsIHJvb3QuZmlyc3RDaGlsZCkpO1xuICAgICAgICByZXNvdXJjZS5zdGF0ZS5sb2FkaW5nIHw9IEluc2VydGVkO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBGaWJlclJvb3ROb2RlKFxuICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgIHRhZyxcbiAgICAgIGh5ZHJhdGUsXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgdGhpcy50YWcgPSAxO1xuICAgICAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgICAgIHRoaXMucGluZ0NhY2hlID0gdGhpcy5jdXJyZW50ID0gdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPSBudWxsO1xuICAgICAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgdGhpcy5jYWxsYmFja05vZGUgPVxuICAgICAgICB0aGlzLm5leHQgPVxuICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0ID1cbiAgICAgICAgdGhpcy5jb250ZXh0ID1cbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nQ29tbWl0ID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy5jYWxsYmFja1ByaW9yaXR5ID0gMDtcbiAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWVzID0gY3JlYXRlTGFuZU1hcCgtMSk7XG4gICAgICB0aGlzLmVudGFuZ2xlZExhbmVzID1cbiAgICAgICAgdGhpcy5zaGVsbFN1c3BlbmRDb3VudGVyID1cbiAgICAgICAgdGhpcy5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyA9XG4gICAgICAgIHRoaXMuZXhwaXJlZExhbmVzID1cbiAgICAgICAgdGhpcy53YXJtTGFuZXMgPVxuICAgICAgICB0aGlzLnBpbmdlZExhbmVzID1cbiAgICAgICAgdGhpcy5zdXNwZW5kZWRMYW5lcyA9XG4gICAgICAgIHRoaXMucGVuZGluZ0xhbmVzID1cbiAgICAgICAgICAwO1xuICAgICAgdGhpcy5lbnRhbmdsZW1lbnRzID0gY3JlYXRlTGFuZU1hcCgwKTtcbiAgICAgIHRoaXMuaGlkZGVuVXBkYXRlcyA9IGNyZWF0ZUxhbmVNYXAobnVsbCk7XG4gICAgICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICAgICAgdGhpcy5vblVuY2F1Z2h0RXJyb3IgPSBvblVuY2F1Z2h0RXJyb3I7XG4gICAgICB0aGlzLm9uQ2F1Z2h0RXJyb3IgPSBvbkNhdWdodEVycm9yO1xuICAgICAgdGhpcy5vblJlY292ZXJhYmxlRXJyb3IgPSBvblJlY292ZXJhYmxlRXJyb3I7XG4gICAgICB0aGlzLnBvb2xlZENhY2hlID0gbnVsbDtcbiAgICAgIHRoaXMucG9vbGVkQ2FjaGVMYW5lcyA9IDA7XG4gICAgICB0aGlzLmZvcm1TdGF0ZSA9IGZvcm1TdGF0ZTtcbiAgICAgIHRoaXMuaW5jb21wbGV0ZVRyYW5zaXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSB0aGlzLmVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICB0aGlzLm1lbW9pemVkVXBkYXRlcnMgPSBuZXcgU2V0KCk7XG4gICAgICBjb250YWluZXJJbmZvID0gdGhpcy5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gW107XG4gICAgICBmb3IgKHRhZyA9IDA7IDMxID4gdGFnOyB0YWcrKykgY29udGFpbmVySW5mby5wdXNoKG5ldyBTZXQoKSk7XG4gICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gaHlkcmF0ZSA/IFwiaHlkcmF0ZVJvb3QoKVwiIDogXCJjcmVhdGVSb290KClcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KFxuICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgIHRhZyxcbiAgICAgIGh5ZHJhdGUsXG4gICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICBpc1N0cmljdE1vZGUsXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIGNvbnRhaW5lckluZm8gPSBuZXcgRmliZXJSb290Tm9kZShcbiAgICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgICAgdGFnLFxuICAgICAgICBoeWRyYXRlLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgICAgZm9ybVN0YXRlXG4gICAgICApO1xuICAgICAgdGFnID0gQ29uY3VycmVudE1vZGU7XG4gICAgICAhMCA9PT0gaXNTdHJpY3RNb2RlICYmICh0YWcgfD0gU3RyaWN0TGVnYWN5TW9kZSB8IFN0cmljdEVmZmVjdHNNb2RlKTtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmICh0YWcgfD0gUHJvZmlsZU1vZGUpO1xuICAgICAgaXNTdHJpY3RNb2RlID0gY3JlYXRlRmliZXIoMywgbnVsbCwgbnVsbCwgdGFnKTtcbiAgICAgIGNvbnRhaW5lckluZm8uY3VycmVudCA9IGlzU3RyaWN0TW9kZTtcbiAgICAgIGlzU3RyaWN0TW9kZS5zdGF0ZU5vZGUgPSBjb250YWluZXJJbmZvO1xuICAgICAgdGFnID0gY3JlYXRlQ2FjaGUoKTtcbiAgICAgIHJldGFpbkNhY2hlKHRhZyk7XG4gICAgICBjb250YWluZXJJbmZvLnBvb2xlZENhY2hlID0gdGFnO1xuICAgICAgcmV0YWluQ2FjaGUodGFnKTtcbiAgICAgIGlzU3RyaWN0TW9kZS5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICBlbGVtZW50OiBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICAgIGlzRGVoeWRyYXRlZDogaHlkcmF0ZSxcbiAgICAgICAgY2FjaGU6IHRhZ1xuICAgICAgfTtcbiAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZShpc1N0cmljdE1vZGUpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lckluZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICBwYXJlbnRDb21wb25lbnQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICByZXR1cm4gcGFyZW50Q29tcG9uZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDb250YWluZXJJbXBsKFxuICAgICAgcm9vdEZpYmVyLFxuICAgICAgbGFuZSxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3RcbiAgICAgIClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELCBjb250YWluZXIsIGVsZW1lbnQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSk7XG4gICAgICBwYXJlbnRDb21wb25lbnQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICAgICAgbnVsbCA9PT0gY29udGFpbmVyLmNvbnRleHRcbiAgICAgICAgPyAoY29udGFpbmVyLmNvbnRleHQgPSBwYXJlbnRDb21wb25lbnQpXG4gICAgICAgIDogKGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpc1JlbmRlcmluZyAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzICYmXG4gICAgICAgICgoZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy5cIixcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpIHx8IFwiVW5rbm93blwiXG4gICAgICAgICkpO1xuICAgICAgY29udGFpbmVyID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgY29udGFpbmVyLnBheWxvYWQgPSB7IGVsZW1lbnQ6IGVsZW1lbnQgfTtcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwID09PSBjYWxsYmFjayA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjayAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICksXG4gICAgICAgIChjb250YWluZXIuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgZWxlbWVudCA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBjb250YWluZXIsIGxhbmUpO1xuICAgICAgbnVsbCAhPT0gZWxlbWVudCAmJlxuICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGVsZW1lbnQsIHJvb3RGaWJlciwgbGFuZSksXG4gICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMoZWxlbWVudCwgcm9vdEZpYmVyLCBsYW5lKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgICAgIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBmaWJlciAmJiBudWxsICE9PSBmaWJlci5kZWh5ZHJhdGVkKSB7XG4gICAgICAgIHZhciBhID0gZmliZXIucmV0cnlMYW5lO1xuICAgICAgICBmaWJlci5yZXRyeUxhbmUgPSAwICE9PSBhICYmIGEgPCByZXRyeUxhbmUgPyBhIDogcmV0cnlMYW5lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKSB7XG4gICAgICBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgICAgIChmaWJlciA9IGZpYmVyLmFsdGVybmF0ZSkgJiYgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGZpYmVyKSB7XG4gICAgICBpZiAoMTMgPT09IGZpYmVyLnRhZykge1xuICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgNjcxMDg4NjQpO1xuICAgICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgNjcxMDg4NjQpO1xuICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgNjcxMDg4NjQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scygpIHtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMYW5lTGFiZWxNYXAoKSB7XG4gICAgICBmb3IgKHZhciBtYXAgPSBuZXcgTWFwKCksIGxhbmUgPSAxLCBpbmRleCA9IDA7IDMxID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGxhYmVsID0gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpO1xuICAgICAgICBtYXAuc2V0KGxhbmUsIGxhYmVsKTtcbiAgICAgICAgbGFuZSAqPSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50KFxuICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG5hdGl2ZUV2ZW50XG4gICAgKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnA7XG4gICAgICB0cnkge1xuICAgICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IERpc2NyZXRlRXZlbnRQcmlvcml0eSksXG4gICAgICAgICAgZGlzcGF0Y2hFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hDb250aW51b3VzRXZlbnQoXG4gICAgICBkb21FdmVudE5hbWUsXG4gICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApIHtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgICAgIHRyeSB7XG4gICAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gQ29udGludW91c0V2ZW50UHJpb3JpdHkpLFxuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBjb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoXG4gICAgICBkb21FdmVudE5hbWUsXG4gICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgdGFyZ2V0Q29udGFpbmVyLFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApIHtcbiAgICAgIGlmIChfZW5hYmxlZCkge1xuICAgICAgICB2YXIgYmxvY2tlZE9uID0gZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChuYXRpdmVFdmVudCk7XG4gICAgICAgIGlmIChudWxsID09PSBibG9ja2VkT24pXG4gICAgICAgICAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKFxuICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgcmV0dXJuX3RhcmdldEluc3QsXG4gICAgICAgICAgICB0YXJnZXRDb250YWluZXJcbiAgICAgICAgICApLFxuICAgICAgICAgICAgY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgcXVldWVJZkNvbnRpbnVvdXNFdmVudChcbiAgICAgICAgICAgIGJsb2NrZWRPbixcbiAgICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgIG5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAoY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSxcbiAgICAgICAgICBldmVudFN5c3RlbUZsYWdzICYgNCAmJlxuICAgICAgICAgICAgLTEgPCBkaXNjcmV0ZVJlcGxheWFibGVFdmVudHMuaW5kZXhPZihkb21FdmVudE5hbWUpKVxuICAgICAgICApIHtcbiAgICAgICAgICBmb3IgKDsgbnVsbCAhPT0gYmxvY2tlZE9uOyApIHtcbiAgICAgICAgICAgIHZhciBmaWJlciA9IGdldEluc3RhbmNlRnJvbU5vZGUoYmxvY2tlZE9uKTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaWJlcilcbiAgICAgICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICBmaWJlciA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIGlmIChmaWJlci5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGZpYmVyLnBlbmRpbmdMYW5lcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwICE9PSBsYW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByb290ID0gZmliZXI7XG4gICAgICAgICAgICAgICAgICAgICAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gMjtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gMjsgbGFuZXM7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSAxIDw8ICgzMSAtIGNsejMyKGxhbmVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290LmVudGFuZ2xlbWVudHNbMV0gfD0gbGFuZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoZmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyQxKCkgKyBSRU5ERVJfVElNRU9VVF9NUyksXG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgKHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpLFxuICAgICAgICAgICAgICAgICAgICBmbHVzaFN5bmNXb3JrJDEoKSxcbiAgICAgICAgICAgICAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWJlciA9IGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgbnVsbCA9PT0gZmliZXIgJiZcbiAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKFxuICAgICAgICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICAgIHJldHVybl90YXJnZXRJbnN0LFxuICAgICAgICAgICAgICAgIHRhcmdldENvbnRhaW5lclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGZpYmVyID09PSBibG9ja2VkT24pIGJyZWFrO1xuICAgICAgICAgICAgYmxvY2tlZE9uID0gZmliZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT09IGJsb2NrZWRPbiAmJiBuYXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKFxuICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRhcmdldENvbnRhaW5lclxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgICAgIG5hdGl2ZUV2ZW50ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICAgICAgcmV0dXJuIGZpbmRJbnN0YW5jZUJsb2NraW5nVGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEluc3RhbmNlQmxvY2tpbmdUYXJnZXQodGFyZ2V0Tm9kZSkge1xuICAgICAgcmV0dXJuX3RhcmdldEluc3QgPSBudWxsO1xuICAgICAgdGFyZ2V0Tm9kZSA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHRhcmdldE5vZGUpO1xuICAgICAgaWYgKG51bGwgIT09IHRhcmdldE5vZGUpIHtcbiAgICAgICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXROb2RlKTtcbiAgICAgICAgaWYgKG51bGwgPT09IG5lYXJlc3RNb3VudGVkKSB0YXJnZXROb2RlID0gbnVsbDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHRhZyA9IG5lYXJlc3RNb3VudGVkLnRhZztcbiAgICAgICAgICBpZiAoMTMgPT09IHRhZykge1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IHRhcmdldE5vZGUpIHJldHVybiB0YXJnZXROb2RlO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmICgzID09PSB0YWcpIHtcbiAgICAgICAgICAgIGlmIChuZWFyZXN0TW91bnRlZC5zdGF0ZU5vZGUuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZClcbiAgICAgICAgICAgICAgcmV0dXJuIDMgPT09IG5lYXJlc3RNb3VudGVkLnRhZ1xuICAgICAgICAgICAgICAgID8gbmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB0YXJnZXROb2RlID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgbmVhcmVzdE1vdW50ZWQgIT09IHRhcmdldE5vZGUgJiYgKHRhcmdldE5vZGUgPSBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuX3RhcmdldEluc3QgPSB0YXJnZXROb2RlO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoZG9tRXZlbnROYW1lKSB7XG4gICAgICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICBjYXNlIFwiYmVmb3JldG9nZ2xlXCI6XG4gICAgICAgIGNhc2UgXCJjYW5jZWxcIjpcbiAgICAgICAgY2FzZSBcImNsaWNrXCI6XG4gICAgICAgIGNhc2UgXCJjbG9zZVwiOlxuICAgICAgICBjYXNlIFwiY29udGV4dG1lbnVcIjpcbiAgICAgICAgY2FzZSBcImNvcHlcIjpcbiAgICAgICAgY2FzZSBcImN1dFwiOlxuICAgICAgICBjYXNlIFwiYXV4Y2xpY2tcIjpcbiAgICAgICAgY2FzZSBcImRibGNsaWNrXCI6XG4gICAgICAgIGNhc2UgXCJkcmFnZW5kXCI6XG4gICAgICAgIGNhc2UgXCJkcmFnc3RhcnRcIjpcbiAgICAgICAgY2FzZSBcImRyb3BcIjpcbiAgICAgICAgY2FzZSBcImZvY3VzaW5cIjpcbiAgICAgICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICBjYXNlIFwiaW52YWxpZFwiOlxuICAgICAgICBjYXNlIFwia2V5ZG93blwiOlxuICAgICAgICBjYXNlIFwia2V5cHJlc3NcIjpcbiAgICAgICAgY2FzZSBcImtleXVwXCI6XG4gICAgICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICAgICAgY2FzZSBcIm1vdXNldXBcIjpcbiAgICAgICAgY2FzZSBcInBhc3RlXCI6XG4gICAgICAgIGNhc2UgXCJwYXVzZVwiOlxuICAgICAgICBjYXNlIFwicGxheVwiOlxuICAgICAgICBjYXNlIFwicG9pbnRlcmNhbmNlbFwiOlxuICAgICAgICBjYXNlIFwicG9pbnRlcmRvd25cIjpcbiAgICAgICAgY2FzZSBcInBvaW50ZXJ1cFwiOlxuICAgICAgICBjYXNlIFwicmF0ZWNoYW5nZVwiOlxuICAgICAgICBjYXNlIFwicmVzZXRcIjpcbiAgICAgICAgY2FzZSBcInJlc2l6ZVwiOlxuICAgICAgICBjYXNlIFwic2Vla2VkXCI6XG4gICAgICAgIGNhc2UgXCJzdWJtaXRcIjpcbiAgICAgICAgY2FzZSBcInRvZ2dsZVwiOlxuICAgICAgICBjYXNlIFwidG91Y2hjYW5jZWxcIjpcbiAgICAgICAgY2FzZSBcInRvdWNoZW5kXCI6XG4gICAgICAgIGNhc2UgXCJ0b3VjaHN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJ2b2x1bWVjaGFuZ2VcIjpcbiAgICAgICAgY2FzZSBcImNoYW5nZVwiOlxuICAgICAgICBjYXNlIFwic2VsZWN0aW9uY2hhbmdlXCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0SW5wdXRcIjpcbiAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9uc3RhcnRcIjpcbiAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6XG4gICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbnVwZGF0ZVwiOlxuICAgICAgICBjYXNlIFwiYmVmb3JlYmx1clwiOlxuICAgICAgICBjYXNlIFwiYWZ0ZXJibHVyXCI6XG4gICAgICAgIGNhc2UgXCJiZWZvcmVpbnB1dFwiOlxuICAgICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICBjYXNlIFwiZnVsbHNjcmVlbmNoYW5nZVwiOlxuICAgICAgICBjYXNlIFwiZm9jdXNcIjpcbiAgICAgICAgY2FzZSBcImhhc2hjaGFuZ2VcIjpcbiAgICAgICAgY2FzZSBcInBvcHN0YXRlXCI6XG4gICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgY2FzZSBcInNlbGVjdHN0YXJ0XCI6XG4gICAgICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICAgICAgY2FzZSBcImRyYWdcIjpcbiAgICAgICAgY2FzZSBcImRyYWdlbnRlclwiOlxuICAgICAgICBjYXNlIFwiZHJhZ2V4aXRcIjpcbiAgICAgICAgY2FzZSBcImRyYWdsZWF2ZVwiOlxuICAgICAgICBjYXNlIFwiZHJhZ292ZXJcIjpcbiAgICAgICAgY2FzZSBcIm1vdXNlbW92ZVwiOlxuICAgICAgICBjYXNlIFwibW91c2VvdXRcIjpcbiAgICAgICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgICAgICBjYXNlIFwicG9pbnRlcm1vdmVcIjpcbiAgICAgICAgY2FzZSBcInBvaW50ZXJvdXRcIjpcbiAgICAgICAgY2FzZSBcInBvaW50ZXJvdmVyXCI6XG4gICAgICAgIGNhc2UgXCJzY3JvbGxcIjpcbiAgICAgICAgY2FzZSBcInRvdWNobW92ZVwiOlxuICAgICAgICBjYXNlIFwid2hlZWxcIjpcbiAgICAgICAgY2FzZSBcIm1vdXNlZW50ZXJcIjpcbiAgICAgICAgY2FzZSBcIm1vdXNlbGVhdmVcIjpcbiAgICAgICAgY2FzZSBcInBvaW50ZXJlbnRlclwiOlxuICAgICAgICBjYXNlIFwicG9pbnRlcmxlYXZlXCI6XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgIHN3aXRjaCAoZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSkge1xuICAgICAgICAgICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICAgICAgICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICAgICAgICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAgICAgICAgIHJldHVybiBDb250aW51b3VzRXZlbnRQcmlvcml0eTtcbiAgICAgICAgICAgIGNhc2UgTm9ybWFsUHJpb3JpdHkkMTpcbiAgICAgICAgICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICAgICAgICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgICAgICAgICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgICAgICAgICByZXR1cm4gSWRsZUV2ZW50UHJpb3JpdHk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICBjYXNlIFwiZm9jdXNpblwiOlxuICAgICAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgICAgICBxdWV1ZWRGb2N1cyA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkcmFnZW50ZXJcIjpcbiAgICAgICAgY2FzZSBcImRyYWdsZWF2ZVwiOlxuICAgICAgICAgIHF1ZXVlZERyYWcgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW91c2VvdmVyXCI6XG4gICAgICAgIGNhc2UgXCJtb3VzZW91dFwiOlxuICAgICAgICAgIHF1ZXVlZE1vdXNlID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBvaW50ZXJvdmVyXCI6XG4gICAgICAgIGNhc2UgXCJwb2ludGVyb3V0XCI6XG4gICAgICAgICAgcXVldWVkUG9pbnRlcnMuZGVsZXRlKG5hdGl2ZUV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOlxuICAgICAgICBjYXNlIFwibG9zdHBvaW50ZXJjYXB0dXJlXCI6XG4gICAgICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmRlbGV0ZShuYXRpdmVFdmVudC5wb2ludGVySWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KFxuICAgICAgZXhpc3RpbmdRdWV1ZWRFdmVudCxcbiAgICAgIGJsb2NrZWRPbixcbiAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBudWxsID09PSBleGlzdGluZ1F1ZXVlZEV2ZW50IHx8XG4gICAgICAgIGV4aXN0aW5nUXVldWVkRXZlbnQubmF0aXZlRXZlbnQgIT09IG5hdGl2ZUV2ZW50XG4gICAgICApXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGV4aXN0aW5nUXVldWVkRXZlbnQgPSB7XG4gICAgICAgICAgICBibG9ja2VkT246IGJsb2NrZWRPbixcbiAgICAgICAgICAgIGRvbUV2ZW50TmFtZTogZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgZXZlbnRTeXN0ZW1GbGFnczogZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgIHRhcmdldENvbnRhaW5lcnM6IFt0YXJnZXRDb250YWluZXJdXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbnVsbCAhPT0gYmxvY2tlZE9uICYmXG4gICAgICAgICAgICAoKGJsb2NrZWRPbiA9IGdldEluc3RhbmNlRnJvbU5vZGUoYmxvY2tlZE9uKSksXG4gICAgICAgICAgICBudWxsICE9PSBibG9ja2VkT24gJiYgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oYmxvY2tlZE9uKSksXG4gICAgICAgICAgZXhpc3RpbmdRdWV1ZWRFdmVudFxuICAgICAgICApO1xuICAgICAgZXhpc3RpbmdRdWV1ZWRFdmVudC5ldmVudFN5c3RlbUZsYWdzIHw9IGV2ZW50U3lzdGVtRmxhZ3M7XG4gICAgICBibG9ja2VkT24gPSBleGlzdGluZ1F1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG4gICAgICBudWxsICE9PSB0YXJnZXRDb250YWluZXIgJiZcbiAgICAgICAgLTEgPT09IGJsb2NrZWRPbi5pbmRleE9mKHRhcmdldENvbnRhaW5lcikgJiZcbiAgICAgICAgYmxvY2tlZE9uLnB1c2godGFyZ2V0Q29udGFpbmVyKTtcbiAgICAgIHJldHVybiBleGlzdGluZ1F1ZXVlZEV2ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZUlmQ29udGludW91c0V2ZW50KFxuICAgICAgYmxvY2tlZE9uLFxuICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgIG5hdGl2ZUV2ZW50XG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICBjYXNlIFwiZm9jdXNpblwiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocXVldWVkRm9jdXMgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KFxuICAgICAgICAgICAgICBxdWV1ZWRGb2N1cyxcbiAgICAgICAgICAgICAgYmxvY2tlZE9uLFxuICAgICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiZHJhZ2VudGVyXCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChxdWV1ZWREcmFnID0gYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChcbiAgICAgICAgICAgICAgcXVldWVkRHJhZyxcbiAgICAgICAgICAgICAgYmxvY2tlZE9uLFxuICAgICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwibW91c2VvdmVyXCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChxdWV1ZWRNb3VzZSA9IGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoXG4gICAgICAgICAgICAgIHF1ZXVlZE1vdXNlLFxuICAgICAgICAgICAgICBibG9ja2VkT24sXG4gICAgICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICAgICAgdGFyZ2V0Q29udGFpbmVyLFxuICAgICAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJwb2ludGVyb3ZlclwiOlxuICAgICAgICAgIHZhciBwb2ludGVySWQgPSBuYXRpdmVFdmVudC5wb2ludGVySWQ7XG4gICAgICAgICAgcXVldWVkUG9pbnRlcnMuc2V0KFxuICAgICAgICAgICAgcG9pbnRlcklkLFxuICAgICAgICAgICAgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChcbiAgICAgICAgICAgICAgcXVldWVkUG9pbnRlcnMuZ2V0KHBvaW50ZXJJZCkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgYmxvY2tlZE9uLFxuICAgICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChwb2ludGVySWQgPSBuYXRpdmVFdmVudC5wb2ludGVySWQpLFxuICAgICAgICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLnNldChcbiAgICAgICAgICAgICAgcG9pbnRlcklkLFxuICAgICAgICAgICAgICBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KFxuICAgICAgICAgICAgICAgIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5nZXQocG9pbnRlcklkKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGJsb2NrZWRPbixcbiAgICAgICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICAgICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHF1ZXVlZFRhcmdldCkge1xuICAgICAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShxdWV1ZWRUYXJnZXQudGFyZ2V0KTtcbiAgICAgIGlmIChudWxsICE9PSB0YXJnZXRJbnN0KSB7XG4gICAgICAgIHZhciBuZWFyZXN0TW91bnRlZCA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIodGFyZ2V0SW5zdCk7XG4gICAgICAgIGlmIChudWxsICE9PSBuZWFyZXN0TW91bnRlZClcbiAgICAgICAgICBpZiAoKCh0YXJnZXRJbnN0ID0gbmVhcmVzdE1vdW50ZWQudGFnKSwgMTMgPT09IHRhcmdldEluc3QpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgodGFyZ2V0SW5zdCA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gdGFyZ2V0SW5zdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICAgICAgcnVuV2l0aFByaW9yaXR5KHF1ZXVlZFRhcmdldC5wcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgxMyA9PT0gbmVhcmVzdE1vdW50ZWQudGFnKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKG5lYXJlc3RNb3VudGVkKTtcbiAgICAgICAgICAgICAgICAgIGxhbmUgPSBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uQnlMYW5lKGxhbmUpO1xuICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoXG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkLFxuICAgICAgICAgICAgICAgICAgICBsYW5lXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgbmVhcmVzdE1vdW50ZWQsIGxhbmUpO1xuICAgICAgICAgICAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQobmVhcmVzdE1vdW50ZWQsIGxhbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgMyA9PT0gdGFyZ2V0SW5zdCAmJlxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPVxuICAgICAgICAgICAgICAzID09PSBuZWFyZXN0TW91bnRlZC50YWdcbiAgICAgICAgICAgICAgICA/IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEV2ZW50KSB7XG4gICAgICBpZiAobnVsbCAhPT0gcXVldWVkRXZlbnQuYmxvY2tlZE9uKSByZXR1cm4gITE7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgdGFyZ2V0Q29udGFpbmVycyA9IHF1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG4gICAgICAgIDAgPCB0YXJnZXRDb250YWluZXJzLmxlbmd0aDtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBuZXh0QmxvY2tlZE9uID0gZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChxdWV1ZWRFdmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgIGlmIChudWxsID09PSBuZXh0QmxvY2tlZE9uKSB7XG4gICAgICAgICAgbmV4dEJsb2NrZWRPbiA9IHF1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgICAgICAgIHZhciBuYXRpdmVFdmVudENsb25lID0gbmV3IG5leHRCbG9ja2VkT24uY29uc3RydWN0b3IoXG4gICAgICAgICAgICAgIG5leHRCbG9ja2VkT24udHlwZSxcbiAgICAgICAgICAgICAgbmV4dEJsb2NrZWRPblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGV2ZW50ID0gbmF0aXZlRXZlbnRDbG9uZTtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50UmVwbGF5aW5nRXZlbnQgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgY3VycmVudGx5IHJlcGxheWluZyBldmVudCB0byBiZSBudWxsLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnRSZXBsYXlpbmdFdmVudCA9IGV2ZW50O1xuICAgICAgICAgIG5leHRCbG9ja2VkT24udGFyZ2V0LmRpc3BhdGNoRXZlbnQobmF0aXZlRXZlbnRDbG9uZSk7XG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudFJlcGxheWluZ0V2ZW50ICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkIGN1cnJlbnRseSByZXBsYXlpbmcgZXZlbnQgdG8gbm90IGJlIG51bGwuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY3VycmVudFJlcGxheWluZ0V2ZW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0YXJnZXRDb250YWluZXJzID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShuZXh0QmxvY2tlZE9uKSksXG4gICAgICAgICAgICBudWxsICE9PSB0YXJnZXRDb250YWluZXJzICYmXG4gICAgICAgICAgICAgIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKHRhcmdldENvbnRhaW5lcnMpLFxuICAgICAgICAgICAgKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG5leHRCbG9ja2VkT24pLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApO1xuICAgICAgICB0YXJnZXRDb250YWluZXJzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcChxdWV1ZWRFdmVudCwga2V5LCBtYXApIHtcbiAgICAgIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpICYmIG1hcC5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5VW5ibG9ja2VkRXZlbnRzKCkge1xuICAgICAgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9ICExO1xuICAgICAgbnVsbCAhPT0gcXVldWVkRm9jdXMgJiZcbiAgICAgICAgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRGb2N1cykgJiZcbiAgICAgICAgKHF1ZXVlZEZvY3VzID0gbnVsbCk7XG4gICAgICBudWxsICE9PSBxdWV1ZWREcmFnICYmXG4gICAgICAgIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRHJhZykgJiZcbiAgICAgICAgKHF1ZXVlZERyYWcgPSBudWxsKTtcbiAgICAgIG51bGwgIT09IHF1ZXVlZE1vdXNlICYmXG4gICAgICAgIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkTW91c2UpICYmXG4gICAgICAgIChxdWV1ZWRNb3VzZSA9IG51bGwpO1xuICAgICAgcXVldWVkUG9pbnRlcnMuZm9yRWFjaChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXApO1xuICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmZvckVhY2goYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEV2ZW50LCB1bmJsb2NrZWQpIHtcbiAgICAgIHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9PT0gdW5ibG9ja2VkICYmXG4gICAgICAgICgocXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbnVsbCksXG4gICAgICAgIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgfHxcbiAgICAgICAgICAoKGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSAhMCksXG4gICAgICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soXG4gICAgICAgICAgICBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgICAgICAgICByZXBsYXlVbmJsb2NrZWRFdmVudHNcbiAgICAgICAgICApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVwbGF5UXVldWVJZk5lZWRlZChmb3JtUmVwbGF5aW5nUXVldWUpIHtcbiAgICAgIGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSAhPT0gZm9ybVJlcGxheWluZ1F1ZXVlICYmXG4gICAgICAgICgobGFzdFNjaGVkdWxlZFJlcGxheVF1ZXVlID0gZm9ybVJlcGxheWluZ1F1ZXVlKSxcbiAgICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soXG4gICAgICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSA9PT0gZm9ybVJlcGxheWluZ1F1ZXVlICYmXG4gICAgICAgICAgICAgIChsYXN0U2NoZWR1bGVkUmVwbGF5UXVldWUgPSBudWxsKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybVJlcGxheWluZ1F1ZXVlLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgIHZhciBmb3JtID0gZm9ybVJlcGxheWluZ1F1ZXVlW2ldLFxuICAgICAgICAgICAgICAgIHN1Ym1pdHRlck9yQWN0aW9uID0gZm9ybVJlcGxheWluZ1F1ZXVlW2kgKyAxXSxcbiAgICAgICAgICAgICAgICBmb3JtRGF0YSA9IGZvcm1SZXBsYXlpbmdRdWV1ZVtpICsgMl07XG4gICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBzdWJtaXR0ZXJPckFjdGlvbilcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBmaW5kSW5zdGFuY2VCbG9ja2luZ1RhcmdldChzdWJtaXR0ZXJPckFjdGlvbiB8fCBmb3JtKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgICAgICAgIHZhciBmb3JtSW5zdCA9IGdldEluc3RhbmNlRnJvbU5vZGUoZm9ybSk7XG4gICAgICAgICAgICAgIG51bGwgIT09IGZvcm1JbnN0ICYmXG4gICAgICAgICAgICAgICAgKGZvcm1SZXBsYXlpbmdRdWV1ZS5zcGxpY2UoaSwgMyksXG4gICAgICAgICAgICAgICAgKGkgLT0gMyksXG4gICAgICAgICAgICAgICAgKGZvcm0gPSB7XG4gICAgICAgICAgICAgICAgICBwZW5kaW5nOiAhMCxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgbWV0aG9kOiBmb3JtLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbjogc3VibWl0dGVyT3JBY3Rpb25cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGZvcm0pLFxuICAgICAgICAgICAgICAgIHN0YXJ0SG9zdFRyYW5zaXRpb24oXG4gICAgICAgICAgICAgICAgICBmb3JtSW5zdCxcbiAgICAgICAgICAgICAgICAgIGZvcm0sXG4gICAgICAgICAgICAgICAgICBzdWJtaXR0ZXJPckFjdGlvbixcbiAgICAgICAgICAgICAgICAgIGZvcm1EYXRhXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlJZkJsb2NrZWRPbih1bmJsb2NrZWQpIHtcbiAgICAgIGZ1bmN0aW9uIHVuYmxvY2socXVldWVkRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCwgdW5ibG9ja2VkKTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IHF1ZXVlZEZvY3VzICYmXG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRGb2N1cywgdW5ibG9ja2VkKTtcbiAgICAgIG51bGwgIT09IHF1ZXVlZERyYWcgJiYgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZERyYWcsIHVuYmxvY2tlZCk7XG4gICAgICBudWxsICE9PSBxdWV1ZWRNb3VzZSAmJlxuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkTW91c2UsIHVuYmxvY2tlZCk7XG4gICAgICBxdWV1ZWRQb2ludGVycy5mb3JFYWNoKHVuYmxvY2spO1xuICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmZvckVhY2godW5ibG9jayk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcXVldWVkVGFyZ2V0ID0gcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzW2ldO1xuICAgICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQgJiYgKHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBudWxsKTtcbiAgICAgIH1cbiAgICAgIGZvciAoXG4gICAgICAgIDtcbiAgICAgICAgMCA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGggJiZcbiAgICAgICAgKChpID0gcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzWzBdKSwgbnVsbCA9PT0gaS5ibG9ja2VkT24pO1xuXG4gICAgICApXG4gICAgICAgIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChpKSxcbiAgICAgICAgICBudWxsID09PSBpLmJsb2NrZWRPbiAmJiBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMuc2hpZnQoKTtcbiAgICAgIGkgPSAodW5ibG9ja2VkLm93bmVyRG9jdW1lbnQgfHwgdW5ibG9ja2VkKS4kJHJlYWN0Rm9ybVJlcGxheTtcbiAgICAgIGlmIChudWxsICE9IGkpXG4gICAgICAgIGZvciAocXVldWVkVGFyZ2V0ID0gMDsgcXVldWVkVGFyZ2V0IDwgaS5sZW5ndGg7IHF1ZXVlZFRhcmdldCArPSAzKSB7XG4gICAgICAgICAgdmFyIGZvcm0gPSBpW3F1ZXVlZFRhcmdldF0sXG4gICAgICAgICAgICBzdWJtaXR0ZXJPckFjdGlvbiA9IGlbcXVldWVkVGFyZ2V0ICsgMV0sXG4gICAgICAgICAgICBmb3JtUHJvcHMgPSBmb3JtW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGw7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHN1Ym1pdHRlck9yQWN0aW9uKVxuICAgICAgICAgICAgZm9ybVByb3BzIHx8IHNjaGVkdWxlUmVwbGF5UXVldWVJZk5lZWRlZChpKTtcbiAgICAgICAgICBlbHNlIGlmIChmb3JtUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzdWJtaXR0ZXJPckFjdGlvbiAmJlxuICAgICAgICAgICAgICBzdWJtaXR0ZXJPckFjdGlvbi5oYXNBdHRyaWJ1dGUoXCJmb3JtQWN0aW9uXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKGZvcm0gPSBzdWJtaXR0ZXJPckFjdGlvbiksXG4gICAgICAgICAgICAgICAgKGZvcm1Qcm9wcyA9IHN1Ym1pdHRlck9yQWN0aW9uW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGwpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gZm9ybVByb3BzLmZvcm1BY3Rpb247XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBmaW5kSW5zdGFuY2VCbG9ja2luZ1RhcmdldChmb3JtKSkgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgYWN0aW9uID0gZm9ybVByb3BzLmFjdGlvbjtcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvblxuICAgICAgICAgICAgICA/IChpW3F1ZXVlZFRhcmdldCArIDFdID0gYWN0aW9uKVxuICAgICAgICAgICAgICA6IChpLnNwbGljZShxdWV1ZWRUYXJnZXQsIDMpLCAocXVldWVkVGFyZ2V0IC09IDMpKTtcbiAgICAgICAgICAgIHNjaGVkdWxlUmVwbGF5UXVldWVJZk5lZWRlZChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RET01Sb290KGludGVybmFsUm9vdCkge1xuICAgICAgdGhpcy5faW50ZXJuYWxSb290ID0gaW50ZXJuYWxSb290O1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdERPTUh5ZHJhdGlvblJvb3QoaW50ZXJuYWxSb290KSB7XG4gICAgICB0aGlzLl9pbnRlcm5hbFJvb3QgPSBpbnRlcm5hbFJvb3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JZlJlYWN0RE9NQ29udGFpbmVySW5ERVYoY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXJbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gJiZcbiAgICAgICAgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBhcmUgY2FsbGluZyBSZWFjdERPTUNsaWVudC5jcmVhdGVSb290KCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSBwYXNzZWQgdG8gUmVhY3RET00ucmVuZGVyKCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJZb3UgYXJlIGNhbGxpbmcgUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpIG9uIGEgY29udGFpbmVyIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBwYXNzZWQgdG8gY3JlYXRlUm9vdCgpIGJlZm9yZS4gSW5zdGVhZCwgY2FsbCByb290LnJlbmRlcigpIG9uIHRoZSBleGlzdGluZyByb290IGluc3RlYWQgaWYgeW91IHdhbnQgdG8gdXBkYXRlIGl0LlwiXG4gICAgICAgICAgICApKTtcbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgU2NoZWR1bGVyID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9zY2hlZHVsZXJcIiksXG4gICAgICBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSZWFjdERPTSA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tXCIpLFxuICAgICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbixcbiAgICAgIFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik7XG4gICAgdmFyIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnRyYWNpbmdfbWFya2VyXCIpO1xuICAgIHZhciBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnZpZXdfdHJhbnNpdGlvblwiKTtcbiAgICB2YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBSZWFjdERPTVNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0RE9NLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIE5vdFBlbmRpbmcgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcGVuZGluZzogITEsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgYWN0aW9uOiBudWxsXG4gICAgICB9KSxcbiAgICAgIHZhbHVlU3RhY2sgPSBbXTtcbiAgICB2YXIgZmliZXJTdGFjayA9IFtdO1xuICAgIHZhciBpbmRleCRqc2NvbXAkMCA9IC0xLFxuICAgICAgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBkaXNhYmxlZERlcHRoID0gMCxcbiAgICAgIHByZXZMb2csXG4gICAgICBwcmV2SW5mbyxcbiAgICAgIHByZXZXYXJuLFxuICAgICAgcHJldkVycm9yLFxuICAgICAgcHJldkdyb3VwLFxuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkLFxuICAgICAgcHJldkdyb3VwRW5kO1xuICAgIGRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIHZhciBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICByZWVudHJ5ID0gITE7XG4gICAgdmFyIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgKFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXBcbiAgICApKCk7XG4gICAgdmFyIGN1cnJlbnQgPSBudWxsLFxuICAgICAgaXNSZW5kZXJpbmcgPSAhMSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMyA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICAgICAgY2FuY2VsQ2FsbGJhY2skMSA9IFNjaGVkdWxlci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxcbiAgICAgIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFxuICAgICAgcmVxdWVzdFBhaW50ID0gU2NoZWR1bGVyLnVuc3RhYmxlX3JlcXVlc3RQYWludCxcbiAgICAgIG5vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgICAgIGdldEN1cnJlbnRQcmlvcml0eUxldmVsID0gU2NoZWR1bGVyLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsLFxuICAgICAgSW1tZWRpYXRlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHksXG4gICAgICBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxcbiAgICAgIE5vcm1hbFByaW9yaXR5JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgICBMb3dQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Mb3dQcmlvcml0eSxcbiAgICAgIElkbGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JZGxlUHJpb3JpdHksXG4gICAgICBsb2ckMSA9IFNjaGVkdWxlci5sb2csXG4gICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSxcbiAgICAgIHJlbmRlcmVySUQgPSBudWxsLFxuICAgICAgaW5qZWN0ZWRIb29rID0gbnVsbCxcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBudWxsLFxuICAgICAgaGFzTG9nZ2VkRXJyb3IgPSAhMSxcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ID0gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyxcbiAgICAgIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrLFxuICAgICAgbG9nID0gTWF0aC5sb2csXG4gICAgICBMTjIgPSBNYXRoLkxOMixcbiAgICAgIG5leHRUcmFuc2l0aW9uTGFuZSA9IDI1NixcbiAgICAgIG5leHRSZXRyeUxhbmUgPSA0MTk0MzA0LFxuICAgICAgRGlzY3JldGVFdmVudFByaW9yaXR5ID0gMixcbiAgICAgIENvbnRpbnVvdXNFdmVudFByaW9yaXR5ID0gOCxcbiAgICAgIERlZmF1bHRFdmVudFByaW9yaXR5ID0gMzIsXG4gICAgICBJZGxlRXZlbnRQcmlvcml0eSA9IDI2ODQzNTQ1NixcbiAgICAgIHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFxuICAgICAgaW50ZXJuYWxJbnN0YW5jZUtleSA9IFwiX19yZWFjdEZpYmVyJFwiICsgcmFuZG9tS2V5LFxuICAgICAgaW50ZXJuYWxQcm9wc0tleSA9IFwiX19yZWFjdFByb3BzJFwiICsgcmFuZG9tS2V5LFxuICAgICAgaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleSA9IFwiX19yZWFjdENvbnRhaW5lciRcIiArIHJhbmRvbUtleSxcbiAgICAgIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9IFwiX19yZWFjdEV2ZW50cyRcIiArIHJhbmRvbUtleSxcbiAgICAgIGludGVybmFsRXZlbnRIYW5kbGVyTGlzdGVuZXJzS2V5ID0gXCJfX3JlYWN0TGlzdGVuZXJzJFwiICsgcmFuZG9tS2V5LFxuICAgICAgaW50ZXJuYWxFdmVudEhhbmRsZXNTZXRLZXkgPSBcIl9fcmVhY3RIYW5kbGVzJFwiICsgcmFuZG9tS2V5LFxuICAgICAgaW50ZXJuYWxSb290Tm9kZVJlc291cmNlc0tleSA9IFwiX19yZWFjdFJlc291cmNlcyRcIiArIHJhbmRvbUtleSxcbiAgICAgIGludGVybmFsSG9pc3RhYmxlTWFya2VyID0gXCJfX3JlYWN0TWFya2VyJFwiICsgcmFuZG9tS2V5LFxuICAgICAgYWxsTmF0aXZlRXZlbnRzID0gbmV3IFNldCgpLFxuICAgICAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9LFxuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IHt9LFxuICAgICAgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICAgICAgYnV0dG9uOiAhMCxcbiAgICAgICAgY2hlY2tib3g6ICEwLFxuICAgICAgICBpbWFnZTogITAsXG4gICAgICAgIGhpZGRlbjogITAsXG4gICAgICAgIHJhZGlvOiAhMCxcbiAgICAgICAgcmVzZXQ6ICEwLFxuICAgICAgICBzdWJtaXQ6ICEwXG4gICAgICB9LFxuICAgICAgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBSZWdFeHAoXG4gICAgICAgIFwiXls6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fSxcbiAgICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9LFxuICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3Rlc1JlZ2V4ID0gL1tcXG5cIlxcXFxdL2csXG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9ICExLFxuICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9ICExLFxuICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSAhMSxcbiAgICAgIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSAhMSxcbiAgICAgIGRpZFdhcm5JbnZhbGlkSW5uZXJIVE1MID0gITE7XG4gICAgdmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9ICExO1xuICAgIHZhciB2YWx1ZVByb3BOYW1lcyA9IFtcInZhbHVlXCIsIFwiZGVmYXVsdFZhbHVlXCJdLFxuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSAhMSxcbiAgICAgIG5lZWRzRXNjYXBpbmcgPSAvW1wiJyY8PlxcblxcdF18Xlxcc3xcXHMkLyxcbiAgICAgIHNwZWNpYWxUYWdzID1cbiAgICAgICAgXCJhZGRyZXNzIGFwcGxldCBhcmVhIGFydGljbGUgYXNpZGUgYmFzZSBiYXNlZm9udCBiZ3NvdW5kIGJsb2NrcXVvdGUgYm9keSBiciBidXR0b24gY2FwdGlvbiBjZW50ZXIgY29sIGNvbGdyb3VwIGRkIGRldGFpbHMgZGlyIGRpdiBkbCBkdCBlbWJlZCBmaWVsZHNldCBmaWdjYXB0aW9uIGZpZ3VyZSBmb290ZXIgZm9ybSBmcmFtZSBmcmFtZXNldCBoMSBoMiBoMyBoNCBoNSBoNiBoZWFkIGhlYWRlciBoZ3JvdXAgaHIgaHRtbCBpZnJhbWUgaW1nIGlucHV0IGlzaW5kZXggbGkgbGluayBsaXN0aW5nIG1haW4gbWFycXVlZSBtZW51IG1lbnVpdGVtIG1ldGEgbmF2IG5vZW1iZWQgbm9mcmFtZXMgbm9zY3JpcHQgb2JqZWN0IG9sIHAgcGFyYW0gcGxhaW50ZXh0IHByZSBzY3JpcHQgc2VjdGlvbiBzZWxlY3Qgc291cmNlIHN0eWxlIHN1bW1hcnkgdGFibGUgdGJvZHkgdGQgdGVtcGxhdGUgdGV4dGFyZWEgdGZvb3QgdGggdGhlYWQgdGl0bGUgdHIgdHJhY2sgdWwgd2JyIHhtcFwiLnNwbGl0KFxuICAgICAgICAgIFwiIFwiXG4gICAgICAgICksXG4gICAgICBpblNjb3BlVGFncyA9XG4gICAgICAgIFwiYXBwbGV0IGNhcHRpb24gaHRtbCB0YWJsZSB0ZCB0aCBtYXJxdWVlIG9iamVjdCB0ZW1wbGF0ZSBmb3JlaWduT2JqZWN0IGRlc2MgdGl0bGVcIi5zcGxpdChcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApLFxuICAgICAgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFtcImJ1dHRvblwiXSksXG4gICAgICBpbXBsaWVkRW5kVGFncyA9IFwiZGQgZHQgbGkgb3B0aW9uIG9wdGdyb3VwIHAgcnAgcnRcIi5zcGxpdChcIiBcIiksXG4gICAgICBlbXB0eUFuY2VzdG9ySW5mb0RldiA9IHtcbiAgICAgICAgY3VycmVudDogbnVsbCxcbiAgICAgICAgZm9ybVRhZzogbnVsbCxcbiAgICAgICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgICAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcbiAgICAgICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICAgICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgICAgIGNvbnRhaW5lclRhZ0luU2NvcGU6IG51bGwsXG4gICAgICAgIGltcGxpY2l0Um9vdFNjb3BlOiAhMVxuICAgICAgfSxcbiAgICAgIGRpZFdhcm4gPSB7fSxcbiAgICAgIHNob3J0aGFuZFRvTG9uZ2hhbmQgPSB7XG4gICAgICAgIGFuaW1hdGlvbjpcbiAgICAgICAgICBcImFuaW1hdGlvbkRlbGF5IGFuaW1hdGlvbkRpcmVjdGlvbiBhbmltYXRpb25EdXJhdGlvbiBhbmltYXRpb25GaWxsTW9kZSBhbmltYXRpb25JdGVyYXRpb25Db3VudCBhbmltYXRpb25OYW1lIGFuaW1hdGlvblBsYXlTdGF0ZSBhbmltYXRpb25UaW1pbmdGdW5jdGlvblwiLnNwbGl0KFxuICAgICAgICAgICAgXCIgXCJcbiAgICAgICAgICApLFxuICAgICAgICBiYWNrZ3JvdW5kOlxuICAgICAgICAgIFwiYmFja2dyb3VuZEF0dGFjaG1lbnQgYmFja2dyb3VuZENsaXAgYmFja2dyb3VuZENvbG9yIGJhY2tncm91bmRJbWFnZSBiYWNrZ3JvdW5kT3JpZ2luIGJhY2tncm91bmRQb3NpdGlvblggYmFja2dyb3VuZFBvc2l0aW9uWSBiYWNrZ3JvdW5kUmVwZWF0IGJhY2tncm91bmRTaXplXCIuc3BsaXQoXG4gICAgICAgICAgICBcIiBcIlxuICAgICAgICAgICksXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogW1wiYmFja2dyb3VuZFBvc2l0aW9uWFwiLCBcImJhY2tncm91bmRQb3NpdGlvbllcIl0sXG4gICAgICAgIGJvcmRlcjpcbiAgICAgICAgICBcImJvcmRlckJvdHRvbUNvbG9yIGJvcmRlckJvdHRvbVN0eWxlIGJvcmRlckJvdHRvbVdpZHRoIGJvcmRlckltYWdlT3V0c2V0IGJvcmRlckltYWdlUmVwZWF0IGJvcmRlckltYWdlU2xpY2UgYm9yZGVySW1hZ2VTb3VyY2UgYm9yZGVySW1hZ2VXaWR0aCBib3JkZXJMZWZ0Q29sb3IgYm9yZGVyTGVmdFN0eWxlIGJvcmRlckxlZnRXaWR0aCBib3JkZXJSaWdodENvbG9yIGJvcmRlclJpZ2h0U3R5bGUgYm9yZGVyUmlnaHRXaWR0aCBib3JkZXJUb3BDb2xvciBib3JkZXJUb3BTdHlsZSBib3JkZXJUb3BXaWR0aFwiLnNwbGl0KFxuICAgICAgICAgICAgXCIgXCJcbiAgICAgICAgICApLFxuICAgICAgICBib3JkZXJCbG9ja0VuZDogW1xuICAgICAgICAgIFwiYm9yZGVyQmxvY2tFbmRDb2xvclwiLFxuICAgICAgICAgIFwiYm9yZGVyQmxvY2tFbmRTdHlsZVwiLFxuICAgICAgICAgIFwiYm9yZGVyQmxvY2tFbmRXaWR0aFwiXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlckJsb2NrU3RhcnQ6IFtcbiAgICAgICAgICBcImJvcmRlckJsb2NrU3RhcnRDb2xvclwiLFxuICAgICAgICAgIFwiYm9yZGVyQmxvY2tTdGFydFN0eWxlXCIsXG4gICAgICAgICAgXCJib3JkZXJCbG9ja1N0YXJ0V2lkdGhcIlxuICAgICAgICBdLFxuICAgICAgICBib3JkZXJCb3R0b206IFtcbiAgICAgICAgICBcImJvcmRlckJvdHRvbUNvbG9yXCIsXG4gICAgICAgICAgXCJib3JkZXJCb3R0b21TdHlsZVwiLFxuICAgICAgICAgIFwiYm9yZGVyQm90dG9tV2lkdGhcIlxuICAgICAgICBdLFxuICAgICAgICBib3JkZXJDb2xvcjogW1xuICAgICAgICAgIFwiYm9yZGVyQm90dG9tQ29sb3JcIixcbiAgICAgICAgICBcImJvcmRlckxlZnRDb2xvclwiLFxuICAgICAgICAgIFwiYm9yZGVyUmlnaHRDb2xvclwiLFxuICAgICAgICAgIFwiYm9yZGVyVG9wQ29sb3JcIlxuICAgICAgICBdLFxuICAgICAgICBib3JkZXJJbWFnZTogW1xuICAgICAgICAgIFwiYm9yZGVySW1hZ2VPdXRzZXRcIixcbiAgICAgICAgICBcImJvcmRlckltYWdlUmVwZWF0XCIsXG4gICAgICAgICAgXCJib3JkZXJJbWFnZVNsaWNlXCIsXG4gICAgICAgICAgXCJib3JkZXJJbWFnZVNvdXJjZVwiLFxuICAgICAgICAgIFwiYm9yZGVySW1hZ2VXaWR0aFwiXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlcklubGluZUVuZDogW1xuICAgICAgICAgIFwiYm9yZGVySW5saW5lRW5kQ29sb3JcIixcbiAgICAgICAgICBcImJvcmRlcklubGluZUVuZFN0eWxlXCIsXG4gICAgICAgICAgXCJib3JkZXJJbmxpbmVFbmRXaWR0aFwiXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlcklubGluZVN0YXJ0OiBbXG4gICAgICAgICAgXCJib3JkZXJJbmxpbmVTdGFydENvbG9yXCIsXG4gICAgICAgICAgXCJib3JkZXJJbmxpbmVTdGFydFN0eWxlXCIsXG4gICAgICAgICAgXCJib3JkZXJJbmxpbmVTdGFydFdpZHRoXCJcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVyTGVmdDogW1wiYm9yZGVyTGVmdENvbG9yXCIsIFwiYm9yZGVyTGVmdFN0eWxlXCIsIFwiYm9yZGVyTGVmdFdpZHRoXCJdLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFtcbiAgICAgICAgICBcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIixcbiAgICAgICAgICBcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXG4gICAgICAgICAgXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXG4gICAgICAgICAgXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlclJpZ2h0OiBbXG4gICAgICAgICAgXCJib3JkZXJSaWdodENvbG9yXCIsXG4gICAgICAgICAgXCJib3JkZXJSaWdodFN0eWxlXCIsXG4gICAgICAgICAgXCJib3JkZXJSaWdodFdpZHRoXCJcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVyU3R5bGU6IFtcbiAgICAgICAgICBcImJvcmRlckJvdHRvbVN0eWxlXCIsXG4gICAgICAgICAgXCJib3JkZXJMZWZ0U3R5bGVcIixcbiAgICAgICAgICBcImJvcmRlclJpZ2h0U3R5bGVcIixcbiAgICAgICAgICBcImJvcmRlclRvcFN0eWxlXCJcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVyVG9wOiBbXCJib3JkZXJUb3BDb2xvclwiLCBcImJvcmRlclRvcFN0eWxlXCIsIFwiYm9yZGVyVG9wV2lkdGhcIl0sXG4gICAgICAgIGJvcmRlcldpZHRoOiBbXG4gICAgICAgICAgXCJib3JkZXJCb3R0b21XaWR0aFwiLFxuICAgICAgICAgIFwiYm9yZGVyTGVmdFdpZHRoXCIsXG4gICAgICAgICAgXCJib3JkZXJSaWdodFdpZHRoXCIsXG4gICAgICAgICAgXCJib3JkZXJUb3BXaWR0aFwiXG4gICAgICAgIF0sXG4gICAgICAgIGNvbHVtblJ1bGU6IFtcImNvbHVtblJ1bGVDb2xvclwiLCBcImNvbHVtblJ1bGVTdHlsZVwiLCBcImNvbHVtblJ1bGVXaWR0aFwiXSxcbiAgICAgICAgY29sdW1uczogW1wiY29sdW1uQ291bnRcIiwgXCJjb2x1bW5XaWR0aFwiXSxcbiAgICAgICAgZmxleDogW1wiZmxleEJhc2lzXCIsIFwiZmxleEdyb3dcIiwgXCJmbGV4U2hyaW5rXCJdLFxuICAgICAgICBmbGV4RmxvdzogW1wiZmxleERpcmVjdGlvblwiLCBcImZsZXhXcmFwXCJdLFxuICAgICAgICBmb250OiBcImZvbnRGYW1pbHkgZm9udEZlYXR1cmVTZXR0aW5ncyBmb250S2VybmluZyBmb250TGFuZ3VhZ2VPdmVycmlkZSBmb250U2l6ZSBmb250U2l6ZUFkanVzdCBmb250U3RyZXRjaCBmb250U3R5bGUgZm9udFZhcmlhbnQgZm9udFZhcmlhbnRBbHRlcm5hdGVzIGZvbnRWYXJpYW50Q2FwcyBmb250VmFyaWFudEVhc3RBc2lhbiBmb250VmFyaWFudExpZ2F0dXJlcyBmb250VmFyaWFudE51bWVyaWMgZm9udFZhcmlhbnRQb3NpdGlvbiBmb250V2VpZ2h0IGxpbmVIZWlnaHRcIi5zcGxpdChcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApLFxuICAgICAgICBmb250VmFyaWFudDpcbiAgICAgICAgICBcImZvbnRWYXJpYW50QWx0ZXJuYXRlcyBmb250VmFyaWFudENhcHMgZm9udFZhcmlhbnRFYXN0QXNpYW4gZm9udFZhcmlhbnRMaWdhdHVyZXMgZm9udFZhcmlhbnROdW1lcmljIGZvbnRWYXJpYW50UG9zaXRpb25cIi5zcGxpdChcbiAgICAgICAgICAgIFwiIFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgZ2FwOiBbXCJjb2x1bW5HYXBcIiwgXCJyb3dHYXBcIl0sXG4gICAgICAgIGdyaWQ6IFwiZ3JpZEF1dG9Db2x1bW5zIGdyaWRBdXRvRmxvdyBncmlkQXV0b1Jvd3MgZ3JpZFRlbXBsYXRlQXJlYXMgZ3JpZFRlbXBsYXRlQ29sdW1ucyBncmlkVGVtcGxhdGVSb3dzXCIuc3BsaXQoXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKSxcbiAgICAgICAgZ3JpZEFyZWE6IFtcbiAgICAgICAgICBcImdyaWRDb2x1bW5FbmRcIixcbiAgICAgICAgICBcImdyaWRDb2x1bW5TdGFydFwiLFxuICAgICAgICAgIFwiZ3JpZFJvd0VuZFwiLFxuICAgICAgICAgIFwiZ3JpZFJvd1N0YXJ0XCJcbiAgICAgICAgXSxcbiAgICAgICAgZ3JpZENvbHVtbjogW1wiZ3JpZENvbHVtbkVuZFwiLCBcImdyaWRDb2x1bW5TdGFydFwiXSxcbiAgICAgICAgZ3JpZENvbHVtbkdhcDogW1wiY29sdW1uR2FwXCJdLFxuICAgICAgICBncmlkR2FwOiBbXCJjb2x1bW5HYXBcIiwgXCJyb3dHYXBcIl0sXG4gICAgICAgIGdyaWRSb3c6IFtcImdyaWRSb3dFbmRcIiwgXCJncmlkUm93U3RhcnRcIl0sXG4gICAgICAgIGdyaWRSb3dHYXA6IFtcInJvd0dhcFwiXSxcbiAgICAgICAgZ3JpZFRlbXBsYXRlOiBbXG4gICAgICAgICAgXCJncmlkVGVtcGxhdGVBcmVhc1wiLFxuICAgICAgICAgIFwiZ3JpZFRlbXBsYXRlQ29sdW1uc1wiLFxuICAgICAgICAgIFwiZ3JpZFRlbXBsYXRlUm93c1wiXG4gICAgICAgIF0sXG4gICAgICAgIGxpc3RTdHlsZTogW1wibGlzdFN0eWxlSW1hZ2VcIiwgXCJsaXN0U3R5bGVQb3NpdGlvblwiLCBcImxpc3RTdHlsZVR5cGVcIl0sXG4gICAgICAgIG1hcmdpbjogW1wibWFyZ2luQm90dG9tXCIsIFwibWFyZ2luTGVmdFwiLCBcIm1hcmdpblJpZ2h0XCIsIFwibWFyZ2luVG9wXCJdLFxuICAgICAgICBtYXJrZXI6IFtcIm1hcmtlckVuZFwiLCBcIm1hcmtlck1pZFwiLCBcIm1hcmtlclN0YXJ0XCJdLFxuICAgICAgICBtYXNrOiBcIm1hc2tDbGlwIG1hc2tDb21wb3NpdGUgbWFza0ltYWdlIG1hc2tNb2RlIG1hc2tPcmlnaW4gbWFza1Bvc2l0aW9uWCBtYXNrUG9zaXRpb25ZIG1hc2tSZXBlYXQgbWFza1NpemVcIi5zcGxpdChcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApLFxuICAgICAgICBtYXNrUG9zaXRpb246IFtcIm1hc2tQb3NpdGlvblhcIiwgXCJtYXNrUG9zaXRpb25ZXCJdLFxuICAgICAgICBvdXRsaW5lOiBbXCJvdXRsaW5lQ29sb3JcIiwgXCJvdXRsaW5lU3R5bGVcIiwgXCJvdXRsaW5lV2lkdGhcIl0sXG4gICAgICAgIG92ZXJmbG93OiBbXCJvdmVyZmxvd1hcIiwgXCJvdmVyZmxvd1lcIl0sXG4gICAgICAgIHBhZGRpbmc6IFtcInBhZGRpbmdCb3R0b21cIiwgXCJwYWRkaW5nTGVmdFwiLCBcInBhZGRpbmdSaWdodFwiLCBcInBhZGRpbmdUb3BcIl0sXG4gICAgICAgIHBsYWNlQ29udGVudDogW1wiYWxpZ25Db250ZW50XCIsIFwianVzdGlmeUNvbnRlbnRcIl0sXG4gICAgICAgIHBsYWNlSXRlbXM6IFtcImFsaWduSXRlbXNcIiwgXCJqdXN0aWZ5SXRlbXNcIl0sXG4gICAgICAgIHBsYWNlU2VsZjogW1wiYWxpZ25TZWxmXCIsIFwianVzdGlmeVNlbGZcIl0sXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBbXG4gICAgICAgICAgXCJ0ZXh0RGVjb3JhdGlvbkNvbG9yXCIsXG4gICAgICAgICAgXCJ0ZXh0RGVjb3JhdGlvbkxpbmVcIixcbiAgICAgICAgICBcInRleHREZWNvcmF0aW9uU3R5bGVcIlxuICAgICAgICBdLFxuICAgICAgICB0ZXh0RW1waGFzaXM6IFtcInRleHRFbXBoYXNpc0NvbG9yXCIsIFwidGV4dEVtcGhhc2lzU3R5bGVcIl0sXG4gICAgICAgIHRyYW5zaXRpb246IFtcbiAgICAgICAgICBcInRyYW5zaXRpb25EZWxheVwiLFxuICAgICAgICAgIFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsXG4gICAgICAgICAgXCJ0cmFuc2l0aW9uUHJvcGVydHlcIixcbiAgICAgICAgICBcInRyYW5zaXRpb25UaW1pbmdGdW5jdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIHdvcmRXcmFwOiBbXCJvdmVyZmxvd1dyYXBcIl1cbiAgICAgIH0sXG4gICAgICB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZyxcbiAgICAgIG1zUGF0dGVybiQxID0gL15tcy0vLFxuICAgICAgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vLFxuICAgICAgbXNQYXR0ZXJuID0gL14tbXMtLyxcbiAgICAgIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nLFxuICAgICAgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC8sXG4gICAgICB3YXJuZWRTdHlsZU5hbWVzID0ge30sXG4gICAgICB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9LFxuICAgICAgd2FybmVkRm9yTmFOVmFsdWUgPSAhMSxcbiAgICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSAhMSxcbiAgICAgIHVuaXRsZXNzTnVtYmVycyA9IG5ldyBTZXQoXG4gICAgICAgIFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgYXNwZWN0UmF0aW8gYm9yZGVySW1hZ2VPdXRzZXQgYm9yZGVySW1hZ2VTbGljZSBib3JkZXJJbWFnZVdpZHRoIGJveEZsZXggYm94RmxleEdyb3VwIGJveE9yZGluYWxHcm91cCBjb2x1bW5Db3VudCBjb2x1bW5zIGZsZXggZmxleEdyb3cgZmxleFBvc2l0aXZlIGZsZXhTaHJpbmsgZmxleE5lZ2F0aXZlIGZsZXhPcmRlciBncmlkQXJlYSBncmlkUm93IGdyaWRSb3dFbmQgZ3JpZFJvd1NwYW4gZ3JpZFJvd1N0YXJ0IGdyaWRDb2x1bW4gZ3JpZENvbHVtbkVuZCBncmlkQ29sdW1uU3BhbiBncmlkQ29sdW1uU3RhcnQgZm9udFdlaWdodCBsaW5lQ2xhbXAgbGluZUhlaWdodCBvcGFjaXR5IG9yZGVyIG9ycGhhbnMgc2NhbGUgdGFiU2l6ZSB3aWRvd3MgekluZGV4IHpvb20gZmlsbE9wYWNpdHkgZmxvb2RPcGFjaXR5IHN0b3BPcGFjaXR5IHN0cm9rZURhc2hhcnJheSBzdHJva2VEYXNob2Zmc2V0IHN0cm9rZU1pdGVybGltaXQgc3Ryb2tlT3BhY2l0eSBzdHJva2VXaWR0aCBNb3pBbmltYXRpb25JdGVyYXRpb25Db3VudCBNb3pCb3hGbGV4IE1vekJveEZsZXhHcm91cCBNb3pMaW5lQ2xhbXAgbXNBbmltYXRpb25JdGVyYXRpb25Db3VudCBtc0ZsZXggbXNab29tIG1zRmxleEdyb3cgbXNGbGV4TmVnYXRpdmUgbXNGbGV4T3JkZXIgbXNGbGV4UG9zaXRpdmUgbXNGbGV4U2hyaW5rIG1zR3JpZENvbHVtbiBtc0dyaWRDb2x1bW5TcGFuIG1zR3JpZFJvdyBtc0dyaWRSb3dTcGFuIFdlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IFdlYmtpdEJveEZsZXggV2ViS2l0Qm94RmxleEdyb3VwIFdlYmtpdEJveE9yZGluYWxHcm91cCBXZWJraXRDb2x1bW5Db3VudCBXZWJraXRDb2x1bW5zIFdlYmtpdEZsZXggV2Via2l0RmxleEdyb3cgV2Via2l0RmxleFBvc2l0aXZlIFdlYmtpdEZsZXhTaHJpbmsgV2Via2l0TGluZUNsYW1wXCIuc3BsaXQoXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIE1BVEhfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsXG4gICAgICBTVkdfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgYWxpYXNlcyA9IG5ldyBNYXAoW1xuICAgICAgICBbXCJhY2NlcHRDaGFyc2V0XCIsIFwiYWNjZXB0LWNoYXJzZXRcIl0sXG4gICAgICAgIFtcImh0bWxGb3JcIiwgXCJmb3JcIl0sXG4gICAgICAgIFtcImh0dHBFcXVpdlwiLCBcImh0dHAtZXF1aXZcIl0sXG4gICAgICAgIFtcImNyb3NzT3JpZ2luXCIsIFwiY3Jvc3NvcmlnaW5cIl0sXG4gICAgICAgIFtcImFjY2VudEhlaWdodFwiLCBcImFjY2VudC1oZWlnaHRcIl0sXG4gICAgICAgIFtcImFsaWdubWVudEJhc2VsaW5lXCIsIFwiYWxpZ25tZW50LWJhc2VsaW5lXCJdLFxuICAgICAgICBbXCJhcmFiaWNGb3JtXCIsIFwiYXJhYmljLWZvcm1cIl0sXG4gICAgICAgIFtcImJhc2VsaW5lU2hpZnRcIiwgXCJiYXNlbGluZS1zaGlmdFwiXSxcbiAgICAgICAgW1wiY2FwSGVpZ2h0XCIsIFwiY2FwLWhlaWdodFwiXSxcbiAgICAgICAgW1wiY2xpcFBhdGhcIiwgXCJjbGlwLXBhdGhcIl0sXG4gICAgICAgIFtcImNsaXBSdWxlXCIsIFwiY2xpcC1ydWxlXCJdLFxuICAgICAgICBbXCJjb2xvckludGVycG9sYXRpb25cIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCJdLFxuICAgICAgICBbXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCJdLFxuICAgICAgICBbXCJjb2xvclByb2ZpbGVcIiwgXCJjb2xvci1wcm9maWxlXCJdLFxuICAgICAgICBbXCJjb2xvclJlbmRlcmluZ1wiLCBcImNvbG9yLXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1wiZG9taW5hbnRCYXNlbGluZVwiLCBcImRvbWluYW50LWJhc2VsaW5lXCJdLFxuICAgICAgICBbXCJlbmFibGVCYWNrZ3JvdW5kXCIsIFwiZW5hYmxlLWJhY2tncm91bmRcIl0sXG4gICAgICAgIFtcImZpbGxPcGFjaXR5XCIsIFwiZmlsbC1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJmaWxsUnVsZVwiLCBcImZpbGwtcnVsZVwiXSxcbiAgICAgICAgW1wiZmxvb2RDb2xvclwiLCBcImZsb29kLWNvbG9yXCJdLFxuICAgICAgICBbXCJmbG9vZE9wYWNpdHlcIiwgXCJmbG9vZC1vcGFjaXR5XCJdLFxuICAgICAgICBbXCJmb250RmFtaWx5XCIsIFwiZm9udC1mYW1pbHlcIl0sXG4gICAgICAgIFtcImZvbnRTaXplXCIsIFwiZm9udC1zaXplXCJdLFxuICAgICAgICBbXCJmb250U2l6ZUFkanVzdFwiLCBcImZvbnQtc2l6ZS1hZGp1c3RcIl0sXG4gICAgICAgIFtcImZvbnRTdHJldGNoXCIsIFwiZm9udC1zdHJldGNoXCJdLFxuICAgICAgICBbXCJmb250U3R5bGVcIiwgXCJmb250LXN0eWxlXCJdLFxuICAgICAgICBbXCJmb250VmFyaWFudFwiLCBcImZvbnQtdmFyaWFudFwiXSxcbiAgICAgICAgW1wiZm9udFdlaWdodFwiLCBcImZvbnQtd2VpZ2h0XCJdLFxuICAgICAgICBbXCJnbHlwaE5hbWVcIiwgXCJnbHlwaC1uYW1lXCJdLFxuICAgICAgICBbXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIl0sXG4gICAgICAgIFtcImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCJdLFxuICAgICAgICBbXCJob3JpekFkdlhcIiwgXCJob3Jpei1hZHYteFwiXSxcbiAgICAgICAgW1wiaG9yaXpPcmlnaW5YXCIsIFwiaG9yaXotb3JpZ2luLXhcIl0sXG4gICAgICAgIFtcImltYWdlUmVuZGVyaW5nXCIsIFwiaW1hZ2UtcmVuZGVyaW5nXCJdLFxuICAgICAgICBbXCJsZXR0ZXJTcGFjaW5nXCIsIFwibGV0dGVyLXNwYWNpbmdcIl0sXG4gICAgICAgIFtcImxpZ2h0aW5nQ29sb3JcIiwgXCJsaWdodGluZy1jb2xvclwiXSxcbiAgICAgICAgW1wibWFya2VyRW5kXCIsIFwibWFya2VyLWVuZFwiXSxcbiAgICAgICAgW1wibWFya2VyTWlkXCIsIFwibWFya2VyLW1pZFwiXSxcbiAgICAgICAgW1wibWFya2VyU3RhcnRcIiwgXCJtYXJrZXItc3RhcnRcIl0sXG4gICAgICAgIFtcIm92ZXJsaW5lUG9zaXRpb25cIiwgXCJvdmVybGluZS1wb3NpdGlvblwiXSxcbiAgICAgICAgW1wib3ZlcmxpbmVUaGlja25lc3NcIiwgXCJvdmVybGluZS10aGlja25lc3NcIl0sXG4gICAgICAgIFtcInBhaW50T3JkZXJcIiwgXCJwYWludC1vcmRlclwiXSxcbiAgICAgICAgW1wicGFub3NlLTFcIiwgXCJwYW5vc2UtMVwiXSxcbiAgICAgICAgW1wicG9pbnRlckV2ZW50c1wiLCBcInBvaW50ZXItZXZlbnRzXCJdLFxuICAgICAgICBbXCJyZW5kZXJpbmdJbnRlbnRcIiwgXCJyZW5kZXJpbmctaW50ZW50XCJdLFxuICAgICAgICBbXCJzaGFwZVJlbmRlcmluZ1wiLCBcInNoYXBlLXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1wic3RvcENvbG9yXCIsIFwic3RvcC1jb2xvclwiXSxcbiAgICAgICAgW1wic3RvcE9wYWNpdHlcIiwgXCJzdG9wLW9wYWNpdHlcIl0sXG4gICAgICAgIFtcInN0cmlrZXRocm91Z2hQb3NpdGlvblwiLCBcInN0cmlrZXRocm91Z2gtcG9zaXRpb25cIl0sXG4gICAgICAgIFtcInN0cmlrZXRocm91Z2hUaGlja25lc3NcIiwgXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiXSxcbiAgICAgICAgW1wic3Ryb2tlRGFzaGFycmF5XCIsIFwic3Ryb2tlLWRhc2hhcnJheVwiXSxcbiAgICAgICAgW1wic3Ryb2tlRGFzaG9mZnNldFwiLCBcInN0cm9rZS1kYXNob2Zmc2V0XCJdLFxuICAgICAgICBbXCJzdHJva2VMaW5lY2FwXCIsIFwic3Ryb2tlLWxpbmVjYXBcIl0sXG4gICAgICAgIFtcInN0cm9rZUxpbmVqb2luXCIsIFwic3Ryb2tlLWxpbmVqb2luXCJdLFxuICAgICAgICBbXCJzdHJva2VNaXRlcmxpbWl0XCIsIFwic3Ryb2tlLW1pdGVybGltaXRcIl0sXG4gICAgICAgIFtcInN0cm9rZU9wYWNpdHlcIiwgXCJzdHJva2Utb3BhY2l0eVwiXSxcbiAgICAgICAgW1wic3Ryb2tlV2lkdGhcIiwgXCJzdHJva2Utd2lkdGhcIl0sXG4gICAgICAgIFtcInRleHRBbmNob3JcIiwgXCJ0ZXh0LWFuY2hvclwiXSxcbiAgICAgICAgW1widGV4dERlY29yYXRpb25cIiwgXCJ0ZXh0LWRlY29yYXRpb25cIl0sXG4gICAgICAgIFtcInRleHRSZW5kZXJpbmdcIiwgXCJ0ZXh0LXJlbmRlcmluZ1wiXSxcbiAgICAgICAgW1widHJhbnNmb3JtT3JpZ2luXCIsIFwidHJhbnNmb3JtLW9yaWdpblwiXSxcbiAgICAgICAgW1widW5kZXJsaW5lUG9zaXRpb25cIiwgXCJ1bmRlcmxpbmUtcG9zaXRpb25cIl0sXG4gICAgICAgIFtcInVuZGVybGluZVRoaWNrbmVzc1wiLCBcInVuZGVybGluZS10aGlja25lc3NcIl0sXG4gICAgICAgIFtcInVuaWNvZGVCaWRpXCIsIFwidW5pY29kZS1iaWRpXCJdLFxuICAgICAgICBbXCJ1bmljb2RlUmFuZ2VcIiwgXCJ1bmljb2RlLXJhbmdlXCJdLFxuICAgICAgICBbXCJ1bml0c1BlckVtXCIsIFwidW5pdHMtcGVyLWVtXCJdLFxuICAgICAgICBbXCJ2QWxwaGFiZXRpY1wiLCBcInYtYWxwaGFiZXRpY1wiXSxcbiAgICAgICAgW1widkhhbmdpbmdcIiwgXCJ2LWhhbmdpbmdcIl0sXG4gICAgICAgIFtcInZJZGVvZ3JhcGhpY1wiLCBcInYtaWRlb2dyYXBoaWNcIl0sXG4gICAgICAgIFtcInZNYXRoZW1hdGljYWxcIiwgXCJ2LW1hdGhlbWF0aWNhbFwiXSxcbiAgICAgICAgW1widmVjdG9yRWZmZWN0XCIsIFwidmVjdG9yLWVmZmVjdFwiXSxcbiAgICAgICAgW1widmVydEFkdllcIiwgXCJ2ZXJ0LWFkdi15XCJdLFxuICAgICAgICBbXCJ2ZXJ0T3JpZ2luWFwiLCBcInZlcnQtb3JpZ2luLXhcIl0sXG4gICAgICAgIFtcInZlcnRPcmlnaW5ZXCIsIFwidmVydC1vcmlnaW4teVwiXSxcbiAgICAgICAgW1wid29yZFNwYWNpbmdcIiwgXCJ3b3JkLXNwYWNpbmdcIl0sXG4gICAgICAgIFtcIndyaXRpbmdNb2RlXCIsIFwid3JpdGluZy1tb2RlXCJdLFxuICAgICAgICBbXCJ4bWxuc1hsaW5rXCIsIFwieG1sbnM6eGxpbmtcIl0sXG4gICAgICAgIFtcInhIZWlnaHRcIiwgXCJ4LWhlaWdodFwiXVxuICAgICAgXSksXG4gICAgICBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gICAgICAgIGFjY2VwdDogXCJhY2NlcHRcIixcbiAgICAgICAgYWNjZXB0Y2hhcnNldDogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIFwiYWNjZXB0LWNoYXJzZXRcIjogXCJhY2NlcHRDaGFyc2V0XCIsXG4gICAgICAgIGFjY2Vzc2tleTogXCJhY2Nlc3NLZXlcIixcbiAgICAgICAgYWN0aW9uOiBcImFjdGlvblwiLFxuICAgICAgICBhbGxvd2Z1bGxzY3JlZW46IFwiYWxsb3dGdWxsU2NyZWVuXCIsXG4gICAgICAgIGFsdDogXCJhbHRcIixcbiAgICAgICAgYXM6IFwiYXNcIixcbiAgICAgICAgYXN5bmM6IFwiYXN5bmNcIixcbiAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwiYXV0b0NhcGl0YWxpemVcIixcbiAgICAgICAgYXV0b2NvbXBsZXRlOiBcImF1dG9Db21wbGV0ZVwiLFxuICAgICAgICBhdXRvY29ycmVjdDogXCJhdXRvQ29ycmVjdFwiLFxuICAgICAgICBhdXRvZm9jdXM6IFwiYXV0b0ZvY3VzXCIsXG4gICAgICAgIGF1dG9wbGF5OiBcImF1dG9QbGF5XCIsXG4gICAgICAgIGF1dG9zYXZlOiBcImF1dG9TYXZlXCIsXG4gICAgICAgIGNhcHR1cmU6IFwiY2FwdHVyZVwiLFxuICAgICAgICBjZWxscGFkZGluZzogXCJjZWxsUGFkZGluZ1wiLFxuICAgICAgICBjZWxsc3BhY2luZzogXCJjZWxsU3BhY2luZ1wiLFxuICAgICAgICBjaGFsbGVuZ2U6IFwiY2hhbGxlbmdlXCIsXG4gICAgICAgIGNoYXJzZXQ6IFwiY2hhclNldFwiLFxuICAgICAgICBjaGVja2VkOiBcImNoZWNrZWRcIixcbiAgICAgICAgY2hpbGRyZW46IFwiY2hpbGRyZW5cIixcbiAgICAgICAgY2l0ZTogXCJjaXRlXCIsXG4gICAgICAgIGNsYXNzOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjbGFzc2lkOiBcImNsYXNzSURcIixcbiAgICAgICAgY2xhc3NuYW1lOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBjb2xzOiBcImNvbHNcIixcbiAgICAgICAgY29sc3BhbjogXCJjb2xTcGFuXCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiY29udGVudFwiLFxuICAgICAgICBjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCIsXG4gICAgICAgIGNvbnRleHRtZW51OiBcImNvbnRleHRNZW51XCIsXG4gICAgICAgIGNvbnRyb2xzOiBcImNvbnRyb2xzXCIsXG4gICAgICAgIGNvbnRyb2xzbGlzdDogXCJjb250cm9sc0xpc3RcIixcbiAgICAgICAgY29vcmRzOiBcImNvb3Jkc1wiLFxuICAgICAgICBjcm9zc29yaWdpbjogXCJjcm9zc09yaWdpblwiLFxuICAgICAgICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiLFxuICAgICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgICAgZGF0ZXRpbWU6IFwiZGF0ZVRpbWVcIixcbiAgICAgICAgZGVmYXVsdDogXCJkZWZhdWx0XCIsXG4gICAgICAgIGRlZmF1bHRjaGVja2VkOiBcImRlZmF1bHRDaGVja2VkXCIsXG4gICAgICAgIGRlZmF1bHR2YWx1ZTogXCJkZWZhdWx0VmFsdWVcIixcbiAgICAgICAgZGVmZXI6IFwiZGVmZXJcIixcbiAgICAgICAgZGlyOiBcImRpclwiLFxuICAgICAgICBkaXNhYmxlZDogXCJkaXNhYmxlZFwiLFxuICAgICAgICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogXCJkaXNhYmxlUGljdHVyZUluUGljdHVyZVwiLFxuICAgICAgICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6IFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCIsXG4gICAgICAgIGRvd25sb2FkOiBcImRvd25sb2FkXCIsXG4gICAgICAgIGRyYWdnYWJsZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgZW5jdHlwZTogXCJlbmNUeXBlXCIsXG4gICAgICAgIGVudGVya2V5aGludDogXCJlbnRlcktleUhpbnRcIixcbiAgICAgICAgZmV0Y2hwcmlvcml0eTogXCJmZXRjaFByaW9yaXR5XCIsXG4gICAgICAgIGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGZvcm06IFwiZm9ybVwiLFxuICAgICAgICBmb3JtbWV0aG9kOiBcImZvcm1NZXRob2RcIixcbiAgICAgICAgZm9ybWFjdGlvbjogXCJmb3JtQWN0aW9uXCIsXG4gICAgICAgIGZvcm1lbmN0eXBlOiBcImZvcm1FbmNUeXBlXCIsXG4gICAgICAgIGZvcm1ub3ZhbGlkYXRlOiBcImZvcm1Ob1ZhbGlkYXRlXCIsXG4gICAgICAgIGZvcm10YXJnZXQ6IFwiZm9ybVRhcmdldFwiLFxuICAgICAgICBmcmFtZWJvcmRlcjogXCJmcmFtZUJvcmRlclwiLFxuICAgICAgICBoZWFkZXJzOiBcImhlYWRlcnNcIixcbiAgICAgICAgaGVpZ2h0OiBcImhlaWdodFwiLFxuICAgICAgICBoaWRkZW46IFwiaGlkZGVuXCIsXG4gICAgICAgIGhpZ2g6IFwiaGlnaFwiLFxuICAgICAgICBocmVmOiBcImhyZWZcIixcbiAgICAgICAgaHJlZmxhbmc6IFwiaHJlZkxhbmdcIixcbiAgICAgICAgaHRtbGZvcjogXCJodG1sRm9yXCIsXG4gICAgICAgIGh0dHBlcXVpdjogXCJodHRwRXF1aXZcIixcbiAgICAgICAgXCJodHRwLWVxdWl2XCI6IFwiaHR0cEVxdWl2XCIsXG4gICAgICAgIGljb246IFwiaWNvblwiLFxuICAgICAgICBpZDogXCJpZFwiLFxuICAgICAgICBpbWFnZXNpemVzOiBcImltYWdlU2l6ZXNcIixcbiAgICAgICAgaW1hZ2VzcmNzZXQ6IFwiaW1hZ2VTcmNTZXRcIixcbiAgICAgICAgaW5lcnQ6IFwiaW5lcnRcIixcbiAgICAgICAgaW5uZXJodG1sOiBcImlubmVySFRNTFwiLFxuICAgICAgICBpbnB1dG1vZGU6IFwiaW5wdXRNb2RlXCIsXG4gICAgICAgIGludGVncml0eTogXCJpbnRlZ3JpdHlcIixcbiAgICAgICAgaXM6IFwiaXNcIixcbiAgICAgICAgaXRlbWlkOiBcIml0ZW1JRFwiLFxuICAgICAgICBpdGVtcHJvcDogXCJpdGVtUHJvcFwiLFxuICAgICAgICBpdGVtcmVmOiBcIml0ZW1SZWZcIixcbiAgICAgICAgaXRlbXNjb3BlOiBcIml0ZW1TY29wZVwiLFxuICAgICAgICBpdGVtdHlwZTogXCJpdGVtVHlwZVwiLFxuICAgICAgICBrZXlwYXJhbXM6IFwia2V5UGFyYW1zXCIsXG4gICAgICAgIGtleXR5cGU6IFwia2V5VHlwZVwiLFxuICAgICAgICBraW5kOiBcImtpbmRcIixcbiAgICAgICAgbGFiZWw6IFwibGFiZWxcIixcbiAgICAgICAgbGFuZzogXCJsYW5nXCIsXG4gICAgICAgIGxpc3Q6IFwibGlzdFwiLFxuICAgICAgICBsb29wOiBcImxvb3BcIixcbiAgICAgICAgbG93OiBcImxvd1wiLFxuICAgICAgICBtYW5pZmVzdDogXCJtYW5pZmVzdFwiLFxuICAgICAgICBtYXJnaW53aWR0aDogXCJtYXJnaW5XaWR0aFwiLFxuICAgICAgICBtYXJnaW5oZWlnaHQ6IFwibWFyZ2luSGVpZ2h0XCIsXG4gICAgICAgIG1heDogXCJtYXhcIixcbiAgICAgICAgbWF4bGVuZ3RoOiBcIm1heExlbmd0aFwiLFxuICAgICAgICBtZWRpYTogXCJtZWRpYVwiLFxuICAgICAgICBtZWRpYWdyb3VwOiBcIm1lZGlhR3JvdXBcIixcbiAgICAgICAgbWV0aG9kOiBcIm1ldGhvZFwiLFxuICAgICAgICBtaW46IFwibWluXCIsXG4gICAgICAgIG1pbmxlbmd0aDogXCJtaW5MZW5ndGhcIixcbiAgICAgICAgbXVsdGlwbGU6IFwibXVsdGlwbGVcIixcbiAgICAgICAgbXV0ZWQ6IFwibXV0ZWRcIixcbiAgICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICAgIG5vbW9kdWxlOiBcIm5vTW9kdWxlXCIsXG4gICAgICAgIG5vbmNlOiBcIm5vbmNlXCIsXG4gICAgICAgIG5vdmFsaWRhdGU6IFwibm9WYWxpZGF0ZVwiLFxuICAgICAgICBvcGVuOiBcIm9wZW5cIixcbiAgICAgICAgb3B0aW11bTogXCJvcHRpbXVtXCIsXG4gICAgICAgIHBhdHRlcm46IFwicGF0dGVyblwiLFxuICAgICAgICBwbGFjZWhvbGRlcjogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBwbGF5c2lubGluZTogXCJwbGF5c0lubGluZVwiLFxuICAgICAgICBwb3N0ZXI6IFwicG9zdGVyXCIsXG4gICAgICAgIHByZWxvYWQ6IFwicHJlbG9hZFwiLFxuICAgICAgICBwcm9maWxlOiBcInByb2ZpbGVcIixcbiAgICAgICAgcmFkaW9ncm91cDogXCJyYWRpb0dyb3VwXCIsXG4gICAgICAgIHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgIHJlZmVycmVycG9saWN5OiBcInJlZmVycmVyUG9saWN5XCIsXG4gICAgICAgIHJlbDogXCJyZWxcIixcbiAgICAgICAgcmVxdWlyZWQ6IFwicmVxdWlyZWRcIixcbiAgICAgICAgcmV2ZXJzZWQ6IFwicmV2ZXJzZWRcIixcbiAgICAgICAgcm9sZTogXCJyb2xlXCIsXG4gICAgICAgIHJvd3M6IFwicm93c1wiLFxuICAgICAgICByb3dzcGFuOiBcInJvd1NwYW5cIixcbiAgICAgICAgc2FuZGJveDogXCJzYW5kYm94XCIsXG4gICAgICAgIHNjb3BlOiBcInNjb3BlXCIsXG4gICAgICAgIHNjb3BlZDogXCJzY29wZWRcIixcbiAgICAgICAgc2Nyb2xsaW5nOiBcInNjcm9sbGluZ1wiLFxuICAgICAgICBzZWFtbGVzczogXCJzZWFtbGVzc1wiLFxuICAgICAgICBzZWxlY3RlZDogXCJzZWxlY3RlZFwiLFxuICAgICAgICBzaGFwZTogXCJzaGFwZVwiLFxuICAgICAgICBzaXplOiBcInNpemVcIixcbiAgICAgICAgc2l6ZXM6IFwic2l6ZXNcIixcbiAgICAgICAgc3BhbjogXCJzcGFuXCIsXG4gICAgICAgIHNwZWxsY2hlY2s6IFwic3BlbGxDaGVja1wiLFxuICAgICAgICBzcmM6IFwic3JjXCIsXG4gICAgICAgIHNyY2RvYzogXCJzcmNEb2NcIixcbiAgICAgICAgc3JjbGFuZzogXCJzcmNMYW5nXCIsXG4gICAgICAgIHNyY3NldDogXCJzcmNTZXRcIixcbiAgICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgICAgc3RlcDogXCJzdGVwXCIsXG4gICAgICAgIHN0eWxlOiBcInN0eWxlXCIsXG4gICAgICAgIHN1bW1hcnk6IFwic3VtbWFyeVwiLFxuICAgICAgICB0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXG4gICAgICAgIHRpdGxlOiBcInRpdGxlXCIsXG4gICAgICAgIHR5cGU6IFwidHlwZVwiLFxuICAgICAgICB1c2VtYXA6IFwidXNlTWFwXCIsXG4gICAgICAgIHZhbHVlOiBcInZhbHVlXCIsXG4gICAgICAgIHdpZHRoOiBcIndpZHRoXCIsXG4gICAgICAgIHdtb2RlOiBcIndtb2RlXCIsXG4gICAgICAgIHdyYXA6IFwid3JhcFwiLFxuICAgICAgICBhYm91dDogXCJhYm91dFwiLFxuICAgICAgICBhY2NlbnRoZWlnaHQ6IFwiYWNjZW50SGVpZ2h0XCIsXG4gICAgICAgIFwiYWNjZW50LWhlaWdodFwiOiBcImFjY2VudEhlaWdodFwiLFxuICAgICAgICBhY2N1bXVsYXRlOiBcImFjY3VtdWxhdGVcIixcbiAgICAgICAgYWRkaXRpdmU6IFwiYWRkaXRpdmVcIixcbiAgICAgICAgYWxpZ25tZW50YmFzZWxpbmU6IFwiYWxpZ25tZW50QmFzZWxpbmVcIixcbiAgICAgICAgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIjogXCJhbGlnbm1lbnRCYXNlbGluZVwiLFxuICAgICAgICBhbGxvd3Jlb3JkZXI6IFwiYWxsb3dSZW9yZGVyXCIsXG4gICAgICAgIGFscGhhYmV0aWM6IFwiYWxwaGFiZXRpY1wiLFxuICAgICAgICBhbXBsaXR1ZGU6IFwiYW1wbGl0dWRlXCIsXG4gICAgICAgIGFyYWJpY2Zvcm06IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBcImFyYWJpYy1mb3JtXCI6IFwiYXJhYmljRm9ybVwiLFxuICAgICAgICBhc2NlbnQ6IFwiYXNjZW50XCIsXG4gICAgICAgIGF0dHJpYnV0ZW5hbWU6IFwiYXR0cmlidXRlTmFtZVwiLFxuICAgICAgICBhdHRyaWJ1dGV0eXBlOiBcImF0dHJpYnV0ZVR5cGVcIixcbiAgICAgICAgYXV0b3JldmVyc2U6IFwiYXV0b1JldmVyc2VcIixcbiAgICAgICAgYXppbXV0aDogXCJhemltdXRoXCIsXG4gICAgICAgIGJhc2VmcmVxdWVuY3k6IFwiYmFzZUZyZXF1ZW5jeVwiLFxuICAgICAgICBiYXNlbGluZXNoaWZ0OiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgXCJiYXNlbGluZS1zaGlmdFwiOiBcImJhc2VsaW5lU2hpZnRcIixcbiAgICAgICAgYmFzZXByb2ZpbGU6IFwiYmFzZVByb2ZpbGVcIixcbiAgICAgICAgYmJveDogXCJiYm94XCIsXG4gICAgICAgIGJlZ2luOiBcImJlZ2luXCIsXG4gICAgICAgIGJpYXM6IFwiYmlhc1wiLFxuICAgICAgICBieTogXCJieVwiLFxuICAgICAgICBjYWxjbW9kZTogXCJjYWxjTW9kZVwiLFxuICAgICAgICBjYXBoZWlnaHQ6IFwiY2FwSGVpZ2h0XCIsXG4gICAgICAgIFwiY2FwLWhlaWdodFwiOiBcImNhcEhlaWdodFwiLFxuICAgICAgICBjbGlwOiBcImNsaXBcIixcbiAgICAgICAgY2xpcHBhdGg6IFwiY2xpcFBhdGhcIixcbiAgICAgICAgXCJjbGlwLXBhdGhcIjogXCJjbGlwUGF0aFwiLFxuICAgICAgICBjbGlwcGF0aHVuaXRzOiBcImNsaXBQYXRoVW5pdHNcIixcbiAgICAgICAgY2xpcHJ1bGU6IFwiY2xpcFJ1bGVcIixcbiAgICAgICAgXCJjbGlwLXJ1bGVcIjogXCJjbGlwUnVsZVwiLFxuICAgICAgICBjb2xvcjogXCJjb2xvclwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb246IFwiY29sb3JJbnRlcnBvbGF0aW9uXCIsXG4gICAgICAgIFwiY29sb3ItaW50ZXJwb2xhdGlvblwiOiBcImNvbG9ySW50ZXJwb2xhdGlvblwiLFxuICAgICAgICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiBcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIixcbiAgICAgICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIjogXCJjb2xvckludGVycG9sYXRpb25GaWx0ZXJzXCIsXG4gICAgICAgIGNvbG9ycHJvZmlsZTogXCJjb2xvclByb2ZpbGVcIixcbiAgICAgICAgXCJjb2xvci1wcm9maWxlXCI6IFwiY29sb3JQcm9maWxlXCIsXG4gICAgICAgIGNvbG9ycmVuZGVyaW5nOiBcImNvbG9yUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiY29sb3ItcmVuZGVyaW5nXCI6IFwiY29sb3JSZW5kZXJpbmdcIixcbiAgICAgICAgY29udGVudHNjcmlwdHR5cGU6IFwiY29udGVudFNjcmlwdFR5cGVcIixcbiAgICAgICAgY29udGVudHN0eWxldHlwZTogXCJjb250ZW50U3R5bGVUeXBlXCIsXG4gICAgICAgIGN1cnNvcjogXCJjdXJzb3JcIixcbiAgICAgICAgY3g6IFwiY3hcIixcbiAgICAgICAgY3k6IFwiY3lcIixcbiAgICAgICAgZDogXCJkXCIsXG4gICAgICAgIGRhdGF0eXBlOiBcImRhdGF0eXBlXCIsXG4gICAgICAgIGRlY2VsZXJhdGU6IFwiZGVjZWxlcmF0ZVwiLFxuICAgICAgICBkZXNjZW50OiBcImRlc2NlbnRcIixcbiAgICAgICAgZGlmZnVzZWNvbnN0YW50OiBcImRpZmZ1c2VDb25zdGFudFwiLFxuICAgICAgICBkaXJlY3Rpb246IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiZGlzcGxheVwiLFxuICAgICAgICBkaXZpc29yOiBcImRpdmlzb3JcIixcbiAgICAgICAgZG9taW5hbnRiYXNlbGluZTogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIFwiZG9taW5hbnQtYmFzZWxpbmVcIjogXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgICAgIGR1cjogXCJkdXJcIixcbiAgICAgICAgZHg6IFwiZHhcIixcbiAgICAgICAgZHk6IFwiZHlcIixcbiAgICAgICAgZWRnZW1vZGU6IFwiZWRnZU1vZGVcIixcbiAgICAgICAgZWxldmF0aW9uOiBcImVsZXZhdGlvblwiLFxuICAgICAgICBlbmFibGViYWNrZ3JvdW5kOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgXCJlbmFibGUtYmFja2dyb3VuZFwiOiBcImVuYWJsZUJhY2tncm91bmRcIixcbiAgICAgICAgZW5kOiBcImVuZFwiLFxuICAgICAgICBleHBvbmVudDogXCJleHBvbmVudFwiLFxuICAgICAgICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcbiAgICAgICAgZmlsbDogXCJmaWxsXCIsXG4gICAgICAgIGZpbGxvcGFjaXR5OiBcImZpbGxPcGFjaXR5XCIsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IFwiZmlsbE9wYWNpdHlcIixcbiAgICAgICAgZmlsbHJ1bGU6IFwiZmlsbFJ1bGVcIixcbiAgICAgICAgXCJmaWxsLXJ1bGVcIjogXCJmaWxsUnVsZVwiLFxuICAgICAgICBmaWx0ZXI6IFwiZmlsdGVyXCIsXG4gICAgICAgIGZpbHRlcnJlczogXCJmaWx0ZXJSZXNcIixcbiAgICAgICAgZmlsdGVydW5pdHM6IFwiZmlsdGVyVW5pdHNcIixcbiAgICAgICAgZmxvb2RvcGFjaXR5OiBcImZsb29kT3BhY2l0eVwiLFxuICAgICAgICBcImZsb29kLW9wYWNpdHlcIjogXCJmbG9vZE9wYWNpdHlcIixcbiAgICAgICAgZmxvb2Rjb2xvcjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIFwiZmxvb2QtY29sb3JcIjogXCJmbG9vZENvbG9yXCIsXG4gICAgICAgIGZvY3VzYWJsZTogXCJmb2N1c2FibGVcIixcbiAgICAgICAgZm9udGZhbWlseTogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCJmb250RmFtaWx5XCIsXG4gICAgICAgIGZvbnRzaXplOiBcImZvbnRTaXplXCIsXG4gICAgICAgIFwiZm9udC1zaXplXCI6IFwiZm9udFNpemVcIixcbiAgICAgICAgZm9udHNpemVhZGp1c3Q6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgXCJmb250LXNpemUtYWRqdXN0XCI6IFwiZm9udFNpemVBZGp1c3RcIixcbiAgICAgICAgZm9udHN0cmV0Y2g6IFwiZm9udFN0cmV0Y2hcIixcbiAgICAgICAgXCJmb250LXN0cmV0Y2hcIjogXCJmb250U3RyZXRjaFwiLFxuICAgICAgICBmb250c3R5bGU6IFwiZm9udFN0eWxlXCIsXG4gICAgICAgIFwiZm9udC1zdHlsZVwiOiBcImZvbnRTdHlsZVwiLFxuICAgICAgICBmb250dmFyaWFudDogXCJmb250VmFyaWFudFwiLFxuICAgICAgICBcImZvbnQtdmFyaWFudFwiOiBcImZvbnRWYXJpYW50XCIsXG4gICAgICAgIGZvbnR3ZWlnaHQ6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBcImZvbnQtd2VpZ2h0XCI6IFwiZm9udFdlaWdodFwiLFxuICAgICAgICBmb3JtYXQ6IFwiZm9ybWF0XCIsXG4gICAgICAgIGZyb206IFwiZnJvbVwiLFxuICAgICAgICBmeDogXCJmeFwiLFxuICAgICAgICBmeTogXCJmeVwiLFxuICAgICAgICBnMTogXCJnMVwiLFxuICAgICAgICBnMjogXCJnMlwiLFxuICAgICAgICBnbHlwaG5hbWU6IFwiZ2x5cGhOYW1lXCIsXG4gICAgICAgIFwiZ2x5cGgtbmFtZVwiOiBcImdseXBoTmFtZVwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIjogXCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbFwiLFxuICAgICAgICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6IFwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsXCIsXG4gICAgICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIjogXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIixcbiAgICAgICAgZ2x5cGhyZWY6IFwiZ2x5cGhSZWZcIixcbiAgICAgICAgZ3JhZGllbnR0cmFuc2Zvcm06IFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgICAgICAgZ3JhZGllbnR1bml0czogXCJncmFkaWVudFVuaXRzXCIsXG4gICAgICAgIGhhbmdpbmc6IFwiaGFuZ2luZ1wiLFxuICAgICAgICBob3JpemFkdng6IFwiaG9yaXpBZHZYXCIsXG4gICAgICAgIFwiaG9yaXotYWR2LXhcIjogXCJob3JpekFkdlhcIixcbiAgICAgICAgaG9yaXpvcmlnaW54OiBcImhvcml6T3JpZ2luWFwiLFxuICAgICAgICBcImhvcml6LW9yaWdpbi14XCI6IFwiaG9yaXpPcmlnaW5YXCIsXG4gICAgICAgIGlkZW9ncmFwaGljOiBcImlkZW9ncmFwaGljXCIsXG4gICAgICAgIGltYWdlcmVuZGVyaW5nOiBcImltYWdlUmVuZGVyaW5nXCIsXG4gICAgICAgIFwiaW1hZ2UtcmVuZGVyaW5nXCI6IFwiaW1hZ2VSZW5kZXJpbmdcIixcbiAgICAgICAgaW4yOiBcImluMlwiLFxuICAgICAgICBpbjogXCJpblwiLFxuICAgICAgICBpbmxpc3Q6IFwiaW5saXN0XCIsXG4gICAgICAgIGludGVyY2VwdDogXCJpbnRlcmNlcHRcIixcbiAgICAgICAgazE6IFwiazFcIixcbiAgICAgICAgazI6IFwiazJcIixcbiAgICAgICAgazM6IFwiazNcIixcbiAgICAgICAgazQ6IFwiazRcIixcbiAgICAgICAgazogXCJrXCIsXG4gICAgICAgIGtlcm5lbG1hdHJpeDogXCJrZXJuZWxNYXRyaXhcIixcbiAgICAgICAga2VybmVsdW5pdGxlbmd0aDogXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gICAgICAgIGtlcm5pbmc6IFwia2VybmluZ1wiLFxuICAgICAgICBrZXlwb2ludHM6IFwia2V5UG9pbnRzXCIsXG4gICAgICAgIGtleXNwbGluZXM6IFwia2V5U3BsaW5lc1wiLFxuICAgICAgICBrZXl0aW1lczogXCJrZXlUaW1lc1wiLFxuICAgICAgICBsZW5ndGhhZGp1c3Q6IFwibGVuZ3RoQWRqdXN0XCIsXG4gICAgICAgIGxldHRlcnNwYWNpbmc6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBcImxldHRlci1zcGFjaW5nXCI6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgICAgICBsaWdodGluZ2NvbG9yOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgXCJsaWdodGluZy1jb2xvclwiOiBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICAgICAgbGltaXRpbmdjb25lYW5nbGU6IFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgICAgICAgbG9jYWw6IFwibG9jYWxcIixcbiAgICAgICAgbWFya2VyZW5kOiBcIm1hcmtlckVuZFwiLFxuICAgICAgICBcIm1hcmtlci1lbmRcIjogXCJtYXJrZXJFbmRcIixcbiAgICAgICAgbWFya2VyaGVpZ2h0OiBcIm1hcmtlckhlaWdodFwiLFxuICAgICAgICBtYXJrZXJtaWQ6IFwibWFya2VyTWlkXCIsXG4gICAgICAgIFwibWFya2VyLW1pZFwiOiBcIm1hcmtlck1pZFwiLFxuICAgICAgICBtYXJrZXJzdGFydDogXCJtYXJrZXJTdGFydFwiLFxuICAgICAgICBcIm1hcmtlci1zdGFydFwiOiBcIm1hcmtlclN0YXJ0XCIsXG4gICAgICAgIG1hcmtlcnVuaXRzOiBcIm1hcmtlclVuaXRzXCIsXG4gICAgICAgIG1hcmtlcndpZHRoOiBcIm1hcmtlcldpZHRoXCIsXG4gICAgICAgIG1hc2s6IFwibWFza1wiLFxuICAgICAgICBtYXNrY29udGVudHVuaXRzOiBcIm1hc2tDb250ZW50VW5pdHNcIixcbiAgICAgICAgbWFza3VuaXRzOiBcIm1hc2tVbml0c1wiLFxuICAgICAgICBtYXRoZW1hdGljYWw6IFwibWF0aGVtYXRpY2FsXCIsXG4gICAgICAgIG1vZGU6IFwibW9kZVwiLFxuICAgICAgICBudW1vY3RhdmVzOiBcIm51bU9jdGF2ZXNcIixcbiAgICAgICAgb2Zmc2V0OiBcIm9mZnNldFwiLFxuICAgICAgICBvcGFjaXR5OiBcIm9wYWNpdHlcIixcbiAgICAgICAgb3BlcmF0b3I6IFwib3BlcmF0b3JcIixcbiAgICAgICAgb3JkZXI6IFwib3JkZXJcIixcbiAgICAgICAgb3JpZW50OiBcIm9yaWVudFwiLFxuICAgICAgICBvcmllbnRhdGlvbjogXCJvcmllbnRhdGlvblwiLFxuICAgICAgICBvcmlnaW46IFwib3JpZ2luXCIsXG4gICAgICAgIG92ZXJmbG93OiBcIm92ZXJmbG93XCIsXG4gICAgICAgIG92ZXJsaW5lcG9zaXRpb246IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBcIm92ZXJsaW5lLXBvc2l0aW9uXCI6IFwib3ZlcmxpbmVQb3NpdGlvblwiLFxuICAgICAgICBvdmVybGluZXRoaWNrbmVzczogXCJvdmVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiOiBcIm92ZXJsaW5lVGhpY2tuZXNzXCIsXG4gICAgICAgIHBhaW50b3JkZXI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBcInBhaW50LW9yZGVyXCI6IFwicGFpbnRPcmRlclwiLFxuICAgICAgICBwYW5vc2UxOiBcInBhbm9zZTFcIixcbiAgICAgICAgXCJwYW5vc2UtMVwiOiBcInBhbm9zZTFcIixcbiAgICAgICAgcGF0aGxlbmd0aDogXCJwYXRoTGVuZ3RoXCIsXG4gICAgICAgIHBhdHRlcm5jb250ZW50dW5pdHM6IFwicGF0dGVybkNvbnRlbnRVbml0c1wiLFxuICAgICAgICBwYXR0ZXJudHJhbnNmb3JtOiBcInBhdHRlcm5UcmFuc2Zvcm1cIixcbiAgICAgICAgcGF0dGVybnVuaXRzOiBcInBhdHRlcm5Vbml0c1wiLFxuICAgICAgICBwb2ludGVyZXZlbnRzOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcInBvaW50ZXJFdmVudHNcIixcbiAgICAgICAgcG9pbnRzOiBcInBvaW50c1wiLFxuICAgICAgICBwb2ludHNhdHg6IFwicG9pbnRzQXRYXCIsXG4gICAgICAgIHBvaW50c2F0eTogXCJwb2ludHNBdFlcIixcbiAgICAgICAgcG9pbnRzYXR6OiBcInBvaW50c0F0WlwiLFxuICAgICAgICBwb3BvdmVyOiBcInBvcG92ZXJcIixcbiAgICAgICAgcG9wb3ZlcnRhcmdldDogXCJwb3BvdmVyVGFyZ2V0XCIsXG4gICAgICAgIHBvcG92ZXJ0YXJnZXRhY3Rpb246IFwicG9wb3ZlclRhcmdldEFjdGlvblwiLFxuICAgICAgICBwcmVmaXg6IFwicHJlZml4XCIsXG4gICAgICAgIHByZXNlcnZlYWxwaGE6IFwicHJlc2VydmVBbHBoYVwiLFxuICAgICAgICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiBcInByZXNlcnZlQXNwZWN0UmF0aW9cIixcbiAgICAgICAgcHJpbWl0aXZldW5pdHM6IFwicHJpbWl0aXZlVW5pdHNcIixcbiAgICAgICAgcHJvcGVydHk6IFwicHJvcGVydHlcIixcbiAgICAgICAgcjogXCJyXCIsXG4gICAgICAgIHJhZGl1czogXCJyYWRpdXNcIixcbiAgICAgICAgcmVmeDogXCJyZWZYXCIsXG4gICAgICAgIHJlZnk6IFwicmVmWVwiLFxuICAgICAgICByZW5kZXJpbmdpbnRlbnQ6IFwicmVuZGVyaW5nSW50ZW50XCIsXG4gICAgICAgIFwicmVuZGVyaW5nLWludGVudFwiOiBcInJlbmRlcmluZ0ludGVudFwiLFxuICAgICAgICByZXBlYXRjb3VudDogXCJyZXBlYXRDb3VudFwiLFxuICAgICAgICByZXBlYXRkdXI6IFwicmVwZWF0RHVyXCIsXG4gICAgICAgIHJlcXVpcmVkZXh0ZW5zaW9uczogXCJyZXF1aXJlZEV4dGVuc2lvbnNcIixcbiAgICAgICAgcmVxdWlyZWRmZWF0dXJlczogXCJyZXF1aXJlZEZlYXR1cmVzXCIsXG4gICAgICAgIHJlc291cmNlOiBcInJlc291cmNlXCIsXG4gICAgICAgIHJlc3RhcnQ6IFwicmVzdGFydFwiLFxuICAgICAgICByZXN1bHQ6IFwicmVzdWx0XCIsXG4gICAgICAgIHJlc3VsdHM6IFwicmVzdWx0c1wiLFxuICAgICAgICByb3RhdGU6IFwicm90YXRlXCIsXG4gICAgICAgIHJ4OiBcInJ4XCIsXG4gICAgICAgIHJ5OiBcInJ5XCIsXG4gICAgICAgIHNjYWxlOiBcInNjYWxlXCIsXG4gICAgICAgIHNlY3VyaXR5OiBcInNlY3VyaXR5XCIsXG4gICAgICAgIHNlZWQ6IFwic2VlZFwiLFxuICAgICAgICBzaGFwZXJlbmRlcmluZzogXCJzaGFwZVJlbmRlcmluZ1wiLFxuICAgICAgICBcInNoYXBlLXJlbmRlcmluZ1wiOiBcInNoYXBlUmVuZGVyaW5nXCIsXG4gICAgICAgIHNsb3BlOiBcInNsb3BlXCIsXG4gICAgICAgIHNwYWNpbmc6IFwic3BhY2luZ1wiLFxuICAgICAgICBzcGVjdWxhcmNvbnN0YW50OiBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgICAgICAgc3BlY3VsYXJleHBvbmVudDogXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gICAgICAgIHNwZWVkOiBcInNwZWVkXCIsXG4gICAgICAgIHNwcmVhZG1ldGhvZDogXCJzcHJlYWRNZXRob2RcIixcbiAgICAgICAgc3RhcnRvZmZzZXQ6IFwic3RhcnRPZmZzZXRcIixcbiAgICAgICAgc3RkZGV2aWF0aW9uOiBcInN0ZERldmlhdGlvblwiLFxuICAgICAgICBzdGVtaDogXCJzdGVtaFwiLFxuICAgICAgICBzdGVtdjogXCJzdGVtdlwiLFxuICAgICAgICBzdGl0Y2h0aWxlczogXCJzdGl0Y2hUaWxlc1wiLFxuICAgICAgICBzdG9wY29sb3I6IFwic3RvcENvbG9yXCIsXG4gICAgICAgIFwic3RvcC1jb2xvclwiOiBcInN0b3BDb2xvclwiLFxuICAgICAgICBzdG9wb3BhY2l0eTogXCJzdG9wT3BhY2l0eVwiLFxuICAgICAgICBcInN0b3Atb3BhY2l0eVwiOiBcInN0b3BPcGFjaXR5XCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIixcbiAgICAgICAgXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCI6IFwic3RyaWtldGhyb3VnaFBvc2l0aW9uXCIsXG4gICAgICAgIHN0cmlrZXRocm91Z2h0aGlja25lc3M6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCI6IFwic3RyaWtldGhyb3VnaFRoaWNrbmVzc1wiLFxuICAgICAgICBzdHJpbmc6IFwic3RyaW5nXCIsXG4gICAgICAgIHN0cm9rZTogXCJzdHJva2VcIixcbiAgICAgICAgc3Ryb2tlZGFzaGFycmF5OiBcInN0cm9rZURhc2hhcnJheVwiLFxuICAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJzdHJva2VEYXNoYXJyYXlcIixcbiAgICAgICAgc3Ryb2tlZGFzaG9mZnNldDogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIFwic3Ryb2tlLWRhc2hvZmZzZXRcIjogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgICAgIHN0cm9rZWxpbmVjYXA6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwic3Ryb2tlTGluZWNhcFwiLFxuICAgICAgICBzdHJva2VsaW5lam9pbjogXCJzdHJva2VMaW5lam9pblwiLFxuICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInN0cm9rZUxpbmVqb2luXCIsXG4gICAgICAgIHN0cm9rZW1pdGVybGltaXQ6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgICAgICBzdHJva2V3aWR0aDogXCJzdHJva2VXaWR0aFwiLFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBcInN0cm9rZVdpZHRoXCIsXG4gICAgICAgIHN0cm9rZW9wYWNpdHk6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgICAgICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6IFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIsXG4gICAgICAgIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIixcbiAgICAgICAgc3VyZmFjZXNjYWxlOiBcInN1cmZhY2VTY2FsZVwiLFxuICAgICAgICBzeXN0ZW1sYW5ndWFnZTogXCJzeXN0ZW1MYW5ndWFnZVwiLFxuICAgICAgICB0YWJsZXZhbHVlczogXCJ0YWJsZVZhbHVlc1wiLFxuICAgICAgICB0YXJnZXR4OiBcInRhcmdldFhcIixcbiAgICAgICAgdGFyZ2V0eTogXCJ0YXJnZXRZXCIsXG4gICAgICAgIHRleHRhbmNob3I6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICBcInRleHQtYW5jaG9yXCI6IFwidGV4dEFuY2hvclwiLFxuICAgICAgICB0ZXh0ZGVjb3JhdGlvbjogXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICAgICAgICBcInRleHQtZGVjb3JhdGlvblwiOiBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgICAgIHRleHRsZW5ndGg6IFwidGV4dExlbmd0aFwiLFxuICAgICAgICB0ZXh0cmVuZGVyaW5nOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgXCJ0ZXh0LXJlbmRlcmluZ1wiOiBcInRleHRSZW5kZXJpbmdcIixcbiAgICAgICAgdG86IFwidG9cIixcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICB0cmFuc2Zvcm1vcmlnaW46IFwidHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgICAgICB0eXBlb2Y6IFwidHlwZW9mXCIsXG4gICAgICAgIHUxOiBcInUxXCIsXG4gICAgICAgIHUyOiBcInUyXCIsXG4gICAgICAgIHVuZGVybGluZXBvc2l0aW9uOiBcInVuZGVybGluZVBvc2l0aW9uXCIsXG4gICAgICAgIFwidW5kZXJsaW5lLXBvc2l0aW9uXCI6IFwidW5kZXJsaW5lUG9zaXRpb25cIixcbiAgICAgICAgdW5kZXJsaW5ldGhpY2tuZXNzOiBcInVuZGVybGluZVRoaWNrbmVzc1wiLFxuICAgICAgICBcInVuZGVybGluZS10aGlja25lc3NcIjogXCJ1bmRlcmxpbmVUaGlja25lc3NcIixcbiAgICAgICAgdW5pY29kZTogXCJ1bmljb2RlXCIsXG4gICAgICAgIHVuaWNvZGViaWRpOiBcInVuaWNvZGVCaWRpXCIsXG4gICAgICAgIFwidW5pY29kZS1iaWRpXCI6IFwidW5pY29kZUJpZGlcIixcbiAgICAgICAgdW5pY29kZXJhbmdlOiBcInVuaWNvZGVSYW5nZVwiLFxuICAgICAgICBcInVuaWNvZGUtcmFuZ2VcIjogXCJ1bmljb2RlUmFuZ2VcIixcbiAgICAgICAgdW5pdHNwZXJlbTogXCJ1bml0c1BlckVtXCIsXG4gICAgICAgIFwidW5pdHMtcGVyLWVtXCI6IFwidW5pdHNQZXJFbVwiLFxuICAgICAgICB1bnNlbGVjdGFibGU6IFwidW5zZWxlY3RhYmxlXCIsXG4gICAgICAgIHZhbHBoYWJldGljOiBcInZBbHBoYWJldGljXCIsXG4gICAgICAgIFwidi1hbHBoYWJldGljXCI6IFwidkFscGhhYmV0aWNcIixcbiAgICAgICAgdmFsdWVzOiBcInZhbHVlc1wiLFxuICAgICAgICB2ZWN0b3JlZmZlY3Q6IFwidmVjdG9yRWZmZWN0XCIsXG4gICAgICAgIFwidmVjdG9yLWVmZmVjdFwiOiBcInZlY3RvckVmZmVjdFwiLFxuICAgICAgICB2ZXJzaW9uOiBcInZlcnNpb25cIixcbiAgICAgICAgdmVydGFkdnk6IFwidmVydEFkdllcIixcbiAgICAgICAgXCJ2ZXJ0LWFkdi15XCI6IFwidmVydEFkdllcIixcbiAgICAgICAgdmVydG9yaWdpbng6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi14XCI6IFwidmVydE9yaWdpblhcIixcbiAgICAgICAgdmVydG9yaWdpbnk6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgXCJ2ZXJ0LW9yaWdpbi15XCI6IFwidmVydE9yaWdpbllcIixcbiAgICAgICAgdmhhbmdpbmc6IFwidkhhbmdpbmdcIixcbiAgICAgICAgXCJ2LWhhbmdpbmdcIjogXCJ2SGFuZ2luZ1wiLFxuICAgICAgICB2aWRlb2dyYXBoaWM6IFwidklkZW9ncmFwaGljXCIsXG4gICAgICAgIFwidi1pZGVvZ3JhcGhpY1wiOiBcInZJZGVvZ3JhcGhpY1wiLFxuICAgICAgICB2aWV3Ym94OiBcInZpZXdCb3hcIixcbiAgICAgICAgdmlld3RhcmdldDogXCJ2aWV3VGFyZ2V0XCIsXG4gICAgICAgIHZpc2liaWxpdHk6IFwidmlzaWJpbGl0eVwiLFxuICAgICAgICB2bWF0aGVtYXRpY2FsOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgXCJ2LW1hdGhlbWF0aWNhbFwiOiBcInZNYXRoZW1hdGljYWxcIixcbiAgICAgICAgdm9jYWI6IFwidm9jYWJcIixcbiAgICAgICAgd2lkdGhzOiBcIndpZHRoc1wiLFxuICAgICAgICB3b3Jkc3BhY2luZzogXCJ3b3JkU3BhY2luZ1wiLFxuICAgICAgICBcIndvcmQtc3BhY2luZ1wiOiBcIndvcmRTcGFjaW5nXCIsXG4gICAgICAgIHdyaXRpbmdtb2RlOiBcIndyaXRpbmdNb2RlXCIsXG4gICAgICAgIFwid3JpdGluZy1tb2RlXCI6IFwid3JpdGluZ01vZGVcIixcbiAgICAgICAgeDE6IFwieDFcIixcbiAgICAgICAgeDI6IFwieDJcIixcbiAgICAgICAgeDogXCJ4XCIsXG4gICAgICAgIHhjaGFubmVsc2VsZWN0b3I6IFwieENoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB4aGVpZ2h0OiBcInhIZWlnaHRcIixcbiAgICAgICAgXCJ4LWhlaWdodFwiOiBcInhIZWlnaHRcIixcbiAgICAgICAgeGxpbmthY3R1YXRlOiBcInhsaW5rQWN0dWF0ZVwiLFxuICAgICAgICBcInhsaW5rOmFjdHVhdGVcIjogXCJ4bGlua0FjdHVhdGVcIixcbiAgICAgICAgeGxpbmthcmNyb2xlOiBcInhsaW5rQXJjcm9sZVwiLFxuICAgICAgICBcInhsaW5rOmFyY3JvbGVcIjogXCJ4bGlua0FyY3JvbGVcIixcbiAgICAgICAgeGxpbmtocmVmOiBcInhsaW5rSHJlZlwiLFxuICAgICAgICBcInhsaW5rOmhyZWZcIjogXCJ4bGlua0hyZWZcIixcbiAgICAgICAgeGxpbmtyb2xlOiBcInhsaW5rUm9sZVwiLFxuICAgICAgICBcInhsaW5rOnJvbGVcIjogXCJ4bGlua1JvbGVcIixcbiAgICAgICAgeGxpbmtzaG93OiBcInhsaW5rU2hvd1wiLFxuICAgICAgICBcInhsaW5rOnNob3dcIjogXCJ4bGlua1Nob3dcIixcbiAgICAgICAgeGxpbmt0aXRsZTogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIFwieGxpbms6dGl0bGVcIjogXCJ4bGlua1RpdGxlXCIsXG4gICAgICAgIHhsaW5rdHlwZTogXCJ4bGlua1R5cGVcIixcbiAgICAgICAgXCJ4bGluazp0eXBlXCI6IFwieGxpbmtUeXBlXCIsXG4gICAgICAgIHhtbGJhc2U6IFwieG1sQmFzZVwiLFxuICAgICAgICBcInhtbDpiYXNlXCI6IFwieG1sQmFzZVwiLFxuICAgICAgICB4bWxsYW5nOiBcInhtbExhbmdcIixcbiAgICAgICAgXCJ4bWw6bGFuZ1wiOiBcInhtbExhbmdcIixcbiAgICAgICAgeG1sbnM6IFwieG1sbnNcIixcbiAgICAgICAgXCJ4bWw6c3BhY2VcIjogXCJ4bWxTcGFjZVwiLFxuICAgICAgICB4bWxuc3hsaW5rOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgXCJ4bWxuczp4bGlua1wiOiBcInhtbG5zWGxpbmtcIixcbiAgICAgICAgeG1sc3BhY2U6IFwieG1sU3BhY2VcIixcbiAgICAgICAgeTE6IFwieTFcIixcbiAgICAgICAgeTI6IFwieTJcIixcbiAgICAgICAgeTogXCJ5XCIsXG4gICAgICAgIHljaGFubmVsc2VsZWN0b3I6IFwieUNoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICB6OiBcInpcIixcbiAgICAgICAgem9vbWFuZHBhbjogXCJ6b29tQW5kUGFuXCJcbiAgICAgIH0sXG4gICAgICBhcmlhUHJvcGVydGllcyA9IHtcbiAgICAgICAgXCJhcmlhLWN1cnJlbnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWRlc2NyaXB0aW9uXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kZXRhaWxzXCI6IDAsXG4gICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAwLFxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1pbnZhbGlkXCI6IDAsXG4gICAgICAgIFwiYXJpYS1rZXlzaG9ydGN1dHNcIjogMCxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogMCxcbiAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiAwLFxuICAgICAgICBcImFyaWEtY2hlY2tlZFwiOiAwLFxuICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IDAsXG4gICAgICAgIFwiYXJpYS1sZXZlbFwiOiAwLFxuICAgICAgICBcImFyaWEtbW9kYWxcIjogMCxcbiAgICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiAwLFxuICAgICAgICBcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1vcmllbnRhdGlvblwiOiAwLFxuICAgICAgICBcImFyaWEtcGxhY2Vob2xkZXJcIjogMCxcbiAgICAgICAgXCJhcmlhLXByZXNzZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLXJlYWRvbmx5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yZXF1aXJlZFwiOiAwLFxuICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogMCxcbiAgICAgICAgXCJhcmlhLXNvcnRcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVlbWF4XCI6IDAsXG4gICAgICAgIFwiYXJpYS12YWx1ZW1pblwiOiAwLFxuICAgICAgICBcImFyaWEtdmFsdWVub3dcIjogMCxcbiAgICAgICAgXCJhcmlhLXZhbHVldGV4dFwiOiAwLFxuICAgICAgICBcImFyaWEtYXRvbWljXCI6IDAsXG4gICAgICAgIFwiYXJpYS1idXN5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1saXZlXCI6IDAsXG4gICAgICAgIFwiYXJpYS1yZWxldmFudFwiOiAwLFxuICAgICAgICBcImFyaWEtZHJvcGVmZmVjdFwiOiAwLFxuICAgICAgICBcImFyaWEtZ3JhYmJlZFwiOiAwLFxuICAgICAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiAwLFxuICAgICAgICBcImFyaWEtY29sY291bnRcIjogMCxcbiAgICAgICAgXCJhcmlhLWNvbGluZGV4XCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb2xzcGFuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiAwLFxuICAgICAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogMCxcbiAgICAgICAgXCJhcmlhLWVycm9ybWVzc2FnZVwiOiAwLFxuICAgICAgICBcImFyaWEtZmxvd3RvXCI6IDAsXG4gICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IDAsXG4gICAgICAgIFwiYXJpYS1vd25zXCI6IDAsXG4gICAgICAgIFwiYXJpYS1wb3NpbnNldFwiOiAwLFxuICAgICAgICBcImFyaWEtcm93Y291bnRcIjogMCxcbiAgICAgICAgXCJhcmlhLXJvd2luZGV4XCI6IDAsXG4gICAgICAgIFwiYXJpYS1yb3dzcGFuXCI6IDAsXG4gICAgICAgIFwiYXJpYS1zZXRzaXplXCI6IDBcbiAgICAgIH0sXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fSxcbiAgICAgIHJBUklBJDEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKS1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICByQVJJQUNhbWVsJDEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKVtBLVpdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICAgICApLFxuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9ICExLFxuICAgICAgd2FybmVkUHJvcGVydGllcyA9IHt9LFxuICAgICAgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLyxcbiAgICAgIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vLFxuICAgICAgckFSSUEgPSBSZWdFeHAoXG4gICAgICAgIFwiXihhcmlhKS1bOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXSokXCJcbiAgICAgICksXG4gICAgICByQVJJQUNhbWVsID0gUmVnRXhwKFxuICAgICAgICBcIl4oYXJpYSlbQS1aXVs6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBdKiRcIlxuICAgICAgKSxcbiAgICAgIGlzSmF2YVNjcmlwdFByb3RvY29sID1cbiAgICAgICAgL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKjovaSxcbiAgICAgIGN1cnJlbnRSZXBsYXlpbmdFdmVudCA9IG51bGwsXG4gICAgICByZXN0b3JlVGFyZ2V0ID0gbnVsbCxcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IG51bGwsXG4gICAgICBpc0luc2lkZUV2ZW50SGFuZGxlciA9ICExLFxuICAgICAgY2FuVXNlRE9NID0gIShcbiAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHdpbmRvdyB8fFxuICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2Ygd2luZG93LmRvY3VtZW50IHx8XG4gICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudFxuICAgICAgKSxcbiAgICAgIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gITE7XG4gICAgaWYgKGNhblVzZURPTSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvcHRpb25zJGpzY29tcCQwID0ge307XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRpb25zJGpzY29tcCQwLCBcInBhc3NpdmVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgb3B0aW9ucyRqc2NvbXAkMCwgb3B0aW9ucyRqc2NvbXAkMCk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLCBvcHRpb25zJGpzY29tcCQwLCBvcHRpb25zJGpzY29tcCQwKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSAhMTtcbiAgICAgIH1cbiAgICB2YXIgcm9vdCA9IG51bGwsXG4gICAgICBzdGFydFRleHQgPSBudWxsLFxuICAgICAgZmFsbGJhY2tUZXh0ID0gbnVsbCxcbiAgICAgIEV2ZW50SW50ZXJmYWNlID0ge1xuICAgICAgICBldmVudFBoYXNlOiAwLFxuICAgICAgICBidWJibGVzOiAwLFxuICAgICAgICBjYW5jZWxhYmxlOiAwLFxuICAgICAgICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFByZXZlbnRlZDogMCxcbiAgICAgICAgaXNUcnVzdGVkOiAwXG4gICAgICB9LFxuICAgICAgU3ludGhldGljRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChFdmVudEludGVyZmFjZSksXG4gICAgICBVSUV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwgeyB2aWV3OiAwLCBkZXRhaWw6IDAgfSksXG4gICAgICBTeW50aGV0aWNVSUV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVUlFdmVudEludGVyZmFjZSksXG4gICAgICBsYXN0TW92ZW1lbnRYLFxuICAgICAgbGFzdE1vdmVtZW50WSxcbiAgICAgIGxhc3RNb3VzZUV2ZW50LFxuICAgICAgTW91c2VFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICAgICAgICBzY3JlZW5YOiAwLFxuICAgICAgICBzY3JlZW5ZOiAwLFxuICAgICAgICBjbGllbnRYOiAwLFxuICAgICAgICBjbGllbnRZOiAwLFxuICAgICAgICBwYWdlWDogMCxcbiAgICAgICAgcGFnZVk6IDAsXG4gICAgICAgIGN0cmxLZXk6IDAsXG4gICAgICAgIHNoaWZ0S2V5OiAwLFxuICAgICAgICBhbHRLZXk6IDAsXG4gICAgICAgIG1ldGFLZXk6IDAsXG4gICAgICAgIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgICAgICAgYnV0dG9uOiAwLFxuICAgICAgICBidXR0b25zOiAwLFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBldmVudC5yZWxhdGVkVGFyZ2V0XG4gICAgICAgICAgICA/IGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50XG4gICAgICAgICAgICAgID8gZXZlbnQudG9FbGVtZW50XG4gICAgICAgICAgICAgIDogZXZlbnQuZnJvbUVsZW1lbnRcbiAgICAgICAgICAgIDogZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgfSxcbiAgICAgICAgbW92ZW1lbnRYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoXCJtb3ZlbWVudFhcIiBpbiBldmVudCkgcmV0dXJuIGV2ZW50Lm1vdmVtZW50WDtcbiAgICAgICAgICBldmVudCAhPT0gbGFzdE1vdXNlRXZlbnQgJiZcbiAgICAgICAgICAgIChsYXN0TW91c2VFdmVudCAmJiBcIm1vdXNlbW92ZVwiID09PSBldmVudC50eXBlXG4gICAgICAgICAgICAgID8gKChsYXN0TW92ZW1lbnRYID0gZXZlbnQuc2NyZWVuWCAtIGxhc3RNb3VzZUV2ZW50LnNjcmVlblgpLFxuICAgICAgICAgICAgICAgIChsYXN0TW92ZW1lbnRZID0gZXZlbnQuc2NyZWVuWSAtIGxhc3RNb3VzZUV2ZW50LnNjcmVlblkpKVxuICAgICAgICAgICAgICA6IChsYXN0TW92ZW1lbnRZID0gbGFzdE1vdmVtZW50WCA9IDApLFxuICAgICAgICAgICAgKGxhc3RNb3VzZUV2ZW50ID0gZXZlbnQpKTtcbiAgICAgICAgICByZXR1cm4gbGFzdE1vdmVtZW50WDtcbiAgICAgICAgfSxcbiAgICAgICAgbW92ZW1lbnRZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gXCJtb3ZlbWVudFlcIiBpbiBldmVudCA/IGV2ZW50Lm1vdmVtZW50WSA6IGxhc3RNb3ZlbWVudFk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgU3ludGhldGljTW91c2VFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KE1vdXNlRXZlbnRJbnRlcmZhY2UpLFxuICAgICAgRHJhZ0V2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7IGRhdGFUcmFuc2ZlcjogMCB9KSxcbiAgICAgIFN5bnRoZXRpY0RyYWdFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KERyYWdFdmVudEludGVyZmFjZSksXG4gICAgICBGb2N1c0V2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7IHJlbGF0ZWRUYXJnZXQ6IDAgfSksXG4gICAgICBTeW50aGV0aWNGb2N1c0V2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoRm9jdXNFdmVudEludGVyZmFjZSksXG4gICAgICBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgICAgICAgYW5pbWF0aW9uTmFtZTogMCxcbiAgICAgICAgZWxhcHNlZFRpbWU6IDAsXG4gICAgICAgIHBzZXVkb0VsZW1lbnQ6IDBcbiAgICAgIH0pLFxuICAgICAgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChBbmltYXRpb25FdmVudEludGVyZmFjZSksXG4gICAgICBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgICAgICAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFwiY2xpcGJvYXJkRGF0YVwiIGluIGV2ZW50XG4gICAgICAgICAgICA/IGV2ZW50LmNsaXBib2FyZERhdGFcbiAgICAgICAgICAgIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChDbGlwYm9hcmRFdmVudEludGVyZmFjZSksXG4gICAgICBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwgeyBkYXRhOiAwIH0pLFxuICAgICAgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFxuICAgICAgICBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlXG4gICAgICApLFxuICAgICAgU3ludGhldGljSW5wdXRFdmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsXG4gICAgICBub3JtYWxpemVLZXkgPSB7XG4gICAgICAgIEVzYzogXCJFc2NhcGVcIixcbiAgICAgICAgU3BhY2ViYXI6IFwiIFwiLFxuICAgICAgICBMZWZ0OiBcIkFycm93TGVmdFwiLFxuICAgICAgICBVcDogXCJBcnJvd1VwXCIsXG4gICAgICAgIFJpZ2h0OiBcIkFycm93UmlnaHRcIixcbiAgICAgICAgRG93bjogXCJBcnJvd0Rvd25cIixcbiAgICAgICAgRGVsOiBcIkRlbGV0ZVwiLFxuICAgICAgICBXaW46IFwiT1NcIixcbiAgICAgICAgTWVudTogXCJDb250ZXh0TWVudVwiLFxuICAgICAgICBBcHBzOiBcIkNvbnRleHRNZW51XCIsXG4gICAgICAgIFNjcm9sbDogXCJTY3JvbGxMb2NrXCIsXG4gICAgICAgIE1velByaW50YWJsZUtleTogXCJVbmlkZW50aWZpZWRcIlxuICAgICAgfSxcbiAgICAgIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAgICAgICA4OiBcIkJhY2tzcGFjZVwiLFxuICAgICAgICA5OiBcIlRhYlwiLFxuICAgICAgICAxMjogXCJDbGVhclwiLFxuICAgICAgICAxMzogXCJFbnRlclwiLFxuICAgICAgICAxNjogXCJTaGlmdFwiLFxuICAgICAgICAxNzogXCJDb250cm9sXCIsXG4gICAgICAgIDE4OiBcIkFsdFwiLFxuICAgICAgICAxOTogXCJQYXVzZVwiLFxuICAgICAgICAyMDogXCJDYXBzTG9ja1wiLFxuICAgICAgICAyNzogXCJFc2NhcGVcIixcbiAgICAgICAgMzI6IFwiIFwiLFxuICAgICAgICAzMzogXCJQYWdlVXBcIixcbiAgICAgICAgMzQ6IFwiUGFnZURvd25cIixcbiAgICAgICAgMzU6IFwiRW5kXCIsXG4gICAgICAgIDM2OiBcIkhvbWVcIixcbiAgICAgICAgMzc6IFwiQXJyb3dMZWZ0XCIsXG4gICAgICAgIDM4OiBcIkFycm93VXBcIixcbiAgICAgICAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICAgICAgICA0MDogXCJBcnJvd0Rvd25cIixcbiAgICAgICAgNDU6IFwiSW5zZXJ0XCIsXG4gICAgICAgIDQ2OiBcIkRlbGV0ZVwiLFxuICAgICAgICAxMTI6IFwiRjFcIixcbiAgICAgICAgMTEzOiBcIkYyXCIsXG4gICAgICAgIDExNDogXCJGM1wiLFxuICAgICAgICAxMTU6IFwiRjRcIixcbiAgICAgICAgMTE2OiBcIkY1XCIsXG4gICAgICAgIDExNzogXCJGNlwiLFxuICAgICAgICAxMTg6IFwiRjdcIixcbiAgICAgICAgMTE5OiBcIkY4XCIsXG4gICAgICAgIDEyMDogXCJGOVwiLFxuICAgICAgICAxMjE6IFwiRjEwXCIsXG4gICAgICAgIDEyMjogXCJGMTFcIixcbiAgICAgICAgMTIzOiBcIkYxMlwiLFxuICAgICAgICAxNDQ6IFwiTnVtTG9ja1wiLFxuICAgICAgICAxNDU6IFwiU2Nyb2xsTG9ja1wiLFxuICAgICAgICAyMjQ6IFwiTWV0YVwiXG4gICAgICB9LFxuICAgICAgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gICAgICAgIEFsdDogXCJhbHRLZXlcIixcbiAgICAgICAgQ29udHJvbDogXCJjdHJsS2V5XCIsXG4gICAgICAgIE1ldGE6IFwibWV0YUtleVwiLFxuICAgICAgICBTaGlmdDogXCJzaGlmdEtleVwiXG4gICAgICB9LFxuICAgICAgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICAgICAgICBrZXk6IGZ1bmN0aW9uIChuYXRpdmVFdmVudCkge1xuICAgICAgICAgIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgICAgICAgICBpZiAoXCJVbmlkZW50aWZpZWRcIiAhPT0ga2V5KSByZXR1cm4ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJrZXlwcmVzc1wiID09PSBuYXRpdmVFdmVudC50eXBlXG4gICAgICAgICAgICA/ICgobmF0aXZlRXZlbnQgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSksXG4gICAgICAgICAgICAgIDEzID09PSBuYXRpdmVFdmVudCA/IFwiRW50ZXJcIiA6IFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQpKVxuICAgICAgICAgICAgOiBcImtleWRvd25cIiA9PT0gbmF0aXZlRXZlbnQudHlwZSB8fCBcImtleXVwXCIgPT09IG5hdGl2ZUV2ZW50LnR5cGVcbiAgICAgICAgICAgICAgPyB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCBcIlVuaWRlbnRpZmllZFwiXG4gICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgY29kZTogMCxcbiAgICAgICAgbG9jYXRpb246IDAsXG4gICAgICAgIGN0cmxLZXk6IDAsXG4gICAgICAgIHNoaWZ0S2V5OiAwLFxuICAgICAgICBhbHRLZXk6IDAsXG4gICAgICAgIG1ldGFLZXk6IDAsXG4gICAgICAgIHJlcGVhdDogMCxcbiAgICAgICAgbG9jYWxlOiAwLFxuICAgICAgICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gICAgICAgIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlwcmVzc1wiID09PSBldmVudC50eXBlID8gZ2V0RXZlbnRDaGFyQ29kZShldmVudCkgOiAwO1xuICAgICAgICB9LFxuICAgICAgICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlkb3duXCIgPT09IGV2ZW50LnR5cGUgfHwgXCJrZXl1cFwiID09PSBldmVudC50eXBlXG4gICAgICAgICAgICA/IGV2ZW50LmtleUNvZGVcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgfSxcbiAgICAgICAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBcImtleXByZXNzXCIgPT09IGV2ZW50LnR5cGVcbiAgICAgICAgICAgID8gZ2V0RXZlbnRDaGFyQ29kZShldmVudClcbiAgICAgICAgICAgIDogXCJrZXlkb3duXCIgPT09IGV2ZW50LnR5cGUgfHwgXCJrZXl1cFwiID09PSBldmVudC50eXBlXG4gICAgICAgICAgICAgID8gZXZlbnQua2V5Q29kZVxuICAgICAgICAgICAgICA6IDA7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpLFxuICAgICAgUG9pbnRlckV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gICAgICAgIHBvaW50ZXJJZDogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgcHJlc3N1cmU6IDAsXG4gICAgICAgIHRhbmdlbnRpYWxQcmVzc3VyZTogMCxcbiAgICAgICAgdGlsdFg6IDAsXG4gICAgICAgIHRpbHRZOiAwLFxuICAgICAgICB0d2lzdDogMCxcbiAgICAgICAgcG9pbnRlclR5cGU6IDAsXG4gICAgICAgIGlzUHJpbWFyeTogMFxuICAgICAgfSksXG4gICAgICBTeW50aGV0aWNQb2ludGVyRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChQb2ludGVyRXZlbnRJbnRlcmZhY2UpLFxuICAgICAgVG91Y2hFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICAgICAgICB0b3VjaGVzOiAwLFxuICAgICAgICB0YXJnZXRUb3VjaGVzOiAwLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlczogMCxcbiAgICAgICAgYWx0S2V5OiAwLFxuICAgICAgICBtZXRhS2V5OiAwLFxuICAgICAgICBjdHJsS2V5OiAwLFxuICAgICAgICBzaGlmdEtleTogMCxcbiAgICAgICAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG4gICAgICB9KSxcbiAgICAgIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUb3VjaEV2ZW50SW50ZXJmYWNlKSxcbiAgICAgIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgICAgICAgcHJvcGVydHlOYW1lOiAwLFxuICAgICAgICBlbGFwc2VkVGltZTogMCxcbiAgICAgICAgcHNldWRvRWxlbWVudDogMFxuICAgICAgfSksXG4gICAgICBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpLFxuICAgICAgV2hlZWxFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwge1xuICAgICAgICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBcImRlbHRhWFwiIGluIGV2ZW50XG4gICAgICAgICAgICA/IGV2ZW50LmRlbHRhWFxuICAgICAgICAgICAgOiBcIndoZWVsRGVsdGFYXCIgaW4gZXZlbnRcbiAgICAgICAgICAgICAgPyAtZXZlbnQud2hlZWxEZWx0YVhcbiAgICAgICAgICAgICAgOiAwO1xuICAgICAgICB9LFxuICAgICAgICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBcImRlbHRhWVwiIGluIGV2ZW50XG4gICAgICAgICAgICA/IGV2ZW50LmRlbHRhWVxuICAgICAgICAgICAgOiBcIndoZWVsRGVsdGFZXCIgaW4gZXZlbnRcbiAgICAgICAgICAgICAgPyAtZXZlbnQud2hlZWxEZWx0YVlcbiAgICAgICAgICAgICAgOiBcIndoZWVsRGVsdGFcIiBpbiBldmVudFxuICAgICAgICAgICAgICAgID8gLWV2ZW50LndoZWVsRGVsdGFcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbHRhWjogMCxcbiAgICAgICAgZGVsdGFNb2RlOiAwXG4gICAgICB9KSxcbiAgICAgIFN5bnRoZXRpY1doZWVsRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChXaGVlbEV2ZW50SW50ZXJmYWNlKSxcbiAgICAgIFRvZ2dsZUV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICAgICAgICBuZXdTdGF0ZTogMCxcbiAgICAgICAgb2xkU3RhdGU6IDBcbiAgICAgIH0pLFxuICAgICAgU3ludGhldGljVG9nZ2xlRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUb2dnbGVFdmVudEludGVyZmFjZSksXG4gICAgICBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl0sXG4gICAgICBTVEFSVF9LRVlDT0RFID0gMjI5LFxuICAgICAgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IGNhblVzZURPTSAmJiBcIkNvbXBvc2l0aW9uRXZlbnRcIiBpbiB3aW5kb3csXG4gICAgICBkb2N1bWVudE1vZGUgPSBudWxsO1xuICAgIGNhblVzZURPTSAmJlxuICAgICAgXCJkb2N1bWVudE1vZGVcIiBpbiBkb2N1bWVudCAmJlxuICAgICAgKGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG4gICAgdmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID1cbiAgICAgICAgY2FuVXNlRE9NICYmIFwiVGV4dEV2ZW50XCIgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUsXG4gICAgICB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9XG4gICAgICAgIGNhblVzZURPTSAmJlxuICAgICAgICAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHxcbiAgICAgICAgICAoZG9jdW1lbnRNb2RlICYmIDggPCBkb2N1bWVudE1vZGUgJiYgMTEgPj0gZG9jdW1lbnRNb2RlKSksXG4gICAgICBTUEFDRUJBUl9DT0RFID0gMzIsXG4gICAgICBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKSxcbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSAhMSxcbiAgICAgIGlzQ29tcG9zaW5nID0gITEsXG4gICAgICBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICAgICAgICBjb2xvcjogITAsXG4gICAgICAgIGRhdGU6ICEwLFxuICAgICAgICBkYXRldGltZTogITAsXG4gICAgICAgIFwiZGF0ZXRpbWUtbG9jYWxcIjogITAsXG4gICAgICAgIGVtYWlsOiAhMCxcbiAgICAgICAgbW9udGg6ICEwLFxuICAgICAgICBudW1iZXI6ICEwLFxuICAgICAgICBwYXNzd29yZDogITAsXG4gICAgICAgIHJhbmdlOiAhMCxcbiAgICAgICAgc2VhcmNoOiAhMCxcbiAgICAgICAgdGVsOiAhMCxcbiAgICAgICAgdGV4dDogITAsXG4gICAgICAgIHRpbWU6ICEwLFxuICAgICAgICB1cmw6ICEwLFxuICAgICAgICB3ZWVrOiAhMFxuICAgICAgfSxcbiAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGwsXG4gICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbCxcbiAgICAgIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9ICExO1xuICAgIGNhblVzZURPTSAmJlxuICAgICAgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9XG4gICAgICAgIGlzRXZlbnRTdXBwb3J0ZWQoXCJpbnB1dFwiKSAmJlxuICAgICAgICAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA5IDwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSk7XG4gICAgdmFyIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXMsXG4gICAgICBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPVxuICAgICAgICBjYW5Vc2VET00gJiYgXCJkb2N1bWVudE1vZGVcIiBpbiBkb2N1bWVudCAmJiAxMSA+PSBkb2N1bWVudC5kb2N1bWVudE1vZGUsXG4gICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbCxcbiAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbCxcbiAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsLFxuICAgICAgbW91c2VEb3duID0gITEsXG4gICAgICB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgICAgICAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKFwiQW5pbWF0aW9uXCIsIFwiQW5pbWF0aW9uRW5kXCIpLFxuICAgICAgICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoXCJBbmltYXRpb25cIiwgXCJBbmltYXRpb25JdGVyYXRpb25cIiksXG4gICAgICAgIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKFwiQW5pbWF0aW9uXCIsIFwiQW5pbWF0aW9uU3RhcnRcIiksXG4gICAgICAgIHRyYW5zaXRpb25ydW46IG1ha2VQcmVmaXhNYXAoXCJUcmFuc2l0aW9uXCIsIFwiVHJhbnNpdGlvblJ1blwiKSxcbiAgICAgICAgdHJhbnNpdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKFwiVHJhbnNpdGlvblwiLCBcIlRyYW5zaXRpb25TdGFydFwiKSxcbiAgICAgICAgdHJhbnNpdGlvbmNhbmNlbDogbWFrZVByZWZpeE1hcChcIlRyYW5zaXRpb25cIiwgXCJUcmFuc2l0aW9uQ2FuY2VsXCIpLFxuICAgICAgICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKFwiVHJhbnNpdGlvblwiLCBcIlRyYW5zaXRpb25FbmRcIilcbiAgICAgIH0sXG4gICAgICBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fSxcbiAgICAgIHN0eWxlID0ge307XG4gICAgY2FuVXNlRE9NICYmXG4gICAgICAoKHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSksXG4gICAgICBcIkFuaW1hdGlvbkV2ZW50XCIgaW4gd2luZG93IHx8XG4gICAgICAgIChkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbixcbiAgICAgICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb24sXG4gICAgICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb24pLFxuICAgICAgXCJUcmFuc2l0aW9uRXZlbnRcIiBpbiB3aW5kb3cgfHxcbiAgICAgICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7XG4gICAgdmFyIEFOSU1BVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcImFuaW1hdGlvbmVuZFwiKSxcbiAgICAgIEFOSU1BVElPTl9JVEVSQVRJT04gPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcImFuaW1hdGlvbml0ZXJhdGlvblwiKSxcbiAgICAgIEFOSU1BVElPTl9TVEFSVCA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwiYW5pbWF0aW9uc3RhcnRcIiksXG4gICAgICBUUkFOU0lUSU9OX1JVTiA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwidHJhbnNpdGlvbnJ1blwiKSxcbiAgICAgIFRSQU5TSVRJT05fU1RBUlQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcInRyYW5zaXRpb25zdGFydFwiKSxcbiAgICAgIFRSQU5TSVRJT05fQ0FOQ0VMID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoXCJ0cmFuc2l0aW9uY2FuY2VsXCIpLFxuICAgICAgVFJBTlNJVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcInRyYW5zaXRpb25lbmRcIiksXG4gICAgICB0b3BMZXZlbEV2ZW50c1RvUmVhY3ROYW1lcyA9IG5ldyBNYXAoKSxcbiAgICAgIHNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzID1cbiAgICAgICAgXCJhYm9ydCBhdXhDbGljayBiZWZvcmVUb2dnbGUgY2FuY2VsIGNhblBsYXkgY2FuUGxheVRocm91Z2ggY2xpY2sgY2xvc2UgY29udGV4dE1lbnUgY29weSBjdXQgZHJhZyBkcmFnRW5kIGRyYWdFbnRlciBkcmFnRXhpdCBkcmFnTGVhdmUgZHJhZ092ZXIgZHJhZ1N0YXJ0IGRyb3AgZHVyYXRpb25DaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgZ290UG9pbnRlckNhcHR1cmUgaW5wdXQgaW52YWxpZCBrZXlEb3duIGtleVByZXNzIGtleVVwIGxvYWQgbG9hZGVkRGF0YSBsb2FkZWRNZXRhZGF0YSBsb2FkU3RhcnQgbG9zdFBvaW50ZXJDYXB0dXJlIG1vdXNlRG93biBtb3VzZU1vdmUgbW91c2VPdXQgbW91c2VPdmVyIG1vdXNlVXAgcGFzdGUgcGF1c2UgcGxheSBwbGF5aW5nIHBvaW50ZXJDYW5jZWwgcG9pbnRlckRvd24gcG9pbnRlck1vdmUgcG9pbnRlck91dCBwb2ludGVyT3ZlciBwb2ludGVyVXAgcHJvZ3Jlc3MgcmF0ZUNoYW5nZSByZXNldCByZXNpemUgc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdWJtaXQgc3VzcGVuZCB0aW1lVXBkYXRlIHRvdWNoQ2FuY2VsIHRvdWNoRW5kIHRvdWNoU3RhcnQgdm9sdW1lQ2hhbmdlIHNjcm9sbCB0b2dnbGUgdG91Y2hNb3ZlIHdhaXRpbmcgd2hlZWxcIi5zcGxpdChcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApO1xuICAgIHNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzLnB1c2goXCJzY3JvbGxFbmRcIik7XG4gICAgdmFyIENhcHR1cmVkU3RhY2tzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIE9mZnNjcmVlblZpc2libGUgPSAxLFxuICAgICAgT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQgPSAyLFxuICAgICAgY29uY3VycmVudFF1ZXVlcyA9IFtdLFxuICAgICAgY29uY3VycmVudFF1ZXVlc0luZGV4ID0gMCxcbiAgICAgIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyA9IDAsXG4gICAgICBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcbiAgICBPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7XG4gICAgdmFyIHJlc29sdmVGYW1pbHkgPSBudWxsLFxuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGwsXG4gICAgICBOb01vZGUgPSAwLFxuICAgICAgQ29uY3VycmVudE1vZGUgPSAxLFxuICAgICAgUHJvZmlsZU1vZGUgPSAyLFxuICAgICAgU3RyaWN0TGVnYWN5TW9kZSA9IDgsXG4gICAgICBTdHJpY3RFZmZlY3RzTW9kZSA9IDE2LFxuICAgICAgTm9TdHJpY3RQYXNzaXZlRWZmZWN0c01vZGUgPSA2NCxcbiAgICAgIFN1c3BlbnNleUltYWdlc01vZGUgPSAzMjtcbiAgICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSAhMTtcbiAgICB0cnkge1xuICAgICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgICBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgfSBjYXRjaCAoZSQzKSB7XG4gICAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9ICEwO1xuICAgIH1cbiAgICB2YXIgZm9ya1N0YWNrID0gW10sXG4gICAgICBmb3JrU3RhY2tJbmRleCA9IDAsXG4gICAgICB0cmVlRm9ya1Byb3ZpZGVyID0gbnVsbCxcbiAgICAgIHRyZWVGb3JrQ291bnQgPSAwLFxuICAgICAgaWRTdGFjayA9IFtdLFxuICAgICAgaWRTdGFja0luZGV4ID0gMCxcbiAgICAgIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBudWxsLFxuICAgICAgdHJlZUNvbnRleHRJZCA9IDEsXG4gICAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gXCJcIixcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbCxcbiAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsLFxuICAgICAgaXNIeWRyYXRpbmcgPSAhMSxcbiAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWID0gITEsXG4gICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwsXG4gICAgICBoeWRyYXRpb25FcnJvcnMgPSBudWxsLFxuICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExLFxuICAgICAgSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJIeWRyYXRpb24gTWlzbWF0Y2ggRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IsIGFuZCBzaG91bGQgbm90IGxlYWsgaW50byB1c2Vyc3BhY2UuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgaXQncyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICksXG4gICAgICBsYXN0UmVzZXRUaW1lID0gMDtcbiAgICBpZiAoXG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2UgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlLm5vd1xuICAgICkge1xuICAgICAgdmFyIGxvY2FsUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcbiAgICAgIHZhciBnZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsUGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYWxEYXRlID0gRGF0ZTtcbiAgICAgIGdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHZhbHVlQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xuICAgIHZhciByZW5kZXJlckN1cnNvckRFViA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgICB2YXIgcmVuZGVyZXJTaWdpbCA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbCxcbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGwsXG4gICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITEsXG4gICAgICBBYm9ydENvbnRyb2xsZXJMb2NhbCA9XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICA/IEFib3J0Q29udHJvbGxlclxuICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gW10sXG4gICAgICAgICAgICAgICAgc2lnbmFsID0gKHRoaXMuc2lnbmFsID0ge1xuICAgICAgICAgICAgICAgICAgYWJvcnRlZDogITEsXG4gICAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNpZ25hbC5hYm9ydGVkID0gITA7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDIgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxcbiAgICAgIE5vcm1hbFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgICAgQ2FjaGVDb250ZXh0ID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgICBDb25zdW1lcjogbnVsbCxcbiAgICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICAgIF9jdXJyZW50VmFsdWU6IG51bGwsXG4gICAgICAgIF9jdXJyZW50VmFsdWUyOiBudWxsLFxuICAgICAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgICAgIF9jdXJyZW50UmVuZGVyZXI6IG51bGwsXG4gICAgICAgIF9jdXJyZW50UmVuZGVyZXIyOiBudWxsXG4gICAgICB9LFxuICAgICAgbm93ID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgICAgIHJlbmRlclN0YXJ0VGltZSA9IC0wLFxuICAgICAgY29tbWl0U3RhcnRUaW1lID0gLTAsXG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xLjEsXG4gICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uID0gLTAsXG4gICAgICBjb21wb25lbnRFZmZlY3RTdGFydFRpbWUgPSAtMS4xLFxuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gITEsXG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBudWxsLFxuICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDAsXG4gICAgICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IDAsXG4gICAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBudWxsLFxuICAgICAgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5TID0gZnVuY3Rpb24gKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiAmJlxuICAgICAgICBlbnRhbmdsZUFzeW5jQWN0aW9uKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgIG51bGwgIT09IHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgICBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2godHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgIH07XG4gICAgdmFyIHJlc3VtZWRDYWNoZSA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICAgICAgICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbiAgICAgIH0sXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdLFxuICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChcbiAgICAgIGZpYmVyLFxuICAgICAgaW5zdGFuY2VcbiAgICApIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpIHx8XG4gICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgJiZcbiAgICAgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAhMCAhPT1cbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAmJlxuICAgICAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgJiZcbiAgICAgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcikpO1xuICAgIH07XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKFxuICAgICAgICAgIGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSkpO1xuICAgICAgaWYgKDAgPCBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSkge1xuICAgICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgMCA8IFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lc1xuICAgICAgICApKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgcmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kZXJpdmVkLXN0YXRlXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzXG4gICAgICAgICkpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpKSxcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbiogUmVuYW1lIGNvbXBvbmVudFdpbGxNb3VudCB0byBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IHRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuIFRvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFxuICAgICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lc1xuICAgICAgICApKSxcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0LmRldi9saW5rL2Rlcml2ZWQtc3RhdGVcXG4qIFJlbmFtZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuIFRvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcykpLFxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJjb21wb25lbnRXaWxsVXBkYXRlIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4qIFJlbmFtZSBjb21wb25lbnRXaWxsVXBkYXRlIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIHRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuIFRvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgfTtcbiAgICB2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpLFxuICAgICAgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCA9IG5ldyBTZXQoKTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChcbiAgICAgIGZpYmVyLFxuICAgICAgaW5zdGFuY2VcbiAgICApIHtcbiAgICAgIHZhciBzdHJpY3RSb290ID0gbnVsbDtcbiAgICAgIGZvciAodmFyIG5vZGUgPSBmaWJlcjsgbnVsbCAhPT0gbm9kZTsgKVxuICAgICAgICBub2RlLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIChzdHJpY3RSb290ID0gbm9kZSksXG4gICAgICAgICAgKG5vZGUgPSBub2RlLnJldHVybik7XG4gICAgICBudWxsID09PSBzdHJpY3RSb290XG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgIClcbiAgICAgICAgOiAhZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5oYXMoZmliZXIudHlwZSkgJiZcbiAgICAgICAgICAoKG5vZGUgPSBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpKSxcbiAgICAgICAgICBudWxsICE9IGZpYmVyLnR5cGUuY29udGV4dFR5cGVzIHx8XG4gICAgICAgICAgICBudWxsICE9IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgfHxcbiAgICAgICAgICAgIChudWxsICE9PSBpbnN0YW5jZSAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQpKSAmJlxuICAgICAgICAgICh2b2lkIDAgPT09IG5vZGUgJiZcbiAgICAgICAgICAgICgobm9kZSA9IFtdKSwgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLnNldChzdHJpY3RSb290LCBub2RlKSksXG4gICAgICAgICAgbm9kZS5wdXNoKGZpYmVyKSk7XG4gICAgfTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyQXJyYXkpIHtcbiAgICAgICAgaWYgKDAgIT09IGZpYmVyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGZpcnN0RmliZXIgPSBmaWJlckFycmF5WzBdLFxuICAgICAgICAgICAgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgZmliZXJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCIpO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpcnN0RmliZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuXFxuXFxuVGhlIG9sZCBBUEkgd2lsbCBiZSBzdXBwb3J0ZWQgaW4gYWxsIDE2LnggcmVsZWFzZXMsIGJ1dCBhcHBsaWNhdGlvbnMgdXNpbmcgaXQgc2hvdWxkIG1pZ3JhdGUgdG8gdGhlIG5ldyB2ZXJzaW9uLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHRcIixcbiAgICAgICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG4gICAgfTtcbiAgICB2YXIgU3VzcGVuc2VFeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJTdXNwZW5zZSBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciEgSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgYHVzZWAgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlci4gWW91IG11c3QgZWl0aGVyIHJldGhyb3cgaXQgaW1tZWRpYXRlbHksIG9yIG1vdmUgdGhlIGB1c2VgIGNhbGwgb3V0c2lkZSBvZiB0aGUgYHRyeS9jYXRjaGAgYmxvY2suIENhcHR1cmluZyB3aXRob3V0IHJldGhyb3dpbmcgd2lsbCBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXFxuXFxuVG8gaGFuZGxlIGFzeW5jIGVycm9ycywgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhbiBlcnJvciBib3VuZGFyeSwgb3IgY2FsbCB0aGUgcHJvbWlzZSdzIGAuY2F0Y2hgIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGB1c2VgLlwiXG4gICAgICApLFxuICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IsIGFuZCBzaG91bGQgbm90IGxlYWsgaW50byB1c2Vyc3BhY2UuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgaXQncyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICksXG4gICAgICBTdXNwZW5zZUFjdGlvbkV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yISBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBgdXNlQWN0aW9uU3RhdGVgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciByZXRocm93IGl0IGltbWVkaWF0ZWx5LCBvciBtb3ZlIHRoZSBgdXNlQWN0aW9uU3RhdGVgIGNhbGwgb3V0c2lkZSBvZiB0aGUgYHRyeS9jYXRjaGAgYmxvY2suIENhcHR1cmluZyB3aXRob3V0IHJldGhyb3dpbmcgd2lsbCBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXFxuXFxuVG8gaGFuZGxlIGFzeW5jIGVycm9ycywgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhbiBlcnJvciBib3VuZGFyeS5cIlxuICAgICAgKSxcbiAgICAgIG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSA9IHtcbiAgICAgICAgdGhlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEEgbGlzdGVuZXIgd2FzIHVuZXhwZWN0ZWRseSBhdHRhY2hlZCB0byBhIFwibm9vcFwiIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbCxcbiAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITEsXG4gICAgICBjYWxsQ29tcG9uZW50ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gICAgICAgICAgdmFyIHdhc1JlbmRlcmluZyA9IGlzUmVuZGVyaW5nO1xuICAgICAgICAgIGlzUmVuZGVyaW5nID0gITA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlzUmVuZGVyaW5nID0gd2FzUmVuZGVyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnRJbkRFViA9XG4gICAgICAgIGNhbGxDb21wb25lbnRbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsQ29tcG9uZW50KSxcbiAgICAgIGNhbGxSZW5kZXIgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIHZhciB3YXNSZW5kZXJpbmcgPSBpc1JlbmRlcmluZztcbiAgICAgICAgICBpc1JlbmRlcmluZyA9ICEwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlzUmVuZGVyaW5nID0gd2FzUmVuZGVyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxSZW5kZXJJbkRFViA9IGNhbGxSZW5kZXJbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsUmVuZGVyKSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGZpbmlzaGVkV29yaywgaW5zdGFuY2UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYgPSBjYWxsQ29tcG9uZW50RGlkTW91bnRbXG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJcbiAgICAgIF0uYmluZChjYWxsQ29tcG9uZW50RGlkTW91bnQpLFxuICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZSA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgcHJldlN0YXRlLFxuICAgICAgICAgIHNuYXBzaG90XG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIHNuYXBzaG90KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWID0gY2FsbENvbXBvbmVudERpZFVwZGF0ZVtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIlxuICAgICAgXS5iaW5kKGNhbGxDb21wb25lbnREaWRVcGRhdGUpLFxuICAgICAgY2FsbENvbXBvbmVudERpZENhdGNoID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGVycm9ySW5mbykge1xuICAgICAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaChlcnJvckluZm8udmFsdWUsIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiBudWxsICE9PSBzdGFjayA/IHN0YWNrIDogXCJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudERpZENhdGNoSW5ERVYgPSBjYWxsQ29tcG9uZW50RGlkQ2F0Y2hbXG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJcbiAgICAgIF0uYmluZChjYWxsQ29tcG9uZW50RGlkQ2F0Y2gpLFxuICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50SW5ERVYgPSBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRbXG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJcbiAgICAgIF0uYmluZChjYWxsQ29tcG9uZW50V2lsbFVubW91bnQpLFxuICAgICAgY2FsbENyZWF0ZSA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGVmZmVjdCkge1xuICAgICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICAgICAgICAgIGVmZmVjdCA9IGVmZmVjdC5pbnN0O1xuICAgICAgICAgIGNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgICAgICAgIHJldHVybiAoZWZmZWN0LmRlc3Ryb3kgPSBjcmVhdGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENyZWF0ZUluREVWID0gY2FsbENyZWF0ZVtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxDcmVhdGUpLFxuICAgICAgY2FsbERlc3Ryb3kgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgZGVzdHJveVxuICAgICAgICApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbERlc3Ryb3lJbkRFViA9XG4gICAgICAgIGNhbGxEZXN0cm95W1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbERlc3Ryb3kpLFxuICAgICAgY2FsbExhenlJbml0ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAobGF6eSkge1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eS5faW5pdDtcbiAgICAgICAgICByZXR1cm4gaW5pdChsYXp5Ll9wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxMYXp5SW5pdEluREVWID1cbiAgICAgICAgY2FsbExhenlJbml0W1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbExhenlJbml0KSxcbiAgICAgIHRoZW5hYmxlU3RhdGUkMSA9IG51bGwsXG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMCxcbiAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBudWxsLFxuICAgICAgZGlkV2FybkFib3V0TWFwcztcbiAgICB2YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IChkaWRXYXJuQWJvdXRNYXBzID0gITEpO1xuICAgIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICB2YXIgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG4gICAgdmFyIG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmcgPSB7fTtcbiAgICB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChyZXR1cm5GaWJlciwgd29ya0luUHJvZ3Jlc3MsIGNoaWxkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IGNoaWxkICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjaGlsZCAmJlxuICAgICAgICBjaGlsZC5fc3RvcmUgJiZcbiAgICAgICAgKCghY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCAmJiBudWxsID09IGNoaWxkLmtleSkgfHxcbiAgICAgICAgICAyID09PSBjaGlsZC5fc3RvcmUudmFsaWRhdGVkKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgY2hpbGQuX3N0b3JlKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gMTtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSxcbiAgICAgICAgICBjb21wb25lbnRLZXkgPSBjb21wb25lbnROYW1lIHx8IFwibnVsbFwiO1xuICAgICAgICBpZiAoIW93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnRLZXldKSB7XG4gICAgICAgICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudEtleV0gPSAhMDtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLl9vd25lcjtcbiAgICAgICAgICByZXR1cm5GaWJlciA9IHJldHVybkZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gXCJcIjtcbiAgICAgICAgICByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHJldHVybkZpYmVyLnRhZyAmJlxuICAgICAgICAgICAgKGNvbXBvbmVudEtleSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpKSAmJlxuICAgICAgICAgICAgKGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPVxuICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIGNvbXBvbmVudEtleSArIFwiYC5cIik7XG4gICAgICAgICAgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyB8fFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgKGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPVxuICAgICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgK1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPi5cIikpO1xuICAgICAgICAgIHZhciBjaGlsZE93bmVyQXBwZW5kaXggPSBcIlwiO1xuICAgICAgICAgIG51bGwgIT0gY2hpbGQgJiZcbiAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBjaGlsZCAmJlxuICAgICAgICAgICAgKChjb21wb25lbnROYW1lID0gbnVsbCksXG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2hpbGQudGFnXG4gICAgICAgICAgICAgID8gKGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGNoaWxkKSlcbiAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGQubmFtZSAmJiAoY29tcG9uZW50TmFtZSA9IGNoaWxkLm5hbWUpLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lckFwcGVuZGl4ID1cbiAgICAgICAgICAgICAgICBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGNvbXBvbmVudE5hbWUgKyBcIi5cIikpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKHdvcmtJblByb2dyZXNzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgICAgIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sXG4gICAgICAgICAgICAgIGNoaWxkT3duZXJBcHBlbmRpeFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKCEwKSxcbiAgICAgIG1vdW50Q2hpbGRGaWJlcnMgPSBjcmVhdGVDaGlsZFJlY29uY2lsZXIoITEpLFxuICAgICAgVXBkYXRlU3RhdGUgPSAwLFxuICAgICAgUmVwbGFjZVN0YXRlID0gMSxcbiAgICAgIEZvcmNlVXBkYXRlID0gMixcbiAgICAgIENhcHR1cmVVcGRhdGUgPSAzLFxuICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICB2YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9ICExO1xuICAgIHZhciBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICAgIHZhciBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITEsXG4gICAgICBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKDApLFxuICAgICAgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBzaGVsbEJvdW5kYXJ5ID0gbnVsbCxcbiAgICAgIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrID0gMSxcbiAgICAgIEZvcmNlU3VzcGVuc2VGYWxsYmFjayA9IDIsXG4gICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKDApLFxuICAgICAgTm9GbGFncyA9IDAsXG4gICAgICBIYXNFZmZlY3QgPSAxLFxuICAgICAgSW5zZXJ0aW9uID0gMixcbiAgICAgIExheW91dCA9IDQsXG4gICAgICBQYXNzaXZlID0gOCxcbiAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90O1xuICAgIHZhciBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciByZW5kZXJMYW5lcyA9IDAsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGwsXG4gICAgICBjdXJyZW50SG9vayA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsLFxuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExLFxuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITEsXG4gICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9ICExLFxuICAgICAgbG9jYWxJZENvdW50ZXIgPSAwLFxuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwLFxuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGwsXG4gICAgICBnbG9iYWxDbGllbnRJZENvdW50ZXIgPSAwLFxuICAgICAgUkVfUkVOREVSX0xJTUlUID0gMjUsXG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGwsXG4gICAgICBob29rVHlwZXNEZXYgPSBudWxsLFxuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMSxcbiAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gITEsXG4gICAgICBDb250ZXh0T25seURpc3BhdGNoZXIgPSB7XG4gICAgICAgIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgICAgICAgdXNlOiB1c2UsXG4gICAgICAgIHVzZUNhbGxiYWNrOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZUNvbnRleHQ6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgICAgdXNlRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgICAgdXNlUmVmOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZUlkOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZUZvcm1TdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VBY3Rpb25TdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VPcHRpbWlzdGljOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICAgIHVzZU1lbW9DYWNoZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgICB1c2VDYWNoZVJlZnJlc2g6IHRocm93SW52YWxpZEhvb2tFcnJvclxuICAgICAgfSxcbiAgICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGwsXG4gICAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0gbnVsbCxcbiAgICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsLFxuICAgICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbCxcbiAgICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsLFxuICAgICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsLFxuICAgICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICBtb3VudEVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICAgIH0sXG4gICAgICB1c2VGb3JtU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0sXG4gICAgICB1c2VBY3Rpb25TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgICB9LFxuICAgICAgdXNlT3B0aW1pc3RpYzogZnVuY3Rpb24gKHBhc3N0aHJvdWdoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgICAgfSxcbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzOiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cyxcbiAgICAgIHVzZU1lbW9DYWNoZTogdXNlTWVtb0NhY2hlLFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIG1vdW50RWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgICB9LFxuICAgICAgdXNlQWN0aW9uU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0sXG4gICAgICB1c2VGb3JtU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgICB9LFxuICAgICAgdXNlT3B0aW1pc3RpYzogZnVuY3Rpb24gKHBhc3N0aHJvdWdoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICAgIH0sXG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1czogdXNlSG9zdFRyYW5zaXRpb25TdGF0dXMsXG4gICAgICB1c2VNZW1vQ2FjaGU6IHVzZU1lbW9DYWNoZSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUZvcm1TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICAgIH0sXG4gICAgICB1c2VBY3Rpb25TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgICAgfSxcbiAgICAgIHVzZU9wdGltaXN0aWM6IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgICAgfSxcbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzOiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cyxcbiAgICAgIHVzZU1lbW9DYWNoZTogdXNlTWVtb0NhY2hlLFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfVxuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlRm9ybVN0YXRlOiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgICB9LFxuICAgICAgdXNlQWN0aW9uU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgICAgfSxcbiAgICAgIHVzZU9wdGltaXN0aWM6IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgICB9LFxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM6IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzLFxuICAgICAgdXNlTWVtb0NhY2hlOiB1c2VNZW1vQ2FjaGUsXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBtb3VudEVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUZvcm1TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0sXG4gICAgICB1c2VBY3Rpb25TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgICAgfSxcbiAgICAgIHVzZU9wdGltaXN0aWM6IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtb0NhY2hlOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICAgIH0sXG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1czogdXNlSG9zdFRyYW5zaXRpb25TdGF0dXMsXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUZvcm1TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgICB9LFxuICAgICAgdXNlQWN0aW9uU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgICB9LFxuICAgICAgdXNlT3B0aW1pc3RpYzogZnVuY3Rpb24gKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9LFxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM6IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzLFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfVxuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlRm9ybVN0YXRlOiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgICAgfSxcbiAgICAgIHVzZUFjdGlvblN0YXRlOiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgICB9LFxuICAgICAgdXNlT3B0aW1pc3RpYzogZnVuY3Rpb24gKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgICB9LFxuICAgICAgdXNlTWVtb0NhY2hlOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICAgIH0sXG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1czogdXNlSG9zdFRyYW5zaXRpb25TdGF0dXMsXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcbiAgICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbiAgICB2YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICAgICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGluc3QpLFxuICAgICAgICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayksICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgICAgIHBheWxvYWQgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gcGF5bG9hZCAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXlsb2FkLCBpbnN0LCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocGF5bG9hZCwgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcbiAgICAgICAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICh3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spLCAodXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2spKTtcbiAgICAgICAgICBwYXlsb2FkID0gZW5xdWV1ZVVwZGF0ZShpbnN0LCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICAgIG51bGwgIT09IHBheWxvYWQgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF5bG9hZCwgaW5zdCwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHBheWxvYWQsIGluc3QsIGxhbmUpKTtcbiAgICAgICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoaW5zdCwgbGFuZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAod2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSwgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICAgICAgY2FsbGJhY2sgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoY2FsbGJhY2ssIGluc3QsIGxhbmUpLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhjYWxsYmFjaywgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkICYmXG4gICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICAgICAgICA/IHJlcG9ydEVycm9yXG4gICAgICAgICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgY29tcG9uZW50TmFtZSA9IG51bGwsXG4gICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGwsXG4gICAgICBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IuIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIFJlYWN0J3Mgc2VsZWN0aXZlIGh5ZHJhdGlvbiBmZWF0dXJlLiBJZiB0aGlzIGxlYWtzIGludG8gdXNlcnNwYWNlLCBpdCdzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKSxcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0VGFpbE9wdGlvbnMgPSB7fTtcbiAgICB2YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgICAgICAgZGVoeWRyYXRlZDogbnVsbCxcbiAgICAgICAgdHJlZUNvbnRleHQ6IG51bGwsXG4gICAgICAgIHJldHJ5TGFuZTogMCxcbiAgICAgICAgaHlkcmF0aW9uRXJyb3JzOiBudWxsXG4gICAgICB9LFxuICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSAhMSxcbiAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbnVsbDtcbiAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gITEsXG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gITEsXG4gICAgICBuZWVkc0Zvcm1SZXNldCA9ICExLFxuICAgICAgUG9zc2libHlXZWFrU2V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha1NldCA/IFdlYWtTZXQgOiBTZXQsXG4gICAgICBuZXh0RWZmZWN0ID0gbnVsbCxcbiAgICAgIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGwsXG4gICAgICBpblByb2dyZXNzUm9vdCA9IG51bGwsXG4gICAgICBob3N0UGFyZW50ID0gbnVsbCxcbiAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExLFxuICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBudWxsLFxuICAgICAgc3VzcGVuc2V5Q29tbWl0RmxhZyA9IDgxOTIsXG4gICAgICBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyID0ge1xuICAgICAgICBnZXRDYWNoZUZvclR5cGU6IGZ1bmN0aW9uIChyZXNvdXJjZVR5cGUpIHtcbiAgICAgICAgICB2YXIgY2FjaGUgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpLFxuICAgICAgICAgICAgY2FjaGVGb3JUeXBlID0gY2FjaGUuZGF0YS5nZXQocmVzb3VyY2VUeXBlKTtcbiAgICAgICAgICB2b2lkIDAgPT09IGNhY2hlRm9yVHlwZSAmJlxuICAgICAgICAgICAgKChjYWNoZUZvclR5cGUgPSByZXNvdXJjZVR5cGUoKSksXG4gICAgICAgICAgICBjYWNoZS5kYXRhLnNldChyZXNvdXJjZVR5cGUsIGNhY2hlRm9yVHlwZSkpO1xuICAgICAgICAgIHJldHVybiBjYWNoZUZvclR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE93bmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuZm9yKSB7XG4gICAgICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgICAgIHN5bWJvbEZvcihcInNlbGVjdG9yLmNvbXBvbmVudFwiKTtcbiAgICAgIHN5bWJvbEZvcihcInNlbGVjdG9yLmhhc19wc2V1ZG9fY2xhc3NcIik7XG4gICAgICBzeW1ib2xGb3IoXCJzZWxlY3Rvci5yb2xlXCIpO1xuICAgICAgc3ltYm9sRm9yKFwic2VsZWN0b3IudGVzdF9pZFwiKTtcbiAgICAgIHN5bWJvbEZvcihcInNlbGVjdG9yLnRleHRcIik7XG4gICAgfVxuICAgIHZhciBjb21taXRIb29rcyA9IFtdLFxuICAgICAgUG9zc2libHlXZWFrTWFwID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXAsXG4gICAgICBOb0NvbnRleHQgPSAwLFxuICAgICAgUmVuZGVyQ29udGV4dCA9IDIsXG4gICAgICBDb21taXRDb250ZXh0ID0gNCxcbiAgICAgIFJvb3RJblByb2dyZXNzID0gMCxcbiAgICAgIFJvb3RGYXRhbEVycm9yZWQgPSAxLFxuICAgICAgUm9vdEVycm9yZWQgPSAyLFxuICAgICAgUm9vdFN1c3BlbmRlZCA9IDMsXG4gICAgICBSb290U3VzcGVuZGVkV2l0aERlbGF5ID0gNCxcbiAgICAgIFJvb3RTdXNwZW5kZWRBdFRoZVNoZWxsID0gNixcbiAgICAgIFJvb3RDb21wbGV0ZWQgPSA1LFxuICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IE5vQ29udGV4dCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDAsXG4gICAgICBOb3RTdXNwZW5kZWQgPSAwLFxuICAgICAgU3VzcGVuZGVkT25FcnJvciA9IDEsXG4gICAgICBTdXNwZW5kZWRPbkRhdGEgPSAyLFxuICAgICAgU3VzcGVuZGVkT25JbW1lZGlhdGUgPSAzLFxuICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZSA9IDQsXG4gICAgICBTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlID0gNSxcbiAgICAgIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSA9IDYsXG4gICAgICBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUgPSA3LFxuICAgICAgU3VzcGVuZGVkT25IeWRyYXRpb24gPSA4LFxuICAgICAgU3VzcGVuZGVkT25BY3Rpb24gPSA5LFxuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9ICExLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSAhMSxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICExLFxuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJblByb2dyZXNzLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSAhMSxcbiAgICAgIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSAwLFxuICAgICAgRkFMTEJBQ0tfVEhST1RUTEVfTVMgPSAzMDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gSW5maW5pdHksXG4gICAgICBSRU5ERVJfVElNRU9VVF9NUyA9IDUwMCxcbiAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsLFxuICAgICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsLFxuICAgICAgSU1NRURJQVRFX0NPTU1JVCA9IDAsXG4gICAgICBTVVNQRU5ERURfQ09NTUlUID0gMSxcbiAgICAgIFRIUk9UVExFRF9DT01NSVQgPSAyLFxuICAgICAgTk9fUEVORElOR19FRkZFQ1RTID0gMCxcbiAgICAgIFBFTkRJTkdfTVVUQVRJT05fUEhBU0UgPSAxLFxuICAgICAgUEVORElOR19MQVlPVVRfUEhBU0UgPSAyLFxuICAgICAgUEVORElOR19BRlRFUl9NVVRBVElPTl9QSEFTRSA9IDMsXG4gICAgICBQRU5ESU5HX1NQQVdORURfV09SSyA9IDQsXG4gICAgICBQRU5ESU5HX1BBU1NJVkVfUEhBU0UgPSA1LFxuICAgICAgcGVuZGluZ0VmZmVjdHNTdGF0dXMgPSAwLFxuICAgICAgcGVuZGluZ0VmZmVjdHNSb290ID0gbnVsbCxcbiAgICAgIHBlbmRpbmdGaW5pc2hlZFdvcmsgPSBudWxsLFxuICAgICAgcGVuZGluZ0VmZmVjdHNMYW5lcyA9IDAsXG4gICAgICBwZW5kaW5nRWZmZWN0c1JlbWFpbmluZ0xhbmVzID0gMCxcbiAgICAgIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsLFxuICAgICAgcGVuZGluZ1JlY292ZXJhYmxlRXJyb3JzID0gbnVsbCxcbiAgICAgIE5FU1RFRF9VUERBVEVfTElNSVQgPSA1MCxcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMCxcbiAgICAgIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGwsXG4gICAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMSxcbiAgICAgIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwLFxuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCxcbiAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsLFxuICAgICAgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITEsXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZmFrZUFjdENhbGxiYWNrTm9kZSQxID0ge30sXG4gICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsLFxuICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsLFxuICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9ICExLFxuICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITEsXG4gICAgICBpc0ZsdXNoaW5nV29yayA9ICExLFxuICAgICAgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSAwLFxuICAgICAgZmFrZUFjdENhbGxiYWNrTm9kZSA9IHt9O1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBzaW1wbGVFdmVudFBsdWdpbkV2ZW50c1tpXSxcbiAgICAgICAgICBkb21FdmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudE5hbWUuc2xpY2UoMSk7XG4gICAgICAgIHJlZ2lzdGVyU2ltcGxlRXZlbnQoZG9tRXZlbnROYW1lLCBcIm9uXCIgKyBldmVudE5hbWUpO1xuICAgICAgfVxuICAgICAgcmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fRU5ELCBcIm9uQW5pbWF0aW9uRW5kXCIpO1xuICAgICAgcmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fSVRFUkFUSU9OLCBcIm9uQW5pbWF0aW9uSXRlcmF0aW9uXCIpO1xuICAgICAgcmVnaXN0ZXJTaW1wbGVFdmVudChBTklNQVRJT05fU1RBUlQsIFwib25BbmltYXRpb25TdGFydFwiKTtcbiAgICAgIHJlZ2lzdGVyU2ltcGxlRXZlbnQoXCJkYmxjbGlja1wiLCBcIm9uRG91YmxlQ2xpY2tcIik7XG4gICAgICByZWdpc3RlclNpbXBsZUV2ZW50KFwiZm9jdXNpblwiLCBcIm9uRm9jdXNcIik7XG4gICAgICByZWdpc3RlclNpbXBsZUV2ZW50KFwiZm9jdXNvdXRcIiwgXCJvbkJsdXJcIik7XG4gICAgICByZWdpc3RlclNpbXBsZUV2ZW50KFRSQU5TSVRJT05fUlVOLCBcIm9uVHJhbnNpdGlvblJ1blwiKTtcbiAgICAgIHJlZ2lzdGVyU2ltcGxlRXZlbnQoVFJBTlNJVElPTl9TVEFSVCwgXCJvblRyYW5zaXRpb25TdGFydFwiKTtcbiAgICAgIHJlZ2lzdGVyU2ltcGxlRXZlbnQoVFJBTlNJVElPTl9DQU5DRUwsIFwib25UcmFuc2l0aW9uQ2FuY2VsXCIpO1xuICAgICAgcmVnaXN0ZXJTaW1wbGVFdmVudChUUkFOU0lUSU9OX0VORCwgXCJvblRyYW5zaXRpb25FbmRcIik7XG4gICAgfSkoKTtcbiAgICByZWdpc3RlckRpcmVjdEV2ZW50KFwib25Nb3VzZUVudGVyXCIsIFtcIm1vdXNlb3V0XCIsIFwibW91c2VvdmVyXCJdKTtcbiAgICByZWdpc3RlckRpcmVjdEV2ZW50KFwib25Nb3VzZUxlYXZlXCIsIFtcIm1vdXNlb3V0XCIsIFwibW91c2VvdmVyXCJdKTtcbiAgICByZWdpc3RlckRpcmVjdEV2ZW50KFwib25Qb2ludGVyRW50ZXJcIiwgW1wicG9pbnRlcm91dFwiLCBcInBvaW50ZXJvdmVyXCJdKTtcbiAgICByZWdpc3RlckRpcmVjdEV2ZW50KFwib25Qb2ludGVyTGVhdmVcIiwgW1wicG9pbnRlcm91dFwiLCBcInBvaW50ZXJvdmVyXCJdKTtcbiAgICByZWdpc3RlclR3b1BoYXNlRXZlbnQoXG4gICAgICBcIm9uQ2hhbmdlXCIsXG4gICAgICBcImNoYW5nZSBjbGljayBmb2N1c2luIGZvY3Vzb3V0IGlucHV0IGtleWRvd24ga2V5dXAgc2VsZWN0aW9uY2hhbmdlXCIuc3BsaXQoXG4gICAgICAgIFwiIFwiXG4gICAgICApXG4gICAgKTtcbiAgICByZWdpc3RlclR3b1BoYXNlRXZlbnQoXG4gICAgICBcIm9uU2VsZWN0XCIsXG4gICAgICBcImZvY3Vzb3V0IGNvbnRleHRtZW51IGRyYWdlbmQgZm9jdXNpbiBrZXlkb3duIGtleXVwIG1vdXNlZG93biBtb3VzZXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFxuICAgICAgICBcIiBcIlxuICAgICAgKVxuICAgICk7XG4gICAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KFwib25CZWZvcmVJbnB1dFwiLCBbXG4gICAgICBcImNvbXBvc2l0aW9uZW5kXCIsXG4gICAgICBcImtleXByZXNzXCIsXG4gICAgICBcInRleHRJbnB1dFwiLFxuICAgICAgXCJwYXN0ZVwiXG4gICAgXSk7XG4gICAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KFxuICAgICAgXCJvbkNvbXBvc2l0aW9uRW5kXCIsXG4gICAgICBcImNvbXBvc2l0aW9uZW5kIGZvY3Vzb3V0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpXG4gICAgKTtcbiAgICByZWdpc3RlclR3b1BoYXNlRXZlbnQoXG4gICAgICBcIm9uQ29tcG9zaXRpb25TdGFydFwiLFxuICAgICAgXCJjb21wb3NpdGlvbnN0YXJ0IGZvY3Vzb3V0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpXG4gICAgKTtcbiAgICByZWdpc3RlclR3b1BoYXNlRXZlbnQoXG4gICAgICBcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixcbiAgICAgIFwiY29tcG9zaXRpb251cGRhdGUgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIilcbiAgICApO1xuICAgIHZhciBtZWRpYUV2ZW50VHlwZXMgPVxuICAgICAgICBcImFib3J0IGNhbnBsYXkgY2FucGxheXRocm91Z2ggZHVyYXRpb25jaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgbG9hZGVkZGF0YSBsb2FkZWRtZXRhZGF0YSBsb2Fkc3RhcnQgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVjaGFuZ2UgcmVzaXplIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VzcGVuZCB0aW1ldXBkYXRlIHZvbHVtZWNoYW5nZSB3YWl0aW5nXCIuc3BsaXQoXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKSxcbiAgICAgIG5vbkRlbGVnYXRlZEV2ZW50cyA9IG5ldyBTZXQoXG4gICAgICAgIFwiYmVmb3JldG9nZ2xlIGNhbmNlbCBjbG9zZSBpbnZhbGlkIGxvYWQgc2Nyb2xsIHNjcm9sbGVuZCB0b2dnbGVcIlxuICAgICAgICAgIC5zcGxpdChcIiBcIilcbiAgICAgICAgICAuY29uY2F0KG1lZGlhRXZlbnRUeXBlcylcbiAgICAgICksXG4gICAgICBsaXN0ZW5pbmdNYXJrZXIgPSBcIl9yZWFjdExpc3RlbmluZ1wiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksXG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gITEsXG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gITEsXG4gICAgICBkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSA9ICExLFxuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSAhMSxcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gITEsXG4gICAgICBkaWRXYXJuUG9wb3ZlclRhcmdldE9iamVjdCA9ICExO1xuICAgIHZhciBkaWRXYXJuRm9yTmV3Qm9vbGVhblByb3BzV2l0aEVtcHR5VmFsdWUgPSB7fTtcbiAgICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZyxcbiAgICAgIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZyxcbiAgICAgIHhsaW5rTmFtZXNwYWNlID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgICB4bWxOYW1lc3BhY2UgPSBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICAgICAgRVhQRUNURURfRk9STV9BQ1RJT05fVVJMID1cbiAgICAgICAgXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignUmVhY3QgZm9ybSB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLicpXCIsXG4gICAgICBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9IFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIsXG4gICAgICBTVVNQRU5TRV9TVEFSVF9EQVRBID0gXCIkXCIsXG4gICAgICBTVVNQRU5TRV9FTkRfREFUQSA9IFwiLyRcIixcbiAgICAgIFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSA9IFwiJD9cIixcbiAgICAgIFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgPSBcIiQhXCIsXG4gICAgICBQUkVBTUJMRV9DT05UUklCVVRJT05fSFRNTCA9IDEsXG4gICAgICBQUkVBTUJMRV9DT05UUklCVVRJT05fQk9EWSA9IDIsXG4gICAgICBQUkVBTUJMRV9DT05UUklCVVRJT05fSEVBRCA9IDQsXG4gICAgICBGT1JNX1NUQVRFX0lTX01BVENISU5HID0gXCJGIVwiLFxuICAgICAgRk9STV9TVEFURV9JU19OT1RfTUFUQ0hJTkcgPSBcIkZcIixcbiAgICAgIERPQ1VNRU5UX1JFQURZX1NUQVRFX0NPTVBMRVRFID0gXCJjb21wbGV0ZVwiLFxuICAgICAgU1RZTEUgPSBcInN0eWxlXCIsXG4gICAgICBIb3N0Q29udGV4dE5hbWVzcGFjZU5vbmUgPSAwLFxuICAgICAgSG9zdENvbnRleHROYW1lc3BhY2VTdmcgPSAxLFxuICAgICAgSG9zdENvbnRleHROYW1lc3BhY2VNYXRoID0gMixcbiAgICAgIGV2ZW50c0VuYWJsZWQgPSBudWxsLFxuICAgICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsLFxuICAgICAgd2FybmVkVW5rbm93blRhZ3MgPSB7IGRpYWxvZzogITAsIHdlYnZpZXc6ICEwIH0sXG4gICAgICBjdXJyZW50UG9wc3RhdGVUcmFuc2l0aW9uRXZlbnQgPSBudWxsLFxuICAgICAgc2NoZWR1bGVUaW1lb3V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc2V0VGltZW91dCA/IHNldFRpbWVvdXQgOiB2b2lkIDAsXG4gICAgICBjYW5jZWxUaW1lb3V0ID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2xlYXJUaW1lb3V0ID8gY2xlYXJUaW1lb3V0IDogdm9pZCAwLFxuICAgICAgbm9UaW1lb3V0ID0gLTEsXG4gICAgICBsb2NhbFByb21pc2UgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBQcm9taXNlID8gUHJvbWlzZSA6IHZvaWQgMCxcbiAgICAgIHNjaGVkdWxlTWljcm90YXNrID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgICA/IHF1ZXVlTWljcm90YXNrXG4gICAgICAgICAgOiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgbG9jYWxQcm9taXNlXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFByb21pc2VcbiAgICAgICAgICAgICAgICAgIC5yZXNvbHZlKG51bGwpXG4gICAgICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChoYW5kbGVFcnJvckluTmV4dFRpY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHNjaGVkdWxlVGltZW91dCxcbiAgICAgIHByZXZpb3VzSHlkcmF0YWJsZU9uRW50ZXJpbmdTY29wZWRTaW5nbGV0b24gPSBudWxsLFxuICAgICAgTm90TG9hZGVkID0gMCxcbiAgICAgIExvYWRlZCA9IDEsXG4gICAgICBFcnJvcmVkID0gMixcbiAgICAgIFNldHRsZWQgPSAzLFxuICAgICAgSW5zZXJ0ZWQgPSA0LFxuICAgICAgcHJlbG9hZFByb3BzTWFwID0gbmV3IE1hcCgpLFxuICAgICAgcHJlY29ubmVjdHNTZXQgPSBuZXcgU2V0KCksXG4gICAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5kO1xuICAgIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmQgPSB7XG4gICAgICBmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1dhc1JlbmRlcmluZyA9IHByZXZpb3VzRGlzcGF0Y2hlci5mKCksXG4gICAgICAgICAgd2FzUmVuZGVyaW5nID0gZmx1c2hTeW5jV29yayQxKCk7XG4gICAgICAgIHJldHVybiBwcmV2aW91c1dhc1JlbmRlcmluZyB8fCB3YXNSZW5kZXJpbmc7XG4gICAgICB9LFxuICAgICAgcjogZnVuY3Rpb24gKGZvcm0pIHtcbiAgICAgICAgdmFyIGZvcm1JbnN0ID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShmb3JtKTtcbiAgICAgICAgbnVsbCAhPT0gZm9ybUluc3QgJiYgNSA9PT0gZm9ybUluc3QudGFnICYmIFwiZm9ybVwiID09PSBmb3JtSW5zdC50eXBlXG4gICAgICAgICAgPyByZXF1ZXN0Rm9ybVJlc2V0JDEoZm9ybUluc3QpXG4gICAgICAgICAgOiBwcmV2aW91c0Rpc3BhdGNoZXIucihmb3JtKTtcbiAgICAgIH0sXG4gICAgICBEOiBmdW5jdGlvbiAoaHJlZikge1xuICAgICAgICBwcmV2aW91c0Rpc3BhdGNoZXIuRChocmVmKTtcbiAgICAgICAgcHJlY29ubmVjdEFzKFwiZG5zLXByZWZldGNoXCIsIGhyZWYsIG51bGwpO1xuICAgICAgfSxcbiAgICAgIEM6IGZ1bmN0aW9uIChocmVmLCBjcm9zc09yaWdpbikge1xuICAgICAgICBwcmV2aW91c0Rpc3BhdGNoZXIuQyhocmVmLCBjcm9zc09yaWdpbik7XG4gICAgICAgIHByZWNvbm5lY3RBcyhcInByZWNvbm5lY3RcIiwgaHJlZiwgY3Jvc3NPcmlnaW4pO1xuICAgICAgfSxcbiAgICAgIEw6IGZ1bmN0aW9uIChocmVmLCBhcywgb3B0aW9ucykge1xuICAgICAgICBwcmV2aW91c0Rpc3BhdGNoZXIuTChocmVmLCBhcywgb3B0aW9ucyk7XG4gICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gZ2xvYmFsRG9jdW1lbnQ7XG4gICAgICAgIGlmIChvd25lckRvY3VtZW50ICYmIGhyZWYgJiYgYXMpIHtcbiAgICAgICAgICB2YXIgcHJlbG9hZFNlbGVjdG9yID1cbiAgICAgICAgICAgICdsaW5rW3JlbD1cInByZWxvYWRcIl1bYXM9XCInICtcbiAgICAgICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoYXMpICtcbiAgICAgICAgICAgICdcIl0nO1xuICAgICAgICAgIFwiaW1hZ2VcIiA9PT0gYXNcbiAgICAgICAgICAgID8gb3B0aW9ucyAmJiBvcHRpb25zLmltYWdlU3JjU2V0XG4gICAgICAgICAgICAgID8gKChwcmVsb2FkU2VsZWN0b3IgKz1cbiAgICAgICAgICAgICAgICAgICdbaW1hZ2VzcmNzZXQ9XCInICtcbiAgICAgICAgICAgICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaW1hZ2VTcmNTZXRcbiAgICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICAgJ1wiXScpLFxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmltYWdlU2l6ZXMgJiZcbiAgICAgICAgICAgICAgICAgIChwcmVsb2FkU2VsZWN0b3IgKz1cbiAgICAgICAgICAgICAgICAgICAgJ1tpbWFnZXNpemVzPVwiJyArXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbWFnZVNpemVzXG4gICAgICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICAgICAnXCJdJykpXG4gICAgICAgICAgICAgIDogKHByZWxvYWRTZWxlY3RvciArPVxuICAgICAgICAgICAgICAgICAgJ1tocmVmPVwiJyArXG4gICAgICAgICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGhyZWYpICtcbiAgICAgICAgICAgICAgICAgICdcIl0nKVxuICAgICAgICAgICAgOiAocHJlbG9hZFNlbGVjdG9yICs9XG4gICAgICAgICAgICAgICAgJ1tocmVmPVwiJyArXG4gICAgICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhocmVmKSArXG4gICAgICAgICAgICAgICAgJ1wiXScpO1xuICAgICAgICAgIHZhciBrZXkgPSBwcmVsb2FkU2VsZWN0b3I7XG4gICAgICAgICAgc3dpdGNoIChhcykge1xuICAgICAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgICAgIGtleSA9IGdldFN0eWxlS2V5KGhyZWYpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAga2V5ID0gZ2V0U2NyaXB0S2V5KGhyZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmVsb2FkUHJvcHNNYXAuaGFzKGtleSkgfHxcbiAgICAgICAgICAgICgoaHJlZiA9IGFzc2lnbihcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgICAgICAgaHJlZjpcbiAgICAgICAgICAgICAgICAgIFwiaW1hZ2VcIiA9PT0gYXMgJiYgb3B0aW9ucyAmJiBvcHRpb25zLmltYWdlU3JjU2V0XG4gICAgICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIDogaHJlZixcbiAgICAgICAgICAgICAgICBhczogYXNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBwcmVsb2FkUHJvcHNNYXAuc2V0KGtleSwgaHJlZiksXG4gICAgICAgICAgICBudWxsICE9PSBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocHJlbG9hZFNlbGVjdG9yKSB8fFxuICAgICAgICAgICAgICAoXCJzdHlsZVwiID09PSBhcyAmJlxuICAgICAgICAgICAgICAgIG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgICAgIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoa2V5KVxuICAgICAgICAgICAgICAgICkpIHx8XG4gICAgICAgICAgICAgIChcInNjcmlwdFwiID09PSBhcyAmJlxuICAgICAgICAgICAgICAgIG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihnZXRTY3JpcHRTZWxlY3RvckZyb21LZXkoa2V5KSkpIHx8XG4gICAgICAgICAgICAgICgoYXMgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpKSxcbiAgICAgICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoYXMsIFwibGlua1wiLCBocmVmKSxcbiAgICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShhcyksXG4gICAgICAgICAgICAgIG93bmVyRG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChhcykpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICAgIHByZXZpb3VzRGlzcGF0Y2hlci5tKGhyZWYsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICAgICAgICBpZiAob3duZXJEb2N1bWVudCAmJiBocmVmKSB7XG4gICAgICAgICAgdmFyIGFzID1cbiAgICAgICAgICAgICAgb3B0aW9ucyAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5hcyA/IG9wdGlvbnMuYXMgOiBcInNjcmlwdFwiLFxuICAgICAgICAgICAgcHJlbG9hZFNlbGVjdG9yID1cbiAgICAgICAgICAgICAgJ2xpbmtbcmVsPVwibW9kdWxlcHJlbG9hZFwiXVthcz1cIicgK1xuICAgICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGFzKSArXG4gICAgICAgICAgICAgICdcIl1baHJlZj1cIicgK1xuICAgICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGhyZWYpICtcbiAgICAgICAgICAgICAgJ1wiXScsXG4gICAgICAgICAgICBrZXkgPSBwcmVsb2FkU2VsZWN0b3I7XG4gICAgICAgICAgc3dpdGNoIChhcykge1xuICAgICAgICAgICAgY2FzZSBcImF1ZGlvd29ya2xldFwiOlxuICAgICAgICAgICAgY2FzZSBcInBhaW50d29ya2xldFwiOlxuICAgICAgICAgICAgY2FzZSBcInNlcnZpY2V3b3JrZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaGFyZWR3b3JrZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ3b3JrZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAga2V5ID0gZ2V0U2NyaXB0S2V5KGhyZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhcHJlbG9hZFByb3BzTWFwLmhhcyhrZXkpICYmXG4gICAgICAgICAgICAoKGhyZWYgPSBhc3NpZ24oeyByZWw6IFwibW9kdWxlcHJlbG9hZFwiLCBocmVmOiBocmVmIH0sIG9wdGlvbnMpKSxcbiAgICAgICAgICAgIHByZWxvYWRQcm9wc01hcC5zZXQoa2V5LCBocmVmKSxcbiAgICAgICAgICAgIG51bGwgPT09IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihwcmVsb2FkU2VsZWN0b3IpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgc3dpdGNoIChhcykge1xuICAgICAgICAgICAgICBjYXNlIFwiYXVkaW93b3JrbGV0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJwYWludHdvcmtsZXRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNlcnZpY2V3b3JrZXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNoYXJlZHdvcmtlclwiOlxuICAgICAgICAgICAgICBjYXNlIFwid29ya2VyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICBpZiAob3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGdldFNjcmlwdFNlbGVjdG9yRnJvbUtleShrZXkpKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGFzLCBcImxpbmtcIiwgaHJlZik7XG4gICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGFzKTtcbiAgICAgICAgICAgIG93bmVyRG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgWDogZnVuY3Rpb24gKHNyYywgb3B0aW9ucykge1xuICAgICAgICBwcmV2aW91c0Rpc3BhdGNoZXIuWChzcmMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICAgICAgICBpZiAob3duZXJEb2N1bWVudCAmJiBzcmMpIHtcbiAgICAgICAgICB2YXIgc2NyaXB0cyA9IGdldFJlc291cmNlc0Zyb21Sb290KG93bmVyRG9jdW1lbnQpLmhvaXN0YWJsZVNjcmlwdHMsXG4gICAgICAgICAgICBrZXkgPSBnZXRTY3JpcHRLZXkoc3JjKSxcbiAgICAgICAgICAgIHJlc291cmNlID0gc2NyaXB0cy5nZXQoa2V5KTtcbiAgICAgICAgICByZXNvdXJjZSB8fFxuICAgICAgICAgICAgKChyZXNvdXJjZSA9IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgZ2V0U2NyaXB0U2VsZWN0b3JGcm9tS2V5KGtleSlcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgcmVzb3VyY2UgfHxcbiAgICAgICAgICAgICAgKChzcmMgPSBhc3NpZ24oeyBzcmM6IHNyYywgYXN5bmM6ICEwIH0sIG9wdGlvbnMpKSxcbiAgICAgICAgICAgICAgKG9wdGlvbnMgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KGtleSkpICYmXG4gICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTY3JpcHQoc3JjLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgKHJlc291cmNlID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSxcbiAgICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShyZXNvdXJjZSksXG4gICAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKHJlc291cmNlLCBcImxpbmtcIiwgc3JjKSxcbiAgICAgICAgICAgICAgb3duZXJEb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHJlc291cmNlKSksXG4gICAgICAgICAgICAocmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic2NyaXB0XCIsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiByZXNvdXJjZSxcbiAgICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICAgIHN0YXRlOiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNjcmlwdHMuc2V0KGtleSwgcmVzb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFM6IGZ1bmN0aW9uIChocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHByZXZpb3VzRGlzcGF0Y2hlci5TKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICAgICAgICBpZiAob3duZXJEb2N1bWVudCAmJiBocmVmKSB7XG4gICAgICAgICAgdmFyIHN0eWxlcyA9IGdldFJlc291cmNlc0Zyb21Sb290KG93bmVyRG9jdW1lbnQpLmhvaXN0YWJsZVN0eWxlcyxcbiAgICAgICAgICAgIGtleSA9IGdldFN0eWxlS2V5KGhyZWYpO1xuICAgICAgICAgIHByZWNlZGVuY2UgPSBwcmVjZWRlbmNlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgIHZhciByZXNvdXJjZSA9IHN0eWxlcy5nZXQoa2V5KTtcbiAgICAgICAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB7IGxvYWRpbmc6IE5vdExvYWRlZCwgcHJlbG9hZDogbnVsbCB9O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAocmVzb3VyY2UgPSBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgZ2V0U3R5bGVzaGVldFNlbGVjdG9yRnJvbUtleShrZXkpXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgPSBMb2FkZWQgfCBJbnNlcnRlZDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBocmVmID0gYXNzaWduKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJlbDogXCJzdHlsZXNoZWV0XCIsXG4gICAgICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAob3B0aW9ucyA9IHByZWxvYWRQcm9wc01hcC5nZXQoa2V5KSkgJiZcbiAgICAgICAgICAgICAgICBhZG9wdFByZWxvYWRQcm9wc0ZvclN0eWxlc2hlZXQoaHJlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIHZhciBsaW5rID0gKHJlc291cmNlID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKSk7XG4gICAgICAgICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUobGluayk7XG4gICAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGxpbmssIFwibGlua1wiLCBocmVmKTtcbiAgICAgICAgICAgICAgbGluay5fcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBsaW5rLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgbGluay5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUubG9hZGluZyB8PSBMb2FkZWQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUubG9hZGluZyB8PSBFcnJvcmVkO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc3RhdGUubG9hZGluZyB8PSBJbnNlcnRlZDtcbiAgICAgICAgICAgICAgaW5zZXJ0U3R5bGVzaGVldChyZXNvdXJjZSwgcHJlY2VkZW5jZSwgb3duZXJEb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvdXJjZSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHlsZXNoZWV0XCIsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiByZXNvdXJjZSxcbiAgICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0eWxlcy5zZXQoa2V5LCByZXNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgTTogZnVuY3Rpb24gKHNyYywgb3B0aW9ucykge1xuICAgICAgICBwcmV2aW91c0Rpc3BhdGNoZXIuTShzcmMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICAgICAgICBpZiAob3duZXJEb2N1bWVudCAmJiBzcmMpIHtcbiAgICAgICAgICB2YXIgc2NyaXB0cyA9IGdldFJlc291cmNlc0Zyb21Sb290KG93bmVyRG9jdW1lbnQpLmhvaXN0YWJsZVNjcmlwdHMsXG4gICAgICAgICAgICBrZXkgPSBnZXRTY3JpcHRLZXkoc3JjKSxcbiAgICAgICAgICAgIHJlc291cmNlID0gc2NyaXB0cy5nZXQoa2V5KTtcbiAgICAgICAgICByZXNvdXJjZSB8fFxuICAgICAgICAgICAgKChyZXNvdXJjZSA9IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgZ2V0U2NyaXB0U2VsZWN0b3JGcm9tS2V5KGtleSlcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgcmVzb3VyY2UgfHxcbiAgICAgICAgICAgICAgKChzcmMgPSBhc3NpZ24oeyBzcmM6IHNyYywgYXN5bmM6ICEwLCB0eXBlOiBcIm1vZHVsZVwiIH0sIG9wdGlvbnMpKSxcbiAgICAgICAgICAgICAgKG9wdGlvbnMgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KGtleSkpICYmXG4gICAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTY3JpcHQoc3JjLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgKHJlc291cmNlID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSxcbiAgICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShyZXNvdXJjZSksXG4gICAgICAgICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKHJlc291cmNlLCBcImxpbmtcIiwgc3JjKSxcbiAgICAgICAgICAgICAgb3duZXJEb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHJlc291cmNlKSksXG4gICAgICAgICAgICAocmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic2NyaXB0XCIsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiByZXNvdXJjZSxcbiAgICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICAgIHN0YXRlOiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNjcmlwdHMuc2V0KGtleSwgcmVzb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGdsb2JhbERvY3VtZW50ID0gXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGRvY3VtZW50ID8gbnVsbCA6IGRvY3VtZW50LFxuICAgICAgdGFnQ2FjaGVzID0gbnVsbCxcbiAgICAgIHN1c3BlbmRlZFN0YXRlID0gbnVsbCxcbiAgICAgIExBU1RfUFJFQ0VERU5DRSA9IG51bGwsXG4gICAgICBwcmVjZWRlbmNlc0J5Um9vdCA9IG51bGwsXG4gICAgICBOb3RQZW5kaW5nVHJhbnNpdGlvbiA9IE5vdFBlbmRpbmcsXG4gICAgICBIb3N0VHJhbnNpdGlvbkNvbnRleHQgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICAgIFByb3ZpZGVyOiBudWxsLFxuICAgICAgICBDb25zdW1lcjogbnVsbCxcbiAgICAgICAgX2N1cnJlbnRWYWx1ZTogTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICAgIF9jdXJyZW50VmFsdWUyOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgX3RocmVhZENvdW50OiAwXG4gICAgICB9LFxuICAgICAgYmFkZ2VGb3JtYXQgPSBcIiVjJXMlYyBcIixcbiAgICAgIGJhZGdlU3R5bGUgPVxuICAgICAgICBcImJhY2tncm91bmQ6ICNlNmU2ZTY7YmFja2dyb3VuZDogbGlnaHQtZGFyayhyZ2JhKDAsMCwwLDAuMSksIHJnYmEoMjU1LDI1NSwyNTUsMC4yNSkpO2NvbG9yOiAjMDAwMDAwO2NvbG9yOiBsaWdodC1kYXJrKCMwMDAwMDAsICNmZmZmZmYpO2JvcmRlci1yYWRpdXM6IDJweFwiLFxuICAgICAgcmVzZXRTdHlsZSA9IFwiXCIsXG4gICAgICBwYWQgPSBcIiBcIixcbiAgICAgIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcbiAgICB2YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9ICExO1xuICAgIHZhciBvdmVycmlkZUhvb2tTdGF0ZSA9IG51bGwsXG4gICAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBudWxsLFxuICAgICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlUHJvcHMgPSBudWxsLFxuICAgICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBudWxsLFxuICAgICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBudWxsLFxuICAgICAgc2NoZWR1bGVVcGRhdGUgPSBudWxsLFxuICAgICAgc2V0RXJyb3JIYW5kbGVyID0gbnVsbCxcbiAgICAgIHNldFN1c3BlbnNlSGFuZGxlciA9IG51bGw7XG4gICAgb3ZlcnJpZGVIb29rU3RhdGUgPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgaWQgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuICAgICAgbnVsbCAhPT0gaWQgJiZcbiAgICAgICAgKChwYXRoID0gY29weVdpdGhTZXRJbXBsKGlkLm1lbW9pemVkU3RhdGUsIHBhdGgsIDAsIHZhbHVlKSksXG4gICAgICAgIChpZC5tZW1vaXplZFN0YXRlID0gcGF0aCksXG4gICAgICAgIChpZC5iYXNlU3RhdGUgPSBwYXRoKSxcbiAgICAgICAgKGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpKSxcbiAgICAgICAgKHBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgbnVsbCAhPT0gcGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF0aCwgZmliZXIsIDIpKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgpIHtcbiAgICAgIGlkID0gZmluZEhvb2soZmliZXIsIGlkKTtcbiAgICAgIG51bGwgIT09IGlkICYmXG4gICAgICAgICgocGF0aCA9IGNvcHlXaXRoRGVsZXRlSW1wbChpZC5tZW1vaXplZFN0YXRlLCBwYXRoLCAwKSksXG4gICAgICAgIChpZC5tZW1vaXplZFN0YXRlID0gcGF0aCksXG4gICAgICAgIChpZC5iYXNlU3RhdGUgPSBwYXRoKSxcbiAgICAgICAgKGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpKSxcbiAgICAgICAgKHBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgbnVsbCAhPT0gcGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF0aCwgZmliZXIsIDIpKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICAgIGlkID0gZmluZEhvb2soZmliZXIsIGlkKTtcbiAgICAgIG51bGwgIT09IGlkICYmXG4gICAgICAgICgob2xkUGF0aCA9IGNvcHlXaXRoUmVuYW1lKGlkLm1lbW9pemVkU3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpKSxcbiAgICAgICAgKGlkLm1lbW9pemVkU3RhdGUgPSBvbGRQYXRoKSxcbiAgICAgICAgKGlkLmJhc2VTdGF0ZSA9IG9sZFBhdGgpLFxuICAgICAgICAoZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcykpLFxuICAgICAgICAob2xkUGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICBudWxsICE9PSBvbGRQYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihvbGRQYXRoLCBmaWJlciwgMikpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVQcm9wcyA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoU2V0SW1wbChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCAwLCB2YWx1ZSk7XG4gICAgICBmaWJlci5hbHRlcm5hdGUgJiYgKGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHMpO1xuICAgICAgcGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSBwYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXRoLCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCkge1xuICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhEZWxldGVJbXBsKGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgsIDApO1xuICAgICAgZmliZXIuYWx0ZXJuYXRlICYmIChmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzKTtcbiAgICAgIHBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF0aCwgZmliZXIsIDIpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoUmVuYW1lKFxuICAgICAgICBmaWJlci5tZW1vaXplZFByb3BzLFxuICAgICAgICBvbGRQYXRoLFxuICAgICAgICBuZXdQYXRoXG4gICAgICApO1xuICAgICAgZmliZXIuYWx0ZXJuYXRlICYmIChmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzKTtcbiAgICAgIG9sZFBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gb2xkUGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIob2xkUGF0aCwgZmliZXIsIDIpO1xuICAgIH07XG4gICAgc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIHNldEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRFcnJvckltcGwpIHtcbiAgICAgIHNob3VsZEVycm9ySW1wbCA9IG5ld1Nob3VsZEVycm9ySW1wbDtcbiAgICB9O1xuICAgIHNldFN1c3BlbnNlSGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRTdXNwZW5kSW1wbCkge1xuICAgICAgc2hvdWxkU3VzcGVuZEltcGwgPSBuZXdTaG91bGRTdXNwZW5kSW1wbDtcbiAgICB9O1xuICAgIHZhciBfZW5hYmxlZCA9ICEwLFxuICAgICAgcmV0dXJuX3RhcmdldEluc3QgPSBudWxsLFxuICAgICAgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9ICExLFxuICAgICAgcXVldWVkRm9jdXMgPSBudWxsLFxuICAgICAgcXVldWVkRHJhZyA9IG51bGwsXG4gICAgICBxdWV1ZWRNb3VzZSA9IG51bGwsXG4gICAgICBxdWV1ZWRQb2ludGVycyA9IG5ldyBNYXAoKSxcbiAgICAgIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcyA9IG5ldyBNYXAoKSxcbiAgICAgIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cyA9IFtdLFxuICAgICAgZGlzY3JldGVSZXBsYXlhYmxlRXZlbnRzID1cbiAgICAgICAgXCJtb3VzZWRvd24gbW91c2V1cCB0b3VjaGNhbmNlbCB0b3VjaGVuZCB0b3VjaHN0YXJ0IGF1eGNsaWNrIGRibGNsaWNrIHBvaW50ZXJjYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlcnVwIGRyYWdlbmQgZHJhZ3N0YXJ0IGRyb3AgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb25zdGFydCBrZXlkb3duIGtleXByZXNzIGtleXVwIGlucHV0IHRleHRJbnB1dCBjb3B5IGN1dCBwYXN0ZSBjbGljayBjaGFuZ2UgY29udGV4dG1lbnUgcmVzZXRcIi5zcGxpdChcbiAgICAgICAgICBcIiBcIlxuICAgICAgICApLFxuICAgICAgbGFzdFNjaGVkdWxlZFJlcGxheVF1ZXVlID0gbnVsbDtcbiAgICBSZWFjdERPTUh5ZHJhdGlvblJvb3QucHJvdG90eXBlLnJlbmRlciA9IFJlYWN0RE9NUm9vdC5wcm90b3R5cGUucmVuZGVyID1cbiAgICAgIGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgICAgICAgaWYgKG51bGwgPT09IHJvb3QpIHRocm93IEVycm9yKFwiQ2Fubm90IHVwZGF0ZSBhbiB1bm1vdW50ZWQgcm9vdC5cIik7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhcmdzWzFdXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImRvZXMgbm90IHN1cHBvcnQgdGhlIHNlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiBhIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGlzVmFsaWRDb250YWluZXIoYXJnc1sxXSlcbiAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIllvdSBwYXNzZWQgYSBjb250YWluZXIgdG8gdGhlIHNlY29uZCBhcmd1bWVudCBvZiByb290LnJlbmRlciguLi4pLiBZb3UgZG9uJ3QgbmVlZCB0byBwYXNzIGl0IGFnYWluIHNpbmNlIHlvdSBhbHJlYWR5IHBhc3NlZCBpdCB0byBjcmVhdGUgdGhlIHJvb3QuXCJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYXJnc1sxXSAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiWW91IHBhc3NlZCBhIHNlY29uZCBhcmd1bWVudCB0byByb290LnJlbmRlciguLi4pIGJ1dCBpdCBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIGFyZ3MgPSBjaGlsZHJlbjtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQsXG4gICAgICAgICAgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQpO1xuICAgICAgICB1cGRhdGVDb250YWluZXJJbXBsKGN1cnJlbnQsIGxhbmUsIGFyZ3MsIHJvb3QsIG51bGwsIG51bGwpO1xuICAgICAgfTtcbiAgICBSZWFjdERPTUh5ZHJhdGlvblJvb3QucHJvdG90eXBlLnVubW91bnQgPSBSZWFjdERPTVJvb3QucHJvdG90eXBlLnVubW91bnQgPVxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYXJnc1swXSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImRvZXMgbm90IHN1cHBvcnQgYSBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiBhIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuXCJcbiAgICAgICAgICApO1xuICAgICAgICBhcmdzID0gdGhpcy5faW50ZXJuYWxSb290O1xuICAgICAgICBpZiAobnVsbCAhPT0gYXJncykge1xuICAgICAgICAgIHRoaXMuX2ludGVybmFsUm9vdCA9IG51bGw7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGFyZ3MuY29udGFpbmVySW5mbztcbiAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQXR0ZW1wdGVkIHRvIHN5bmNocm9ub3VzbHkgdW5tb3VudCBhIHJvb3Qgd2hpbGUgUmVhY3Qgd2FzIGFscmVhZHkgcmVuZGVyaW5nLiBSZWFjdCBjYW5ub3QgZmluaXNoIHVubW91bnRpbmcgdGhlIHJvb3QgdW50aWwgdGhlIGN1cnJlbnQgcmVuZGVyIGhhcyBjb21wbGV0ZWQsIHdoaWNoIG1heSBsZWFkIHRvIGEgcmFjZSBjb25kaXRpb24uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdXBkYXRlQ29udGFpbmVySW1wbChhcmdzLmN1cnJlbnQsIDIsIG51bGwsIGFyZ3MsIG51bGwsIG51bGwpO1xuICAgICAgICAgIGZsdXNoU3luY1dvcmskMSgpO1xuICAgICAgICAgIGNvbnRhaW5lcltpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgUmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS51bnN0YWJsZV9zY2hlZHVsZUh5ZHJhdGlvbiA9IGZ1bmN0aW9uIChcbiAgICAgIHRhcmdldFxuICAgICkge1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB2YXIgdXBkYXRlUHJpb3JpdHkgPSByZXNvbHZlVXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgICAgdGFyZ2V0ID0geyBibG9ja2VkT246IG51bGwsIHRhcmdldDogdGFyZ2V0LCBwcmlvcml0eTogdXBkYXRlUHJpb3JpdHkgfTtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgaSA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGggJiZcbiAgICAgICAgICAwICE9PSB1cGRhdGVQcmlvcml0eSAmJlxuICAgICAgICAgIHVwZGF0ZVByaW9yaXR5IDwgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzW2ldLnByaW9yaXR5O1xuICAgICAgICAgIGkrK1xuICAgICAgICApO1xuICAgICAgICBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMuc3BsaWNlKGksIDAsIHRhcmdldCk7XG4gICAgICAgIDAgPT09IGkgJiYgYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlzb21vcnBoaWNSZWFjdFBhY2thZ2VWZXJzaW9uID0gUmVhY3QudmVyc2lvbjtcbiAgICAgIGlmIChcIjE5LjIuMC1jYW5hcnktM2ZiZmI5YmEtMjAyNTA0MDlcIiAhPT0gaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24pXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdJbmNvbXBhdGlibGUgUmVhY3QgdmVyc2lvbnM6IFRoZSBcInJlYWN0XCIgYW5kIFwicmVhY3QtZG9tXCIgcGFja2FnZXMgbXVzdCBoYXZlIHRoZSBleGFjdCBzYW1lIHZlcnNpb24uIEluc3RlYWQgZ290OlxcbiAgLSByZWFjdDogICAgICAnICtcbiAgICAgICAgICAgIChpc29tb3JwaGljUmVhY3RQYWNrYWdlVmVyc2lvbiArXG4gICAgICAgICAgICAgIFwiXFxuICAtIHJlYWN0LWRvbTogIDE5LjIuMC1jYW5hcnktM2ZiZmI5YmEtMjAyNTA0MDlcXG5MZWFybiBtb3JlOiBodHRwczovL3JlYWN0LmRldi93YXJuaW5ncy92ZXJzaW9uLW1pc21hdGNoXCIpXG4gICAgICAgICk7XG4gICAgfSkoKTtcbiAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgTWFwICYmXG4gICAgICBudWxsICE9IE1hcC5wcm90b3R5cGUgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU2V0ICYmXG4gICAgICBudWxsICE9IFNldC5wcm90b3R5cGUgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCkgfHxcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiUmVhY3QgZGVwZW5kcyBvbiBNYXAgYW5kIFNldCBidWlsdC1pbiB0eXBlcy4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSBwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9yZWFjdC1wb2x5ZmlsbHNcIlxuICAgICAgKTtcbiAgICBSZWFjdERPTVNoYXJlZEludGVybmFscy5maW5kRE9NTm9kZSA9IGZ1bmN0aW9uIChjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgICAgIHZhciBmaWJlciA9IGNvbXBvbmVudE9yRWxlbWVudC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICBpZiAodm9pZCAwID09PSBmaWJlcikge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29tcG9uZW50T3JFbGVtZW50LnJlbmRlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICAgIGNvbXBvbmVudE9yRWxlbWVudCA9IE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkuam9pbihcIixcIik7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgK1xuICAgICAgICAgICAgY29tcG9uZW50T3JFbGVtZW50XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb21wb25lbnRPckVsZW1lbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcik7XG4gICAgICBjb21wb25lbnRPckVsZW1lbnQgPVxuICAgICAgICBudWxsICE9PSBjb21wb25lbnRPckVsZW1lbnRcbiAgICAgICAgICA/IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChjb21wb25lbnRPckVsZW1lbnQpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgY29tcG9uZW50T3JFbGVtZW50ID1cbiAgICAgICAgbnVsbCA9PT0gY29tcG9uZW50T3JFbGVtZW50ID8gbnVsbCA6IGNvbXBvbmVudE9yRWxlbWVudC5zdGF0ZU5vZGU7XG4gICAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICAgIH07XG4gICAgaWYgKFxuICAgICAgIShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbHMgPSB7XG4gICAgICAgICAgYnVuZGxlVHlwZTogMSxcbiAgICAgICAgICB2ZXJzaW9uOiBcIjE5LjIuMC1jYW5hcnktM2ZiZmI5YmEtMjAyNTA0MDlcIixcbiAgICAgICAgICByZW5kZXJlclBhY2thZ2VOYW1lOiBcInJlYWN0LWRvbVwiLFxuICAgICAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBSZWFjdFNoYXJlZEludGVybmFscyxcbiAgICAgICAgICByZWNvbmNpbGVyVmVyc2lvbjogXCIxOS4yLjAtY2FuYXJ5LTNmYmZiOWJhLTIwMjUwNDA5XCJcbiAgICAgICAgfTtcbiAgICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlSG9va1N0YXRlID0gb3ZlcnJpZGVIb29rU3RhdGU7XG4gICAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg7XG4gICAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg7XG4gICAgICAgIGludGVybmFscy5vdmVycmlkZVByb3BzID0gb3ZlcnJpZGVQcm9wcztcbiAgICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg7XG4gICAgICAgIGludGVybmFscy5vdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoO1xuICAgICAgICBpbnRlcm5hbHMuc2NoZWR1bGVVcGRhdGUgPSBzY2hlZHVsZVVwZGF0ZTtcbiAgICAgICAgaW50ZXJuYWxzLnNldEVycm9ySGFuZGxlciA9IHNldEVycm9ySGFuZGxlcjtcbiAgICAgICAgaW50ZXJuYWxzLnNldFN1c3BlbnNlSGFuZGxlciA9IHNldFN1c3BlbnNlSGFuZGxlcjtcbiAgICAgICAgaW50ZXJuYWxzLnNjaGVkdWxlUmVmcmVzaCA9IHNjaGVkdWxlUmVmcmVzaDtcbiAgICAgICAgaW50ZXJuYWxzLnNjaGVkdWxlUm9vdCA9IHNjaGVkdWxlUm9vdDtcbiAgICAgICAgaW50ZXJuYWxzLnNldFJlZnJlc2hIYW5kbGVyID0gc2V0UmVmcmVzaEhhbmRsZXI7XG4gICAgICAgIGludGVybmFscy5nZXRDdXJyZW50RmliZXIgPSBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scztcbiAgICAgICAgaW50ZXJuYWxzLmdldExhbmVMYWJlbE1hcCA9IGdldExhbmVMYWJlbE1hcDtcbiAgICAgICAgaW50ZXJuYWxzLmluamVjdFByb2ZpbGluZ0hvb2tzID0gaW5qZWN0UHJvZmlsaW5nSG9va3M7XG4gICAgICAgIHJldHVybiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKTtcbiAgICAgIH0pKCkgJiZcbiAgICAgIGNhblVzZURPTSAmJlxuICAgICAgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYgJiZcbiAgICAgICgoLTEgPCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJDaHJvbWVcIikgJiZcbiAgICAgICAgLTEgPT09IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkVkZ2VcIikpIHx8XG4gICAgICAgIC0xIDwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSlcbiAgICApIHtcbiAgICAgIHZhciBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgIC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSAmJlxuICAgICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgICAgXCIlY0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9yZWFjdC1kZXZ0b29sc1wiICtcbiAgICAgICAgICAgIChcImZpbGU6XCIgPT09IHByb3RvY29sXG4gICAgICAgICAgICAgID8gXCJcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9yZWFjdC1kZXZ0b29scy1mYXFcIlxuICAgICAgICAgICAgICA6IFwiXCIpLFxuICAgICAgICAgIFwiZm9udC13ZWlnaHQ6Ym9sZFwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGV4cG9ydHMuY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIpO1xuICAgICAgd2FybklmUmVhY3RET01Db250YWluZXJJbkRFVihjb250YWluZXIpO1xuICAgICAgdmFyIGlzU3RyaWN0TW9kZSA9ICExLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4ID0gXCJcIixcbiAgICAgICAgb25VbmNhdWdodEVycm9yID0gZGVmYXVsdE9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvciA9IGRlZmF1bHRPbkNhdWdodEVycm9yLFxuICAgICAgICBvblJlY292ZXJhYmxlRXJyb3IgPSBkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIG51bGwgIT09IG9wdGlvbnMgJiZcbiAgICAgICAgdm9pZCAwICE9PSBvcHRpb25zICYmXG4gICAgICAgIChvcHRpb25zLmh5ZHJhdGVcbiAgICAgICAgICA/IGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJoeWRyYXRlIHRocm91Z2ggY3JlYXRlUm9vdCBpcyBkZXByZWNhdGVkLiBVc2UgUmVhY3RET01DbGllbnQuaHlkcmF0ZVJvb3QoY29udGFpbmVyLCA8QXBwIC8+KSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBcIm9iamVjdFwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gb3B0aW9ucyAmJlxuICAgICAgICAgICAgb3B0aW9ucy4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBwYXNzZWQgYSBKU1ggZWxlbWVudCB0byBjcmVhdGVSb290LiBZb3UgcHJvYmFibHkgbWVhbnQgdG8gY2FsbCByb290LnJlbmRlciBpbnN0ZWFkLiBFeGFtcGxlIHVzYWdlOlxcblxcbiAgbGV0IHJvb3QgPSBjcmVhdGVSb290KGRvbUNvbnRhaW5lcik7XFxuICByb290LnJlbmRlcig8QXBwIC8+KTtcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgITAgPT09IG9wdGlvbnMudW5zdGFibGVfc3RyaWN0TW9kZSAmJiAoaXNTdHJpY3RNb2RlID0gITApLFxuICAgICAgICB2b2lkIDAgIT09IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCAmJlxuICAgICAgICAgIChpZGVudGlmaWVyUHJlZml4ID0gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4KSxcbiAgICAgICAgdm9pZCAwICE9PSBvcHRpb25zLm9uVW5jYXVnaHRFcnJvciAmJlxuICAgICAgICAgIChvblVuY2F1Z2h0RXJyb3IgPSBvcHRpb25zLm9uVW5jYXVnaHRFcnJvciksXG4gICAgICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vbkNhdWdodEVycm9yICYmXG4gICAgICAgICAgKG9uQ2F1Z2h0RXJyb3IgPSBvcHRpb25zLm9uQ2F1Z2h0RXJyb3IpLFxuICAgICAgICB2b2lkIDAgIT09IG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yICYmXG4gICAgICAgICAgKG9uUmVjb3ZlcmFibGVFcnJvciA9IG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yKSxcbiAgICAgICAgdm9pZCAwICE9PSBvcHRpb25zLnVuc3RhYmxlX3RyYW5zaXRpb25DYWxsYmFja3MgJiZcbiAgICAgICAgICAodHJhbnNpdGlvbkNhbGxiYWNrcyA9IG9wdGlvbnMudW5zdGFibGVfdHJhbnNpdGlvbkNhbGxiYWNrcykpO1xuICAgICAgb3B0aW9ucyA9IGNyZWF0ZUZpYmVyUm9vdChcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAxLFxuICAgICAgICAhMSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgaXNTdHJpY3RNb2RlLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrcyxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIGNvbnRhaW5lcltpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSA9IG9wdGlvbnMuY3VycmVudDtcbiAgICAgIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKGNvbnRhaW5lcik7XG4gICAgICByZXR1cm4gbmV3IFJlYWN0RE9NUm9vdChvcHRpb25zKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaHlkcmF0ZVJvb3QgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBpbml0aWFsQ2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICAgIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIpO1xuICAgICAgd2FybklmUmVhY3RET01Db250YWluZXJJbkRFVihjb250YWluZXIpO1xuICAgICAgdm9pZCAwID09PSBpbml0aWFsQ2hpbGRyZW4gJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIk11c3QgcHJvdmlkZSBpbml0aWFsIGNoaWxkcmVuIGFzIHNlY29uZCBhcmd1bWVudCB0byBoeWRyYXRlUm9vdC4gRXhhbXBsZSB1c2FnZTogaHlkcmF0ZVJvb3QoZG9tQ29udGFpbmVyLCA8QXBwIC8+KVwiXG4gICAgICAgICk7XG4gICAgICB2YXIgaXNTdHJpY3RNb2RlID0gITEsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggPSBcIlwiLFxuICAgICAgICBvblVuY2F1Z2h0RXJyb3IgPSBkZWZhdWx0T25VbmNhdWdodEVycm9yLFxuICAgICAgICBvbkNhdWdodEVycm9yID0gZGVmYXVsdE9uQ2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvciA9IGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MgPSBudWxsLFxuICAgICAgICBmb3JtU3RhdGUgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gb3B0aW9ucyAmJlxuICAgICAgICB2b2lkIDAgIT09IG9wdGlvbnMgJiZcbiAgICAgICAgKCEwID09PSBvcHRpb25zLnVuc3RhYmxlX3N0cmljdE1vZGUgJiYgKGlzU3RyaWN0TW9kZSA9ICEwKSxcbiAgICAgICAgdm9pZCAwICE9PSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggJiZcbiAgICAgICAgICAoaWRlbnRpZmllclByZWZpeCA9IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCksXG4gICAgICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IgJiZcbiAgICAgICAgICAob25VbmNhdWdodEVycm9yID0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IpLFxuICAgICAgICB2b2lkIDAgIT09IG9wdGlvbnMub25DYXVnaHRFcnJvciAmJlxuICAgICAgICAgIChvbkNhdWdodEVycm9yID0gb3B0aW9ucy5vbkNhdWdodEVycm9yKSxcbiAgICAgICAgdm9pZCAwICE9PSBvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciAmJlxuICAgICAgICAgIChvblJlY292ZXJhYmxlRXJyb3IgPSBvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciksXG4gICAgICAgIHZvaWQgMCAhPT0gb3B0aW9ucy51bnN0YWJsZV90cmFuc2l0aW9uQ2FsbGJhY2tzICYmXG4gICAgICAgICAgKHRyYW5zaXRpb25DYWxsYmFja3MgPSBvcHRpb25zLnVuc3RhYmxlX3RyYW5zaXRpb25DYWxsYmFja3MpLFxuICAgICAgICB2b2lkIDAgIT09IG9wdGlvbnMuZm9ybVN0YXRlICYmIChmb3JtU3RhdGUgPSBvcHRpb25zLmZvcm1TdGF0ZSkpO1xuICAgICAgaW5pdGlhbENoaWxkcmVuID0gY3JlYXRlRmliZXJSb290KFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIDEsXG4gICAgICAgICEwLFxuICAgICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICAgIG51bGwgIT0gb3B0aW9ucyA/IG9wdGlvbnMgOiBudWxsLFxuICAgICAgICBpc1N0cmljdE1vZGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBmb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4uY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpO1xuICAgICAgb3B0aW9ucyA9IGluaXRpYWxDaGlsZHJlbi5jdXJyZW50O1xuICAgICAgaXNTdHJpY3RNb2RlID0gcmVxdWVzdFVwZGF0ZUxhbmUob3B0aW9ucyk7XG4gICAgICBpc1N0cmljdE1vZGUgPSBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uQnlMYW5lKGlzU3RyaWN0TW9kZSk7XG4gICAgICBpZGVudGlmaWVyUHJlZml4ID0gY3JlYXRlVXBkYXRlKGlzU3RyaWN0TW9kZSk7XG4gICAgICBpZGVudGlmaWVyUHJlZml4LmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGVucXVldWVVcGRhdGUob3B0aW9ucywgaWRlbnRpZmllclByZWZpeCwgaXNTdHJpY3RNb2RlKTtcbiAgICAgIG9wdGlvbnMgPSBpc1N0cmljdE1vZGU7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4uY3VycmVudC5sYW5lcyA9IG9wdGlvbnM7XG4gICAgICBtYXJrUm9vdFVwZGF0ZWQkMShpbml0aWFsQ2hpbGRyZW4sIG9wdGlvbnMpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGluaXRpYWxDaGlsZHJlbik7XG4gICAgICBjb250YWluZXJbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBpbml0aWFsQ2hpbGRyZW4uY3VycmVudDtcbiAgICAgIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKGNvbnRhaW5lcik7XG4gICAgICByZXR1cm4gbmV3IFJlYWN0RE9NSHlkcmF0aW9uUm9vdChpbml0aWFsQ2hpbGRyZW4pO1xuICAgIH07XG4gICAgZXhwb3J0cy52ZXJzaW9uID0gXCIxOS4yLjAtY2FuYXJ5LTNmYmZiOWJhLTIwMjUwNDA5XCI7XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0pKCk7XG4iXSwibmFtZXMiOlsiZmluZEhvb2siLCJmaWJlciIsImlkIiwibWVtb2l6ZWRTdGF0ZSIsIm5leHQiLCJjb3B5V2l0aFNldEltcGwiLCJvYmoiLCJwYXRoIiwiaW5kZXgiLCJ2YWx1ZSIsImxlbmd0aCIsImtleSIsInVwZGF0ZWQiLCJpc0FycmF5SW1wbCIsInNsaWNlIiwiYXNzaWduIiwiY29weVdpdGhSZW5hbWUiLCJvbGRQYXRoIiwibmV3UGF0aCIsImNvbnNvbGUiLCJ3YXJuIiwiaSIsImNvcHlXaXRoUmVuYW1lSW1wbCIsIm9sZEtleSIsInNwbGljZSIsImNvcHlXaXRoRGVsZXRlSW1wbCIsInNob3VsZFN1c3BlbmRJbXBsIiwic2hvdWxkRXJyb3JJbXBsIiwid2FybkludmFsaWRIb29rQWNjZXNzIiwiZXJyb3IiLCJ3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MiLCJub29wJDIiLCJ3YXJuRm9yTWlzc2luZ0tleSIsInNldFRvU29ydGVkU3RyaW5nIiwic2V0IiwiYXJyYXkiLCJmb3JFYWNoIiwicHVzaCIsInNvcnQiLCJqb2luIiwiY3JlYXRlRmliZXIiLCJ0YWciLCJwZW5kaW5nUHJvcHMiLCJtb2RlIiwiRmliZXJOb2RlIiwic2NoZWR1bGVSb290Iiwicm9vdCIsImVsZW1lbnQiLCJjb250ZXh0IiwiZW1wdHlDb250ZXh0T2JqZWN0IiwidXBkYXRlQ29udGFpbmVySW1wbCIsImN1cnJlbnQiLCJmbHVzaFN5bmNXb3JrJDEiLCJzY2hlZHVsZVJlZnJlc2giLCJ1cGRhdGUiLCJyZXNvbHZlRmFtaWx5Iiwic3RhbGVGYW1pbGllcyIsInVwZGF0ZWRGYW1pbGllcyIsImZsdXNoUGVuZGluZ0VmZmVjdHMiLCJzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5Iiwic2V0UmVmcmVzaEhhbmRsZXIiLCJoYW5kbGVyIiwiaXNWYWxpZENvbnRhaW5lciIsIm5vZGUiLCJub2RlVHlwZSIsImdldE5lYXJlc3RNb3VudGVkRmliZXIiLCJuZWFyZXN0TW91bnRlZCIsImFsdGVybmF0ZSIsInJldHVybiIsImZsYWdzIiwiZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlciIsInN1c3BlbnNlU3RhdGUiLCJkZWh5ZHJhdGVkIiwiYXNzZXJ0SXNNb3VudGVkIiwiRXJyb3IiLCJmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCIsImEiLCJiIiwicGFyZW50QSIsInBhcmVudEIiLCJjaGlsZCIsInNpYmxpbmciLCJkaWRGaW5kQ2hpbGQiLCJfY2hpbGQiLCJzdGF0ZU5vZGUiLCJmaW5kQ3VycmVudEhvc3RGaWJlckltcGwiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfQUNUSVZJVFlfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfQ09OU1VNRVJfVFlQRSIsIl9jb250ZXh0IiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsImlubmVyVHlwZSIsInJlbmRlciIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIl9wYXlsb2FkIiwiX2luaXQiLCJ4IiwiZ2V0Q29tcG9uZW50TmFtZUZyb21Pd25lciIsIm93bmVyIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlciIsIl9kZWJ1Z0luZm8iLCJjcmVhdGVDdXJzb3IiLCJkZWZhdWx0VmFsdWUiLCJwb3AiLCJjdXJzb3IiLCJpbmRleCRqc2NvbXAkMCIsImZpYmVyU3RhY2siLCJ2YWx1ZVN0YWNrIiwicmVxdWlyZWRDb250ZXh0IiwiYyIsInB1c2hIb3N0Q29udGFpbmVyIiwibmV4dFJvb3RJbnN0YW5jZSIsInJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yIiwiY29udGV4dEZpYmVyU3RhY2tDdXJzb3IiLCJjb250ZXh0U3RhY2tDdXJzb3IiLCJuZXh0Um9vdENvbnRleHQiLCJkb2N1bWVudEVsZW1lbnQiLCJuYW1lc3BhY2VVUkkiLCJnZXRPd25Ib3N0Q29udGV4dCIsIkhvc3RDb250ZXh0TmFtZXNwYWNlTm9uZSIsInRhZ05hbWUiLCJnZXRDaGlsZEhvc3RDb250ZXh0UHJvZCIsIkhvc3RDb250ZXh0TmFtZXNwYWNlU3ZnIiwiSG9zdENvbnRleHROYW1lc3BhY2VNYXRoIiwidG9Mb3dlckNhc2UiLCJ1cGRhdGVkQW5jZXN0b3JJbmZvRGV2IiwiYW5jZXN0b3JJbmZvIiwicG9wSG9zdENvbnRhaW5lciIsImdldEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250ZXh0IiwiaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciIsIm5leHRDb250ZXh0IiwicG9wSG9zdENvbnRleHQiLCJIb3N0VHJhbnNpdGlvbkNvbnRleHQiLCJfY3VycmVudFZhbHVlIiwiTm90UGVuZGluZ1RyYW5zaXRpb24iLCJkaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJsb2ciLCJwcmV2SW5mbyIsImluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsImdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJncm91cEVuZCIsInByb3BzIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwicHJlZml4IiwibWF0Y2giLCJzdGFjayIsInRyaW0iLCJzdWZmaXgiLCJpbmRleE9mIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwicmVlbnRyeSIsImZyYW1lIiwiY29tcG9uZW50RnJhbWVDYWNoZSIsImdldCIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJIIiwiUnVuSW5Sb290RnJhbWUiLCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJwcm90b3R5cGUiLCJSZWZsZWN0IiwiY29udHJvbCIsImNhbGwiLCJ4JDAiLCJ4JDEiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsImluY2x1ZGVzIiwiX2ZyYW1lIiwicmVwbGFjZSIsImZvcm1hdE93bmVyU3RhY2siLCJwcmV2UHJlcGFyZVN0YWNrVHJhY2UiLCJzdGFydHNXaXRoIiwibGFzdEluZGV4T2YiLCJkZXNjcmliZUZpYmVyIiwiZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kIiwid29ya0luUHJvZ3Jlc3MiLCJkZWJ1Z0luZm8iLCJlbnRyeSIsIkpTQ29tcGlsZXJfdGVtcF9jb25zdCIsImVudiIsIkpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCIsIm1lc3NhZ2UiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWVXaXRob3V0TGluZU51bWJlciIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsIiwiX2RlYnVnT3duZXIiLCJnZXRDdXJyZW50RmliZXJTdGFja0luRGV2IiwiZGVidWdTdGFjayIsIl9kZWJ1Z1N0YWNrIiwib3duZXJTdGFjayIsInJ1bldpdGhGaWJlckluREVWIiwiY2FsbGJhY2siLCJhcmcwIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYXJnNCIsInByZXZpb3VzRmliZXIiLCJzZXRDdXJyZW50RmliZXIiLCJfZGVidWdUYXNrIiwicnVuIiwiYmluZCIsImdldEN1cnJlbnRTdGFjayIsImlzUmVuZGVyaW5nIiwidHlwZU5hbWUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImNvbnN0cnVjdG9yIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJlIiwiY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbiIsImF0dHJpYnV0ZU5hbWUiLCJjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24iLCJwcm9wTmFtZSIsImNoZWNrRm9ybUZpZWxkVmFsdWVTdHJpbmdDb2VyY2lvbiIsImluamVjdEludGVybmFscyIsImludGVybmFscyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImhvb2siLCJpc0Rpc2FibGVkIiwic3VwcG9ydHNGaWJlciIsInJlbmRlcmVySUQiLCJpbmplY3QiLCJpbmplY3RlZEhvb2siLCJlcnIiLCJjaGVja0RDRSIsInNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzIiwibmV3SXNTdHJpY3RNb2RlIiwibG9nJDEiLCJ1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSIsInNldFN0cmljdE1vZGUiLCJoYXNMb2dnZWRFcnJvciIsImluamVjdFByb2ZpbGluZ0hvb2tzIiwicHJvZmlsaW5nSG9va3MiLCJpbmplY3RlZFByb2ZpbGluZ0hvb2tzIiwibWFya0NvbW1pdFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkIiwibWFya1JlbmRlclN0YXJ0ZWQiLCJsYW5lcyIsIm1hcmtSZW5kZXJTdG9wcGVkIiwibWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkIiwibGFuZSIsImNsejMyRmFsbGJhY2siLCJMTjIiLCJnZXRMYWJlbEZvckxhbmUiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyIsInBlbmRpbmdTeW5jTGFuZXMiLCJnZXROZXh0TGFuZXMiLCJ3aXBMYW5lcyIsInJvb3RIYXNQZW5kaW5nQ29tbWl0IiwicGVuZGluZ0xhbmVzIiwibmV4dExhbmVzIiwic3VzcGVuZGVkTGFuZXMiLCJwaW5nZWRMYW5lcyIsIndhcm1MYW5lcyIsIm5vbklkbGVQZW5kaW5nTGFuZXMiLCJjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nIiwicmVuZGVyTGFuZXMiLCJjb21wdXRlRXhwaXJhdGlvblRpbWUiLCJjdXJyZW50VGltZSIsImNsYWltTmV4dFRyYW5zaXRpb25MYW5lIiwibmV4dFRyYW5zaXRpb25MYW5lIiwiY2xhaW1OZXh0UmV0cnlMYW5lIiwibmV4dFJldHJ5TGFuZSIsImNyZWF0ZUxhbmVNYXAiLCJpbml0aWFsIiwibGFuZU1hcCIsIm1hcmtSb290VXBkYXRlZCQxIiwidXBkYXRlTGFuZSIsIm1hcmtSb290RmluaXNoZWQiLCJmaW5pc2hlZExhbmVzIiwicmVtYWluaW5nTGFuZXMiLCJzcGF3bmVkTGFuZSIsInVwZGF0ZWRMYW5lcyIsInN1c3BlbmRlZFJldHJ5TGFuZXMiLCJwcmV2aW91c2x5UGVuZGluZ0xhbmVzIiwiZXhwaXJlZExhbmVzIiwiZW50YW5nbGVkTGFuZXMiLCJlcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyIsInNoZWxsU3VzcGVuZENvdW50ZXIiLCJlbnRhbmdsZW1lbnRzIiwiZXhwaXJhdGlvblRpbWVzIiwiaGlkZGVuVXBkYXRlcyIsImNsejMyIiwiaGlkZGVuVXBkYXRlc0ZvckxhbmUiLCJtYXJrU3Bhd25lZERlZmVycmVkTGFuZSIsInNwYXduZWRMYW5lSW5kZXgiLCJtYXJrUm9vdEVudGFuZ2xlZCIsInJvb3RFbnRhbmdsZWRMYW5lcyIsImdldEJ1bXBlZExhbmVGb3JIeWRyYXRpb25CeUxhbmUiLCJhZGRGaWJlclRvTGFuZXNNYXAiLCJpc0RldlRvb2xzUHJlc2VudCIsInBlbmRpbmdVcGRhdGVyc0xhbmVNYXAiLCJhZGQiLCJtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQiLCJtZW1vaXplZFVwZGF0ZXJzIiwic2l6ZSIsImhhcyIsImNsZWFyIiwibGFuZXNUb0V2ZW50UHJpb3JpdHkiLCJEaXNjcmV0ZUV2ZW50UHJpb3JpdHkiLCJDb250aW51b3VzRXZlbnRQcmlvcml0eSIsIkRlZmF1bHRFdmVudFByaW9yaXR5IiwiSWRsZUV2ZW50UHJpb3JpdHkiLCJyZXNvbHZlVXBkYXRlUHJpb3JpdHkiLCJ1cGRhdGVQcmlvcml0eSIsIlJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzIiwicCIsIndpbmRvdyIsImV2ZW50IiwiZ2V0RXZlbnRQcmlvcml0eSIsInJ1bldpdGhQcmlvcml0eSIsInByaW9yaXR5IiwicHJldmlvdXNQcmlvcml0eSIsImRldGFjaERlbGV0ZWRJbnN0YW5jZSIsImludGVybmFsSW5zdGFuY2VLZXkiLCJpbnRlcm5hbFByb3BzS2V5IiwiaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5IiwiaW50ZXJuYWxFdmVudEhhbmRsZXJMaXN0ZW5lcnNLZXkiLCJpbnRlcm5hbEV2ZW50SGFuZGxlc1NldEtleSIsImdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlIiwidGFyZ2V0Tm9kZSIsInRhcmdldEluc3QiLCJwYXJlbnROb2RlIiwiaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleSIsImdldFBhcmVudFN1c3BlbnNlSW5zdGFuY2UiLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSIsImluc3QiLCJnZXRSZXNvdXJjZXNGcm9tUm9vdCIsInJlc291cmNlcyIsImludGVybmFsUm9vdE5vZGVSZXNvdXJjZXNLZXkiLCJob2lzdGFibGVTdHlsZXMiLCJNYXAiLCJob2lzdGFibGVTY3JpcHRzIiwibWFya05vZGVBc0hvaXN0YWJsZSIsImludGVybmFsSG9pc3RhYmxlTWFya2VyIiwicmVnaXN0ZXJUd29QaGFzZUV2ZW50IiwicmVnaXN0cmF0aW9uTmFtZSIsImRlcGVuZGVuY2llcyIsInJlZ2lzdGVyRGlyZWN0RXZlbnQiLCJyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzIiwibG93ZXJDYXNlZE5hbWUiLCJwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIiwib25kYmxjbGljayIsImFsbE5hdGl2ZUV2ZW50cyIsImNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMiLCJoYXNSZWFkT25seVZhbHVlIiwib25DaGFuZ2UiLCJvbklucHV0IiwicmVhZE9ubHkiLCJkaXNhYmxlZCIsImNoZWNrZWQiLCJpc0F0dHJpYnV0ZU5hbWVTYWZlIiwiaGFzT3duUHJvcGVydHkiLCJ2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJ0ZXN0IiwiZ2V0VmFsdWVGb3JBdHRyaWJ1dGVPbkN1c3RvbUNvbXBvbmVudCIsImV4cGVjdGVkIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwic2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlIiwic2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlIiwibmFtZXNwYWNlIiwic2V0QXR0cmlidXRlTlMiLCJnZXRUb1N0cmluZ1ZhbHVlIiwiaXNDaGVja2FibGUiLCJlbGVtIiwibm9kZU5hbWUiLCJ0cmFja1ZhbHVlT25Ob2RlIiwidmFsdWVGaWVsZCIsImRlc2NyaXB0b3IiLCJjdXJyZW50VmFsdWUiLCJnZXRWYWx1ZSIsInNldFZhbHVlIiwic3RvcFRyYWNraW5nIiwiX3ZhbHVlVHJhY2tlciIsInRyYWNrIiwidXBkYXRlVmFsdWVJZkNoYW5nZWQiLCJ0cmFja2VyIiwibGFzdFZhbHVlIiwiZ2V0QWN0aXZlRWxlbWVudCIsImRvYyIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImJvZHkiLCJlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzIiwiZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3Rlc1JlZ2V4IiwiY2giLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJ2YWxpZGF0ZUlucHV0UHJvcHMiLCJkZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSIsInVwZGF0ZUlucHV0IiwibGFzdERlZmF1bHRWYWx1ZSIsInNldERlZmF1bHRWYWx1ZSIsImluaXRJbnB1dCIsImlzSHlkcmF0aW5nIiwib3duZXJEb2N1bWVudCIsInZhbGlkYXRlT3B0aW9uUHJvcHMiLCJjaGlsZHJlbiIsIlJlYWN0IiwiQ2hpbGRyZW4iLCJkaWRXYXJuSW52YWxpZENoaWxkIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJkaWRXYXJuSW52YWxpZElubmVySFRNTCIsInNlbGVjdGVkIiwiZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24iLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJvd25lck5hbWUiLCJ1cGRhdGVPcHRpb25zIiwibXVsdGlwbGUiLCJwcm9wVmFsdWUiLCJzZXREZWZhdWx0U2VsZWN0ZWQiLCJvcHRpb25zIiwiZGVmYXVsdFNlbGVjdGVkIiwidmFsaWRhdGVTZWxlY3RQcm9wcyIsInZhbHVlUHJvcE5hbWVzIiwicHJvcE5hbWVJc0FycmF5IiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwidmFsaWRhdGVUZXh0YXJlYVByb3BzIiwiZGlkV2FyblZhbERlZmF1bHRWYWwiLCJ1cGRhdGVUZXh0YXJlYSIsImluaXRUZXh0YXJlYSIsInRleHRDb250ZW50IiwiZmluZE5vdGFibGVOb2RlIiwiaW5kZW50Iiwic2VydmVyUHJvcHMiLCJzZXJ2ZXJUYWlsIiwiZGlzdGFuY2VGcm9tTGVhZiIsImluZGVudGF0aW9uIiwicmVwZWF0IiwiYWRkZWQiLCJyZW1vdmVkIiwiZGVzY3JpYmVGaWJlclR5cGUiLCJkZXNjcmliZVRleHROb2RlIiwiY29udGVudCIsIm1heExlbmd0aCIsIm5lZWRzRXNjYXBpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzY3JpYmVUZXh0RGlmZiIsImNsaWVudFRleHQiLCJmaXJzdERpZmYiLCJvYmplY3ROYW1lIiwib2JqZWN0IiwibSIsInAwIiwiZGVzY3JpYmVWYWx1ZSIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsImpzb25Qcm9wTmFtZSIsIlN0cmluZyIsImRlc2NyaWJlUHJvcFZhbHVlIiwiZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQiLCJyb3dQcmVmaXgiLCJyZW1haW5pbmdSb3dMZW5ndGgiLCJwcm9wZXJ0aWVzIiwiZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZiIsImNsaWVudE9iamVjdCIsInNlcnZlck9iamVjdCIsInJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMiLCJjbGllbnRQcm9wVmFsdWUiLCJfcHJvcE5hbWUiLCJkZXNjcmliZUVsZW1lbnREaWZmIiwiY2xpZW50UHJvcHMiLCJzZXJ2ZXJQcm9wTmFtZXMiLCJwcm9wTmFtZSRqc2NvbXAkMCIsIl9wcm9wTmFtZTIiLCJtYXhMZW5ndGgkanNjb21wJDAiLCJzZXJ2ZXJQcm9wTmFtZSIsImRlbGV0ZSIsImtleXMiLCJkZXNjcmliZVNpYmxpbmdGaWJlciIsImRlc2NyaWJlTm9kZSIsInNraXBUb05vZGUiLCJzZXJ2ZXJDb21wb25lbnROYW1lIiwiZGVzY3JpYmVEaWZmIiwicm9vdE5vZGUiLCJkZXNjcmliZUFuY2VzdG9ycyIsImFuY2VzdG9yIiwicmVwbGFjZUFsbCIsIm9sZEluZm8iLCJlbXB0eUFuY2VzdG9ySW5mb0RldiIsImluU2NvcGVUYWdzIiwiYVRhZ0luU2NvcGUiLCJidXR0b25UYWdJblNjb3BlIiwibm9iclRhZ0luU2NvcGUiLCJidXR0b25TY29wZVRhZ3MiLCJwVGFnSW5CdXR0b25TY29wZSIsInNwZWNpYWxUYWdzIiwibGlzdEl0ZW1UYWdBdXRvY2xvc2luZyIsImRsSXRlbVRhZ0F1dG9jbG9zaW5nIiwiZm9ybVRhZyIsImNvbnRhaW5lclRhZ0luU2NvcGUiLCJpbXBsaWNpdFJvb3RTY29wZSIsImlzVGFnVmFsaWRXaXRoUGFyZW50IiwicGFyZW50VGFnIiwiaW1wbGllZEVuZFRhZ3MiLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZmluZEFuY2VzdG9yIiwicGFyZW50IiwidmFsaWRhdGVET01OZXN0aW5nIiwiY2hpbGRUYWciLCJwYXJlbnRJbmZvIiwiYW5jZXN0b3JUYWciLCJkaWRXYXJuIiwiYW5jZXN0b3JEZXNjcmlwdGlvbiIsInRhZ0Rpc3BsYXlOYW1lIiwidmFsaWRhdGVUZXh0TmVzdGluZyIsImNoaWxkVGV4dCIsInNldFRleHRDb250ZW50IiwidGV4dCIsImZpcnN0Q2hpbGQiLCJsYXN0Q2hpbGQiLCJub2RlVmFsdWUiLCJjYW1lbGl6ZSIsInN0cmluZyIsImh5cGhlblBhdHRlcm4iLCJfIiwiY2hhcmFjdGVyIiwidG9VcHBlckNhc2UiLCJzZXRWYWx1ZUZvclN0eWxlIiwic3R5bGUiLCJzdHlsZU5hbWUiLCJpc0N1c3RvbVByb3BlcnR5Iiwid2FybmVkU3R5bGVOYW1lcyIsIm1zUGF0dGVybiIsImJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiIsImNoYXJBdCIsImJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiIsIndhcm5lZFN0eWxlVmFsdWVzIiwiaXNOYU4iLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsImlzRmluaXRlIiwid2FybmVkRm9ySW5maW5pdHlWYWx1ZSIsInNldFByb3BlcnR5IiwiY3NzRmxvYXQiLCJ1bml0bGVzc051bWJlcnMiLCJzZXRWYWx1ZUZvclN0eWxlcyIsInN0eWxlcyIsInByZXZTdHlsZXMiLCJmcmVlemUiLCJleHBhbmRlZFVwZGF0ZXMiLCJsb25naGFuZHMiLCJzaG9ydGhhbmRUb0xvbmdoYW5kIiwiX2tleSIsImtleSRqc2NvbXAkMCIsIl9rZXkyIiwiX3N0eWxlTmFtZSIsImlzQ3VzdG9tRWxlbWVudCIsImdldEF0dHJpYnV0ZUFsaWFzIiwiYWxpYXNlcyIsInZhbGlkYXRlUHJvcGVydHkkMSIsIndhcm5lZFByb3BlcnRpZXMkMSIsInJBUklBQ2FtZWwkMSIsImFyaWFQcm9wZXJ0aWVzIiwickFSSUEkMSIsInZhbGlkYXRlUHJvcGVydGllcyQyIiwiaW52YWxpZFByb3BzIiwibWFwIiwicHJvcCIsInZhbGlkYXRlUHJvcGVydHkiLCJldmVudFJlZ2lzdHJ5Iiwid2FybmVkUHJvcGVydGllcyIsIkVWRU5UX05BTUVfUkVHRVgiLCJJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSIsInJBUklBQ2FtZWwiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJ3YXJuVW5rbm93blByb3BlcnRpZXMiLCJ1bmtub3duUHJvcHMiLCJzYW5pdGl6ZVVSTCIsInVybCIsImlzSmF2YVNjcmlwdFByb3RvY29sIiwiZ2V0RXZlbnRUYXJnZXQiLCJuYXRpdmVFdmVudCIsInRhcmdldCIsInNyY0VsZW1lbnQiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsInJlc3RvcmVTdGF0ZU9mVGFyZ2V0IiwiaW50ZXJuYWxJbnN0YW5jZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvdGhlck5vZGUiLCJmb3JtIiwib3RoZXJQcm9wcyIsImJhdGNoZWRVcGRhdGVzJDEiLCJpc0luc2lkZUV2ZW50SGFuZGxlciIsInJlc3RvcmVUYXJnZXQiLCJyZXN0b3JlUXVldWUiLCJnZXRMaXN0ZW5lciIsImdldERhdGEiLCJmYWxsYmFja1RleHQiLCJzdGFydCIsInN0YXJ0VmFsdWUiLCJzdGFydFRleHQiLCJzdGFydExlbmd0aCIsImVuZCIsImVuZFZhbHVlIiwiZW5kTGVuZ3RoIiwibWluRW5kIiwiZ2V0RXZlbnRDaGFyQ29kZSIsImtleUNvZGUiLCJjaGFyQ29kZSIsImZ1bmN0aW9uVGhhdFJldHVybnNUcnVlIiwiZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlIiwiY3JlYXRlU3ludGhldGljRXZlbnQiLCJJbnRlcmZhY2UiLCJTeW50aGV0aWNCYXNlRXZlbnQiLCJyZWFjdE5hbWUiLCJyZWFjdEV2ZW50VHlwZSIsIm5hdGl2ZUV2ZW50VGFyZ2V0IiwiX3JlYWN0TmFtZSIsIl90YXJnZXRJbnN0IiwiY3VycmVudFRhcmdldCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJyZXR1cm5WYWx1ZSIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiaXNQZXJzaXN0ZW50IiwibW9kaWZpZXJTdGF0ZUdldHRlciIsImtleUFyZyIsImdldE1vZGlmaWVyU3RhdGUiLCJtb2RpZmllcktleVRvUHJvcCIsImdldEV2ZW50TW9kaWZpZXJTdGF0ZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImRvbUV2ZW50TmFtZSIsIkVORF9LRVlDT0RFUyIsIlNUQVJUX0tFWUNPREUiLCJnZXREYXRhRnJvbUN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiZGF0YSIsImdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMiLCJ3aGljaCIsIlNQQUNFQkFSX0NPREUiLCJoYXNTcGFjZUtleXByZXNzIiwiU1BBQ0VCQVJfQ0hBUiIsImdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyIsImlzQ29tcG9zaW5nIiwiY2FuVXNlQ29tcG9zaXRpb25FdmVudCIsImN0cmxLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwiY2hhciIsImZyb21DaGFyQ29kZSIsInVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhIiwibG9jYWxlIiwiaXNUZXh0SW5wdXRFbGVtZW50Iiwic3VwcG9ydGVkSW5wdXRUeXBlcyIsImlzRXZlbnRTdXBwb3J0ZWQiLCJldmVudE5hbWVTdWZmaXgiLCJjYW5Vc2VET00iLCJpc1N1cHBvcnRlZCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQiLCJkaXNwYXRjaFF1ZXVlIiwiYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzIiwiU3ludGhldGljRXZlbnQiLCJsaXN0ZW5lcnMiLCJydW5FdmVudEluQmF0Y2giLCJwcm9jZXNzRGlzcGF0Y2hRdWV1ZSIsImdldEluc3RJZlZhbHVlQ2hhbmdlZCIsImdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiYWN0aXZlRWxlbWVudCQxIiwiZGV0YWNoRXZlbnQiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsImFjdGl2ZUVsZW1lbnRJbnN0JDEiLCJwcm9wZXJ0eU5hbWUiLCJoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwiLCJhdHRhY2hFdmVudCIsImdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwiLCJnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQiLCJpcyIsInkiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsIm9iamVjdElzIiwia2V5c0EiLCJrZXlzQiIsImN1cnJlbnRLZXkiLCJnZXRMZWFmTm9kZSIsImdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQiLCJvZmZzZXQiLCJub2RlRW5kIiwibmV4dFNpYmxpbmciLCJjb250YWluc05vZGUiLCJvdXRlck5vZGUiLCJpbm5lck5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiZ2V0QWN0aXZlRWxlbWVudERlZXAiLCJjb250YWluZXJJbmZvIiwiZGVmYXVsdFZpZXciLCJIVE1MSUZyYW1lRWxlbWVudCIsImNvbnRlbnRXaW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMiLCJjb250ZW50RWRpdGFibGUiLCJjb25zdHJ1Y3RTZWxlY3RFdmVudCIsIm1vdXNlRG93biIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwiZ2V0U2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwibGFzdFNlbGVjdGlvbiIsImFjdGl2ZUVsZW1lbnRJbnN0IiwibWFrZVByZWZpeE1hcCIsInN0eWxlUHJvcCIsImV2ZW50TmFtZSIsInByZWZpeGVzIiwiZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUiLCJwcmVmaXhlZEV2ZW50TmFtZXMiLCJ2ZW5kb3JQcmVmaXhlcyIsInByZWZpeE1hcCIsInJlZ2lzdGVyU2ltcGxlRXZlbnQiLCJ0b3BMZXZlbEV2ZW50c1RvUmVhY3ROYW1lcyIsImNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyIiwic291cmNlIiwiZXhpc3RpbmciLCJDYXB0dXJlZFN0YWNrcyIsImZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMiLCJlbmRJbmRleCIsImNvbmN1cnJlbnRRdWV1ZXNJbmRleCIsImNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyIsImNvbmN1cnJlbnRRdWV1ZXMiLCJxdWV1ZSIsInBlbmRpbmciLCJtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdCIsImVucXVldWVVcGRhdGUkMSIsImVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZSIsImdldFJvb3RGb3JVcGRhdGVkRmliZXIiLCJlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUiLCJzb3VyY2VGaWJlciIsImlzSGlkZGVuIiwiY2hpbGRMYW5lcyIsIl92aXNpYmlsaXR5IiwiT2Zmc2NyZWVuVmlzaWJsZSIsIm5lc3RlZFVwZGF0ZUNvdW50IiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCIsInJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMiLCJyb290V2l0aE5lc3RlZFVwZGF0ZXMiLCJORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQiLCJ3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWIiwicmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nIiwiZmFtaWx5IiwicmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmciLCJpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmciLCJwcmV2VHlwZSIsImVsZW1lbnRUeXBlIiwibmVlZHNDb21wYXJlRmFtaWxpZXMiLCIkJHR5cGVvZk5leHRUeXBlIiwibWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmciLCJXZWFrU2V0IiwiZmFpbGVkQm91bmRhcmllcyIsImNhbmRpZGF0ZVR5cGUiLCJuZWVkc1JlbmRlciIsIl9kZWJ1Z05lZWRzUmVtb3VudCIsInNjaGVkdWxlVXBkYXRlT25GaWJlciIsInJlZkNsZWFudXAiLCJyZWYiLCJ1cGRhdGVRdWV1ZSIsIm1lbW9pemVkUHJvcHMiLCJzdWJ0cmVlRmxhZ3MiLCJkZWxldGlvbnMiLCJhY3R1YWxEdXJhdGlvbiIsImFjdHVhbFN0YXJ0VGltZSIsInRyZWVCYXNlRHVyYXRpb24iLCJzZWxmQmFzZUR1cmF0aW9uIiwiX2RlYnVnSG9va1R5cGVzIiwiaGFzQmFkTWFwUG9seWZpbGwiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInNob3VsZENvbnN0cnVjdCIsIkNvbXBvbmVudCIsImlzUmVhY3RDb21wb25lbnQiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzcyIsImZpcnN0Q29udGV4dCIsIl9kZWJ1Z1RoZW5hYmxlU3RhdGUiLCJyZXNldFdvcmtJblByb2dyZXNzIiwiY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzIiwiZmliZXJUYWciLCJyZXNvbHZlZFR5cGUiLCJpc0hvc3RIb2lzdGFibGVUeXBlIiwiY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQiLCJTdHJpY3RMZWdhY3lNb2RlIiwiU3RyaWN0RWZmZWN0c01vZGUiLCJQcm9maWxlTW9kZSIsImVmZmVjdER1cmF0aW9uIiwicGFzc2l2ZUVmZmVjdER1cmF0aW9uIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsImNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQiLCJfb3duZXIiLCJlbGVtZW50cyIsImNyZWF0ZUZpYmVyRnJvbVRleHQiLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJwb3J0YWwiLCJwZW5kaW5nQ2hpbGRyZW4iLCJpbXBsZW1lbnRhdGlvbiIsInB1c2hUcmVlRm9yayIsInRvdGFsQ2hpbGRyZW4iLCJ3YXJuSWZOb3RIeWRyYXRpbmciLCJmb3JrU3RhY2siLCJmb3JrU3RhY2tJbmRleCIsInRyZWVGb3JrQ291bnQiLCJ0cmVlRm9ya1Byb3ZpZGVyIiwicHVzaFRyZWVJZCIsImlkU3RhY2siLCJpZFN0YWNrSW5kZXgiLCJ0cmVlQ29udGV4dElkIiwidHJlZUNvbnRleHRPdmVyZmxvdyIsInRyZWVDb250ZXh0UHJvdmlkZXIiLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VMZW5ndGgiLCJudW1iZXJPZk92ZXJmbG93Qml0cyIsInB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQiLCJwb3BUcmVlQ29udGV4dCIsImJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUiLCJoeWRyYXRpb25EaWZmUm9vdERFViIsInNpYmxpbmdzIiwid2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UiLCJyZWplY3RlZENhbmRpZGF0ZSIsImRpZFN1c3BlbmRPckVycm9yREVWIiwiZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyIsInRocm93T25IeWRyYXRpb25NaXNtYXRjaCIsImZyb21UZXh0IiwiYXJndW1lbnRzIiwiZGlmZiIsImRpZmZSb290IiwicXVldWVIeWRyYXRpb25FcnJvciIsIkh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSIsImRpZEh5ZHJhdGUiLCJ2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50IiwibGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCIsIm1lZGlhRXZlbnRUeXBlcyIsInN1cHByZXNzSHlkcmF0aW9uV2FybmluZyIsImNoZWNrRm9yVW5tYXRjaGVkVGV4dCIsInBvcG92ZXIiLCJvblNjcm9sbCIsIm9uU2Nyb2xsRW5kIiwib25DbGljayIsIm9uY2xpY2siLCJub29wJDEiLCJwb3BUb05leHRIb3N0UGFyZW50IiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJyb290T3JTaW5nbGV0b25Db250ZXh0IiwicG9wSHlkcmF0aW9uU3RhdGUiLCJKU0NvbXBpbGVyX3RlbXAiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJkaWZmTm9kZSIsImRlc2NyaXB0aW9uIiwiZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSIsImdldE5leHRIeWRyYXRhYmxlIiwiaXNTaW5nbGV0b25TY29wZSIsInByZXZpb3VzSHlkcmF0YWJsZU9uRW50ZXJpbmdTY29wZWRTaW5nbGV0b24iLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwidXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUiLCJxdWV1ZWRFcnJvcnMiLCJoeWRyYXRpb25FcnJvcnMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyIsImFwcGx5IiwiZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncyIsInJlc2V0Q29udGV4dERlcGVuZGVuY2llcyIsImxhc3RDb250ZXh0RGVwZW5kZW5jeSIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicHVzaFByb3ZpZGVyIiwicHJvdmlkZXJGaWJlciIsIm5leHRWYWx1ZSIsInZhbHVlQ3Vyc29yIiwicmVuZGVyZXJDdXJzb3JERVYiLCJfY3VycmVudFJlbmRlcmVyIiwicmVuZGVyZXJTaWdpbCIsInBvcFByb3ZpZGVyIiwiY3VycmVudFJlbmRlcmVyIiwic2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aCIsInByb3BhZ2F0aW9uUm9vdCIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzIiwiY29udGV4dHMiLCJmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWUiLCJsaXN0IiwibmV4dEZpYmVyIiwiZGVwZW5kZW5jeSIsInByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzIiwiaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQiLCJjdXJyZW50UGFyZW50IiwiY2hlY2tJZkNvbnRleHRDaGFuZ2VkIiwiY3VycmVudERlcGVuZGVuY2llcyIsIm1lbW9pemVkVmFsdWUiLCJwcmVwYXJlVG9SZWFkQ29udGV4dCIsInJlYWRDb250ZXh0IiwicmVhZENvbnRleHRGb3JDb25zdW1lciIsInJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24iLCJjb25zdW1lciIsImNyZWF0ZUNhY2hlIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlckxvY2FsIiwicmVmQ291bnQiLCJyZXRhaW5DYWNoZSIsImNhY2hlIiwic2lnbmFsIiwiYWJvcnRlZCIsInJlbGVhc2VDYWNoZSIsInNjaGVkdWxlQ2FsbGJhY2skMiIsIk5vcm1hbFByaW9yaXR5IiwiYWJvcnQiLCJwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zIiwicHJldkVmZmVjdER1cmF0aW9uIiwicHJvZmlsZXJFZmZlY3REdXJhdGlvbiIsInBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyIsImVsYXBzZWRUaW1lIiwiYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zIiwicHVzaENvbXBvbmVudEVmZmVjdFN0YXJ0IiwicHJldkVmZmVjdFN0YXJ0IiwiY29tcG9uZW50RWZmZWN0U3RhcnRUaW1lIiwicG9wQ29tcG9uZW50RWZmZWN0U3RhcnQiLCJzdGFydFByb2ZpbGVyVGltZXIiLCJwcm9maWxlclN0YXJ0VGltZSIsIm5vdyIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24iLCJzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbiIsInJlY29yZEVmZmVjdER1cmF0aW9uIiwic3RhcnRFZmZlY3RUaW1lciIsInRyYW5zZmVyQWN0dWFsRHVyYXRpb24iLCJlbnRhbmdsZUFzeW5jQWN0aW9uIiwidHJhbnNpdGlvbiIsInRoZW5hYmxlIiwiY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyIsImVudGFuZ2xlZExpc3RlbmVycyIsImN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQiLCJjdXJyZW50RW50YW5nbGVkTGFuZSIsInJlcXVlc3RUcmFuc2l0aW9uTGFuZSIsImN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSIsInN0YXR1cyIsInRoZW4iLCJyZXNvbHZlIiwicGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSIsImNoYWluVGhlbmFibGVWYWx1ZSIsInJlc3VsdCIsInRoZW5hYmxlV2l0aE92ZXJyaWRlIiwicmVhc29uIiwicGVla0NhY2hlRnJvbVBvb2wiLCJjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXIiLCJyZXN1bWVkQ2FjaGUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3QiLCJwb29sZWRDYWNoZSIsInB1c2hUcmFuc2l0aW9uIiwib2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MiLCJwcmV2Q2FjaGVQb29sIiwicG9vbCIsImdldFN1c3BlbmRlZENhY2hlIiwiY2FjaGVGcm9tUG9vbCIsIkNhY2hlQ29udGV4dCIsImNyZWF0ZVRoZW5hYmxlU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UiLCJ0aGVuYWJsZXMiLCJpc1RoZW5hYmxlUmVzb2x2ZWQiLCJub29wJDMiLCJ0cmFja1VzZWRUaGVuYWJsZSIsInRoZW5hYmxlU3RhdGUiLCJhY3RRdWV1ZSIsImRpZFVzZVByb21pc2UiLCJ0cmFja2VkVGhlbmFibGVzIiwiY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2giLCJmdWxmaWxsZWRWYWx1ZSIsImZ1bGZpbGxlZFRoZW5hYmxlIiwicmVqZWN0ZWRUaGVuYWJsZSIsInN1c3BlbmRlZFRoZW5hYmxlIiwibmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYiLCJTdXNwZW5zZUV4Y2VwdGlvbiIsImdldFN1c3BlbmRlZFRoZW5hYmxlIiwicmVqZWN0ZWRSZWFzb24iLCJTdXNwZW5zZUFjdGlvbkV4Y2VwdGlvbiIsInB1c2hEZWJ1Z0luZm8iLCJwcmV2aW91c0RlYnVnSW5mbyIsImN1cnJlbnREZWJ1Z0luZm8iLCJjb25jYXQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJyZXR1cm5GaWJlciIsImVycm9yZWRLZXkiLCJ1bndyYXBUaGVuYWJsZSIsInRoZW5hYmxlSW5kZXhDb3VudGVyJDEiLCJ0aGVuYWJsZVN0YXRlJDEiLCJjb2VyY2VSZWYiLCJ0aHJvd09uSW52YWxpZE9iamVjdFR5cGUiLCJuZXdDaGlsZCIsIlJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUiLCJ3YXJuT25GdW5jdGlvblR5cGUiLCJpbnZhbGlkQ2hpbGQiLCJwYXJlbnROYW1lIiwib3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nIiwid2Fybk9uU3ltYm9sVHlwZSIsIm93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmciLCJjcmVhdGVDaGlsZFJlY29uY2lsZXIiLCJzaG91bGRUcmFja1NpZGVFZmZlY3RzIiwiZGVsZXRlQ2hpbGQiLCJjaGlsZFRvRGVsZXRlIiwiZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4iLCJjdXJyZW50Rmlyc3RDaGlsZCIsIm1hcFJlbWFpbmluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZHJlbiIsInVzZUZpYmVyIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlRnJhZ21lbnQiLCJjYWxsTGF6eUluaXRJbkRFViIsInVwZGF0ZVBvcnRhbCIsImZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfcHJldkRlYnVnSW5mbyIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJfcHJldkRlYnVnSW5mbzciLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwiU2V0IiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJyZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yIiwic3RlcCIsImRvbmUiLCJyZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwiLCJwcmV2RGVidWdJbmZvIiwiZGlkV2FybkFib3V0R2VuZXJhdG9ycyIsImVudHJpZXMiLCJkaWRXYXJuQWJvdXRNYXBzIiwiZmlyc3RDaGlsZEZpYmVyIiwiZGVidWdUYXNrIiwiaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlIiwiYmFzZVN0YXRlIiwiZmlyc3RCYXNlVXBkYXRlIiwibGFzdEJhc2VVcGRhdGUiLCJzaGFyZWQiLCJoaWRkZW5DYWxsYmFja3MiLCJjYWxsYmFja3MiLCJjbG9uZVVwZGF0ZVF1ZXVlIiwiY3JlYXRlVXBkYXRlIiwiVXBkYXRlU3RhdGUiLCJwYXlsb2FkIiwiZW5xdWV1ZVVwZGF0ZSIsImN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSIsImRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUiLCJjb21wb25lbnROYW1lIiwiZXhlY3V0aW9uQ29udGV4dCIsIlJlbmRlckNvbnRleHQiLCJOb0NvbnRleHQiLCJlbnRhbmdsZVRyYW5zaXRpb25zIiwicXVldWVMYW5lcyIsImVucXVldWVDYXB0dXJlZFVwZGF0ZSIsImNhcHR1cmVkVXBkYXRlIiwibmV3Rmlyc3QiLCJuZXdMYXN0IiwiY2xvbmUiLCJzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uIiwiZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiIsImVudGFuZ2xlZEFjdGlvblRoZW5hYmxlIiwicHJvY2Vzc1VwZGF0ZVF1ZXVlIiwiaW5zdGFuY2UkanNjb21wJDAiLCJoYXNGb3JjZVVwZGF0ZSIsInBlbmRpbmdRdWV1ZSIsImxhc3RQZW5kaW5nVXBkYXRlIiwiZmlyc3RQZW5kaW5nVXBkYXRlIiwibmV3U3RhdGUiLCJpc0hpZGRlblVwZGF0ZSIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIiwicGFydGlhbFN0YXRlIiwibmV4dFByb3BzIiwiaW5zdGFuY2UiLCJSZXBsYWNlU3RhdGUiLCJuZXh0U3RhdGUiLCJDYXB0dXJlVXBkYXRlIiwiRm9yY2VVcGRhdGUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMiLCJjYWxsQ2FsbGJhY2siLCJjb21taXRIaWRkZW5DYWxsYmFja3MiLCJjb21taXRDYWxsYmFja3MiLCJwdXNoSGlkZGVuQ29udGV4dCIsInByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyIsImVudGFuZ2xlZFJlbmRlckxhbmVzIiwicHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yIiwiY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciIsImJhc2VMYW5lcyIsInJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2siLCJwb3BIaWRkZW5Db250ZXh0IiwicHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyIiwic3VzcGVuc2VTdGFja0N1cnNvciIsIlN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIiwic3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IiLCJzaGVsbEJvdW5kYXJ5IiwicHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlciIsInJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayIsInBvcFN1c3BlbnNlSGFuZGxlciIsImZpbmRGaXJzdFN1c3BlbmRlZCIsInJvdyIsInN0YXRlIiwiU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBIiwiaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2siLCJyZXZlYWxPcmRlciIsIm1vdW50SG9va1R5cGVzRGV2IiwiaG9va05hbWUiLCJjdXJyZW50SG9va05hbWVJbkRldiIsImhvb2tUeXBlc0RldiIsInVwZGF0ZUhvb2tUeXBlc0RldiIsImhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2IiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQiLCJ0YWJsZSIsIm9sZEhvb2tOYW1lIiwibmV3SG9va05hbWUiLCJjaGVja0RlcHNBcmVBcnJheURldiIsImRlcHMiLCJ3YXJuT25Vc2VGb3JtU3RhdGVJbkRldiIsImRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZSIsInRocm93SW52YWxpZEhvb2tFcnJvciIsImFyZUhvb2tJbnB1dHNFcXVhbCIsIm5leHREZXBzIiwicHJldkRlcHMiLCJpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyIsInJlbmRlcldpdGhIb29rcyIsInNlY29uZEFyZyIsIm5leHRSZW5kZXJMYW5lcyIsImRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50IiwiSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViIsIk5vTW9kZSIsImNhbGxDb21wb25lbnRJbkRFViIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyIsInJlbmRlcldpdGhIb29rc0FnYWluIiwiZmluaXNoUmVuZGVyaW5nSG9va3MiLCJDb250ZXh0T25seURpc3BhdGNoZXIiLCJkaWRSZW5kZXJUb29GZXdIb29rcyIsImN1cnJlbnRIb29rIiwid29ya0luUHJvZ3Jlc3NIb29rIiwiZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSIsInRoZW5hYmxlSW5kZXhDb3VudGVyIiwiZGlkUmVjZWl2ZVVwZGF0ZSIsImRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJSRV9SRU5ERVJfTElNSVQiLCJsYXN0RWZmZWN0IiwiZXZlbnRzIiwic3RvcmVzIiwibWVtb0NhY2hlIiwiSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIiwiVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCIsImRpc3BhdGNoZXIiLCJtYXliZVRoZW5hYmxlIiwidXNlU3RhdGUiLCJ1c2VUaGVuYWJsZSIsImNoZWNrRGlkUmVuZGVySWRIb29rIiwiZGlkUmVuZGVySWRIb29rIiwibG9jYWxJZENvdW50ZXIiLCJiYWlsb3V0SG9va3MiLCJyZXNldEhvb2tzT25VbndpbmQiLCJtb3VudFdvcmtJblByb2dyZXNzSG9vayIsImJhc2VRdWV1ZSIsInVwZGF0ZVdvcmtJblByb2dyZXNzSG9vayIsIm5leHRDdXJyZW50SG9vayIsIm5leHRXb3JrSW5Qcm9ncmVzc0hvb2siLCJjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwidXNlIiwidXNhYmxlIiwidXNlTWVtb0NhY2hlIiwiQXJyYXkiLCJSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMIiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJhY3Rpb24iLCJtb3VudFJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsImluaXQiLCJpbml0aWFsU3RhdGUiLCJkaXNwYXRjaCIsImxhc3RSZW5kZXJlZFJlZHVjZXIiLCJsYXN0UmVuZGVyZWRTdGF0ZSIsImRpc3BhdGNoUmVkdWNlckFjdGlvbiIsInVwZGF0ZVJlZHVjZXIiLCJ1cGRhdGVSZWR1Y2VySW1wbCIsImJhc2VGaXJzdCIsIm5ld0Jhc2VRdWV1ZUZpcnN0IiwibmV3QmFzZVF1ZXVlTGFzdCIsInJldmVydExhbmUiLCJnZXN0dXJlIiwiaGFzRWFnZXJTdGF0ZSIsImVhZ2VyU3RhdGUiLCJyZXJlbmRlclJlZHVjZXIiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJtb3VudFN5bmNFeHRlcm5hbFN0b3JlIiwic3Vic2NyaWJlIiwiZ2V0U25hcHNob3QiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsIm5leHRTbmFwc2hvdCIsImRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IiwicHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayIsIm1vdW50RWZmZWN0Iiwic3Vic2NyaWJlVG9TdG9yZSIsInB1c2hTaW1wbGVFZmZlY3QiLCJIYXNFZmZlY3QiLCJQYXNzaXZlIiwiZGVzdHJveSIsInVwZGF0ZVN0b3JlSW5zdGFuY2UiLCJ1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSIsImlzSHlkcmF0aW5nJGpzY29tcCQwIiwiY2FjaGVkU25hcHNob3QiLCJjcmVhdGUiLCJ1cGRhdGVFZmZlY3RJbXBsIiwicmVuZGVyZWRTbmFwc2hvdCIsImNoZWNrSWZTbmFwc2hvdENoYW5nZWQiLCJmb3JjZVN0b3JlUmVyZW5kZXIiLCJsYXRlc3RHZXRTbmFwc2hvdCIsIm1vdW50U3RhdGVJbXBsIiwiaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIiLCJtb3VudFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZSIsIm1vdW50T3B0aW1pc3RpYyIsInBhc3N0aHJvdWdoIiwiZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUiLCJ1cGRhdGVPcHRpbWlzdGljIiwidXBkYXRlT3B0aW1pc3RpY0ltcGwiLCJyZXJlbmRlck9wdGltaXN0aWMiLCJkaXNwYXRjaEFjdGlvblN0YXRlIiwiYWN0aW9uUXVldWUiLCJzZXRQZW5kaW5nU3RhdGUiLCJzZXRTdGF0ZSIsImlzUmVuZGVyUGhhc2VVcGRhdGUiLCJhY3Rpb25Ob2RlIiwiaXNUcmFuc2l0aW9uIiwibGlzdGVuZXIiLCJUIiwicnVuQWN0aW9uU3RhdGVBY3Rpb24iLCJwcmV2U3RhdGUiLCJwcmV2VHJhbnNpdGlvbiIsImN1cnJlbnRUcmFuc2l0aW9uIiwiX3VwZGF0ZWRGaWJlcnMiLCJvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCIsIlMiLCJoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZSIsIm9uQWN0aW9uRXJyb3IiLCJ0eXBlcyIsImVycm9yJDQiLCJhc3luY1RyYW5zaXRpb25zIiwicmVsZWFzZUFzeW5jVHJhbnNpdGlvbiIsIm9uQWN0aW9uU3VjY2VzcyIsIm5vdGlmeUFjdGlvbkxpc3RlbmVycyIsImxhc3QiLCJhY3Rpb25TdGF0ZVJlZHVjZXIiLCJvbGRTdGF0ZSIsIm1vdW50QWN0aW9uU3RhdGUiLCJpbml0aWFsU3RhdGVQcm9wIiwic3NyRm9ybVN0YXRlIiwiZm9ybVN0YXRlIiwiaXNNYXRjaGluZyIsIm1hcmtlckluc3RhbmNlIiwiaW5Sb290T3JTaW5nbGV0b24iLCJGT1JNX1NUQVRFX0lTX01BVENISU5HIiwiRk9STV9TVEFURV9JU19OT1RfTUFUQ0hJTkciLCJ1cGRhdGVBY3Rpb25TdGF0ZSIsInN0YXRlSG9vayIsInVwZGF0ZUFjdGlvblN0YXRlSW1wbCIsImN1cnJlbnRTdGF0ZUhvb2siLCJhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdCIsInJlcmVuZGVyQWN0aW9uU3RhdGUiLCJtb3VudFJlZiIsImluaXRpYWxWYWx1ZSIsIm1vdW50RWZmZWN0SW1wbCIsImZpYmVyRmxhZ3MiLCJob29rRmxhZ3MiLCJOb1N0cmljdFBhc3NpdmVFZmZlY3RzTW9kZSIsIm1vdW50TGF5b3V0RWZmZWN0IiwiTGF5b3V0IiwiaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdCIsIm1vdW50SW1wZXJhdGl2ZUhhbmRsZSIsInVwZGF0ZUltcGVyYXRpdmVIYW5kbGUiLCJtb3VudENhbGxiYWNrIiwidXBkYXRlQ2FsbGJhY2siLCJtb3VudE1lbW8iLCJuZXh0Q3JlYXRlIiwidXBkYXRlTWVtbyIsIm1vdW50RGVmZXJyZWRWYWx1ZSIsIm1vdW50RGVmZXJyZWRWYWx1ZUltcGwiLCJ1cGRhdGVEZWZlcnJlZFZhbHVlIiwidXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwiLCJyZXJlbmRlckRlZmVycmVkVmFsdWUiLCJyZXF1ZXN0RGVmZXJyZWRMYW5lIiwicHJldlZhbHVlIiwic3RhcnRUcmFuc2l0aW9uIiwicGVuZGluZ1N0YXRlIiwiZmluaXNoZWRTdGF0ZSIsInRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSIsImRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbCIsInJlcXVlc3RVcGRhdGVMYW5lIiwic3RhcnRIb3N0VHJhbnNpdGlvbiIsImZvcm1GaWJlciIsImZvcm1EYXRhIiwiZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwiLCJyZXF1ZXN0Rm9ybVJlc2V0JDEiLCJleGlzdGluZ1N0YXRlSG9vayIsImluaXRpYWxSZXNldFN0YXRlIiwicmVzZXRTdGF0ZVF1ZXVlIiwibW91bnRUcmFuc2l0aW9uIiwidXBkYXRlVHJhbnNpdGlvbiIsImJvb2xlYW5PclRoZW5hYmxlIiwicmVyZW5kZXJUcmFuc2l0aW9uIiwidXNlSG9zdFRyYW5zaXRpb25TdGF0dXMiLCJtb3VudElkIiwiaWRlbnRpZmllclByZWZpeCIsInRyZWVJZCIsImlkV2l0aExlYWRpbmdCaXQiLCJnbG9iYWxDbGllbnRJZENvdW50ZXIiLCJtb3VudFJlZnJlc2giLCJyZWZyZXNoQ2FjaGUiLCJzZWVkS2V5IiwicHJvdmlkZXIiLCJhcmdzIiwiZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlIiwiZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlIiwicHJldkRpc3BhdGNoZXIiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsImN1cnJlbnRTdGF0ZSIsInRocm93SWZEdXJpbmdSZW5kZXIiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2siLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImN0b3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsImNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50IiwiY2xhc3NDb21wb25lbnRVcGRhdGVyIiwiZW5xdWV1ZVJlcGxhY2VTdGF0ZSIsInJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzIiwiYmFzZVByb3BzIiwiZGVmYXVsdFByb3BzIiwiZGVmYXVsdE9uVW5jYXVnaHRFcnJvciIsInJlcG9ydEdsb2JhbEVycm9yIiwiZGVmYXVsdE9uQ2F1Z2h0RXJyb3IiLCJjb21wb25lbnROYW1lTWVzc2FnZSIsInJlY3JlYXRlTWVzc2FnZSIsImVycm9yQm91bmRhcnlOYW1lIiwiZW52aXJvbm1lbnROYW1lIiwiYmFkZ2VGb3JtYXQiLCJiYWRnZVN0eWxlIiwicGFkIiwicmVzZXRTdHlsZSIsInVuc2hpZnQiLCJkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yIiwibG9nVW5jYXVnaHRFcnJvciIsImVycm9ySW5mbyIsInRocm93bkVycm9ycyIsIm9uVW5jYXVnaHRFcnJvciIsImNvbXBvbmVudFN0YWNrIiwiZSQ1Iiwic2V0VGltZW91dCIsImxvZ0NhdWdodEVycm9yIiwiYm91bmRhcnkiLCJvbkNhdWdodEVycm9yIiwiZXJyb3JCb3VuZGFyeSIsImUkNiIsImNyZWF0ZVJvb3RFcnJvclVwZGF0ZSIsImNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUiLCJpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImNvbXBvbmVudERpZENhdGNoIiwibGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQiLCJjYWxsQ29tcG9uZW50RGlkQ2F0Y2hJbkRFViIsInRocm93RXhjZXB0aW9uIiwicm9vdFJlbmRlckxhbmVzIiwicmVzdG9yZVBlbmRpbmdVcGRhdGVycyIsInJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzIiwiUm9vdEluUHJvZ3Jlc3MiLCJSb290U3VzcGVuZGVkIiwibm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlIiwiYXR0YWNoUGluZ0xpc3RlbmVyIiwidHJhbnNpdGlvbnMiLCJtYXJrZXJJbnN0YW5jZXMiLCJyZXRyeVF1ZXVlIiwiY2F1c2UiLCJSb290U3VzcGVuZGVkV2l0aERlbGF5IiwiUm9vdEVycm9yZWQiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzIiwicmVjb25jaWxlQ2hpbGRyZW4iLCJuZXh0Q2hpbGRyZW4iLCJtb3VudENoaWxkRmliZXJzIiwicmVjb25jaWxlQ2hpbGRGaWJlcnMiLCJ1cGRhdGVGb3J3YXJkUmVmIiwicHJvcHNXaXRob3V0UmVmIiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsInVwZGF0ZU1lbW9Db21wb25lbnQiLCJjb21wYXJlIiwidmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2IiwidXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudCIsImNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0IiwicHJldlByb3BzIiwidXBkYXRlRnVuY3Rpb25Db21wb25lbnQiLCJ1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQiLCJkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudCIsImNhY2hlUG9vbCIsIm5leHRCYXNlTGFuZXMiLCJtYXJrUmVmIiwiZGlkV2FybkFib3V0QmFkQ2xhc3MiLCJSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyIsInJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiY29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVzIiwicmVwbGF5RnVuY3Rpb25Db21wb25lbnQiLCJ1cGRhdGVDbGFzc0NvbXBvbmVudCIsIl9pbnN0YW5jZSIsInVwZGF0ZXIiLCJlbnF1ZXVlU2V0U3RhdGUiLCJjb250ZXh0VHlwZSIsImRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSIsIl9yZWFjdEludGVybmFscyIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJmYWtlSW50ZXJuYWxJbnN0YW5jZSIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwibmV3QXBpTmFtZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsImNoaWxkQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMSIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudERpZFVubW91bnQiLCJjb21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJjb21wb25lbnREaWRVcGRhdGUiLCJkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUiLCJnZXRDaGlsZENvbnRleHQiLCJyZWZzIiwiZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUiLCJyZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsImNvbXBvbmVudERpZE1vdW50IiwidW5yZXNvbHZlZE9sZFByb3BzIiwib2xkQ29udGV4dCIsImNhbGxSZW5kZXJJbkRFViIsImRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMiLCJtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyIsImRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQiLCJtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUiLCJnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZSIsInByaW1hcnlUcmVlRGlkRGVmZXIiLCJ3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSIsInVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50IiwiSlNDb21waWxlcl9vYmplY3RfaW5saW5lX2RpZ2VzdF8yNDQ2IiwiSlNDb21waWxlcl9vYmplY3RfaW5saW5lX3N0YWNrXzI0NDciLCJKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfY29tcG9uZW50U3RhY2tfMjQ0OCIsImRpZFN1c3BlbmQiLCJGb3JjZVN1c3BlbnNlRmFsbGJhY2siLCJKU0NvbXBpbGVyX29iamVjdF9pbmxpbmVfbWVzc2FnZV8yNDQ1IiwidHJlZUNvbnRleHQiLCJvdmVyZmxvdyIsInJldHJ5TGFuZSIsImZhbGxiYWNrIiwibW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyIiwiU1VTUEVOREVEX01BUktFUiIsIm1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4iLCJyZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyIsImRhdGFzZXQiLCJkZ3N0IiwibXNnIiwic3RjayIsImNzdGNrIiwiZGlnZXN0IiwiU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uIiwicHJpbWFyeUNoaWxkcmVuIiwib2Zmc2NyZWVuUHJvcHMiLCJfcGVuZGluZ01hcmtlcnMiLCJfcmV0cnlDYWNoZSIsIl90cmFuc2l0aW9ucyIsInNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlciIsInZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQiLCJjaGlsZFNsb3QiLCJpc0FuQXJyYXkiLCJpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUiLCJpc0JhY2t3YXJkcyIsInRhaWwiLCJsYXN0Q29udGVudFJvdyIsInRhaWxNb2RlIiwicmVuZGVyU3RhdGUiLCJyZW5kZXJpbmciLCJyZW5kZXJpbmdTdGFydFRpbWUiLCJ1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRSZXZlYWxPcmRlciIsImRpZFdhcm5BYm91dFRhaWxPcHRpb25zIiwiX2kiLCJhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZSIsImRpZFN1c3BlbmRCZWZvcmUiLCJiZWdpbldvcmsiLCJwcmV2U2libGluZyIsImlzRGVoeWRyYXRlZCIsImdldFJlc291cmNlIiwiZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyIiwic2V0SW5pdGlhbFByb3BlcnRpZXMiLCJyZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UiLCJkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzIiwiY2FuSHlkcmF0ZUluc3RhbmNlIiwiY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSIsImhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyIiwicG9vbGVkQ2FjaGVMYW5lcyIsIm1hcmtVcGRhdGUiLCJwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQiLCJTdXNwZW5zZXlJbWFnZXNNb2RlIiwiY29tcGxldGUiLCJzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuIiwiU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uIiwicHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkIiwicmVzb3VyY2UiLCJsb2FkaW5nIiwiSW5zZXJ0ZWQiLCJOb3RMb2FkZWQiLCJwcmVsb2FkUmVzb3VyY2UiLCJzY2hlZHVsZVJldHJ5RWZmZWN0Iiwid29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzIiwiY3V0T2ZmVGFpbElmTmVlZGVkIiwiaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrIiwibGFzdFRhaWxOb2RlIiwiX2xhc3RUYWlsTm9kZSIsImJ1YmJsZVByb3BlcnRpZXMiLCJjb21wbGV0ZWRXb3JrIiwiZGlkQmFpbG91dCIsIm5ld0NoaWxkTGFuZXMiLCJfdHJlZUJhc2VEdXJhdGlvbiIsIl9jaGlsZDIiLCJjb21wbGV0ZVdvcmsiLCJwZW5kaW5nQ29udGV4dCIsIm5leHRSZXNvdXJjZSIsIl9jdXJyZW50SG9zdENvbnRleHQiLCJjcmVhdGVFbGVtZW50TlMiLCJTVkdfTkFNRVNQQUNFIiwiTUFUSF9OQU1FU1BBQ0UiLCJpbm5lckhUTUwiLCJyZW1vdmVDaGlsZCIsIndhcm5lZFVua25vd25UYWdzIiwiYXBwZW5kQ2hpbGQiLCJhdXRvRm9jdXMiLCJkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MiLCJjcmVhdGVUZXh0Tm9kZSIsImxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzIiwibm93JDEiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lIiwidW53aW5kV29yayIsInVud2luZEludGVycnVwdGVkV29yayIsImludGVycnVwdGVkV29yayIsInNob3VsZFByb2ZpbGUiLCJjb21taXRIb29rTGF5b3V0RWZmZWN0cyIsImZpbmlzaGVkV29yayIsImNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQiLCJjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMiLCJuZWFyZXN0TW91bnRlZEFuY2VzdG9yIiwiY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50IiwiZmlyc3RFZmZlY3QiLCJOb0ZsYWdzIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkIiwiSW5zZXJ0aW9uIiwiaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0IiwiY2FsbENyZWF0ZUluREVWIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkIiwiYWRkZW5kdW0iLCJuIiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkIiwiY2FsbERlc3Ryb3lJbkRFViIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQiLCJjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJjb21taXRDbGFzc0NhbGxiYWNrcyIsImNhbGxHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXMiLCJjb21taXRDbGFzc1NuYXBzaG90IiwicmVzb2x2ZWRQcmV2UHJvcHMiLCJzbmFwc2hvdCIsImRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUiLCJzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFViIsImNvbW1pdEF0dGFjaFJlZiIsImluc3RhbmNlVG9Vc2UiLCJzYWZlbHlBdHRhY2hSZWYiLCJzYWZlbHlEZXRhY2hSZWYiLCJlcnJvciQ3IiwiY29tbWl0UHJvZmlsZXIiLCJjb21taXRTdGFydFRpbWUiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUiLCJvbkNvbW1pdCIsIm9uUmVuZGVyIiwiY3VycmVudFVwZGF0ZUlzTmVzdGVkIiwiY29tbWl0UHJvZmlsZXJQb3N0Q29tbWl0SW1wbCIsIl9maW5pc2hlZFdvcmskbWVtb2l6ZTIiLCJvblBvc3RDb21taXQiLCJjb21taXRIb3N0TW91bnQiLCJjb21taXRNb3VudCIsImNvbW1pdEhvc3RVcGRhdGUiLCJjb21taXRVcGRhdGUiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIiLCJiZWZvcmUiLCJ3YXJuRm9yUmVhY3RDaGlsZHJlbkNvbmZsaWN0IiwiaW5zZXJ0QmVmb3JlIiwiX3JlYWN0Um9vdENvbnRhaW5lciIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZSIsImNvbW1pdFBsYWNlbWVudCIsImhvc3RQYXJlbnRGaWJlciIsInBhcmVudEZpYmVyIiwicmVzZXRUZXh0Q29udGVudCIsImNvbW1pdEhvc3RTaW5nbGV0b25BY3F1aXNpdGlvbiIsInNpbmdsZXRvbiIsImFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyIsImV2ZW50c0VuYWJsZWQiLCJfZW5hYmxlZCIsInNlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJlJDIiLCJpbmRleFdpdGhpbkFuY2hvciIsImluZGV4V2l0aGluRm9jdXMiLCJzZWxlY3Rpb25JbmZvcm1hdGlvbiIsImZvY3VzZWRFbGVtIiwic2VsZWN0aW9uUmFuZ2UiLCJuZXh0RWZmZWN0IiwiY2xlYXJDb250YWluZXJTcGFyaW5nbHkiLCJjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyIiwiZmluaXNoZWRSb290IiwicmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMiLCJjYWxsQ29tcG9uZW50RGlkTW91bnRJbkRFViIsImNhbGxDb21wb25lbnREaWRVcGRhdGVJbkRFViIsImNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzIiwicmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeSIsInJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5Iiwib2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwib2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyIsImRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyIsImNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIiLCJkZWxldGVkRmliZXIiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsImNvdW50IiwicHJldkhvc3RQYXJlbnQiLCJob3N0UGFyZW50IiwicHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciIsImhvc3RQYXJlbnRJc0NvbnRhaW5lciIsInJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImNsZWFyU3VzcGVuc2VCb3VuZGFyeSIsInJldHJ5SWZCbG9ja2VkT24iLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSIsImdldFJldHJ5Q2FjaGUiLCJyZXRyeUNhY2hlIiwiUG9zc2libHlXZWFrU2V0IiwiYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyIsIndha2VhYmxlcyIsIndha2VhYmxlIiwicmV0cnkiLCJyZXNvbHZlUmV0cnlXYWtlYWJsZSIsImluUHJvZ3Jlc3NMYW5lcyIsImluUHJvZ3Jlc3NSb290IiwicmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyIsInJvb3QkanNjb21wJDAiLCJjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyIiwiY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzIiwiaG9pc3RhYmxlUm9vdCIsImN1cnJlbnRIb2lzdGFibGVSb290IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJoZWFkIiwicXVlcnlTZWxlY3RvciIsIm1heWJlTm9kZXMiLCJnZXRIeWRyYXRhYmxlSG9pc3RhYmxlQ2FjaGUiLCJyZWwiLCJ0aXRsZSIsImNyb3NzT3JpZ2luIiwicHJvcGVydHkiLCJodHRwRXF1aXYiLCJjaGFyU2V0IiwibW91bnRIb2lzdGFibGUiLCJhY3F1aXJlUmVzb3VyY2UiLCJuZWVkc0Zvcm1SZXNldCIsImNvbW1pdFRleHRVcGRhdGUiLCJ0YWdDYWNoZXMiLCJnZXRIb2lzdGFibGVSb290IiwiY29tbWl0SHlkcmF0ZWRDb250YWluZXIiLCJyZWN1cnNpdmVseVJlc2V0Rm9ybXMiLCJnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIiwid2FzSGlkZGVuIiwicHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzIiwiaGlkZUluc3RhbmNlIiwidW5oaWRlSW5zdGFuY2UiLCJoaWRlVGV4dEluc3RhbmNlIiwidW5oaWRlVGV4dEluc3RhbmNlIiwicmVzZXQiLCJkaXNhcHBlYXJMYXlvdXRFZmZlY3RzIiwicmVhcHBlYXJMYXlvdXRFZmZlY3RzIiwiaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyIsImNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMiLCJwcmV2aW91c0NhY2hlIiwiY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QiLCJyZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdHRlZExhbmVzIiwiY29tbWl0dGVkVHJhbnNpdGlvbnMiLCJjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyIiwicHJldlByb2ZpbGVyRWZmZWN0RHVyYXRpb24iLCJfY3VycmVudCIsIk9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkIiwicmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzIiwicmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJfaW5zdGFuY2UyIiwiZmluaXNoZWRSb290JGpzY29tcCQwIiwicmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0Iiwic3VzcGVuc2V5Q29tbWl0RmxhZyIsImFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyIiwic3VzcGVuZFJlc291cmNlIiwicHJldmlvdXNIb2lzdGFibGVSb290IiwiZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MiLCJyZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbiIsImNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdCIsImRlbGV0ZWRTdWJ0cmVlUm9vdCIsIm5lYXJlc3RNb3VudGVkQW5jZXN0b3IkanNjb21wJDAiLCJvbkNvbW1pdFJvb3QiLCJjb21taXRIb29rcyIsImNvbW1pdEhvb2siLCJpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCIsImlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCIsIklTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCIsInN1c3BlbnNlSGFuZGxlciIsImlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyIsImRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMiLCJ3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiIsIlN1c3BlbmRlZE9uRGF0YSIsIlN1c3BlbmRlZE9uQWN0aW9uIiwiY2FuY2VsUGVuZGluZ0NvbW1pdCIsInByZXBhcmVGcmVzaFN0YWNrIiwibWFya1Jvb3RTdXNwZW5kZWQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciIsIndhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFViIsIndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIiwiZW5zdXJlUm9vdElzU2NoZWR1bGVkIiwicGVyZm9ybVdvcmtPblJvb3QiLCJmb3JjZVN5bmMiLCJDb21taXRDb250ZXh0Iiwic2hvdWxkVGltZVNsaWNlIiwiZXhpdFN0YXR1cyIsInJlbmRlclJvb3RDb25jdXJyZW50IiwicmVuZGVyUm9vdFN5bmMiLCJyZW5kZXJXYXNDb25jdXJyZW50Iiwid29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmciLCJpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMiLCJlcnJvclJldHJ5TGFuZXMiLCJlcnJvclJldHJ5TGFuZXMkanNjb21wJDAiLCJ3YXNSb290RGVoeWRyYXRlZCIsIndvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciIsIlJvb3RGYXRhbEVycm9yZWQiLCJSb290U3VzcGVuZGVkQXRUaGVTaGVsbCIsIndvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyIsIlJvb3RDb21wbGV0ZWQiLCJjb21taXRSb290Iiwid29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyIsIndvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUiLCJGQUxMQkFDS19USFJPVFRMRV9NUyIsInRpbWVvdXRIYW5kbGUiLCJzY2hlZHVsZVRpbWVvdXQiLCJjb21taXRSb290V2hlblJlYWR5IiwiVEhST1RUTEVEX0NPTU1JVCIsInJlbmRlclN0YXJ0VGltZSIsIklNTUVESUFURV9DT01NSVQiLCJyZWNvdmVyYWJsZUVycm9ycyIsImRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSIsImRpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyIsInN1c3BlbmRlZENvbW1pdFJlYXNvbiIsImNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSIsImNvbXBsZXRlZFJlbmRlckVuZFRpbWUiLCJub1RpbWVvdXQiLCJzdXNwZW5kZWRTdGF0ZSIsInN0eWxlc2hlZXRzIiwidW5zdXNwZW5kIiwibm9vcCIsIndhaXRGb3JDb21taXRUb0JlUmVhZHkiLCJTVVNQRU5ERURfQ09NTUlUIiwiY2hlY2siLCJkaWRBdHRlbXB0RW50aXJlVHJlZSIsIndvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIiwiZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwiLCJyZXNldFdvcmtJblByb2dyZXNzU3RhY2siLCJOb3RTdXNwZW5kZWQiLCJjYW5jZWxUaW1lb3V0Iiwid29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSIsImFsbEVudGFuZ2xlZExhbmVzIiwiZ2V0Q3VycmVudFRpbWUiLCJsYXN0UmVzZXRUaW1lIiwicmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MiLCJkaXNjYXJkUGVuZGluZ1dhcm5pbmdzIiwiaGFuZGxlVGhyb3ciLCJ0aHJvd25WYWx1ZSIsIlN1c3BlbmRlZE9uSW1tZWRpYXRlIiwiU3VzcGVuZGVkT25JbnN0YW5jZSIsIlN1c3BlbmRlZE9uSHlkcmF0aW9uIiwiU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlIiwiU3VzcGVuZGVkT25FcnJvciIsImVycm9yZWRXb3JrIiwibWFya0NvbXBvbmVudEVycm9yZWQiLCJTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUiLCJtYXJrQ29tcG9uZW50U3VzcGVuZGVkIiwicHVzaERpc3BhdGNoZXIiLCJwdXNoQXN5bmNEaXNwYXRjaGVyIiwicHJldkFzeW5jRGlzcGF0Y2hlciIsIkEiLCJEZWZhdWx0QXN5bmNEaXNwYXRjaGVyIiwic2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmciLCJwcmV2RXhlY3V0aW9uQ29udGV4dCIsInVuaXRPZldvcmsiLCJ0aHJvd0FuZFVud2luZFdvcmtMb29wIiwid29ya0xvb3BTeW5jIiwidGhyb3duVmFsdWUkOCIsInBlcmZvcm1Vbml0T2ZXb3JrIiwiUkVOREVSX1RJTUVPVVRfTVMiLCJyZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrIiwiU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZSIsImhvc3RGaWJlciIsImNvbXBsZXRlVW5pdE9mV29yayIsIndvcmtMb29wQ29uY3VycmVudEJ5U2NoZWR1bGVyIiwidGhyb3duVmFsdWUkOSIsIm1hcmtSZW5kZXJZaWVsZGVkIiwic2hvdWxkWWllbGQiLCJyZXBsYXlCZWdpbldvcmsiLCJpc1Byb2ZpbGluZ01vZGUiLCJzdXNwZW5kZWRSZWFzb24iLCJ1bndpbmRVbml0T2ZXb3JrIiwic2tpcFNpYmxpbmdzIiwicGVuZGluZ0VmZmVjdHNTdGF0dXMiLCJOT19QRU5ESU5HX0VGRkVDVFMiLCJmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJtYXJrQ29tbWl0U3RhcnRlZCIsInBlbmRpbmdGaW5pc2hlZFdvcmsiLCJwZW5kaW5nRWZmZWN0c1Jvb3QiLCJwZW5kaW5nRWZmZWN0c0xhbmVzIiwicGVuZGluZ0VmZmVjdHNSZW1haW5pbmdMYW5lcyIsInBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMiLCJwZW5kaW5nUmVjb3ZlcmFibGVFcnJvcnMiLCJjYWxsYmFja05vZGUiLCJjYWxsYmFja1ByaW9yaXR5Iiwic2NoZWR1bGVDYWxsYmFjayQxIiwiTm9ybWFsUHJpb3JpdHkkMSIsImZsdXNoUGFzc2l2ZUVmZmVjdHMiLCJQRU5ESU5HX01VVEFUSU9OX1BIQVNFIiwiZmx1c2hNdXRhdGlvbkVmZmVjdHMiLCJmbHVzaExheW91dEVmZmVjdHMiLCJmbHVzaFNwYXduZWRXb3JrIiwicm9vdE11dGF0aW9uSGFzRWZmZWN0IiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsIk1hdGgiLCJtaW4iLCJ3aW4iLCJzdGFydCRqc2NvbXAkMCIsImVuZCRqc2NvbXAkMCIsImV4dGVuZCIsInN0YXJ0TWFya2VyIiwiZW5kTWFya2VyIiwicmFuZ2UiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0IiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJzZXRFbmQiLCJsZWZ0Iiwic2Nyb2xsTGVmdCIsInRvcCIsInNjcm9sbFRvcCIsImZvY3VzIiwiUEVORElOR19MQVlPVVRfUEhBU0UiLCJyb290SGFzTGF5b3V0RWZmZWN0IiwibWFya0xheW91dEVmZmVjdHNTdGFydGVkIiwibWFya0xheW91dEVmZmVjdHNTdG9wcGVkIiwiUEVORElOR19BRlRFUl9NVVRBVElPTl9QSEFTRSIsIlBFTkRJTkdfU1BBV05FRF9XT1JLIiwicmVxdWVzdFBhaW50Iiwicm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cyIsIlBFTkRJTkdfUEFTU0lWRV9QSEFTRSIsInJlbGVhc2VSb290UG9vbGVkQ2FjaGUiLCJjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYiLCJvbkNvbW1pdEZpYmVyUm9vdCIsImRpZEVycm9yIiwic2NoZWR1bGVyUHJpb3JpdHkiLCJJbW1lZGlhdGVQcmlvcml0eSIsIlVzZXJCbG9ja2luZ1ByaW9yaXR5IiwiSWRsZVByaW9yaXR5Iiwib25SZWNvdmVyYWJsZUVycm9yIiwicmVjb3ZlcmFibGVFcnJvciIsIm1ha2VFcnJvckluZm8iLCJuZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJ3YXNEZWxheWVkQ29tbWl0IiwicmVuZGVyUHJpb3JpdHkiLCJtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkIiwiZmluaXNoZWRXb3JrJGpzY29tcCQwIiwibWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCIsIm9uUG9zdENvbW1pdEZpYmVyUm9vdCIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290Iiwicm9vdEZpYmVyIiwicGluZ0NhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwidGhyZWFkSURzIiwicGluZ1N1c3BlbmRlZFJvb3QiLCJyZXRyeVRpbWVkT3V0Qm91bmRhcnkiLCJib3VuZGFyeUZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFViIsImlzSW5TdHJpY3RNb2RlIiwiaXNTdHJpY3RNb2RlRmliZXIiLCJkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlciIsInNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzIiwiZG91YmxlSW52b2tlRWZmZWN0cyIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQiLCJzY2hlZHVsaW5nRmliZXIiLCJwcmlvcml0eUxldmVsIiwiZmFrZUFjdENhbGxiYWNrTm9kZSQxIiwic2NoZWR1bGVDYWxsYmFjayQzIiwibGFzdFNjaGVkdWxlZFJvb3QiLCJmaXJzdFNjaGVkdWxlZFJvb3QiLCJtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsiLCJkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QiLCJzY2hlZHVsZUltbWVkaWF0ZVJvb3RTY2hlZHVsZVRhc2siLCJkaWRTY2hlZHVsZU1pY3JvdGFzayIsInN5bmNUcmFuc2l0aW9uTGFuZXMiLCJvbmx5TGVnYWN5IiwiaXNGbHVzaGluZ1dvcmsiLCJkaWRQZXJmb3JtU29tZVdvcmsiLCJwZXJmb3JtU3luY1dvcmtPblJvb3QiLCJwcm9jZXNzUm9vdFNjaGVkdWxlSW5JbW1lZGlhdGVUYXNrIiwicHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrIiwiY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUiLCJzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uIiwicHJldiIsInNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2siLCJleHBpcmF0aW9uVGltZSIsImNhbmNlbENhbGxiYWNrIiwiZmFrZUFjdENhbGxiYWNrTm9kZSIsInBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzayIsImRpZFRpbWVvdXQiLCJvcmlnaW5hbENhbGxiYWNrTm9kZSIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwIiwiY2FuY2VsQ2FsbGJhY2skMSIsInNjaGVkdWxlTWljcm90YXNrIiwiY29lcmNlRm9ybUFjdGlvblByb3AiLCJhY3Rpb25Qcm9wIiwiY3JlYXRlRm9ybURhdGFXaXRoU3VibWl0dGVyIiwic3VibWl0dGVyIiwidGVtcCIsIkZvcm1EYXRhIiwiZXh0cmFjdEV2ZW50cyQxIiwibWF5YmVUYXJnZXRJbnN0IiwiZm9ybUFjdGlvbiIsIm1ldGhvZCIsImV4ZWN1dGVEaXNwYXRjaCIsImV2ZW50U3lzdGVtRmxhZ3MiLCJfZGlzcGF0Y2hRdWV1ZSRpIiwicHJldmlvdXNJbnN0YW5jZSIsImkkanNjb21wJDAiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMkaSIsInRhcmdldEVsZW1lbnQiLCJub25EZWxlZ2F0ZWRFdmVudHMiLCJsaXN0ZW5lclNldCIsImxpc3RlbmVyU2V0S2V5IiwiYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5Ub05hdGl2ZUV2ZW50IiwiaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciIsInJvb3RDb250YWluZXJFbGVtZW50IiwibGlzdGVuaW5nTWFya2VyIiwidGFyZ2V0Q29udGFpbmVyIiwibGlzdGVuZXJXcmFwcGVyIiwiZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50IiwiZGlzcGF0Y2hDb250aW51b3VzRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwicGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2FwdHVyZSIsInBhc3NpdmUiLCJkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0iLCJ0YXJnZXRJbnN0JGpzY29tcCQwIiwiYW5jZXN0b3JJbnN0Iiwibm9kZVRhZyIsImNvbnRhaW5lciIsImdyYW5kVGFnIiwiU3ludGhldGljRXZlbnRDdG9yIiwiU3ludGhldGljS2V5Ym9hcmRFdmVudCIsIlN5bnRoZXRpY0ZvY3VzRXZlbnQiLCJidXR0b24iLCJTeW50aGV0aWNNb3VzZUV2ZW50IiwiU3ludGhldGljRHJhZ0V2ZW50IiwiU3ludGhldGljVG91Y2hFdmVudCIsIkFOSU1BVElPTl9FTkQiLCJBTklNQVRJT05fSVRFUkFUSU9OIiwiQU5JTUFUSU9OX1NUQVJUIiwiU3ludGhldGljQW5pbWF0aW9uRXZlbnQiLCJUUkFOU0lUSU9OX0VORCIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIlN5bnRoZXRpY1VJRXZlbnQiLCJTeW50aGV0aWNXaGVlbEV2ZW50IiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJTeW50aGV0aWNQb2ludGVyRXZlbnQiLCJTeW50aGV0aWNUb2dnbGVFdmVudCIsImluQ2FwdHVyZVBoYXNlIiwiYWNjdW11bGF0ZVRhcmdldE9ubHkiLCJyZWFjdEV2ZW50TmFtZSIsImxhc3RIb3N0Q29tcG9uZW50IiwiY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lciIsImN1cnJlbnRSZXBsYXlpbmdFdmVudCIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsInBhcmVudFdpbmRvdyIsInRvRWxlbWVudCIsImdldFBhcmVudCIsImFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQiLCJnZXRUYXJnZXRJbnN0RnVuYyIsImlzSW5wdXRFdmVudFN1cHBvcnRlZCIsImhhbmRsZUV2ZW50RnVuYyIsInNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCIsImZhbGxiYWNrRGF0YSIsImV2ZW50VHlwZSIsIlN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQiLCJjYW5Vc2VUZXh0SW5wdXRFdmVudCIsIlN5bnRoZXRpY0lucHV0RXZlbnQiLCJ0YXJnZXRGaWJlciIsImNhcHR1cmVOYW1lIiwiX2luc3RhbmNlMyIsImNvbW1vbiIsIl9pbnN0YW5jZTQiLCJkaWRXYXJuVmFsdWVOdWxsIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwid2FybkZvclByb3BEaWZmZXJlbmNlIiwic2VydmVyVmFsdWUiLCJjbGllbnRWYWx1ZSIsInNlcnZlckRpZmZlcmVuY2VzIiwibm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlIiwid2FybkZvckV4dHJhQXR0cmlidXRlcyIsImRvbUVsZW1lbnQiLCJhdHRyaWJ1dGVOYW1lcyIsImdldFByb3BOYW1lRnJvbUF0dHJpYnV0ZU5hbWUiLCJnZXRTdHlsZXNPYmplY3RGcm9tRWxlbWVudCIsIndhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciIsIm5vcm1hbGl6ZUhUTUwiLCJodG1sIiwibWFya3VwIiwiTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYIiwiTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYIiwic2VydmVyVGV4dCIsInNldFByb3AiLCJlbmNUeXBlIiwiZGlkV2FybkZvcm1BY3Rpb25NZXRob2QiLCJkaWRXYXJuRm9ybUFjdGlvblRhcmdldCIsImRpZFdhcm5Gb3JtQWN0aW9uVHlwZSIsImRpZFdhcm5Gb3JtQWN0aW9uTmFtZSIsImZvcm1FbmNUeXBlIiwiZm9ybU1ldGhvZCIsImZvcm1UYXJnZXQiLCJfX2h0bWwiLCJtdXRlZCIsInhsaW5rTmFtZXNwYWNlIiwiZGlkV2FybkZvck5ld0Jvb2xlYW5Qcm9wc1dpdGhFbXB0eVZhbHVlIiwieG1sTmFtZXNwYWNlIiwiZGlkV2FyblBvcG92ZXJUYXJnZXRPYmplY3QiLCJzZXRQcm9wT25DdXN0b21FbGVtZW50IiwiZW5kc1dpdGgiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFzU3JjIiwiaGFzU3JjU2V0IiwicHJvcEtleSIsInNyY1NldCIsInNyYyIsIl9wcm9wVmFsdWUiLCJ1cGRhdGVQcm9wZXJ0aWVzIiwibGFzdFByb3BzIiwibGFzdFByb3AiLCJfcHJvcEtleTgiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCIsIl9wcm9wS2V5MTMiLCJfcHJvcEtleTE1IiwiX3Byb3BLZXkxNyIsIl9wcm9wS2V5MTkiLCJhdHRyTmFtZSIsInNlcnZlclZhbHVlSW5PYmplY3RGb3JtIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImRpZmZIeWRyYXRlZFN0eWxlcyIsInZhbHVlJGpzY29tcCQwIiwiZGVsaW1pdGVyIiwidXBwZXJjYXNlUGF0dGVybiIsIm1zUGF0dGVybiQxIiwiaHlkcmF0ZUF0dHJpYnV0ZSIsImV4dHJhQXR0cmlidXRlcyIsImh5ZHJhdGVCb29sZWFuQXR0cmlidXRlIiwiaHlkcmF0ZUJvb2xlYW5pc2hBdHRyaWJ1dGUiLCJoeWRyYXRlTnVtZXJpY0F0dHJpYnV0ZSIsImh5ZHJhdGVTYW5pdGl6ZWRBdHRyaWJ1dGUiLCJob3N0Q29udGV4dCIsImF0dHJpYnV0ZXMiLCJhdXRvZm9jdXMiLCJFWFBFQ1RFRF9GT1JNX0FDVElPTl9VUkwiLCJzZXJ2ZXJEaWZmZXJlbmNlcyRqc2NvbXAkMCIsInByb3BOYW1lc0xpc3RKb2luIiwiY29tYmluYXRvciIsInBhcmVudE5hbWVzcGFjZSIsImN1cnJlbnRQb3BzdGF0ZVRyYW5zaXRpb25FdmVudCIsImhhbmRsZUVycm9ySW5OZXh0VGljayIsInNyY3NldCIsInRleHRJbnN0YW5jZSIsIm9sZFRleHQiLCJuZXdUZXh0IiwiX19yZWFjdFdhcm5lZEFib3V0Q2hpbGRyZW5Db25mbGljdCIsInBhcmVudEluc3RhbmNlIiwic3VzcGVuc2VJbnN0YW5jZSIsInBvc3NpYmxlUHJlYW1ibGVDb250cmlidXRpb24iLCJkZXB0aCIsIm5leHROb2RlIiwiU1VTUEVOU0VfRU5EX0RBVEEiLCJQUkVBTUJMRV9DT05UUklCVVRJT05fSFRNTCIsIlBSRUFNQkxFX0NPTlRSSUJVVElPTl9CT0RZIiwiUFJFQU1CTEVfQ09OVFJJQlVUSU9OX0hFQUQiLCJuZXh0Tm9kZSRqc2NvbXAkMCIsIlNVU1BFTlNFX1NUQVJUX0RBVEEiLCJTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBIiwiZGlzcGxheSIsIlNUWUxFIiwiYW55UHJvcHMiLCJyZWFkeVN0YXRlIiwiRE9DVU1FTlRfUkVBRFlfU1RBVEVfQ09NUExFVEUiLCJfcmVhY3RSZXRyeSIsImF0dHIiLCJwYXJlbnRQcm9wcyIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HIiwidGFyZ2V0SW5zdGFuY2UiLCJwcmV2aW91c1NpYmxpbmciLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJ2YWxpZGF0ZURPTU5lc3RpbmdEZXYiLCJpbnRlcm5hbEluc3RhbmNlSGFuZGxlIiwicmVtb3ZlQXR0cmlidXRlTm9kZSIsImdldFJvb3ROb2RlIiwicHJlY29ubmVjdEFzIiwiZ2xvYmFsRG9jdW1lbnQiLCJsaW1pdGVkRXNjYXBlZEhyZWYiLCJwcmVjb25uZWN0c1NldCIsImN1cnJlbnRQcm9wcyIsImN1cnJlbnRSZXNvdXJjZSIsInJlc291cmNlUm9vdCIsInByZWNlZGVuY2UiLCJnZXRTdHlsZUtleSIsIl9zdHlsZXMiLCJfcmVzb3VyY2UiLCJwcmVsb2FkIiwiZ2V0U3R5bGVzaGVldFNlbGVjdG9yRnJvbUtleSIsIl9wIiwiTG9hZGVkIiwicHJlbG9hZFByb3BzTWFwIiwicHJlbG9hZFByb3BzIiwiYXMiLCJpbnRlZ3JpdHkiLCJtZWRpYSIsImhyZWZMYW5nIiwicmVmZXJyZXJQb2xpY3kiLCJwcmVsb2FkU3R5bGVzaGVldCIsImRlc2NyaWJlTGlua0ZvclJlc291cmNlRXJyb3JERVYiLCJhc3luYyIsImdldFNjcmlwdEtleSIsImRlc2NyaWJlZFByb3BzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInN0eWxlc2hlZXRQcm9wc0Zyb21SYXdQcm9wcyIsInJhd1Byb3BzIiwiRXJyb3JlZCIsImdldFNjcmlwdFNlbGVjdG9yRnJvbUtleSIsInN0eWxlUHJvcHMiLCJpbnNlcnRTdHlsZXNoZWV0IiwiYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0IiwibGlua0luc3RhbmNlIiwiUHJvbWlzZSIsInJlamVjdCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJhZG9wdFByZWxvYWRQcm9wc0ZvclNjcmlwdCIsIm5vZGVzIiwicHJpb3IiLCJzdHlsZXNoZWV0UHJvcHMiLCJzY3JpcHRQcm9wcyIsImtleUF0dHJpYnV0ZSIsImNhY2hlcyIsIm5vZGVLZXkiLCJvdXRzaWRlSG9zdENvbnRhaW5lckNvbnRleHQiLCJpdGVtUHJvcCIsIm9uTG9hZCIsIm9uRXJyb3IiLCJTZXR0bGVkIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJvblVuc3VzcGVuZCIsImluc2VydFN1c3BlbmRlZFN0eWxlc2hlZXRzIiwiY29tbWl0Iiwic3R5bGVzaGVldFRpbWVyIiwiY2xlYXJUaW1lb3V0IiwicHJlY2VkZW5jZXNCeVJvb3QiLCJpbnNlcnRTdHlsZXNoZWV0SW50b1Jvb3QiLCJwcmVjZWRlbmNlcyIsIkxBU1RfUFJFQ0VERU5DRSIsIkZpYmVyUm9vdE5vZGUiLCJoeWRyYXRlIiwiaW5jb21wbGV0ZVRyYW5zaXRpb25zIiwiX2RlYnVnUm9vdFR5cGUiLCJjcmVhdGVGaWJlclJvb3QiLCJpbml0aWFsQ2hpbGRyZW4iLCJoeWRyYXRpb25DYWxsYmFja3MiLCJpc1N0cmljdE1vZGUiLCJ0cmFuc2l0aW9uQ2FsbGJhY2tzIiwiQ29uY3VycmVudE1vZGUiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsIm9uU2NoZWR1bGVGaWJlclJvb3QiLCJtYXJrUmVuZGVyU2NoZWR1bGVkIiwiZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyIsIm1hcmtSZXRyeUxhbmVJbXBsIiwibWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQiLCJhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiIsImdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzIiwiZ2V0TGFuZUxhYmVsTWFwIiwibGFiZWwiLCJibG9ja2VkT24iLCJmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50IiwicmV0dXJuX3RhcmdldEluc3QiLCJjbGVhcklmQ29udGludW91c0V2ZW50IiwicXVldWVJZkNvbnRpbnVvdXNFdmVudCIsImRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cyIsImZpbmRJbnN0YW5jZUJsb2NraW5nVGFyZ2V0IiwiZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwiLCJMb3dQcmlvcml0eSIsInF1ZXVlZEZvY3VzIiwicXVldWVkRHJhZyIsInF1ZXVlZE1vdXNlIiwicXVldWVkUG9pbnRlcnMiLCJwb2ludGVySWQiLCJxdWV1ZWRQb2ludGVyQ2FwdHVyZXMiLCJhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50IiwiZXhpc3RpbmdRdWV1ZWRFdmVudCIsInRhcmdldENvbnRhaW5lcnMiLCJhdHRlbXB0RXhwbGljaXRIeWRyYXRpb25UYXJnZXQiLCJxdWV1ZWRUYXJnZXQiLCJhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50IiwicXVldWVkRXZlbnQiLCJuZXh0QmxvY2tlZE9uIiwibmF0aXZlRXZlbnRDbG9uZSIsInNoaWZ0IiwiYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwIiwicmVwbGF5VW5ibG9ja2VkRXZlbnRzIiwiaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCIsInNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZCIsInVuYmxvY2tlZCIsIlNjaGVkdWxlciIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsInNjaGVkdWxlUmVwbGF5UXVldWVJZk5lZWRlZCIsImZvcm1SZXBsYXlpbmdRdWV1ZSIsImxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSIsInN1Ym1pdHRlck9yQWN0aW9uIiwiZm9ybUluc3QiLCJ1bmJsb2NrIiwicXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzIiwiJCRyZWFjdEZvcm1SZXBsYXkiLCJmb3JtUHJvcHMiLCJSZWFjdERPTVJvb3QiLCJpbnRlcm5hbFJvb3QiLCJfaW50ZXJuYWxSb290IiwiUmVhY3RET01IeWRyYXRpb25Sb290Iiwid2FybklmUmVhY3RET01Db250YWluZXJJbkRFViIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCIsInJlcXVpcmUiLCJSZWFjdERPTSIsImZvciIsIml0ZXJhdG9yIiwiaXNBcnJheSIsIl9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSIsIl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSIsIk5vdFBlbmRpbmciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJXZWFrTWFwIiwidW5zdGFibGVfY2FuY2VsQ2FsbGJhY2siLCJ1bnN0YWJsZV9zaG91bGRZaWVsZCIsInVuc3RhYmxlX3JlcXVlc3RQYWludCIsInVuc3RhYmxlX25vdyIsInVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsIiwidW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkiLCJ1bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSIsInVuc3RhYmxlX0xvd1ByaW9yaXR5IiwidW5zdGFibGVfSWRsZVByaW9yaXR5IiwicmFuZG9tS2V5IiwicmFuZG9tIiwiY2hlY2tib3giLCJpbWFnZSIsImhpZGRlbiIsInJhZGlvIiwic3VibWl0IiwiUmVnRXhwIiwiYW5pbWF0aW9uIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRQb3NpdGlvbiIsImJvcmRlciIsImJvcmRlckJsb2NrRW5kIiwiYm9yZGVyQmxvY2tTdGFydCIsImJvcmRlckJvdHRvbSIsImJvcmRlckNvbG9yIiwiYm9yZGVySW1hZ2UiLCJib3JkZXJJbmxpbmVFbmQiLCJib3JkZXJJbmxpbmVTdGFydCIsImJvcmRlckxlZnQiLCJib3JkZXJSYWRpdXMiLCJib3JkZXJSaWdodCIsImJvcmRlclN0eWxlIiwiYm9yZGVyVG9wIiwiYm9yZGVyV2lkdGgiLCJjb2x1bW5SdWxlIiwiY29sdW1ucyIsImZsZXgiLCJmbGV4RmxvdyIsImZvbnQiLCJmb250VmFyaWFudCIsImdhcCIsImdyaWQiLCJncmlkQXJlYSIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uR2FwIiwiZ3JpZEdhcCIsImdyaWRSb3ciLCJncmlkUm93R2FwIiwiZ3JpZFRlbXBsYXRlIiwibGlzdFN0eWxlIiwibWFyZ2luIiwibWFya2VyIiwibWFzayIsIm1hc2tQb3NpdGlvbiIsIm91dGxpbmUiLCJwYWRkaW5nIiwicGxhY2VDb250ZW50IiwicGxhY2VJdGVtcyIsInBsYWNlU2VsZiIsInRleHREZWNvcmF0aW9uIiwidGV4dEVtcGhhc2lzIiwid29yZFdyYXAiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXV0b2NhcGl0YWxpemUiLCJhdXRvY29tcGxldGUiLCJhdXRvY29ycmVjdCIsImF1dG9wbGF5IiwiYXV0b3NhdmUiLCJjZWxscGFkZGluZyIsImNlbGxzcGFjaW5nIiwiY2hhbGxlbmdlIiwiY2hhcnNldCIsImNpdGUiLCJjbGFzcyIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzIiwiY29sc3BhbiIsImNvbnRlbnRlZGl0YWJsZSIsImNvbnRleHRtZW51IiwiY29udHJvbHMiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGF0ZXRpbWUiLCJkZWZhdWx0IiwiZGVmYXVsdGNoZWNrZWQiLCJkZWZhdWx0dmFsdWUiLCJkZWZlciIsImRpciIsImRpc2FibGVwaWN0dXJlaW5waWN0dXJlIiwiZGlzYWJsZXJlbW90ZXBsYXliYWNrIiwiZG93bmxvYWQiLCJkcmFnZ2FibGUiLCJlbmN0eXBlIiwiZW50ZXJrZXloaW50IiwiZmV0Y2hwcmlvcml0eSIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWdoIiwiaHJlZmxhbmciLCJodG1sZm9yIiwiaHR0cGVxdWl2IiwiaWNvbiIsImltYWdlc2l6ZXMiLCJpbWFnZXNyY3NldCIsImluZXJ0IiwiaW5uZXJodG1sIiwiaW5wdXRtb2RlIiwiaXRlbWlkIiwiaXRlbXByb3AiLCJpdGVtcmVmIiwiaXRlbXNjb3BlIiwiaXRlbXR5cGUiLCJrZXlwYXJhbXMiLCJrZXl0eXBlIiwia2luZCIsImxhbmciLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW53aWR0aCIsIm1hcmdpbmhlaWdodCIsIm1heCIsIm1heGxlbmd0aCIsIm1lZGlhZ3JvdXAiLCJtaW5sZW5ndGgiLCJub21vZHVsZSIsIm5vbmNlIiwibm92YWxpZGF0ZSIsIm9wZW4iLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicGxheXNpbmxpbmUiLCJwb3N0ZXIiLCJwcm9maWxlIiwicmFkaW9ncm91cCIsInJlYWRvbmx5IiwicmVmZXJyZXJwb2xpY3kiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm9sZSIsInJvd3MiLCJyb3dzcGFuIiwic2FuZGJveCIsInNjb3BlIiwic2NvcGVkIiwic2Nyb2xsaW5nIiwic2VhbWxlc3MiLCJzaGFwZSIsInNpemVzIiwic3BhbiIsInNwZWxsY2hlY2siLCJzcmNkb2MiLCJzcmNsYW5nIiwic3VtbWFyeSIsInRhYmluZGV4IiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3giLCJjeSIsImQiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGl2aXNvciIsImRvbWluYW50YmFzZWxpbmUiLCJkdXIiLCJkeCIsImR5IiwiZWRnZW1vZGUiLCJlbGV2YXRpb24iLCJlbmFibGViYWNrZ3JvdW5kIiwiZXhwb25lbnQiLCJleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkIiwiZmlsbCIsImZpbGxvcGFjaXR5IiwiZmlsbHJ1bGUiLCJmaWx0ZXIiLCJmaWx0ZXJyZXMiLCJmaWx0ZXJ1bml0cyIsImZsb29kb3BhY2l0eSIsImZsb29kY29sb3IiLCJmb2N1c2FibGUiLCJmb250ZmFtaWx5IiwiZm9udHNpemUiLCJmb250c2l6ZWFkanVzdCIsImZvbnRzdHJldGNoIiwiZm9udHN0eWxlIiwiZm9udHZhcmlhbnQiLCJmb250d2VpZ2h0IiwiZm9ybWF0IiwiZnJvbSIsImZ4IiwiZnkiLCJnMSIsImcyIiwiZ2x5cGhuYW1lIiwiZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWwiLCJnbHlwaG9yaWVudGF0aW9udmVydGljYWwiLCJnbHlwaHJlZiIsImdyYWRpZW50dHJhbnNmb3JtIiwiZ3JhZGllbnR1bml0cyIsImhhbmdpbmciLCJob3JpemFkdngiLCJob3Jpem9yaWdpbngiLCJpZGVvZ3JhcGhpYyIsImltYWdlcmVuZGVyaW5nIiwiaW4yIiwiaW4iLCJpbmxpc3QiLCJpbnRlcmNlcHQiLCJrMSIsImsyIiwiazMiLCJrNCIsImsiLCJrZXJuZWxtYXRyaXgiLCJrZXJuZWx1bml0bGVuZ3RoIiwia2VybmluZyIsImtleXBvaW50cyIsImtleXNwbGluZXMiLCJrZXl0aW1lcyIsImxlbmd0aGFkanVzdCIsImxldHRlcnNwYWNpbmciLCJsaWdodGluZ2NvbG9yIiwibGltaXRpbmdjb25lYW5nbGUiLCJsb2NhbCIsIm1hcmtlcmVuZCIsIm1hcmtlcmhlaWdodCIsIm1hcmtlcm1pZCIsIm1hcmtlcnN0YXJ0IiwibWFya2VydW5pdHMiLCJtYXJrZXJ3aWR0aCIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJudW1vY3RhdmVzIiwib3BhY2l0eSIsIm9wZXJhdG9yIiwib3JkZXIiLCJvcmllbnQiLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIm92ZXJsaW5lcG9zaXRpb24iLCJvdmVybGluZXRoaWNrbmVzcyIsInBhaW50b3JkZXIiLCJwYW5vc2UxIiwicGF0aGxlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIiwicG9pbnRlcmV2ZW50cyIsInBvaW50cyIsInBvaW50c2F0eCIsInBvaW50c2F0eSIsInBvaW50c2F0eiIsInBvcG92ZXJ0YXJnZXQiLCJwb3BvdmVydGFyZ2V0YWN0aW9uIiwicHJlc2VydmVhbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iLCJwcmltaXRpdmV1bml0cyIsInIiLCJyYWRpdXMiLCJyZWZ4IiwicmVmeSIsInJlbmRlcmluZ2ludGVudCIsInJlcGVhdGNvdW50IiwicmVwZWF0ZHVyIiwicmVxdWlyZWRleHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyIsInJlc3RhcnQiLCJyZXN1bHRzIiwicm90YXRlIiwicngiLCJyeSIsInNjYWxlIiwic2VjdXJpdHkiLCJzZWVkIiwic2hhcGVyZW5kZXJpbmciLCJzbG9wZSIsInNwYWNpbmciLCJzcGVjdWxhcmNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCIsInNwZWVkIiwic3ByZWFkbWV0aG9kIiwic3RhcnRvZmZzZXQiLCJzdGRkZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNodGlsZXMiLCJzdG9wY29sb3IiLCJzdG9wb3BhY2l0eSIsInN0cmlrZXRocm91Z2hwb3NpdGlvbiIsInN0cmlrZXRocm91Z2h0aGlja25lc3MiLCJzdHJva2UiLCJzdHJva2VkYXNoYXJyYXkiLCJzdHJva2VkYXNob2Zmc2V0Iiwic3Ryb2tlbGluZWNhcCIsInN0cm9rZWxpbmVqb2luIiwic3Ryb2tlbWl0ZXJsaW1pdCIsInN0cm9rZXdpZHRoIiwic3Ryb2tlb3BhY2l0eSIsInN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZyIsInN1cHByZXNzaHlkcmF0aW9ud2FybmluZyIsInN1cmZhY2VzY2FsZSIsInN5c3RlbWxhbmd1YWdlIiwidGFibGV2YWx1ZXMiLCJ0YXJnZXR4IiwidGFyZ2V0eSIsInRleHRhbmNob3IiLCJ0ZXh0ZGVjb3JhdGlvbiIsInRleHRsZW5ndGgiLCJ0ZXh0cmVuZGVyaW5nIiwidG8iLCJ0cmFuc2Zvcm0iLCJ0cmFuc2Zvcm1vcmlnaW4iLCJ0eXBlb2YiLCJ1MSIsInUyIiwidW5kZXJsaW5lcG9zaXRpb24iLCJ1bmRlcmxpbmV0aGlja25lc3MiLCJ1bmljb2RlIiwidW5pY29kZWJpZGkiLCJ1bmljb2RlcmFuZ2UiLCJ1bml0c3BlcmVtIiwidW5zZWxlY3RhYmxlIiwidmFscGhhYmV0aWMiLCJ2YWx1ZXMiLCJ2ZWN0b3JlZmZlY3QiLCJ2ZXJzaW9uIiwidmVydGFkdnkiLCJ2ZXJ0b3JpZ2lueCIsInZlcnRvcmlnaW55IiwidmhhbmdpbmciLCJ2aWRlb2dyYXBoaWMiLCJ2aWV3Ym94Iiwidmlld3RhcmdldCIsInZpc2liaWxpdHkiLCJ2bWF0aGVtYXRpY2FsIiwidm9jYWIiLCJ3aWR0aHMiLCJ3b3Jkc3BhY2luZyIsIndyaXRpbmdtb2RlIiwieDEiLCJ4MiIsInhjaGFubmVsc2VsZWN0b3IiLCJ4aGVpZ2h0IiwieGxpbmthY3R1YXRlIiwieGxpbmthcmNyb2xlIiwieGxpbmtocmVmIiwieGxpbmtyb2xlIiwieGxpbmtzaG93IiwieGxpbmt0aXRsZSIsInhsaW5rdHlwZSIsInhtbGJhc2UiLCJ4bWxsYW5nIiwieG1sbnMiLCJ4bWxuc3hsaW5rIiwieG1sc3BhY2UiLCJ5MSIsInkyIiwieWNoYW5uZWxzZWxlY3RvciIsInoiLCJ6b29tYW5kcGFuIiwib3B0aW9ucyRqc2NvbXAkMCIsIkV2ZW50SW50ZXJmYWNlIiwiZXZlbnRQaGFzZSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidGltZVN0YW1wIiwiRGF0ZSIsImlzVHJ1c3RlZCIsIlVJRXZlbnRJbnRlcmZhY2UiLCJ2aWV3IiwibGFzdE1vdmVtZW50WCIsImxhc3RNb3ZlbWVudFkiLCJsYXN0TW91c2VFdmVudCIsIk1vdXNlRXZlbnRJbnRlcmZhY2UiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwicGFnZVgiLCJwYWdlWSIsInNoaWZ0S2V5IiwiYnV0dG9ucyIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsIkRyYWdFdmVudEludGVyZmFjZSIsImRhdGFUcmFuc2ZlciIsIkZvY3VzRXZlbnRJbnRlcmZhY2UiLCJBbmltYXRpb25FdmVudEludGVyZmFjZSIsImFuaW1hdGlvbk5hbWUiLCJwc2V1ZG9FbGVtZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSIsIm5vcm1hbGl6ZUtleSIsIkVzYyIsIlNwYWNlYmFyIiwiTGVmdCIsIlVwIiwiUmlnaHQiLCJEb3duIiwiRGVsIiwiV2luIiwiTWVudSIsIkFwcHMiLCJTY3JvbGwiLCJNb3pQcmludGFibGVLZXkiLCJ0cmFuc2xhdGVUb0tleSIsIkFsdCIsIkNvbnRyb2wiLCJNZXRhIiwiU2hpZnQiLCJLZXlib2FyZEV2ZW50SW50ZXJmYWNlIiwiY29kZSIsIlBvaW50ZXJFdmVudEludGVyZmFjZSIsInByZXNzdXJlIiwidGFuZ2VudGlhbFByZXNzdXJlIiwidGlsdFgiLCJ0aWx0WSIsInR3aXN0IiwicG9pbnRlclR5cGUiLCJpc1ByaW1hcnkiLCJUb3VjaEV2ZW50SW50ZXJmYWNlIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIlRyYW5zaXRpb25FdmVudEludGVyZmFjZSIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIlRvZ2dsZUV2ZW50SW50ZXJmYWNlIiwiZG9jdW1lbnRNb2RlIiwiZGF0ZSIsImVtYWlsIiwibW9udGgiLCJudW1iZXIiLCJwYXNzd29yZCIsInNlYXJjaCIsInRlbCIsInRpbWUiLCJ3ZWVrIiwiYW5pbWF0aW9uZW5kIiwiYW5pbWF0aW9uaXRlcmF0aW9uIiwiYW5pbWF0aW9uc3RhcnQiLCJ0cmFuc2l0aW9ucnVuIiwidHJhbnNpdGlvbnN0YXJ0IiwidHJhbnNpdGlvbmNhbmNlbCIsInRyYW5zaXRpb25lbmQiLCJUUkFOU0lUSU9OX1JVTiIsIlRSQU5TSVRJT05fU1RBUlQiLCJUUkFOU0lUSU9OX0NBTkNFTCIsInNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsImUkMyIsInBlcmZvcm1hbmNlIiwibG9jYWxQZXJmb3JtYW5jZSIsImxvY2FsRGF0ZSIsIkFib3J0Q29udHJvbGxlciIsIkNvbnN1bWVyIiwiUHJvdmlkZXIiLCJfY3VycmVudFZhbHVlMiIsIl90aHJlYWRDb3VudCIsIl9jdXJyZW50UmVuZGVyZXIyIiwicHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoIiwicGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsImRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMiLCJjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwic29ydGVkTmFtZXMiLCJwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmciLCJkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0Iiwic3RyaWN0Um9vdCIsImZpYmVyQXJyYXkiLCJmaXJzdEZpYmVyIiwidW5pcXVlTmFtZXMiLCJjYWxsQ29tcG9uZW50Iiwid2FzUmVuZGVyaW5nIiwiY2FsbFJlbmRlciIsImNhbGxDb21wb25lbnREaWRNb3VudCIsImNhbGxDb21wb25lbnREaWRVcGRhdGUiLCJjYWxsQ29tcG9uZW50RGlkQ2F0Y2giLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJjYWxsQ3JlYXRlIiwiZWZmZWN0IiwiY2FsbERlc3Ryb3kiLCJjYWxsTGF6eUluaXQiLCJsYXp5Iiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiX3N0b3JlIiwidmFsaWRhdGVkIiwiY29tcG9uZW50S2V5IiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXJBcHBlbmRpeCIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVkdWNlciIsInVzZVJlZiIsInVzZURlYnVnVmFsdWUiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidXNlVHJhbnNpdGlvbiIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlSWQiLCJ1c2VGb3JtU3RhdGUiLCJ1c2VBY3Rpb25TdGF0ZSIsInVzZU9wdGltaXN0aWMiLCJ1c2VDYWNoZVJlZnJlc2giLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViIsImVucXVldWVGb3JjZVVwZGF0ZSIsIm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZCIsInJlcG9ydEVycm9yIiwiRXJyb3JFdmVudCIsInByb2Nlc3MiLCJlbWl0IiwiZ2V0Q2FjaGVGb3JUeXBlIiwicmVzb3VyY2VUeXBlIiwiY2FjaGVGb3JUeXBlIiwiZ2V0T3duZXIiLCJzeW1ib2xGb3IiLCJJbmZpbml0eSIsImRpYWxvZyIsIndlYnZpZXciLCJsb2NhbFByb21pc2UiLCJxdWV1ZU1pY3JvdGFzayIsImYiLCJwcmV2aW91c1dhc1JlbmRlcmluZyIsIkQiLCJDIiwiTCIsInByZWxvYWRTZWxlY3RvciIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsIlgiLCJzY3JpcHRzIiwibGluayIsIk0iLCJGdW5jdGlvbiIsIm92ZXJyaWRlSG9va1N0YXRlIiwib3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoIiwib3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoIiwib3ZlcnJpZGVQcm9wcyIsIm92ZXJyaWRlUHJvcHNEZWxldGVQYXRoIiwib3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgiLCJzY2hlZHVsZVVwZGF0ZSIsInNldEVycm9ySGFuZGxlciIsInNldFN1c3BlbnNlSGFuZGxlciIsIm5ld1Nob3VsZEVycm9ySW1wbCIsIm5ld1Nob3VsZFN1c3BlbmRJbXBsIiwidW5tb3VudCIsInVuc3RhYmxlX3NjaGVkdWxlSHlkcmF0aW9uIiwiaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24iLCJmaW5kRE9NTm9kZSIsImNvbXBvbmVudE9yRWxlbWVudCIsImJ1bmRsZVR5cGUiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwiY3VycmVudERpc3BhdGNoZXJSZWYiLCJyZWNvbmNpbGVyVmVyc2lvbiIsImdldEN1cnJlbnRGaWJlciIsInNlbGYiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJwcm90b2NvbCIsImV4cG9ydHMiLCJjcmVhdGVSb290IiwidW5zdGFibGVfc3RyaWN0TW9kZSIsInVuc3RhYmxlX3RyYW5zaXRpb25DYWxsYmFja3MiLCJoeWRyYXRlUm9vdCIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-client.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-dom.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function noop() {}\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function createPortal$1(children, containerInfo, implementation) {\n      var key =\n        3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n      try {\n        testStringCoercion(key);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      JSCompiler_inline_result &&\n        (console.error(\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            key[Symbol.toStringTag]) ||\n            key.constructor.name ||\n            \"Object\"\n        ),\n        testStringCoercion(key));\n      return {\n        $$typeof: REACT_PORTAL_TYPE,\n        key: null == key ? null : \"\" + key,\n        children: children,\n        containerInfo: containerInfo,\n        implementation: implementation\n      };\n    }\n    function getCrossOriginStringAs(as, input) {\n      if (\"font\" === as) return \"\";\n      if (\"string\" === typeof input)\n        return \"use-credentials\" === input ? input : \"\";\n    }\n    function getValueDescriptorExpectingObjectForWarning(thing) {\n      return null === thing\n        ? \"`null`\"\n        : void 0 === thing\n          ? \"`undefined`\"\n          : \"\" === thing\n            ? \"an empty string\"\n            : 'something with type \"' + typeof thing + '\"';\n    }\n    function getValueDescriptorExpectingEnumForWarning(thing) {\n      return null === thing\n        ? \"`null`\"\n        : void 0 === thing\n          ? \"`undefined`\"\n          : \"\" === thing\n            ? \"an empty string\"\n            : \"string\" === typeof thing\n              ? JSON.stringify(thing)\n              : \"number\" === typeof thing\n                ? \"`\" + thing + \"`\"\n                : 'something with type \"' + typeof thing + '\"';\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactSharedInternals.H;\n      null === dispatcher &&\n        console.error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      return dispatcher;\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(ssr)/./node_modules/next/dist/compiled/react/index.js\"),\n      Internals = {\n        d: {\n          f: noop,\n          r: function () {\n            throw Error(\n              \"Invalid form element. requestFormReset must be passed a form that was rendered by React.\"\n            );\n          },\n          D: noop,\n          C: noop,\n          L: noop,\n          m: noop,\n          X: noop,\n          S: noop,\n          M: noop\n        },\n        p: 0,\n        findDOMNode: null\n      },\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n    (\"function\" === typeof Map &&\n      null != Map.prototype &&\n      \"function\" === typeof Map.prototype.forEach &&\n      \"function\" === typeof Set &&\n      null != Set.prototype &&\n      \"function\" === typeof Set.prototype.clear &&\n      \"function\" === typeof Set.prototype.forEach) ||\n      console.error(\n        \"React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills\"\n      );\n    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n      Internals;\n    exports.createPortal = function (children, container) {\n      var key =\n        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;\n      if (\n        !container ||\n        (1 !== container.nodeType &&\n          9 !== container.nodeType &&\n          11 !== container.nodeType)\n      )\n        throw Error(\"Target container is not a DOM element.\");\n      return createPortal$1(children, container, null, key);\n    };\n    exports.flushSync = function (fn) {\n      var previousTransition = ReactSharedInternals.T,\n        previousUpdatePriority = Internals.p;\n      try {\n        if (((ReactSharedInternals.T = null), (Internals.p = 2), fn))\n          return fn();\n      } finally {\n        (ReactSharedInternals.T = previousTransition),\n          (Internals.p = previousUpdatePriority),\n          Internals.d.f() &&\n            console.error(\n              \"flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.\"\n            );\n      }\n    };\n    exports.preconnect = function (href, options) {\n      \"string\" === typeof href && href\n        ? null != options && \"object\" !== typeof options\n          ? console.error(\n              \"ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            )\n          : null != options &&\n            \"string\" !== typeof options.crossOrigin &&\n            console.error(\n              \"ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.\",\n              getValueDescriptorExpectingObjectForWarning(options.crossOrigin)\n            )\n        : console.error(\n            \"ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\",\n            getValueDescriptorExpectingObjectForWarning(href)\n          );\n      \"string\" === typeof href &&\n        (options\n          ? ((options = options.crossOrigin),\n            (options =\n              \"string\" === typeof options\n                ? \"use-credentials\" === options\n                  ? options\n                  : \"\"\n                : void 0))\n          : (options = null),\n        Internals.d.C(href, options));\n    };\n    exports.prefetchDNS = function (href) {\n      if (\"string\" !== typeof href || !href)\n        console.error(\n          \"ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\",\n          getValueDescriptorExpectingObjectForWarning(href)\n        );\n      else if (1 < arguments.length) {\n        var options = arguments[1];\n        \"object\" === typeof options && options.hasOwnProperty(\"crossOrigin\")\n          ? console.error(\n              \"ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            )\n          : console.error(\n              \"ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            );\n      }\n      \"string\" === typeof href && Internals.d.D(href);\n    };\n    exports.preinit = function (href, options) {\n      \"string\" === typeof href && href\n        ? null == options || \"object\" !== typeof options\n          ? console.error(\n              \"ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.\",\n              getValueDescriptorExpectingEnumForWarning(options)\n            )\n          : \"style\" !== options.as &&\n            \"script\" !== options.as &&\n            console.error(\n              'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are \"style\" and \"script\".',\n              getValueDescriptorExpectingEnumForWarning(options.as)\n            )\n        : console.error(\n            \"ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.\",\n            getValueDescriptorExpectingObjectForWarning(href)\n          );\n      if (\n        \"string\" === typeof href &&\n        options &&\n        \"string\" === typeof options.as\n      ) {\n        var as = options.as,\n          crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),\n          integrity =\n            \"string\" === typeof options.integrity ? options.integrity : void 0,\n          fetchPriority =\n            \"string\" === typeof options.fetchPriority\n              ? options.fetchPriority\n              : void 0;\n        \"style\" === as\n          ? Internals.d.S(\n              href,\n              \"string\" === typeof options.precedence\n                ? options.precedence\n                : void 0,\n              {\n                crossOrigin: crossOrigin,\n                integrity: integrity,\n                fetchPriority: fetchPriority\n              }\n            )\n          : \"script\" === as &&\n            Internals.d.X(href, {\n              crossOrigin: crossOrigin,\n              integrity: integrity,\n              fetchPriority: fetchPriority,\n              nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\n            });\n      }\n    };\n    exports.preinitModule = function (href, options) {\n      var encountered = \"\";\n      (\"string\" === typeof href && href) ||\n        (encountered +=\n          \" The `href` argument encountered was \" +\n          getValueDescriptorExpectingObjectForWarning(href) +\n          \".\");\n      void 0 !== options && \"object\" !== typeof options\n        ? (encountered +=\n            \" The `options` argument encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options) +\n            \".\")\n        : options &&\n          \"as\" in options &&\n          \"script\" !== options.as &&\n          (encountered +=\n            \" The `as` option encountered was \" +\n            getValueDescriptorExpectingEnumForWarning(options.as) +\n            \".\");\n      if (encountered)\n        console.error(\n          \"ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s\",\n          encountered\n        );\n      else\n        switch (\n          ((encountered =\n            options && \"string\" === typeof options.as ? options.as : \"script\"),\n          encountered)\n        ) {\n          case \"script\":\n            break;\n          default:\n            (encountered =\n              getValueDescriptorExpectingEnumForWarning(encountered)),\n              console.error(\n                'ReactDOM.preinitModule(): Currently the only supported \"as\" type for this function is \"script\" but received \"%s\" instead. This warning was generated for `href` \"%s\". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',\n                encountered,\n                href\n              );\n        }\n      if (\"string\" === typeof href)\n        if (\"object\" === typeof options && null !== options) {\n          if (null == options.as || \"script\" === options.as)\n            (encountered = getCrossOriginStringAs(\n              options.as,\n              options.crossOrigin\n            )),\n              Internals.d.M(href, {\n                crossOrigin: encountered,\n                integrity:\n                  \"string\" === typeof options.integrity\n                    ? options.integrity\n                    : void 0,\n                nonce:\n                  \"string\" === typeof options.nonce ? options.nonce : void 0\n              });\n        } else null == options && Internals.d.M(href);\n    };\n    exports.preload = function (href, options) {\n      var encountered = \"\";\n      (\"string\" === typeof href && href) ||\n        (encountered +=\n          \" The `href` argument encountered was \" +\n          getValueDescriptorExpectingObjectForWarning(href) +\n          \".\");\n      null == options || \"object\" !== typeof options\n        ? (encountered +=\n            \" The `options` argument encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options) +\n            \".\")\n        : (\"string\" === typeof options.as && options.as) ||\n          (encountered +=\n            \" The `as` option encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options.as) +\n            \".\");\n      encountered &&\n        console.error(\n          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel=\"preload\" as=\"...\" />` tag.%s',\n          encountered\n        );\n      if (\n        \"string\" === typeof href &&\n        \"object\" === typeof options &&\n        null !== options &&\n        \"string\" === typeof options.as\n      ) {\n        encountered = options.as;\n        var crossOrigin = getCrossOriginStringAs(\n          encountered,\n          options.crossOrigin\n        );\n        Internals.d.L(href, encountered, {\n          crossOrigin: crossOrigin,\n          integrity:\n            \"string\" === typeof options.integrity ? options.integrity : void 0,\n          nonce: \"string\" === typeof options.nonce ? options.nonce : void 0,\n          type: \"string\" === typeof options.type ? options.type : void 0,\n          fetchPriority:\n            \"string\" === typeof options.fetchPriority\n              ? options.fetchPriority\n              : void 0,\n          referrerPolicy:\n            \"string\" === typeof options.referrerPolicy\n              ? options.referrerPolicy\n              : void 0,\n          imageSrcSet:\n            \"string\" === typeof options.imageSrcSet\n              ? options.imageSrcSet\n              : void 0,\n          imageSizes:\n            \"string\" === typeof options.imageSizes\n              ? options.imageSizes\n              : void 0,\n          media: \"string\" === typeof options.media ? options.media : void 0\n        });\n      }\n    };\n    exports.preloadModule = function (href, options) {\n      var encountered = \"\";\n      (\"string\" === typeof href && href) ||\n        (encountered +=\n          \" The `href` argument encountered was \" +\n          getValueDescriptorExpectingObjectForWarning(href) +\n          \".\");\n      void 0 !== options && \"object\" !== typeof options\n        ? (encountered +=\n            \" The `options` argument encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options) +\n            \".\")\n        : options &&\n          \"as\" in options &&\n          \"string\" !== typeof options.as &&\n          (encountered +=\n            \" The `as` option encountered was \" +\n            getValueDescriptorExpectingObjectForWarning(options.as) +\n            \".\");\n      encountered &&\n        console.error(\n          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel=\"modulepreload\" as=\"...\" />` tag.%s',\n          encountered\n        );\n      \"string\" === typeof href &&\n        (options\n          ? ((encountered = getCrossOriginStringAs(\n              options.as,\n              options.crossOrigin\n            )),\n            Internals.d.m(href, {\n              as:\n                \"string\" === typeof options.as && \"script\" !== options.as\n                  ? options.as\n                  : void 0,\n              crossOrigin: encountered,\n              integrity:\n                \"string\" === typeof options.integrity\n                  ? options.integrity\n                  : void 0\n            }))\n          : Internals.d.m(href));\n    };\n    exports.requestFormReset = function (form) {\n      Internals.d.r(form);\n    };\n    exports.unstable_batchedUpdates = function (fn, a) {\n      return fn(a);\n    };\n    exports.useFormState = function (action, initialState, permalink) {\n      return resolveDispatcher().useFormState(action, initialState, permalink);\n    };\n    exports.useFormStatus = function () {\n      return resolveDispatcher().useHostTransitionStatus();\n    };\n    exports.version = \"19.2.0-canary-3fbfb9ba-20250409\";\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHdGQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvRUFBb0U7QUFDeEU7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixVQUFVO0FBQ1Y7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1NvZnR3YWFyZSBQcm9ncmFtL2FwcHRpdml0eSBmaW5hbCB2MS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLCBpbXBsZW1lbnRhdGlvbikge1xuICAgICAgdmFyIGtleSA9XG4gICAgICAgIDMgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbihrZXkpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYmXG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIGtleVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgICAga2V5LmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICAgIFwiT2JqZWN0XCJcbiAgICAgICAgKSxcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKGtleSkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgICAgICBrZXk6IG51bGwgPT0ga2V5ID8gbnVsbCA6IFwiXCIgKyBrZXksXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDcm9zc09yaWdpblN0cmluZ0FzKGFzLCBpbnB1dCkge1xuICAgICAgaWYgKFwiZm9udFwiID09PSBhcykgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0KVxuICAgICAgICByZXR1cm4gXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gaW5wdXQgPyBpbnB1dCA6IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcodGhpbmcpIHtcbiAgICAgIHJldHVybiBudWxsID09PSB0aGluZ1xuICAgICAgICA/IFwiYG51bGxgXCJcbiAgICAgICAgOiB2b2lkIDAgPT09IHRoaW5nXG4gICAgICAgICAgPyBcImB1bmRlZmluZWRgXCJcbiAgICAgICAgICA6IFwiXCIgPT09IHRoaW5nXG4gICAgICAgICAgICA/IFwiYW4gZW1wdHkgc3RyaW5nXCJcbiAgICAgICAgICAgIDogJ3NvbWV0aGluZyB3aXRoIHR5cGUgXCInICsgdHlwZW9mIHRoaW5nICsgJ1wiJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nRW51bUZvcldhcm5pbmcodGhpbmcpIHtcbiAgICAgIHJldHVybiBudWxsID09PSB0aGluZ1xuICAgICAgICA/IFwiYG51bGxgXCJcbiAgICAgICAgOiB2b2lkIDAgPT09IHRoaW5nXG4gICAgICAgICAgPyBcImB1bmRlZmluZWRgXCJcbiAgICAgICAgICA6IFwiXCIgPT09IHRoaW5nXG4gICAgICAgICAgICA/IFwiYW4gZW1wdHkgc3RyaW5nXCJcbiAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoaW5nXG4gICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkodGhpbmcpXG4gICAgICAgICAgICAgIDogXCJudW1iZXJcIiA9PT0gdHlwZW9mIHRoaW5nXG4gICAgICAgICAgICAgICAgPyBcImBcIiArIHRoaW5nICsgXCJgXCJcbiAgICAgICAgICAgICAgICA6ICdzb21ldGhpbmcgd2l0aCB0eXBlIFwiJyArIHR5cGVvZiB0aGluZyArICdcIic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgbnVsbCA9PT0gZGlzcGF0Y2hlciAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpLFxuICAgICAgSW50ZXJuYWxzID0ge1xuICAgICAgICBkOiB7XG4gICAgICAgICAgZjogbm9vcCxcbiAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGZvcm0gZWxlbWVudC4gcmVxdWVzdEZvcm1SZXNldCBtdXN0IGJlIHBhc3NlZCBhIGZvcm0gdGhhdCB3YXMgcmVuZGVyZWQgYnkgUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBEOiBub29wLFxuICAgICAgICAgIEM6IG5vb3AsXG4gICAgICAgICAgTDogbm9vcCxcbiAgICAgICAgICBtOiBub29wLFxuICAgICAgICAgIFg6IG5vb3AsXG4gICAgICAgICAgUzogbm9vcCxcbiAgICAgICAgICBNOiBub29wXG4gICAgICAgIH0sXG4gICAgICAgIHA6IDAsXG4gICAgICAgIGZpbmRET01Ob2RlOiBudWxsXG4gICAgICB9LFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREU7XG4gICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE1hcCAmJlxuICAgICAgbnVsbCAhPSBNYXAucHJvdG90eXBlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFNldCAmJlxuICAgICAgbnVsbCAhPSBTZXQucHJvdG90eXBlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTZXQucHJvdG90eXBlLmNsZWFyICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTZXQucHJvdG90eXBlLmZvckVhY2gpIHx8XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlJlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgcG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHNcIlxuICAgICAgKTtcbiAgICBleHBvcnRzLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSA9XG4gICAgICBJbnRlcm5hbHM7XG4gICAgZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICAgICAgdmFyIGtleSA9XG4gICAgICAgIDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIGlmIChcbiAgICAgICAgIWNvbnRhaW5lciB8fFxuICAgICAgICAoMSAhPT0gY29udGFpbmVyLm5vZGVUeXBlICYmXG4gICAgICAgICAgOSAhPT0gY29udGFpbmVyLm5vZGVUeXBlICYmXG4gICAgICAgICAgMTEgIT09IGNvbnRhaW5lci5ub2RlVHlwZSlcbiAgICAgIClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiKTtcbiAgICAgIHJldHVybiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVyLCBudWxsLCBrZXkpO1xuICAgIH07XG4gICAgZXhwb3J0cy5mbHVzaFN5bmMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHZhciBwcmV2aW91c1RyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBwcmV2aW91c1VwZGF0ZVByaW9yaXR5ID0gSW50ZXJuYWxzLnA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoKChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksIChJbnRlcm5hbHMucCA9IDIpLCBmbikpXG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZpb3VzVHJhbnNpdGlvbiksXG4gICAgICAgICAgKEludGVybmFscy5wID0gcHJldmlvdXNVcGRhdGVQcmlvcml0eSksXG4gICAgICAgICAgSW50ZXJuYWxzLmQuZigpICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gUmVhY3QgY2Fubm90IGZsdXNoIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuIENvbnNpZGVyIG1vdmluZyB0aGlzIGNhbGwgdG8gYSBzY2hlZHVsZXIgdGFzayBvciBtaWNybyB0YXNrLlwiXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5wcmVjb25uZWN0ID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWZcbiAgICAgICAgPyBudWxsICE9IG9wdGlvbnMgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3RET00ucHJlY29ubmVjdCgpOiBFeHBlY3RlZCB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IChzZWNvbmQpIHRvIGJlIGFuIG9iamVjdCBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC4gVGhlIG9ubHkgc3VwcG9ydGVkIG9wdGlvbiBhdCB0aGlzIHRpbWUgaXMgYGNyb3NzT3JpZ2luYCB3aGljaCBhY2NlcHRzIGEgc3RyaW5nLlwiLFxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogbnVsbCAhPSBvcHRpb25zICYmXG4gICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVjb25uZWN0KCk6IEV4cGVjdGVkIHRoZSBgY3Jvc3NPcmlnaW5gIG9wdGlvbiAoc2Vjb25kIGFyZ3VtZW50KSB0byBiZSBhIHN0cmluZyBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC4gVHJ5IHJlbW92aW5nIHRoaXMgb3B0aW9uIG9yIHBhc3NpbmcgYSBzdHJpbmcgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zLmNyb3NzT3JpZ2luKVxuICAgICAgICAgICAgKVxuICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0RE9NLnByZWNvbm5lY3QoKTogRXhwZWN0ZWQgdGhlIGBocmVmYCBhcmd1bWVudCAoZmlyc3QpIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZyBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZilcbiAgICAgICAgICApO1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiZcbiAgICAgICAgKG9wdGlvbnNcbiAgICAgICAgICA/ICgob3B0aW9ucyA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4pLFxuICAgICAgICAgICAgKG9wdGlvbnMgPVxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9uc1xuICAgICAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgPyBvcHRpb25zXG4gICAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgICAgICA6IHZvaWQgMCkpXG4gICAgICAgICAgOiAob3B0aW9ucyA9IG51bGwpLFxuICAgICAgICBJbnRlcm5hbHMuZC5DKGhyZWYsIG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIGV4cG9ydHMucHJlZmV0Y2hETlMgPSBmdW5jdGlvbiAoaHJlZikge1xuICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBocmVmIHx8ICFocmVmKVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3RET00ucHJlZmV0Y2hETlMoKTogRXhwZWN0ZWQgdGhlIGBocmVmYCBhcmd1bWVudCAoZmlyc3QpIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZyBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC5cIixcbiAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpXG4gICAgICAgICk7XG4gICAgICBlbHNlIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImNyb3NzT3JpZ2luXCIpXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0RE9NLnByZWZldGNoRE5TKCk6IEV4cGVjdGVkIG9ubHkgb25lIGFyZ3VtZW50LCBgaHJlZmAsIGJ1dCBlbmNvdW50ZXJlZCAlcyBhcyBhIHNlY29uZCBhcmd1bWVudCBpbnN0ZWFkLiBUaGlzIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgb3B0aW9ucyBhbmQgaXMgY3VycmVudGx5IGRpc2FsbG93ZWQuIEl0IGxvb2tzIGxpa2UgdGhlIHlvdSBhcmUgYXR0ZW1wdGluZyB0byBzZXQgYSBjcm9zc09yaWdpbiBwcm9wZXJ0eSBmb3IgdGhpcyBETlMgbG9va3VwIGhpbnQuIEJyb3dzZXJzIGRvIG5vdCBwZXJmb3JtIEROUyBxdWVyaWVzIHVzaW5nIENPUlMgYW5kIHNldHRpbmcgdGhpcyBhdHRyaWJ1dGUgb24gdGhlIHJlc291cmNlIGhpbnQgaGFzIG5vIGVmZmVjdC4gVHJ5IGNhbGxpbmcgUmVhY3RET00ucHJlZmV0Y2hETlMoKSB3aXRoIGp1c3QgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50LCBgaHJlZmAuXCIsXG4gICAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ0VudW1Gb3JXYXJuaW5nKG9wdGlvbnMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0RE9NLnByZWZldGNoRE5TKCk6IEV4cGVjdGVkIG9ubHkgb25lIGFyZ3VtZW50LCBgaHJlZmAsIGJ1dCBlbmNvdW50ZXJlZCAlcyBhcyBhIHNlY29uZCBhcmd1bWVudCBpbnN0ZWFkLiBUaGlzIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgb3B0aW9ucyBhbmQgaXMgY3VycmVudGx5IGRpc2FsbG93ZWQuIFRyeSBjYWxsaW5nIFJlYWN0RE9NLnByZWZldGNoRE5TKCkgd2l0aCBqdXN0IGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCwgYGhyZWZgLlwiLFxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zKVxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIEludGVybmFscy5kLkQoaHJlZik7XG4gICAgfTtcbiAgICBleHBvcnRzLnByZWluaXQgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZlxuICAgICAgICA/IG51bGwgPT0gb3B0aW9ucyB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb3B0aW9uc1xuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdERPTS5wcmVpbml0KCk6IEV4cGVjdGVkIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgKHNlY29uZCkgdG8gYmUgYW4gb2JqZWN0IHdpdGggYW4gYGFzYCBwcm9wZXJ0eSBkZXNjcmliaW5nIHRoZSB0eXBlIG9mIHJlc291cmNlIHRvIGJlIHByZWluaXRpYWxpemVkIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogXCJzdHlsZVwiICE9PSBvcHRpb25zLmFzICYmXG4gICAgICAgICAgICBcInNjcmlwdFwiICE9PSBvcHRpb25zLmFzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnUmVhY3RET00ucHJlaW5pdCgpOiBFeHBlY3RlZCB0aGUgYGFzYCBwcm9wZXJ0eSBpbiB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IChzZWNvbmQpIHRvIGNvbnRhaW4gYSB2YWxpZCB2YWx1ZSBkZXNjcmliaW5nIHRoZSB0eXBlIG9mIHJlc291cmNlIHRvIGJlIHByZWluaXRpYWxpemVkIGJ1dCBlbmNvdW50ZXJlZCAlcyBpbnN0ZWFkLiBWYWxpZCB2YWx1ZXMgZm9yIGBhc2AgYXJlIFwic3R5bGVcIiBhbmQgXCJzY3JpcHRcIi4nLFxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zLmFzKVxuICAgICAgICAgICAgKVxuICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0RE9NLnByZWluaXQoKTogRXhwZWN0ZWQgdGhlIGBocmVmYCBhcmd1bWVudCAoZmlyc3QpIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZyBidXQgZW5jb3VudGVyZWQgJXMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZilcbiAgICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgICAgICBvcHRpb25zICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzXG4gICAgICApIHtcbiAgICAgICAgdmFyIGFzID0gb3B0aW9ucy5hcyxcbiAgICAgICAgICBjcm9zc09yaWdpbiA9IGdldENyb3NzT3JpZ2luU3RyaW5nQXMoYXMsIG9wdGlvbnMuY3Jvc3NPcmlnaW4pLFxuICAgICAgICAgIGludGVncml0eSA9XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPyBvcHRpb25zLmludGVncml0eSA6IHZvaWQgMCxcbiAgICAgICAgICBmZXRjaFByaW9yaXR5ID1cbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgPyBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgIFwic3R5bGVcIiA9PT0gYXNcbiAgICAgICAgICA/IEludGVybmFscy5kLlMoXG4gICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLnByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMucHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgIDogdm9pZCAwLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICAgIGludGVncml0eTogaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgIGZldGNoUHJpb3JpdHk6IGZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogXCJzY3JpcHRcIiA9PT0gYXMgJiZcbiAgICAgICAgICAgIEludGVybmFscy5kLlgoaHJlZiwge1xuICAgICAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgIGludGVncml0eTogaW50ZWdyaXR5LFxuICAgICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBmZXRjaFByaW9yaXR5LFxuICAgICAgICAgICAgICBub25jZTogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMucHJlaW5pdE1vZHVsZSA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZW5jb3VudGVyZWQgPSBcIlwiO1xuICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHx8XG4gICAgICAgIChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgIFwiIFRoZSBgaHJlZmAgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpICtcbiAgICAgICAgICBcIi5cIik7XG4gICAgICB2b2lkIDAgIT09IG9wdGlvbnMgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgPyAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgb3B0aW9uc2AgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucykgK1xuICAgICAgICAgICAgXCIuXCIpXG4gICAgICAgIDogb3B0aW9ucyAmJlxuICAgICAgICAgIFwiYXNcIiBpbiBvcHRpb25zICYmXG4gICAgICAgICAgXCJzY3JpcHRcIiAhPT0gb3B0aW9ucy5hcyAmJlxuICAgICAgICAgIChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgICAgXCIgVGhlIGBhc2Agb3B0aW9uIGVuY291bnRlcmVkIHdhcyBcIiArXG4gICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhvcHRpb25zLmFzKSArXG4gICAgICAgICAgICBcIi5cIik7XG4gICAgICBpZiAoZW5jb3VudGVyZWQpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdERPTS5wcmVpbml0TW9kdWxlKCk6IEV4cGVjdGVkIHVwIHRvIHR3byBhcmd1bWVudHMsIGEgbm9uLWVtcHR5IGBocmVmYCBzdHJpbmcgYW5kLCBvcHRpb25hbGx5LCBhbiBgb3B0aW9uc2Agb2JqZWN0IHdpdGggYSB2YWxpZCBgYXNgIHByb3BlcnR5LiVzXCIsXG4gICAgICAgICAgZW5jb3VudGVyZWRcbiAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoKGVuY291bnRlcmVkID1cbiAgICAgICAgICAgIG9wdGlvbnMgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgPyBvcHRpb25zLmFzIDogXCJzY3JpcHRcIiksXG4gICAgICAgICAgZW5jb3VudGVyZWQpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAoZW5jb3VudGVyZWQgPVxuICAgICAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdFbnVtRm9yV2FybmluZyhlbmNvdW50ZXJlZCkpLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdSZWFjdERPTS5wcmVpbml0TW9kdWxlKCk6IEN1cnJlbnRseSB0aGUgb25seSBzdXBwb3J0ZWQgXCJhc1wiIHR5cGUgZm9yIHRoaXMgZnVuY3Rpb24gaXMgXCJzY3JpcHRcIiBidXQgcmVjZWl2ZWQgXCIlc1wiIGluc3RlYWQuIFRoaXMgd2FybmluZyB3YXMgZ2VuZXJhdGVkIGZvciBgaHJlZmAgXCIlc1wiLiBJbiB0aGUgZnV0dXJlIG90aGVyIG1vZHVsZSB0eXBlcyB3aWxsIGJlIHN1cHBvcnRlZCwgYWxpZ25pbmcgd2l0aCB0aGUgaW1wb3J0LWF0dHJpYnV0ZXMgcHJvcG9zYWwuIExlYXJuIG1vcmUgaGVyZTogKGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWltcG9ydC1hdHRyaWJ1dGVzKScsXG4gICAgICAgICAgICAgICAgZW5jb3VudGVyZWQsXG4gICAgICAgICAgICAgICAgaHJlZlxuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYpXG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJiBudWxsICE9PSBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT0gb3B0aW9ucy5hcyB8fCBcInNjcmlwdFwiID09PSBvcHRpb25zLmFzKVxuICAgICAgICAgICAgKGVuY291bnRlcmVkID0gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhcbiAgICAgICAgICAgICAgb3B0aW9ucy5hcyxcbiAgICAgICAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpblxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIEludGVybmFscy5kLk0oaHJlZiwge1xuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBlbmNvdW50ZXJlZCxcbiAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6XG4gICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmludGVncml0eVxuICAgICAgICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBub25jZTpcbiAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIG51bGwgPT0gb3B0aW9ucyAmJiBJbnRlcm5hbHMuZC5NKGhyZWYpO1xuICAgIH07XG4gICAgZXhwb3J0cy5wcmVsb2FkID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBlbmNvdW50ZXJlZCA9IFwiXCI7XG4gICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikgfHxcbiAgICAgICAgKGVuY291bnRlcmVkICs9XG4gICAgICAgICAgXCIgVGhlIGBocmVmYCBhcmd1bWVudCBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikgK1xuICAgICAgICAgIFwiLlwiKTtcbiAgICAgIG51bGwgPT0gb3B0aW9ucyB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb3B0aW9uc1xuICAgICAgICA/IChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgICAgXCIgVGhlIGBvcHRpb25zYCBhcmd1bWVudCBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zKSArXG4gICAgICAgICAgICBcIi5cIilcbiAgICAgICAgOiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgJiYgb3B0aW9ucy5hcykgfHxcbiAgICAgICAgICAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgYXNgIG9wdGlvbiBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zLmFzKSArXG4gICAgICAgICAgICBcIi5cIik7XG4gICAgICBlbmNvdW50ZXJlZCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdSZWFjdERPTS5wcmVsb2FkKCk6IEV4cGVjdGVkIHR3byBhcmd1bWVudHMsIGEgbm9uLWVtcHR5IGBocmVmYCBzdHJpbmcgYW5kIGFuIGBvcHRpb25zYCBvYmplY3Qgd2l0aCBhbiBgYXNgIHByb3BlcnR5IHZhbGlkIGZvciBhIGA8bGluayByZWw9XCJwcmVsb2FkXCIgYXM9XCIuLi5cIiAvPmAgdGFnLiVzJyxcbiAgICAgICAgICBlbmNvdW50ZXJlZFxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJlxuICAgICAgICBudWxsICE9PSBvcHRpb25zICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzXG4gICAgICApIHtcbiAgICAgICAgZW5jb3VudGVyZWQgPSBvcHRpb25zLmFzO1xuICAgICAgICB2YXIgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKFxuICAgICAgICAgIGVuY291bnRlcmVkLFxuICAgICAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW5cbiAgICAgICAgKTtcbiAgICAgICAgSW50ZXJuYWxzLmQuTChocmVmLCBlbmNvdW50ZXJlZCwge1xuICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICBpbnRlZ3JpdHk6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPyBvcHRpb25zLmludGVncml0eSA6IHZvaWQgMCxcbiAgICAgICAgICBub25jZTogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdm9pZCAwLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLnR5cGUgPyBvcHRpb25zLnR5cGUgOiB2b2lkIDAsXG4gICAgICAgICAgZmV0Y2hQcmlvcml0eTpcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgPyBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgcmVmZXJyZXJQb2xpY3k6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5yZWZlcnJlclBvbGljeVxuICAgICAgICAgICAgICA/IG9wdGlvbnMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgaW1hZ2VTcmNTZXQ6XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNyY1NldFxuICAgICAgICAgICAgICA/IG9wdGlvbnMuaW1hZ2VTcmNTZXRcbiAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgaW1hZ2VTaXplczpcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmltYWdlU2l6ZXNcbiAgICAgICAgICAgICAgPyBvcHRpb25zLmltYWdlU2l6ZXNcbiAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgICAgbWVkaWE6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm1lZGlhID8gb3B0aW9ucy5tZWRpYSA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMucHJlbG9hZE1vZHVsZSA9IGZ1bmN0aW9uIChocmVmLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZW5jb3VudGVyZWQgPSBcIlwiO1xuICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIGhyZWYpIHx8XG4gICAgICAgIChlbmNvdW50ZXJlZCArPVxuICAgICAgICAgIFwiIFRoZSBgaHJlZmAgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKGhyZWYpICtcbiAgICAgICAgICBcIi5cIik7XG4gICAgICB2b2lkIDAgIT09IG9wdGlvbnMgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgPyAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgb3B0aW9uc2AgYXJndW1lbnQgZW5jb3VudGVyZWQgd2FzIFwiICtcbiAgICAgICAgICAgIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcob3B0aW9ucykgK1xuICAgICAgICAgICAgXCIuXCIpXG4gICAgICAgIDogb3B0aW9ucyAmJlxuICAgICAgICAgIFwiYXNcIiBpbiBvcHRpb25zICYmXG4gICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9wdGlvbnMuYXMgJiZcbiAgICAgICAgICAoZW5jb3VudGVyZWQgKz1cbiAgICAgICAgICAgIFwiIFRoZSBgYXNgIG9wdGlvbiBlbmNvdW50ZXJlZCB3YXMgXCIgK1xuICAgICAgICAgICAgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhvcHRpb25zLmFzKSArXG4gICAgICAgICAgICBcIi5cIik7XG4gICAgICBlbmNvdW50ZXJlZCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdSZWFjdERPTS5wcmVsb2FkTW9kdWxlKCk6IEV4cGVjdGVkIHR3byBhcmd1bWVudHMsIGEgbm9uLWVtcHR5IGBocmVmYCBzdHJpbmcgYW5kLCBvcHRpb25hbGx5LCBhbiBgb3B0aW9uc2Agb2JqZWN0IHdpdGggYW4gYGFzYCBwcm9wZXJ0eSB2YWxpZCBmb3IgYSBgPGxpbmsgcmVsPVwibW9kdWxlcHJlbG9hZFwiIGFzPVwiLi4uXCIgLz5gIHRhZy4lcycsXG4gICAgICAgICAgZW5jb3VudGVyZWRcbiAgICAgICAgKTtcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgICAgIChvcHRpb25zXG4gICAgICAgICAgPyAoKGVuY291bnRlcmVkID0gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhcbiAgICAgICAgICAgICAgb3B0aW9ucy5hcyxcbiAgICAgICAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpblxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBJbnRlcm5hbHMuZC5tKGhyZWYsIHtcbiAgICAgICAgICAgICAgYXM6XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMgJiYgXCJzY3JpcHRcIiAhPT0gb3B0aW9ucy5hc1xuICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmFzXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGVuY291bnRlcmVkLFxuICAgICAgICAgICAgICBpbnRlZ3JpdHk6XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgOiBJbnRlcm5hbHMuZC5tKGhyZWYpKTtcbiAgICB9O1xuICAgIGV4cG9ydHMucmVxdWVzdEZvcm1SZXNldCA9IGZ1bmN0aW9uIChmb3JtKSB7XG4gICAgICBJbnRlcm5hbHMuZC5yKGZvcm0pO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSkge1xuICAgICAgcmV0dXJuIGZuKGEpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VGb3JtU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMoKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMi4wLWNhbmFyeS0zZmJmYjliYS0yMDI1MDQwOVwiO1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/compiled/react-dom/client.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/client.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom-client.development.js */ \"(ssr)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-client.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLEVBSzFDLENBQUM7QUFDRixFQUFFLDBLQUFpRTtBQUNuRSIsInNvdXJjZXMiOlsiL1ZvbHVtZXMvU29mdHdhYXJlIFByb2dyYW0vYXBwdGl2aXR5IGZpbmFsIHYxL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tY2xpZW50LnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLWNsaWVudC5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/compiled/react-dom/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/compiled/react-dom/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"(ssr)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWRvbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFLMUMsQ0FBQztBQUNGLEVBQUUsNEpBQTBEO0FBQzVEIiwic291cmNlcyI6WyIvVm9sdW1lcy9Tb2Z0d2FhcmUgUHJvZ3JhbS9hcHB0aXZpdHkgZmluYWwgdjEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/compiled/react-dom/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/compiled/react/cjs/react.development.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react.development.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function defineDeprecationWarning(methodName, info) {\n      Object.defineProperty(Component.prototype, methodName, {\n        get: function () {\n          console.warn(\n            \"%s(...) is deprecated in plain JavaScript React classes. %s\",\n            info[0],\n            info[1]\n          );\n        }\n      });\n    }\n    function getIteratorFn(maybeIterable) {\n      if (null === maybeIterable || \"object\" !== typeof maybeIterable)\n        return null;\n      maybeIterable =\n        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n        maybeIterable[\"@@iterator\"];\n      return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function warnNoop(publicInstance, callerName) {\n      publicInstance =\n        ((publicInstance = publicInstance.constructor) &&\n          (publicInstance.displayName || publicInstance.name)) ||\n        \"ReactClass\";\n      var warningKey = publicInstance + \".\" + callerName;\n      didWarnStateUpdateForUnmountedComponent[warningKey] ||\n        (console.error(\n          \"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.\",\n          callerName,\n          publicInstance\n        ),\n        (didWarnStateUpdateForUnmountedComponent[warningKey] = !0));\n    }\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    function ComponentDummy() {}\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function cloneAndReplaceKey(oldElement, newKey) {\n      newKey = ReactElement(\n        oldElement.type,\n        newKey,\n        void 0,\n        void 0,\n        oldElement._owner,\n        oldElement.props,\n        oldElement._debugStack,\n        oldElement._debugTask\n      );\n      oldElement._store &&\n        (newKey._store.validated = oldElement._store.validated);\n      return newKey;\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function escape(key) {\n      var escaperLookup = { \"=\": \"=0\", \":\": \"=2\" };\n      return (\n        \"$\" +\n        key.replace(/[=:]/g, function (match) {\n          return escaperLookup[match];\n        })\n      );\n    }\n    function getElementKey(element, index) {\n      return \"object\" === typeof element &&\n        null !== element &&\n        null != element.key\n        ? (checkKeyStringCoercion(element.key), escape(\"\" + element.key))\n        : index.toString(36);\n    }\n    function noop$1() {}\n    function resolveThenable(thenable) {\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n        default:\n          switch (\n            (\"string\" === typeof thenable.status\n              ? thenable.then(noop$1, noop$1)\n              : ((thenable.status = \"pending\"),\n                thenable.then(\n                  function (fulfilledValue) {\n                    \"pending\" === thenable.status &&\n                      ((thenable.status = \"fulfilled\"),\n                      (thenable.value = fulfilledValue));\n                  },\n                  function (error) {\n                    \"pending\" === thenable.status &&\n                      ((thenable.status = \"rejected\"),\n                      (thenable.reason = error));\n                  }\n                )),\n            thenable.status)\n          ) {\n            case \"fulfilled\":\n              return thenable.value;\n            case \"rejected\":\n              throw thenable.reason;\n          }\n      }\n      throw thenable;\n    }\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = typeof children;\n      if (\"undefined\" === type || \"boolean\" === type) children = null;\n      var invokeCallback = !1;\n      if (null === children) invokeCallback = !0;\n      else\n        switch (type) {\n          case \"bigint\":\n          case \"string\":\n          case \"number\":\n            invokeCallback = !0;\n            break;\n          case \"object\":\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = !0;\n                break;\n              case REACT_LAZY_TYPE:\n                return (\n                  (invokeCallback = children._init),\n                  mapIntoArray(\n                    invokeCallback(children._payload),\n                    array,\n                    escapedPrefix,\n                    nameSoFar,\n                    callback\n                  )\n                );\n            }\n        }\n      if (invokeCallback) {\n        invokeCallback = children;\n        callback = callback(invokeCallback);\n        var childKey =\n          \"\" === nameSoFar ? \".\" + getElementKey(invokeCallback, 0) : nameSoFar;\n        isArrayImpl(callback)\n          ? ((escapedPrefix = \"\"),\n            null != childKey &&\n              (escapedPrefix =\n                childKey.replace(userProvidedKeyEscapeRegex, \"$&/\") + \"/\"),\n            mapIntoArray(callback, array, escapedPrefix, \"\", function (c) {\n              return c;\n            }))\n          : null != callback &&\n            (isValidElement(callback) &&\n              (null != callback.key &&\n                ((invokeCallback && invokeCallback.key === callback.key) ||\n                  checkKeyStringCoercion(callback.key)),\n              (escapedPrefix = cloneAndReplaceKey(\n                callback,\n                escapedPrefix +\n                  (null == callback.key ||\n                  (invokeCallback && invokeCallback.key === callback.key)\n                    ? \"\"\n                    : (\"\" + callback.key).replace(\n                        userProvidedKeyEscapeRegex,\n                        \"$&/\"\n                      ) + \"/\") +\n                  childKey\n              )),\n              \"\" !== nameSoFar &&\n                null != invokeCallback &&\n                isValidElement(invokeCallback) &&\n                null == invokeCallback.key &&\n                invokeCallback._store &&\n                !invokeCallback._store.validated &&\n                (escapedPrefix._store.validated = 2),\n              (callback = escapedPrefix)),\n            array.push(callback));\n        return 1;\n      }\n      invokeCallback = 0;\n      childKey = \"\" === nameSoFar ? \".\" : nameSoFar + \":\";\n      if (isArrayImpl(children))\n        for (var i = 0; i < children.length; i++)\n          (nameSoFar = children[i]),\n            (type = childKey + getElementKey(nameSoFar, i)),\n            (invokeCallback += mapIntoArray(\n              nameSoFar,\n              array,\n              escapedPrefix,\n              type,\n              callback\n            ));\n      else if (((i = getIteratorFn(children)), \"function\" === typeof i))\n        for (\n          i === children.entries &&\n            (didWarnAboutMaps ||\n              console.warn(\n                \"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"\n              ),\n            (didWarnAboutMaps = !0)),\n            children = i.call(children),\n            i = 0;\n          !(nameSoFar = children.next()).done;\n\n        )\n          (nameSoFar = nameSoFar.value),\n            (type = childKey + getElementKey(nameSoFar, i++)),\n            (invokeCallback += mapIntoArray(\n              nameSoFar,\n              array,\n              escapedPrefix,\n              type,\n              callback\n            ));\n      else if (\"object\" === type) {\n        if (\"function\" === typeof children.then)\n          return mapIntoArray(\n            resolveThenable(children),\n            array,\n            escapedPrefix,\n            nameSoFar,\n            callback\n          );\n        array = String(children);\n        throw Error(\n          \"Objects are not valid as a React child (found: \" +\n            (\"[object Object]\" === array\n              ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\"\n              : array) +\n            \"). If you meant to render a collection of children, use an array instead.\"\n        );\n      }\n      return invokeCallback;\n    }\n    function mapChildren(children, func, context) {\n      if (null == children) return children;\n      var result = [],\n        count = 0;\n      mapIntoArray(children, result, \"\", \"\", function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    function lazyInitializer(payload) {\n      if (-1 === payload._status) {\n        var ctor = payload._result;\n        ctor = ctor();\n        ctor.then(\n          function (moduleObject) {\n            if (0 === payload._status || -1 === payload._status)\n              (payload._status = 1), (payload._result = moduleObject);\n          },\n          function (error) {\n            if (0 === payload._status || -1 === payload._status)\n              (payload._status = 2), (payload._result = error);\n          }\n        );\n        -1 === payload._status &&\n          ((payload._status = 0), (payload._result = ctor));\n      }\n      if (1 === payload._status)\n        return (\n          (ctor = payload._result),\n          void 0 === ctor &&\n            console.error(\n              \"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\\n\\nDid you accidentally put curly braces around the import?\",\n              ctor\n            ),\n          \"default\" in ctor ||\n            console.error(\n              \"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\",\n              ctor\n            ),\n          ctor.default\n        );\n      throw payload._result;\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactSharedInternals.H;\n      null === dispatcher &&\n        console.error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n        );\n      return dispatcher;\n    }\n    function releaseAsyncTransition() {\n      ReactSharedInternals.asyncTransitions--;\n    }\n    function noop() {}\n    function enqueueTask(task) {\n      if (null === enqueueTaskImpl)\n        try {\n          var requireString = (\"require\" + Math.random()).slice(0, 7);\n          enqueueTaskImpl = (module && module[requireString]).call(\n            module,\n            \"timers\"\n          ).setImmediate;\n        } catch (_err) {\n          enqueueTaskImpl = function (callback) {\n            !1 === didWarnAboutMessageChannel &&\n              ((didWarnAboutMessageChannel = !0),\n              \"undefined\" === typeof MessageChannel &&\n                console.error(\n                  \"This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.\"\n                ));\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(void 0);\n          };\n        }\n      return enqueueTaskImpl(task);\n    }\n    function aggregateErrors(errors) {\n      return 1 < errors.length && \"function\" === typeof AggregateError\n        ? new AggregateError(errors)\n        : errors[0];\n    }\n    function popActScope(prevActQueue, prevActScopeDepth) {\n      prevActScopeDepth !== actScopeDepth - 1 &&\n        console.error(\n          \"You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. \"\n        );\n      actScopeDepth = prevActScopeDepth;\n    }\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      var queue = ReactSharedInternals.actQueue;\n      if (null !== queue)\n        if (0 !== queue.length)\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            });\n            return;\n          } catch (error) {\n            ReactSharedInternals.thrownErrors.push(error);\n          }\n        else ReactSharedInternals.actQueue = null;\n      0 < ReactSharedInternals.thrownErrors.length\n        ? ((queue = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          reject(queue))\n        : resolve(returnValue);\n    }\n    function flushActQueue(queue) {\n      if (!isFlushing) {\n        isFlushing = !0;\n        var i = 0;\n        try {\n          for (; i < queue.length; i++) {\n            var callback = queue[i];\n            do {\n              ReactSharedInternals.didUsePromise = !1;\n              var continuation = callback(!1);\n              if (null !== continuation) {\n                if (ReactSharedInternals.didUsePromise) {\n                  queue[i] = callback;\n                  queue.splice(0, i);\n                  return;\n                }\n                callback = continuation;\n              } else break;\n            } while (1);\n          }\n          queue.length = 0;\n        } catch (error) {\n          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);\n        } finally {\n          isFlushing = !1;\n        }\n      }\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      didWarnStateUpdateForUnmountedComponent = {},\n      ReactNoopUpdateQueue = {\n        isMounted: function () {\n          return !1;\n        },\n        enqueueForceUpdate: function (publicInstance) {\n          warnNoop(publicInstance, \"forceUpdate\");\n        },\n        enqueueReplaceState: function (publicInstance) {\n          warnNoop(publicInstance, \"replaceState\");\n        },\n        enqueueSetState: function (publicInstance) {\n          warnNoop(publicInstance, \"setState\");\n        }\n      },\n      assign = Object.assign,\n      emptyObject = {};\n    Object.freeze(emptyObject);\n    Component.prototype.isReactComponent = {};\n    Component.prototype.setState = function (partialState, callback) {\n      if (\n        \"object\" !== typeof partialState &&\n        \"function\" !== typeof partialState &&\n        null != partialState\n      )\n        throw Error(\n          \"takes an object of state variables to update or a function which returns an object of state variables.\"\n        );\n      this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n    };\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n    };\n    var deprecatedAPIs = {\n        isMounted: [\n          \"isMounted\",\n          \"Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.\"\n        ],\n        replaceState: [\n          \"replaceState\",\n          \"Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).\"\n        ]\n      },\n      fnName;\n    for (fnName in deprecatedAPIs)\n      deprecatedAPIs.hasOwnProperty(fnName) &&\n        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    ComponentDummy.prototype = Component.prototype;\n    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();\n    deprecatedAPIs.constructor = PureComponent;\n    assign(deprecatedAPIs, Component.prototype);\n    deprecatedAPIs.isPureReactComponent = !0;\n    var isArrayImpl = Array.isArray,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals = {\n        H: null,\n        A: null,\n        T: null,\n        S: null,\n        actQueue: null,\n        asyncTransitions: 0,\n        isBatchingLegacy: !1,\n        didScheduleLegacyUpdate: !1,\n        didUsePromise: !1,\n        thrownErrors: [],\n        getCurrentStack: null,\n        recentlyCreatedOwnerStacks: 0\n      },\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    deprecatedAPIs = {\n      \"react-stack-bottom-frame\": function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = deprecatedAPIs[\n      \"react-stack-bottom-frame\"\n    ].bind(deprecatedAPIs, UnknownOwner)();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutMaps = !1,\n      userProvidedKeyEscapeRegex = /\\/+/g,\n      reportGlobalError =\n        \"function\" === typeof reportError\n          ? reportError\n          : function (error) {\n              if (\n                \"object\" === typeof window &&\n                \"function\" === typeof window.ErrorEvent\n              ) {\n                var event = new window.ErrorEvent(\"error\", {\n                  bubbles: !0,\n                  cancelable: !0,\n                  message:\n                    \"object\" === typeof error &&\n                    null !== error &&\n                    \"string\" === typeof error.message\n                      ? String(error.message)\n                      : String(error),\n                  error: error\n                });\n                if (!window.dispatchEvent(event)) return;\n              } else if (\n                \"object\" === typeof process &&\n                \"function\" === typeof process.emit\n              ) {\n                process.emit(\"uncaughtException\", error);\n                return;\n              }\n              console.error(error);\n            },\n      didWarnAboutMessageChannel = !1,\n      enqueueTaskImpl = null,\n      actScopeDepth = 0,\n      didWarnNoAwaitAct = !1,\n      isFlushing = !1,\n      queueSeveralMicrotasks =\n        \"function\" === typeof queueMicrotask\n          ? function (callback) {\n              queueMicrotask(function () {\n                return queueMicrotask(callback);\n              });\n            }\n          : enqueueTask;\n    deprecatedAPIs = Object.freeze({\n      __proto__: null,\n      c: function (size) {\n        return resolveDispatcher().useMemoCache(size);\n      }\n    });\n    exports.Children = {\n      map: mapChildren,\n      forEach: function (children, forEachFunc, forEachContext) {\n        mapChildren(\n          children,\n          function () {\n            forEachFunc.apply(this, arguments);\n          },\n          forEachContext\n        );\n      },\n      count: function (children) {\n        var n = 0;\n        mapChildren(children, function () {\n          n++;\n        });\n        return n;\n      },\n      toArray: function (children) {\n        return (\n          mapChildren(children, function (child) {\n            return child;\n          }) || []\n        );\n      },\n      only: function (children) {\n        if (!isValidElement(children))\n          throw Error(\n            \"React.Children.only expected to receive a single React element child.\"\n          );\n        return children;\n      }\n    };\n    exports.Component = Component;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.Profiler = REACT_PROFILER_TYPE;\n    exports.PureComponent = PureComponent;\n    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n    exports.Suspense = REACT_SUSPENSE_TYPE;\n    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n      ReactSharedInternals;\n    exports.__COMPILER_RUNTIME = deprecatedAPIs;\n    exports.act = function (callback) {\n      var prevActQueue = ReactSharedInternals.actQueue,\n        prevActScopeDepth = actScopeDepth;\n      actScopeDepth++;\n      var queue = (ReactSharedInternals.actQueue =\n          null !== prevActQueue ? prevActQueue : []),\n        didAwaitActCall = !1;\n      try {\n        var result = callback();\n      } catch (error) {\n        ReactSharedInternals.thrownErrors.push(error);\n      }\n      if (0 < ReactSharedInternals.thrownErrors.length)\n        throw (\n          (popActScope(prevActQueue, prevActScopeDepth),\n          (callback = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          callback)\n        );\n      if (\n        null !== result &&\n        \"object\" === typeof result &&\n        \"function\" === typeof result.then\n      ) {\n        var thenable = result;\n        queueSeveralMicrotasks(function () {\n          didAwaitActCall ||\n            didWarnNoAwaitAct ||\n            ((didWarnNoAwaitAct = !0),\n            console.error(\n              \"You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);\"\n            ));\n        });\n        return {\n          then: function (resolve, reject) {\n            didAwaitActCall = !0;\n            thenable.then(\n              function (returnValue) {\n                popActScope(prevActQueue, prevActScopeDepth);\n                if (0 === prevActScopeDepth) {\n                  try {\n                    flushActQueue(queue),\n                      enqueueTask(function () {\n                        return recursivelyFlushAsyncActWork(\n                          returnValue,\n                          resolve,\n                          reject\n                        );\n                      });\n                  } catch (error$0) {\n                    ReactSharedInternals.thrownErrors.push(error$0);\n                  }\n                  if (0 < ReactSharedInternals.thrownErrors.length) {\n                    var _thrownError = aggregateErrors(\n                      ReactSharedInternals.thrownErrors\n                    );\n                    ReactSharedInternals.thrownErrors.length = 0;\n                    reject(_thrownError);\n                  }\n                } else resolve(returnValue);\n              },\n              function (error) {\n                popActScope(prevActQueue, prevActScopeDepth);\n                0 < ReactSharedInternals.thrownErrors.length\n                  ? ((error = aggregateErrors(\n                      ReactSharedInternals.thrownErrors\n                    )),\n                    (ReactSharedInternals.thrownErrors.length = 0),\n                    reject(error))\n                  : reject(error);\n              }\n            );\n          }\n        };\n      }\n      var returnValue$jscomp$0 = result;\n      popActScope(prevActQueue, prevActScopeDepth);\n      0 === prevActScopeDepth &&\n        (flushActQueue(queue),\n        0 !== queue.length &&\n          queueSeveralMicrotasks(function () {\n            didAwaitActCall ||\n              didWarnNoAwaitAct ||\n              ((didWarnNoAwaitAct = !0),\n              console.error(\n                \"A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\\n\\nawait act(() => ...)\"\n              ));\n          }),\n        (ReactSharedInternals.actQueue = null));\n      if (0 < ReactSharedInternals.thrownErrors.length)\n        throw (\n          ((callback = aggregateErrors(ReactSharedInternals.thrownErrors)),\n          (ReactSharedInternals.thrownErrors.length = 0),\n          callback)\n        );\n      return {\n        then: function (resolve, reject) {\n          didAwaitActCall = !0;\n          0 === prevActScopeDepth\n            ? ((ReactSharedInternals.actQueue = queue),\n              enqueueTask(function () {\n                return recursivelyFlushAsyncActWork(\n                  returnValue$jscomp$0,\n                  resolve,\n                  reject\n                );\n              }))\n            : resolve(returnValue$jscomp$0);\n        }\n      };\n    };\n    exports.cache = function (fn) {\n      return function () {\n        return fn.apply(null, arguments);\n      };\n    };\n    exports.captureOwnerStack = function () {\n      var getCurrentStack = ReactSharedInternals.getCurrentStack;\n      return null === getCurrentStack ? null : getCurrentStack();\n    };\n    exports.cloneElement = function (element, config, children) {\n      if (null === element || void 0 === element)\n        throw Error(\n          \"The argument must be a React element, but you passed \" +\n            element +\n            \".\"\n        );\n      var props = assign({}, element.props),\n        key = element.key,\n        owner = element._owner;\n      if (null != config) {\n        var JSCompiler_inline_result;\n        a: {\n          if (\n            hasOwnProperty.call(config, \"ref\") &&\n            (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(\n              config,\n              \"ref\"\n            ).get) &&\n            JSCompiler_inline_result.isReactWarning\n          ) {\n            JSCompiler_inline_result = !1;\n            break a;\n          }\n          JSCompiler_inline_result = void 0 !== config.ref;\n        }\n        JSCompiler_inline_result && (owner = getOwner());\n        hasValidKey(config) &&\n          (checkKeyStringCoercion(config.key), (key = \"\" + config.key));\n        for (propName in config)\n          !hasOwnProperty.call(config, propName) ||\n            \"key\" === propName ||\n            \"__self\" === propName ||\n            \"__source\" === propName ||\n            (\"ref\" === propName && void 0 === config.ref) ||\n            (props[propName] = config[propName]);\n      }\n      var propName = arguments.length - 2;\n      if (1 === propName) props.children = children;\n      else if (1 < propName) {\n        JSCompiler_inline_result = Array(propName);\n        for (var i = 0; i < propName; i++)\n          JSCompiler_inline_result[i] = arguments[i + 2];\n        props.children = JSCompiler_inline_result;\n      }\n      props = ReactElement(\n        element.type,\n        key,\n        void 0,\n        void 0,\n        owner,\n        props,\n        element._debugStack,\n        element._debugTask\n      );\n      for (key = 2; key < arguments.length; key++)\n        (owner = arguments[key]),\n          isValidElement(owner) && owner._store && (owner._store.validated = 1);\n      return props;\n    };\n    exports.createContext = function (defaultValue) {\n      defaultValue = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        _threadCount: 0,\n        Provider: null,\n        Consumer: null\n      };\n      defaultValue.Provider = defaultValue;\n      defaultValue.Consumer = {\n        $$typeof: REACT_CONSUMER_TYPE,\n        _context: defaultValue\n      };\n      defaultValue._currentRenderer = null;\n      defaultValue._currentRenderer2 = null;\n      return defaultValue;\n    };\n    exports.createElement = function (type, config, children) {\n      for (var i = 2; i < arguments.length; i++) {\n        var node = arguments[i];\n        isValidElement(node) && node._store && (node._store.validated = 1);\n      }\n      i = {};\n      node = null;\n      if (null != config)\n        for (propName in (didWarnAboutOldJSXRuntime ||\n          !(\"__self\" in config) ||\n          \"key\" in config ||\n          ((didWarnAboutOldJSXRuntime = !0),\n          console.warn(\n            \"Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform\"\n          )),\n        hasValidKey(config) &&\n          (checkKeyStringCoercion(config.key), (node = \"\" + config.key)),\n        config))\n          hasOwnProperty.call(config, propName) &&\n            \"key\" !== propName &&\n            \"__self\" !== propName &&\n            \"__source\" !== propName &&\n            (i[propName] = config[propName]);\n      var childrenLength = arguments.length - 2;\n      if (1 === childrenLength) i.children = children;\n      else if (1 < childrenLength) {\n        for (\n          var childArray = Array(childrenLength), _i = 0;\n          _i < childrenLength;\n          _i++\n        )\n          childArray[_i] = arguments[_i + 2];\n        Object.freeze && Object.freeze(childArray);\n        i.children = childArray;\n      }\n      if (type && type.defaultProps)\n        for (propName in ((childrenLength = type.defaultProps), childrenLength))\n          void 0 === i[propName] && (i[propName] = childrenLength[propName]);\n      node &&\n        defineKeyPropWarningGetter(\n          i,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return ReactElement(\n        type,\n        node,\n        void 0,\n        void 0,\n        getOwner(),\n        i,\n        propName ? Error(\"react-stack-top-frame\") : unknownOwnerDebugStack,\n        propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n    exports.createRef = function () {\n      var refObject = { current: null };\n      Object.seal(refObject);\n      return refObject;\n    };\n    exports.forwardRef = function (render) {\n      null != render && render.$$typeof === REACT_MEMO_TYPE\n        ? console.error(\n            \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).\"\n          )\n        : \"function\" !== typeof render\n          ? console.error(\n              \"forwardRef requires a render function but was given %s.\",\n              null === render ? \"null\" : typeof render\n            )\n          : 0 !== render.length &&\n            2 !== render.length &&\n            console.error(\n              \"forwardRef render functions accept exactly two parameters: props and ref. %s\",\n              1 === render.length\n                ? \"Did you forget to use the ref parameter?\"\n                : \"Any additional parameter will be undefined.\"\n            );\n      null != render &&\n        null != render.defaultProps &&\n        console.error(\n          \"forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?\"\n        );\n      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render },\n        ownName;\n      Object.defineProperty(elementType, \"displayName\", {\n        enumerable: !1,\n        configurable: !0,\n        get: function () {\n          return ownName;\n        },\n        set: function (name) {\n          ownName = name;\n          render.name ||\n            render.displayName ||\n            (Object.defineProperty(render, \"name\", { value: name }),\n            (render.displayName = name));\n        }\n      });\n      return elementType;\n    };\n    exports.isValidElement = isValidElement;\n    exports.lazy = function (ctor) {\n      return {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: { _status: -1, _result: ctor },\n        _init: lazyInitializer\n      };\n    };\n    exports.memo = function (type, compare) {\n      null == type &&\n        console.error(\n          \"memo: The first argument must be a component. Instead received: %s\",\n          null === type ? \"null\" : typeof type\n        );\n      compare = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: void 0 === compare ? null : compare\n      };\n      var ownName;\n      Object.defineProperty(compare, \"displayName\", {\n        enumerable: !1,\n        configurable: !0,\n        get: function () {\n          return ownName;\n        },\n        set: function (name) {\n          ownName = name;\n          type.name ||\n            type.displayName ||\n            (Object.defineProperty(type, \"name\", { value: name }),\n            (type.displayName = name));\n        }\n      });\n      return compare;\n    };\n    exports.startTransition = function (scope) {\n      var prevTransition = ReactSharedInternals.T,\n        currentTransition = {};\n      currentTransition._updatedFibers = new Set();\n      ReactSharedInternals.T = currentTransition;\n      try {\n        var returnValue = scope(),\n          onStartTransitionFinish = ReactSharedInternals.S;\n        null !== onStartTransitionFinish &&\n          onStartTransitionFinish(currentTransition, returnValue);\n        \"object\" === typeof returnValue &&\n          null !== returnValue &&\n          \"function\" === typeof returnValue.then &&\n          (ReactSharedInternals.asyncTransitions++,\n          returnValue.then(releaseAsyncTransition, releaseAsyncTransition),\n          returnValue.then(noop, reportGlobalError));\n      } catch (error) {\n        reportGlobalError(error);\n      } finally {\n        null === prevTransition &&\n          currentTransition._updatedFibers &&\n          ((scope = currentTransition._updatedFibers.size),\n          currentTransition._updatedFibers.clear(),\n          10 < scope &&\n            console.warn(\n              \"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"\n            )),\n          null !== prevTransition &&\n            null !== currentTransition.types &&\n            (null !== prevTransition.types &&\n              prevTransition.types !== currentTransition.types &&\n              console.error(\n                \"We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React.\"\n              ),\n            (prevTransition.types = currentTransition.types)),\n          (ReactSharedInternals.T = prevTransition);\n      }\n    };\n    exports.unstable_useCacheRefresh = function () {\n      return resolveDispatcher().useCacheRefresh();\n    };\n    exports.use = function (usable) {\n      return resolveDispatcher().use(usable);\n    };\n    exports.useActionState = function (action, initialState, permalink) {\n      return resolveDispatcher().useActionState(\n        action,\n        initialState,\n        permalink\n      );\n    };\n    exports.useCallback = function (callback, deps) {\n      return resolveDispatcher().useCallback(callback, deps);\n    };\n    exports.useContext = function (Context) {\n      var dispatcher = resolveDispatcher();\n      Context.$$typeof === REACT_CONSUMER_TYPE &&\n        console.error(\n          \"Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?\"\n        );\n      return dispatcher.useContext(Context);\n    };\n    exports.useDebugValue = function (value, formatterFn) {\n      return resolveDispatcher().useDebugValue(value, formatterFn);\n    };\n    exports.useDeferredValue = function (value, initialValue) {\n      return resolveDispatcher().useDeferredValue(value, initialValue);\n    };\n    exports.useEffect = function (create, deps) {\n      null == create &&\n        console.warn(\n          \"React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      return resolveDispatcher().useEffect(create, deps);\n    };\n    exports.useId = function () {\n      return resolveDispatcher().useId();\n    };\n    exports.useImperativeHandle = function (ref, create, deps) {\n      return resolveDispatcher().useImperativeHandle(ref, create, deps);\n    };\n    exports.useInsertionEffect = function (create, deps) {\n      null == create &&\n        console.warn(\n          \"React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      return resolveDispatcher().useInsertionEffect(create, deps);\n    };\n    exports.useLayoutEffect = function (create, deps) {\n      null == create &&\n        console.warn(\n          \"React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?\"\n        );\n      return resolveDispatcher().useLayoutEffect(create, deps);\n    };\n    exports.useMemo = function (create, deps) {\n      return resolveDispatcher().useMemo(create, deps);\n    };\n    exports.useOptimistic = function (passthrough, reducer) {\n      return resolveDispatcher().useOptimistic(passthrough, reducer);\n    };\n    exports.useReducer = function (reducer, initialArg, init) {\n      return resolveDispatcher().useReducer(reducer, initialArg, init);\n    };\n    exports.useRef = function (initialValue) {\n      return resolveDispatcher().useRef(initialValue);\n    };\n    exports.useState = function (initialState) {\n      return resolveDispatcher().useState(initialState);\n    };\n    exports.useSyncExternalStore = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot\n    ) {\n      return resolveDispatcher().useSyncExternalStore(\n        subscribe,\n        getSnapshot,\n        getServerSnapshot\n      );\n    };\n    exports.useTransition = function () {\n      return resolveDispatcher().useTransition();\n    };\n    exports.version = \"19.2.0-canary-3fbfb9ba-20250409\";\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9NQUFvTTtBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyIvVm9sdW1lcy9Tb2Z0d2FhcmUgUHJvZ3JhbS9hcHB0aXZpdHkgZmluYWwgdjEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXNcIixcbiAgICAgICAgICAgIGluZm9bMF0sXG4gICAgICAgICAgICBpbmZvWzFdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IG1heWJlSXRlcmFibGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG1heWJlSXRlcmFibGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgbWF5YmVJdGVyYWJsZSA9XG4gICAgICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgICBtYXliZUl0ZXJhYmxlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlID8gbWF5YmVJdGVyYWJsZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gICAgICBwdWJsaWNJbnN0YW5jZSA9XG4gICAgICAgICgocHVibGljSW5zdGFuY2UgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcikgJiZcbiAgICAgICAgICAocHVibGljSW5zdGFuY2UuZGlzcGxheU5hbWUgfHwgcHVibGljSW5zdGFuY2UubmFtZSkpIHx8XG4gICAgICAgIFwiUmVhY3RDbGFzc1wiO1xuICAgICAgdmFyIHdhcm5pbmdLZXkgPSBwdWJsaWNJbnN0YW5jZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSB8fFxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFRoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uIEluc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCBjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuXCIsXG4gICAgICAgICAgY2FsbGVyTmFtZSxcbiAgICAgICAgICBwdWJsaWNJbnN0YW5jZVxuICAgICAgICApLFxuICAgICAgICAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gITApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG4gICAgZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudChcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBzZWxmLFxuICAgICAgc291cmNlLFxuICAgICAgb3duZXIsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICAgICAgbmV3S2V5ID0gUmVhY3RFbGVtZW50KFxuICAgICAgICBvbGRFbGVtZW50LnR5cGUsXG4gICAgICAgIG5ld0tleSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIG9sZEVsZW1lbnQuX293bmVyLFxuICAgICAgICBvbGRFbGVtZW50LnByb3BzLFxuICAgICAgICBvbGRFbGVtZW50Ll9kZWJ1Z1N0YWNrLFxuICAgICAgICBvbGRFbGVtZW50Ll9kZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgICBvbGRFbGVtZW50Ll9zdG9yZSAmJlxuICAgICAgICAobmV3S2V5Ll9zdG9yZS52YWxpZGF0ZWQgPSBvbGRFbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQpO1xuICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICAgICAgdmFyIGVzY2FwZXJMb29rdXAgPSB7IFwiPVwiOiBcIj0wXCIsIFwiOlwiOiBcIj0yXCIgfTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIFwiJFwiICtcbiAgICAgICAga2V5LnJlcGxhY2UoL1s9Ol0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlbGVtZW50ICYmXG4gICAgICAgIG51bGwgIT09IGVsZW1lbnQgJiZcbiAgICAgICAgbnVsbCAhPSBlbGVtZW50LmtleVxuICAgICAgICA/IChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGVsZW1lbnQua2V5KSwgZXNjYXBlKFwiXCIgKyBlbGVtZW50LmtleSkpXG4gICAgICAgIDogaW5kZXgudG9TdHJpbmcoMzYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDEoKSB7fVxuICAgIGZ1bmN0aW9uIHJlc29sdmVUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1c1xuICAgICAgICAgICAgICA/IHRoZW5hYmxlLnRoZW4obm9vcCQxLCBub29wJDEpXG4gICAgICAgICAgICAgIDogKCh0aGVuYWJsZS5zdGF0dXMgPSBcInBlbmRpbmdcIiksXG4gICAgICAgICAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAodGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICh0aGVuYWJsZS5yZWFzb24gPSBlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdGhlbmFibGUuc3RhdHVzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcbiAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlIHx8IFwiYm9vbGVhblwiID09PSB0eXBlKSBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2YXIgaW52b2tlQ2FsbGJhY2sgPSAhMTtcbiAgICAgIGlmIChudWxsID09PSBjaGlsZHJlbikgaW52b2tlQ2FsbGJhY2sgPSAhMDtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrID0gY2hpbGRyZW4uX2luaXQpLFxuICAgICAgICAgICAgICAgICAgbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhjaGlsZHJlbi5fcGF5bG9hZCksXG4gICAgICAgICAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gY2hpbGRyZW47XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soaW52b2tlQ2FsbGJhY2spO1xuICAgICAgICB2YXIgY2hpbGRLZXkgPVxuICAgICAgICAgIFwiXCIgPT09IG5hbWVTb0ZhciA/IFwiLlwiICsgZ2V0RWxlbWVudEtleShpbnZva2VDYWxsYmFjaywgMCkgOiBuYW1lU29GYXI7XG4gICAgICAgIGlzQXJyYXlJbXBsKGNhbGxiYWNrKVxuICAgICAgICAgID8gKChlc2NhcGVkUHJlZml4ID0gXCJcIiksXG4gICAgICAgICAgICBudWxsICE9IGNoaWxkS2V5ICYmXG4gICAgICAgICAgICAgIChlc2NhcGVkUHJlZml4ID1cbiAgICAgICAgICAgICAgICBjaGlsZEtleS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCBcIiQmL1wiKSArIFwiL1wiKSxcbiAgICAgICAgICAgIG1hcEludG9BcnJheShjYWxsYmFjaywgYXJyYXksIGVzY2FwZWRQcmVmaXgsIFwiXCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgOiBudWxsICE9IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAoaXNWYWxpZEVsZW1lbnQoY2FsbGJhY2spICYmXG4gICAgICAgICAgICAgIChudWxsICE9IGNhbGxiYWNrLmtleSAmJlxuICAgICAgICAgICAgICAgICgoaW52b2tlQ2FsbGJhY2sgJiYgaW52b2tlQ2FsbGJhY2sua2V5ID09PSBjYWxsYmFjay5rZXkpIHx8XG4gICAgICAgICAgICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNhbGxiYWNrLmtleSkpLFxuICAgICAgICAgICAgICAoZXNjYXBlZFByZWZpeCA9IGNsb25lQW5kUmVwbGFjZUtleShcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4ICtcbiAgICAgICAgICAgICAgICAgIChudWxsID09IGNhbGxiYWNrLmtleSB8fFxuICAgICAgICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrICYmIGludm9rZUNhbGxiYWNrLmtleSA9PT0gY2FsbGJhY2sua2V5KVxuICAgICAgICAgICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgOiAoXCJcIiArIGNhbGxiYWNrLmtleSkucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIkJi9cIlxuICAgICAgICAgICAgICAgICAgICAgICkgKyBcIi9cIikgK1xuICAgICAgICAgICAgICAgICAgY2hpbGRLZXlcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIFwiXCIgIT09IG5hbWVTb0ZhciAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT0gaW52b2tlQ2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChpbnZva2VDYWxsYmFjaykgJiZcbiAgICAgICAgICAgICAgICBudWxsID09IGludm9rZUNhbGxiYWNrLmtleSAmJlxuICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrLl9zdG9yZSAmJlxuICAgICAgICAgICAgICAgICFpbnZva2VDYWxsYmFjay5fc3RvcmUudmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKGVzY2FwZWRQcmVmaXguX3N0b3JlLnZhbGlkYXRlZCA9IDIpLFxuICAgICAgICAgICAgICAoY2FsbGJhY2sgPSBlc2NhcGVkUHJlZml4KSksXG4gICAgICAgICAgICBhcnJheS5wdXNoKGNhbGxiYWNrKSk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaW52b2tlQ2FsbGJhY2sgPSAwO1xuICAgICAgY2hpbGRLZXkgPSBcIlwiID09PSBuYW1lU29GYXIgPyBcIi5cIiA6IG5hbWVTb0ZhciArIFwiOlwiO1xuICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAobmFtZVNvRmFyID0gY2hpbGRyZW5baV0pLFxuICAgICAgICAgICAgKHR5cGUgPSBjaGlsZEtleSArIGdldEVsZW1lbnRLZXkobmFtZVNvRmFyLCBpKSksXG4gICAgICAgICAgICAoaW52b2tlQ2FsbGJhY2sgKz0gbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICAgKSk7XG4gICAgICBlbHNlIGlmICgoKGkgPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKSksIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkpKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGkgPT09IGNoaWxkcmVuLmVudHJpZXMgJiZcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBpLmNhbGwoY2hpbGRyZW4pLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgIShuYW1lU29GYXIgPSBjaGlsZHJlbi5uZXh0KCkpLmRvbmU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIChuYW1lU29GYXIgPSBuYW1lU29GYXIudmFsdWUpLFxuICAgICAgICAgICAgKHR5cGUgPSBjaGlsZEtleSArIGdldEVsZW1lbnRLZXkobmFtZVNvRmFyLCBpKyspKSxcbiAgICAgICAgICAgIChpbnZva2VDYWxsYmFjayArPSBtYXBJbnRvQXJyYXkoXG4gICAgICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICAgICAgYXJyYXksXG4gICAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICApKTtcbiAgICAgIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGUpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNoaWxkcmVuLnRoZW4pXG4gICAgICAgICAgcmV0dXJuIG1hcEludG9BcnJheShcbiAgICAgICAgICAgIHJlc29sdmVUaGVuYWJsZShjaGlsZHJlbiksXG4gICAgICAgICAgICBhcnJheSxcbiAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGFycmF5ID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICtcbiAgICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBhcnJheVxuICAgICAgICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICAgOiBhcnJheSkgK1xuICAgICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChudWxsID09IGNoaWxkcmVuKSByZXR1cm4gY2hpbGRyZW47XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCBcIlwiLCBcIlwiLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gICAgICBpZiAoLTEgPT09IHBheWxvYWQuX3N0YXR1cykge1xuICAgICAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICAgICAgY3RvciA9IGN0b3IoKTtcbiAgICAgICAgY3Rvci50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgICAgICAgIGlmICgwID09PSBwYXlsb2FkLl9zdGF0dXMgfHwgLTEgPT09IHBheWxvYWQuX3N0YXR1cylcbiAgICAgICAgICAgICAgKHBheWxvYWQuX3N0YXR1cyA9IDEpLCAocGF5bG9hZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKDAgPT09IHBheWxvYWQuX3N0YXR1cyB8fCAtMSA9PT0gcGF5bG9hZC5fc3RhdHVzKVxuICAgICAgICAgICAgICAocGF5bG9hZC5fc3RhdHVzID0gMiksIChwYXlsb2FkLl9yZXN1bHQgPSBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICAtMSA9PT0gcGF5bG9hZC5fc3RhdHVzICYmXG4gICAgICAgICAgKChwYXlsb2FkLl9zdGF0dXMgPSAwKSwgKHBheWxvYWQuX3Jlc3VsdCA9IGN0b3IpKTtcbiAgICAgIH1cbiAgICAgIGlmICgxID09PSBwYXlsb2FkLl9zdGF0dXMpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gY3RvciAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gIGNvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXBvcnQoJy4vTXlDb21wb25lbnQnKSlcXG5cXG5EaWQgeW91IGFjY2lkZW50YWxseSBwdXQgY3VybHkgYnJhY2VzIGFyb3VuZCB0aGUgaW1wb3J0P1wiLFxuICAgICAgICAgICAgICBjdG9yXG4gICAgICAgICAgICApLFxuICAgICAgICAgIFwiZGVmYXVsdFwiIGluIGN0b3IgfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwibGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICBjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wb3J0KCcuL015Q29tcG9uZW50JykpXCIsXG4gICAgICAgICAgICAgIGN0b3JcbiAgICAgICAgICAgICksXG4gICAgICAgICAgY3Rvci5kZWZhdWx0XG4gICAgICAgICk7XG4gICAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgbnVsbCA9PT0gZGlzcGF0Y2hlciAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsZWFzZUFzeW5jVHJhbnNpdGlvbigpIHtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFzeW5jVHJhbnNpdGlvbnMtLTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2sodGFzaykge1xuICAgICAgaWYgKG51bGwgPT09IGVucXVldWVUYXNrSW1wbClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmVxdWlyZVN0cmluZyA9IChcInJlcXVpcmVcIiArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDAsIDcpO1xuICAgICAgICAgIGVucXVldWVUYXNrSW1wbCA9IChtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddKS5jYWxsKFxuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgXCJ0aW1lcnNcIlxuICAgICAgICAgICkuc2V0SW1tZWRpYXRlO1xuICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAhMSA9PT0gZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgJiZcbiAgICAgICAgICAgICAgKChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9ICEwKSxcbiAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIE1lc3NhZ2VDaGFubmVsICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IGhhdmUgYSBNZXNzYWdlQ2hhbm5lbCBpbXBsZW1lbnRhdGlvbiwgc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMgaWYgeW91IGVuY291bnRlciB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSh2b2lkIDApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBlbnF1ZXVlVGFza0ltcGwodGFzayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZUVycm9ycyhlcnJvcnMpIHtcbiAgICAgIHJldHVybiAxIDwgZXJyb3JzLmxlbmd0aCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBBZ2dyZWdhdGVFcnJvclxuICAgICAgICA/IG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMpXG4gICAgICAgIDogZXJyb3JzWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICBwcmV2QWN0U2NvcGVEZXB0aCAhPT0gYWN0U2NvcGVEZXB0aCAtIDEgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIllvdSBzZWVtIHRvIGhhdmUgb3ZlcmxhcHBpbmcgYWN0KCkgY2FsbHMsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gQmUgc3VyZSB0byBhd2FpdCBwcmV2aW91cyBhY3QoKSBjYWxscyBiZWZvcmUgbWFraW5nIGEgbmV3IG9uZS4gXCJcbiAgICAgICAgKTtcbiAgICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSBxdWV1ZSlcbiAgICAgICAgaWYgKDAgIT09IHF1ZXVlLmxlbmd0aClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG4gICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPSBudWxsO1xuICAgICAgMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGhcbiAgICAgICAgPyAoKHF1ZXVlID0gYWdncmVnYXRlRXJyb3JzKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgcmVqZWN0KHF1ZXVlKSlcbiAgICAgICAgOiByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hBY3RRdWV1ZShxdWV1ZSkge1xuICAgICAgaWYgKCFpc0ZsdXNoaW5nKSB7XG4gICAgICAgIGlzRmx1c2hpbmcgPSAhMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5kaWRVc2VQcm9taXNlID0gITE7XG4gICAgICAgICAgICAgIHZhciBjb250aW51YXRpb24gPSBjYWxsYmFjayghMSk7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSBjb250aW51YXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZGlkVXNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgcXVldWVbaV0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjb250aW51YXRpb247XG4gICAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpICsgMSksIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpc0ZsdXNoaW5nID0gITE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge30sXG4gICAgICBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBcImZvcmNlVXBkYXRlXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgXCJyZXBsYWNlU3RhdGVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIFwic2V0U3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICAgICAgZW1wdHlPYmplY3QgPSB7fTtcbiAgICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwYXJ0aWFsU3RhdGUgJiZcbiAgICAgICAgbnVsbCAhPSBwYXJ0aWFsU3RhdGVcbiAgICAgIClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJ0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIlxuICAgICAgICApO1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBcInNldFN0YXRlXCIpO1xuICAgIH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgXCJmb3JjZVVwZGF0ZVwiKTtcbiAgICB9O1xuICAgIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBbXG4gICAgICAgICAgXCJpc01vdW50ZWRcIixcbiAgICAgICAgICBcIkluc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluIGNvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLlwiXG4gICAgICAgIF0sXG4gICAgICAgIHJlcGxhY2VTdGF0ZTogW1xuICAgICAgICAgIFwicmVwbGFjZVN0YXRlXCIsXG4gICAgICAgICAgXCJSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLlwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBmbk5hbWU7XG4gICAgZm9yIChmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpXG4gICAgICBkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpICYmXG4gICAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIENvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgZGVwcmVjYXRlZEFQSXMgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuICAgIGRlcHJlY2F0ZWRBUElzLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbiAgICBhc3NpZ24oZGVwcmVjYXRlZEFQSXMsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuICAgIGRlcHJlY2F0ZWRBUElzLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gITA7XG4gICAgdmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICAgICAgICBIOiBudWxsLFxuICAgICAgICBBOiBudWxsLFxuICAgICAgICBUOiBudWxsLFxuICAgICAgICBTOiBudWxsLFxuICAgICAgICBhY3RRdWV1ZTogbnVsbCxcbiAgICAgICAgYXN5bmNUcmFuc2l0aW9uczogMCxcbiAgICAgICAgaXNCYXRjaGluZ0xlZ2FjeTogITEsXG4gICAgICAgIGRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlOiAhMSxcbiAgICAgICAgZGlkVXNlUHJvbWlzZTogITEsXG4gICAgICAgIHRocm93bkVycm9yczogW10sXG4gICAgICAgIGdldEN1cnJlbnRTdGFjazogbnVsbCxcbiAgICAgICAgcmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3M6IDBcbiAgICAgIH0sXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChjYWxsU3RhY2tGb3JFcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbFN0YWNrRm9yRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgZGlkV2FybkFib3V0T2xkSlNYUnVudGltZTtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1N0YWNrID0gZGVwcmVjYXRlZEFQSXNbXG4gICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgXS5iaW5kKGRlcHJlY2F0ZWRBUElzLCBVbmtub3duT3duZXIpKCk7XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnVGFzayA9IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUoVW5rbm93bk93bmVyKSk7XG4gICAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSAhMSxcbiAgICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZyxcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICAgICAgICA/IHJlcG9ydEVycm9yXG4gICAgICAgICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPSAhMSxcbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IG51bGwsXG4gICAgICBhY3RTY29wZURlcHRoID0gMCxcbiAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0ID0gITEsXG4gICAgICBpc0ZsdXNoaW5nID0gITEsXG4gICAgICBxdWV1ZVNldmVyYWxNaWNyb3Rhc2tzID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgICA/IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBlbnF1ZXVlVGFzaztcbiAgICBkZXByZWNhdGVkQVBJcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgYzogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlTWVtb0NhY2hlKHNpemUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGV4cG9ydHMuQ2hpbGRyZW4gPSB7XG4gICAgICBtYXA6IG1hcENoaWxkcmVuLFxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgICAgICAgbWFwQ2hpbGRyZW4oXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvckVhY2hDb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgY291bnQ6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9LFxuICAgICAgdG9BcnJheTogZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgIH0pIHx8IFtdXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgb25seTogZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICAgIGV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG4gICAgZXhwb3J0cy5TdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbiAgICBleHBvcnRzLlN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgICBleHBvcnRzLl9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSA9XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscztcbiAgICBleHBvcnRzLl9fQ09NUElMRVJfUlVOVElNRSA9IGRlcHJlY2F0ZWRBUElzO1xuICAgIGV4cG9ydHMuYWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcHJldkFjdFF1ZXVlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUsXG4gICAgICAgIHByZXZBY3RTY29wZURlcHRoID0gYWN0U2NvcGVEZXB0aDtcbiAgICAgIGFjdFNjb3BlRGVwdGgrKztcbiAgICAgIHZhciBxdWV1ZSA9IChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSA9XG4gICAgICAgICAgbnVsbCAhPT0gcHJldkFjdFF1ZXVlID8gcHJldkFjdFF1ZXVlIDogW10pLFxuICAgICAgICBkaWRBd2FpdEFjdENhbGwgPSAhMTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjaygpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgfVxuICAgICAgaWYgKDAgPCBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoKVxuICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgKHBvcEFjdFNjb3BlKHByZXZBY3RRdWV1ZSwgcHJldkFjdFNjb3BlRGVwdGgpLFxuICAgICAgICAgIChjYWxsYmFjayA9IGFnZ3JlZ2F0ZUVycm9ycyhSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMpKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aCA9IDApLFxuICAgICAgICAgIGNhbGxiYWNrKVxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSByZXN1bHQgJiZcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJlc3VsdCAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXN1bHQudGhlblxuICAgICAgKSB7XG4gICAgICAgIHZhciB0aGVuYWJsZSA9IHJlc3VsdDtcbiAgICAgICAgcXVldWVTZXZlcmFsTWljcm90YXNrcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlkQXdhaXRBY3RDYWxsIHx8XG4gICAgICAgICAgICBkaWRXYXJuTm9Bd2FpdEFjdCB8fFxuICAgICAgICAgICAgKChkaWRXYXJuTm9Bd2FpdEFjdCA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWW91IGNhbGxlZCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aXRob3V0IGF3YWl0LiBUaGlzIGNvdWxkIGxlYWQgdG8gdW5leHBlY3RlZCB0ZXN0aW5nIGJlaGF2aW91ciwgaW50ZXJsZWF2aW5nIG11bHRpcGxlIGFjdCBjYWxscyBhbmQgbWl4aW5nIHRoZWlyIHNjb3Blcy4gWW91IHNob3VsZCAtIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pO1wiXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gITA7XG4gICAgICAgICAgICB0aGVuYWJsZS50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gcHJldkFjdFNjb3BlRGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoQWN0UXVldWUocXVldWUpLFxuICAgICAgICAgICAgICAgICAgICAgIGVucXVldWVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IkMCkge1xuICAgICAgICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMucHVzaChlcnJvciQwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICgwIDwgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3Rocm93bkVycm9yID0gYWdncmVnYXRlRXJyb3JzKFxuICAgICAgICAgICAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9yc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF90aHJvd25FcnJvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICAgICAgICAwIDwgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgPyAoKGVycm9yID0gYWdncmVnYXRlRXJyb3JzKFxuICAgICAgICAgICAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9yc1xuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGggPSAwKSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKSlcbiAgICAgICAgICAgICAgICAgIDogcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgcmV0dXJuVmFsdWUkanNjb21wJDAgPSByZXN1bHQ7XG4gICAgICBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgIDAgPT09IHByZXZBY3RTY29wZURlcHRoICYmXG4gICAgICAgIChmbHVzaEFjdFF1ZXVlKHF1ZXVlKSxcbiAgICAgICAgMCAhPT0gcXVldWUubGVuZ3RoICYmXG4gICAgICAgICAgcXVldWVTZXZlcmFsTWljcm90YXNrcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkaWRBd2FpdEFjdENhbGwgfHxcbiAgICAgICAgICAgICAgZGlkV2Fybk5vQXdhaXRBY3QgfHxcbiAgICAgICAgICAgICAgKChkaWRXYXJuTm9Bd2FpdEFjdCA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkEgY29tcG9uZW50IHN1c3BlbmRlZCBpbnNpZGUgYW4gYGFjdGAgc2NvcGUsIGJ1dCB0aGUgYGFjdGAgY2FsbCB3YXMgbm90IGF3YWl0ZWQuIFdoZW4gdGVzdGluZyBSZWFjdCBjb21wb25lbnRzIHRoYXQgZGVwZW5kIG9uIGFzeW5jaHJvbm91cyBkYXRhLCB5b3UgbXVzdCBhd2FpdCB0aGUgcmVzdWx0OlxcblxcbmF3YWl0IGFjdCgoKSA9PiAuLi4pXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfSksXG4gICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSA9IG51bGwpKTtcbiAgICAgIGlmICgwIDwgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICgoY2FsbGJhY2sgPSBhZ2dyZWdhdGVFcnJvcnMoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzKSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGggPSAwKSxcbiAgICAgICAgICBjYWxsYmFjaylcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBkaWRBd2FpdEFjdENhbGwgPSAhMDtcbiAgICAgICAgICAwID09PSBwcmV2QWN0U2NvcGVEZXB0aFxuICAgICAgICAgICAgPyAoKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlID0gcXVldWUpLFxuICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsoXG4gICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDogcmVzb2x2ZShyZXR1cm5WYWx1ZSRqc2NvbXAkMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNhY2hlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNhcHR1cmVPd25lclN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGdldEN1cnJlbnRTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjaztcbiAgICAgIHJldHVybiBudWxsID09PSBnZXRDdXJyZW50U3RhY2sgPyBudWxsIDogZ2V0Q3VycmVudFN0YWNrKCk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gICAgICBpZiAobnVsbCA9PT0gZWxlbWVudCB8fCB2b2lkIDAgPT09IGVsZW1lbnQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArXG4gICAgICAgICAgICBlbGVtZW50ICtcbiAgICAgICAgICAgIFwiLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpLFxuICAgICAgICBrZXkgPSBlbGVtZW50LmtleSxcbiAgICAgICAgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIGlmIChudWxsICE9IGNvbmZpZykge1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICBhOiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwicmVmXCIpICYmXG4gICAgICAgICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICBcInJlZlwiXG4gICAgICAgICAgICApLmdldCkgJiZcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5pc1JlYWN0V2FybmluZ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSB2b2lkIDAgIT09IGNvbmZpZy5yZWY7XG4gICAgICAgIH1cbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYmIChvd25lciA9IGdldE93bmVyKCkpO1xuICAgICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChrZXkgPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICAhaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSB8fFxuICAgICAgICAgICAgXCJrZXlcIiA9PT0gcHJvcE5hbWUgfHxcbiAgICAgICAgICAgIFwiX19zZWxmXCIgPT09IHByb3BOYW1lIHx8XG4gICAgICAgICAgICBcIl9fc291cmNlXCIgPT09IHByb3BOYW1lIHx8XG4gICAgICAgICAgICAoXCJyZWZcIiA9PT0gcHJvcE5hbWUgJiYgdm9pZCAwID09PSBjb25maWcucmVmKSB8fFxuICAgICAgICAgICAgKHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV0pO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BOYW1lID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICBpZiAoMSA9PT0gcHJvcE5hbWUpIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICBlbHNlIGlmICgxIDwgcHJvcE5hbWUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gQXJyYXkocHJvcE5hbWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BOYW1lOyBpKyspXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IFJlYWN0RWxlbWVudChcbiAgICAgICAgZWxlbWVudC50eXBlLFxuICAgICAgICBrZXksXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBvd25lcixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIGVsZW1lbnQuX2RlYnVnU3RhY2ssXG4gICAgICAgIGVsZW1lbnQuX2RlYnVnVGFza1xuICAgICAgKTtcbiAgICAgIGZvciAoa2V5ID0gMjsga2V5IDwgYXJndW1lbnRzLmxlbmd0aDsga2V5KyspXG4gICAgICAgIChvd25lciA9IGFyZ3VtZW50c1trZXldKSxcbiAgICAgICAgICBpc1ZhbGlkRWxlbWVudChvd25lcikgJiYgb3duZXIuX3N0b3JlICYmIChvd25lci5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgX3RocmVhZENvdW50OiAwLFxuICAgICAgICBQcm92aWRlcjogbnVsbCxcbiAgICAgICAgQ29uc3VtZXI6IG51bGxcbiAgICAgIH07XG4gICAgICBkZWZhdWx0VmFsdWUuUHJvdmlkZXIgPSBkZWZhdWx0VmFsdWU7XG4gICAgICBkZWZhdWx0VmFsdWUuQ29uc3VtZXIgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05TVU1FUl9UWVBFLFxuICAgICAgICBfY29udGV4dDogZGVmYXVsdFZhbHVlXG4gICAgICB9O1xuICAgICAgZGVmYXVsdFZhbHVlLl9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgICAgZGVmYXVsdFZhbHVlLl9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGlzVmFsaWRFbGVtZW50KG5vZGUpICYmIG5vZGUuX3N0b3JlICYmIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKTtcbiAgICAgIH1cbiAgICAgIGkgPSB7fTtcbiAgICAgIG5vZGUgPSBudWxsO1xuICAgICAgaWYgKG51bGwgIT0gY29uZmlnKVxuICAgICAgICBmb3IgKHByb3BOYW1lIGluIChkaWRXYXJuQWJvdXRPbGRKU1hSdW50aW1lIHx8XG4gICAgICAgICAgIShcIl9fc2VsZlwiIGluIGNvbmZpZykgfHxcbiAgICAgICAgICBcImtleVwiIGluIGNvbmZpZyB8fFxuICAgICAgICAgICgoZGlkV2FybkFib3V0T2xkSlNYUnVudGltZSA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIllvdXIgYXBwIChvciBvbmUgb2YgaXRzIGRlcGVuZGVuY2llcykgaXMgdXNpbmcgYW4gb3V0ZGF0ZWQgSlNYIHRyYW5zZm9ybS4gVXBkYXRlIHRvIHRoZSBtb2Rlcm4gSlNYIHRyYW5zZm9ybSBmb3IgZmFzdGVyIHBlcmZvcm1hbmNlOiBodHRwczovL3JlYWN0LmRldi9saW5rL25ldy1qc3gtdHJhbnNmb3JtXCJcbiAgICAgICAgICApKSxcbiAgICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAobm9kZSA9IFwiXCIgKyBjb25maWcua2V5KSksXG4gICAgICAgIGNvbmZpZykpXG4gICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJlxuICAgICAgICAgICAgXCJrZXlcIiAhPT0gcHJvcE5hbWUgJiZcbiAgICAgICAgICAgIFwiX19zZWxmXCIgIT09IHByb3BOYW1lICYmXG4gICAgICAgICAgICBcIl9fc291cmNlXCIgIT09IHByb3BOYW1lICYmXG4gICAgICAgICAgICAoaVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgaWYgKDEgPT09IGNoaWxkcmVuTGVuZ3RoKSBpLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICBlbHNlIGlmICgxIDwgY2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKSwgX2kgPSAwO1xuICAgICAgICAgIF9pIDwgY2hpbGRyZW5MZW5ndGg7XG4gICAgICAgICAgX2krK1xuICAgICAgICApXG4gICAgICAgICAgY2hpbGRBcnJheVtfaV0gPSBhcmd1bWVudHNbX2kgKyAyXTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgICBpLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKVxuICAgICAgICBmb3IgKHByb3BOYW1lIGluICgoY2hpbGRyZW5MZW5ndGggPSB0eXBlLmRlZmF1bHRQcm9wcyksIGNoaWxkcmVuTGVuZ3RoKSlcbiAgICAgICAgICB2b2lkIDAgPT09IGlbcHJvcE5hbWVdICYmIChpW3Byb3BOYW1lXSA9IGNoaWxkcmVuTGVuZ3RoW3Byb3BOYW1lXSk7XG4gICAgICBub2RlICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIGksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgICAgICAgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgOiB0eXBlXG4gICAgICAgICk7XG4gICAgICB2YXIgcHJvcE5hbWUgPSAxZTQgPiBSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcysrO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGdldE93bmVyKCksXG4gICAgICAgIGksXG4gICAgICAgIHByb3BOYW1lID8gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIikgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICBwcm9wTmFtZSA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVmT2JqZWN0ID0geyBjdXJyZW50OiBudWxsIH07XG4gICAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICAgICAgcmV0dXJuIHJlZk9iamVjdDtcbiAgICB9O1xuICAgIGV4cG9ydHMuZm9yd2FyZFJlZiA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcbiAgICAgIG51bGwgIT0gcmVuZGVyICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlIG1lbW8oZm9yd2FyZFJlZiguLi4pKS5cIlxuICAgICAgICAgIClcbiAgICAgICAgOiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZW5kZXJcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLlwiLFxuICAgICAgICAgICAgICBudWxsID09PSByZW5kZXIgPyBcIm51bGxcIiA6IHR5cGVvZiByZW5kZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IDAgIT09IHJlbmRlci5sZW5ndGggJiZcbiAgICAgICAgICAgIDIgIT09IHJlbmRlci5sZW5ndGggJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlc1wiLFxuICAgICAgICAgICAgICAxID09PSByZW5kZXIubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBcIkRpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj9cIlxuICAgICAgICAgICAgICAgIDogXCJBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICBudWxsICE9IHJlbmRlciAmJlxuICAgICAgICBudWxsICE9IHJlbmRlci5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBkZWZhdWx0UHJvcHMuIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/XCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IHsgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsIHJlbmRlcjogcmVuZGVyIH0sXG4gICAgICAgIG93bk5hbWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBvd25OYW1lID0gbmFtZTtcbiAgICAgICAgICByZW5kZXIubmFtZSB8fFxuICAgICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICAoT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbmRlciwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSksXG4gICAgICAgICAgICAocmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGVtZW50VHlwZTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbiAgICBleHBvcnRzLmxhenkgPSBmdW5jdGlvbiAoY3Rvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICAgICAgX3BheWxvYWQ6IHsgX3N0YXR1czogLTEsIF9yZXN1bHQ6IGN0b3IgfSxcbiAgICAgICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMubWVtbyA9IGZ1bmN0aW9uICh0eXBlLCBjb21wYXJlKSB7XG4gICAgICBudWxsID09IHR5cGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIm1lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1wiLFxuICAgICAgICAgIG51bGwgPT09IHR5cGUgPyBcIm51bGxcIiA6IHR5cGVvZiB0eXBlXG4gICAgICAgICk7XG4gICAgICBjb21wYXJlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb21wYXJlOiB2b2lkIDAgPT09IGNvbXBhcmUgPyBudWxsIDogY29tcGFyZVxuICAgICAgfTtcbiAgICAgIHZhciBvd25OYW1lO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXBhcmUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBvd25OYW1lID0gbmFtZTtcbiAgICAgICAgICB0eXBlLm5hbWUgfHxcbiAgICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgfHxcbiAgICAgICAgICAgIChPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSksXG4gICAgICAgICAgICAodHlwZS5kaXNwbGF5TmFtZSA9IG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcGFyZTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBzY29wZSgpLFxuICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gJiZcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYXN5bmNUcmFuc2l0aW9ucysrLFxuICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4ocmVsZWFzZUFzeW5jVHJhbnNpdGlvbiwgcmVsZWFzZUFzeW5jVHJhbnNpdGlvbiksXG4gICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihub29wLCByZXBvcnRHbG9iYWxFcnJvcikpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbnVsbCA9PT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyAmJlxuICAgICAgICAgICgoc2NvcGUgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplKSxcbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpLFxuICAgICAgICAgIDEwIDwgc2NvcGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uIElmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuIE90aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS5cIlxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgbnVsbCAhPT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gcHJldlRyYW5zaXRpb24udHlwZXMgJiZcbiAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb24udHlwZXMgIT09IGN1cnJlbnRUcmFuc2l0aW9uLnR5cGVzICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJXZSBleHBlY3RlZCBpbm5lciBUcmFuc2l0aW9ucyB0byBoYXZlIHRyYW5zZmVycmVkIHRoZSBvdXRlciB0eXBlcyBzZXQgYW5kIHRoYXQgeW91IGNhbm5vdCBhZGQgdG8gdGhlIG91dGVyIFRyYW5zaXRpb24gd2hpbGUgaW5zaWRlIHRoZSBpbm5lci5UaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAocHJldlRyYW5zaXRpb24udHlwZXMgPSBjdXJyZW50VHJhbnNpdGlvbi50eXBlcykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV91c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VDYWNoZVJlZnJlc2goKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlID0gZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlKHVzYWJsZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUFjdGlvblN0YXRlKFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgcGVybWFsaW5rXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VDb250ZXh0ID0gZnVuY3Rpb24gKENvbnRleHQpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIENvbnRleHQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGJ1Z3MuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD9cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0KTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VFZmZlY3QgPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBudWxsID09IGNyZWF0ZSAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJSZWFjdCBIb29rIHVzZUVmZmVjdCByZXF1aXJlcyBhbiBlZmZlY3QgY2FsbGJhY2suIERpZCB5b3UgZm9yZ2V0IHRvIHBhc3MgYSBjYWxsYmFjayB0byB0aGUgaG9vaz9cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlSWQoKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUluc2VydGlvbkVmZmVjdCA9IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIG51bGwgPT0gY3JlYXRlICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlJlYWN0IEhvb2sgdXNlSW5zZXJ0aW9uRWZmZWN0IHJlcXVpcmVzIGFuIGVmZmVjdCBjYWxsYmFjay4gRGlkIHlvdSBmb3JnZXQgdG8gcGFzcyBhIGNhbGxiYWNrIHRvIHRoZSBob29rP1wiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgbnVsbCA9PSBjcmVhdGUgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiUmVhY3QgSG9vayB1c2VMYXlvdXRFZmZlY3QgcmVxdWlyZXMgYW4gZWZmZWN0IGNhbGxiYWNrLiBEaWQgeW91IGZvcmdldCB0byBwYXNzIGEgY2FsbGJhY2sgdG8gdGhlIGhvb2s/XCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VNZW1vID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlUmVkdWNlciA9IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VSZWYgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlU3RhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IGZ1bmN0aW9uIChcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICApIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZVRyYW5zaXRpb24oKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMi4wLWNhbmFyeS0zZmJmYjliYS0yMDI1MDQwOVwiO1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/compiled/react/cjs/react.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/compiled/react/index.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"(ssr)/./node_modules/next/dist/compiled/react/cjs/react.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxnSkFBc0Q7QUFDeEQiLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1NvZnR3YWFyZSBQcm9ncmFtL2FwcHRpdml0eSBmaW5hbCB2MS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/compiled/react/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/compiled/scheduler/cjs/scheduler.development.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/scheduler/cjs/scheduler.development.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function performWorkUntilDeadline() {\n      needsPaint = !1;\n      if (isMessageLoopRunning) {\n        var currentTime = exports.unstable_now();\n        startTime = currentTime;\n        var hasMoreWork = !0;\n        try {\n          a: {\n            isHostCallbackScheduled = !1;\n            isHostTimeoutScheduled &&\n              ((isHostTimeoutScheduled = !1),\n              localClearTimeout(taskTimeoutID),\n              (taskTimeoutID = -1));\n            isPerformingWork = !0;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n              b: {\n                advanceTimers(currentTime);\n                for (\n                  currentTask = peek(taskQueue);\n                  null !== currentTask &&\n                  !(\n                    currentTask.expirationTime > currentTime &&\n                    shouldYieldToHost()\n                  );\n\n                ) {\n                  var callback = currentTask.callback;\n                  if (\"function\" === typeof callback) {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var continuationCallback = callback(\n                      currentTask.expirationTime <= currentTime\n                    );\n                    currentTime = exports.unstable_now();\n                    if (\"function\" === typeof continuationCallback) {\n                      currentTask.callback = continuationCallback;\n                      advanceTimers(currentTime);\n                      hasMoreWork = !0;\n                      break b;\n                    }\n                    currentTask === peek(taskQueue) && pop(taskQueue);\n                    advanceTimers(currentTime);\n                  } else pop(taskQueue);\n                  currentTask = peek(taskQueue);\n                }\n                if (null !== currentTask) hasMoreWork = !0;\n                else {\n                  var firstTimer = peek(timerQueue);\n                  null !== firstTimer &&\n                    requestHostTimeout(\n                      handleTimeout,\n                      firstTimer.startTime - currentTime\n                    );\n                  hasMoreWork = !1;\n                }\n              }\n              break a;\n            } finally {\n              (currentTask = null),\n                (currentPriorityLevel = previousPriorityLevel),\n                (isPerformingWork = !1);\n            }\n            hasMoreWork = void 0;\n          }\n        } finally {\n          hasMoreWork\n            ? schedulePerformWorkUntilDeadline()\n            : (isMessageLoopRunning = !1);\n        }\n      }\n    }\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      a: for (; 0 < index; ) {\n        var parentIndex = (index - 1) >>> 1,\n          parent = heap[parentIndex];\n        if (0 < compare(parent, node))\n          (heap[parentIndex] = node),\n            (heap[index] = parent),\n            (index = parentIndex);\n        else break a;\n      }\n    }\n    function peek(heap) {\n      return 0 === heap.length ? null : heap[0];\n    }\n    function pop(heap) {\n      if (0 === heap.length) return null;\n      var first = heap[0],\n        last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        a: for (\n          var index = 0, length = heap.length, halfLength = length >>> 1;\n          index < halfLength;\n\n        ) {\n          var leftIndex = 2 * (index + 1) - 1,\n            left = heap[leftIndex],\n            rightIndex = leftIndex + 1,\n            right = heap[rightIndex];\n          if (0 > compare(left, last))\n            rightIndex < length && 0 > compare(right, left)\n              ? ((heap[index] = right),\n                (heap[rightIndex] = last),\n                (index = rightIndex))\n              : ((heap[index] = left),\n                (heap[leftIndex] = last),\n                (index = leftIndex));\n          else if (rightIndex < length && 0 > compare(right, last))\n            (heap[index] = right),\n              (heap[rightIndex] = last),\n              (index = rightIndex);\n          else break a;\n        }\n      }\n      return first;\n    }\n    function compare(a, b) {\n      var diff = a.sortIndex - b.sortIndex;\n      return 0 !== diff ? diff : a.id - b.id;\n    }\n    function advanceTimers(currentTime) {\n      for (var timer = peek(timerQueue); null !== timer; ) {\n        if (null === timer.callback) pop(timerQueue);\n        else if (timer.startTime <= currentTime)\n          pop(timerQueue),\n            (timer.sortIndex = timer.expirationTime),\n            push(taskQueue, timer);\n        else break;\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = !1;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled)\n        if (null !== peek(taskQueue))\n          (isHostCallbackScheduled = !0),\n            isMessageLoopRunning ||\n              ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n        else {\n          var firstTimer = peek(timerQueue);\n          null !== firstTimer &&\n            requestHostTimeout(\n              handleTimeout,\n              firstTimer.startTime - currentTime\n            );\n        }\n    }\n    function shouldYieldToHost() {\n      return needsPaint\n        ? !0\n        : exports.unstable_now() - startTime < frameInterval\n          ? !1\n          : !0;\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    exports.unstable_now = void 0;\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date,\n        initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    }\n    var taskQueue = [],\n      timerQueue = [],\n      taskIdCounter = 1,\n      currentTask = null,\n      currentPriorityLevel = 3,\n      isPerformingWork = !1,\n      isHostCallbackScheduled = !1,\n      isHostTimeoutScheduled = !1,\n      needsPaint = !1,\n      localSetTimeout = \"function\" === typeof setTimeout ? setTimeout : null,\n      localClearTimeout =\n        \"function\" === typeof clearTimeout ? clearTimeout : null,\n      localSetImmediate =\n        \"undefined\" !== typeof setImmediate ? setImmediate : null,\n      isMessageLoopRunning = !1,\n      taskTimeoutID = -1,\n      frameInterval = 5,\n      startTime = -1;\n    if (\"function\" === typeof localSetImmediate)\n      var schedulePerformWorkUntilDeadline = function () {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    else if (\"undefined\" !== typeof MessageChannel) {\n      var channel = new MessageChannel(),\n        port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function () {\n        port.postMessage(null);\n      };\n    } else\n      schedulePerformWorkUntilDeadline = function () {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    exports.unstable_IdlePriority = 5;\n    exports.unstable_ImmediatePriority = 1;\n    exports.unstable_LowPriority = 4;\n    exports.unstable_NormalPriority = 3;\n    exports.unstable_Profiling = null;\n    exports.unstable_UserBlockingPriority = 2;\n    exports.unstable_cancelCallback = function (task) {\n      task.callback = null;\n    };\n    exports.unstable_forceFrameRate = function (fps) {\n      0 > fps || 125 < fps\n        ? console.error(\n            \"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"\n          )\n        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);\n    };\n    exports.unstable_getCurrentPriorityLevel = function () {\n      return currentPriorityLevel;\n    };\n    exports.unstable_next = function (eventHandler) {\n      switch (currentPriorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n          var priorityLevel = 3;\n          break;\n        default:\n          priorityLevel = currentPriorityLevel;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_requestPaint = function () {\n      needsPaint = !0;\n    };\n    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          break;\n        default:\n          priorityLevel = 3;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_scheduleCallback = function (\n      priorityLevel,\n      callback,\n      options\n    ) {\n      var currentTime = exports.unstable_now();\n      \"object\" === typeof options && null !== options\n        ? ((options = options.delay),\n          (options =\n            \"number\" === typeof options && 0 < options\n              ? currentTime + options\n              : currentTime))\n        : (options = currentTime);\n      switch (priorityLevel) {\n        case 1:\n          var timeout = -1;\n          break;\n        case 2:\n          timeout = 250;\n          break;\n        case 5:\n          timeout = 1073741823;\n          break;\n        case 4:\n          timeout = 1e4;\n          break;\n        default:\n          timeout = 5e3;\n      }\n      timeout = options + timeout;\n      priorityLevel = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: options,\n        expirationTime: timeout,\n        sortIndex: -1\n      };\n      options > currentTime\n        ? ((priorityLevel.sortIndex = options),\n          push(timerQueue, priorityLevel),\n          null === peek(taskQueue) &&\n            priorityLevel === peek(timerQueue) &&\n            (isHostTimeoutScheduled\n              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n              : (isHostTimeoutScheduled = !0),\n            requestHostTimeout(handleTimeout, options - currentTime)))\n        : ((priorityLevel.sortIndex = timeout),\n          push(taskQueue, priorityLevel),\n          isHostCallbackScheduled ||\n            isPerformingWork ||\n            ((isHostCallbackScheduled = !0),\n            isMessageLoopRunning ||\n              ((isMessageLoopRunning = !0),\n              schedulePerformWorkUntilDeadline())));\n      return priorityLevel;\n    };\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = function (callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9CQUFvQjtBQUMxQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNLG9CQUFvQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUksNkJBQTZCO0FBQ2pDLElBQUksa0NBQWtDO0FBQ3RDLElBQUksNEJBQTRCO0FBQ2hDLElBQUksK0JBQStCO0FBQ25DLElBQUksMEJBQTBCO0FBQzlCLElBQUkscUNBQXFDO0FBQ3pDLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQSxJQUFJLCtCQUErQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdDQUF3QztBQUM1QztBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2QkFBNkI7QUFDakM7QUFDQTtBQUNBLElBQUksZ0NBQWdDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQ0FBaUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDLElBQUksNkJBQTZCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1ZvbHVtZXMvU29mdHdhYXJlIFByb2dyYW0vYXBwdGl2aXR5IGZpbmFsIHYxL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpIHtcbiAgICAgIG5lZWRzUGFpbnQgPSAhMTtcbiAgICAgIGlmIChpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgdmFyIGhhc01vcmVXb3JrID0gITA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMTtcbiAgICAgICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgJiZcbiAgICAgICAgICAgICAgKChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gITEpLFxuICAgICAgICAgICAgICBsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKSxcbiAgICAgICAgICAgICAgKHRhc2tUaW1lb3V0SUQgPSAtMSkpO1xuICAgICAgICAgICAgaXNQZXJmb3JtaW5nV29yayA9ICEwO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYjoge1xuICAgICAgICAgICAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRUYXNrICYmXG4gICAgICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA+IGN1cnJlbnRUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFlpZWxkVG9Ib3N0KClcbiAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50VGFzay5wcmlvcml0eUxldmVsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGludWF0aW9uQ2FsbGJhY2sgPSBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250aW51YXRpb25DYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gY29udGludWF0aW9uQ2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID09PSBwZWVrKHRhc2tRdWV1ZSkgJiYgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHBvcCh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50VGFzaykgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGZpcnN0VGltZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaGFzTW9yZVdvcmsgPSAhMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIChjdXJyZW50VGFzayA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbCksXG4gICAgICAgICAgICAgICAgKGlzUGVyZm9ybWluZ1dvcmsgPSAhMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNNb3JlV29yayA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaGFzTW9yZVdvcmtcbiAgICAgICAgICAgID8gc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKVxuICAgICAgICAgICAgOiAoaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSAhMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaChoZWFwLCBub2RlKSB7XG4gICAgICB2YXIgaW5kZXggPSBoZWFwLmxlbmd0aDtcbiAgICAgIGhlYXAucHVzaChub2RlKTtcbiAgICAgIGE6IGZvciAoOyAwIDwgaW5kZXg7ICkge1xuICAgICAgICB2YXIgcGFyZW50SW5kZXggPSAoaW5kZXggLSAxKSA+Pj4gMSxcbiAgICAgICAgICBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcbiAgICAgICAgaWYgKDAgPCBjb21wYXJlKHBhcmVudCwgbm9kZSkpXG4gICAgICAgICAgKGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZSksXG4gICAgICAgICAgICAoaGVhcFtpbmRleF0gPSBwYXJlbnQpLFxuICAgICAgICAgICAgKGluZGV4ID0gcGFyZW50SW5kZXgpO1xuICAgICAgICBlbHNlIGJyZWFrIGE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZWsoaGVhcCkge1xuICAgICAgcmV0dXJuIDAgPT09IGhlYXAubGVuZ3RoID8gbnVsbCA6IGhlYXBbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcChoZWFwKSB7XG4gICAgICBpZiAoMCA9PT0gaGVhcC5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGZpcnN0ID0gaGVhcFswXSxcbiAgICAgICAgbGFzdCA9IGhlYXAucG9wKCk7XG4gICAgICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICAgICAgaGVhcFswXSA9IGxhc3Q7XG4gICAgICAgIGE6IGZvciAoXG4gICAgICAgICAgdmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gaGVhcC5sZW5ndGgsIGhhbGZMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gICAgICAgICAgaW5kZXggPCBoYWxmTGVuZ3RoO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBsZWZ0SW5kZXggPSAyICogKGluZGV4ICsgMSkgLSAxLFxuICAgICAgICAgICAgbGVmdCA9IGhlYXBbbGVmdEluZGV4XSxcbiAgICAgICAgICAgIHJpZ2h0SW5kZXggPSBsZWZ0SW5kZXggKyAxLFxuICAgICAgICAgICAgcmlnaHQgPSBoZWFwW3JpZ2h0SW5kZXhdO1xuICAgICAgICAgIGlmICgwID4gY29tcGFyZShsZWZ0LCBsYXN0KSlcbiAgICAgICAgICAgIHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgMCA+IGNvbXBhcmUocmlnaHQsIGxlZnQpXG4gICAgICAgICAgICAgID8gKChoZWFwW2luZGV4XSA9IHJpZ2h0KSxcbiAgICAgICAgICAgICAgICAoaGVhcFtyaWdodEluZGV4XSA9IGxhc3QpLFxuICAgICAgICAgICAgICAgIChpbmRleCA9IHJpZ2h0SW5kZXgpKVxuICAgICAgICAgICAgICA6ICgoaGVhcFtpbmRleF0gPSBsZWZ0KSxcbiAgICAgICAgICAgICAgICAoaGVhcFtsZWZ0SW5kZXhdID0gbGFzdCksXG4gICAgICAgICAgICAgICAgKGluZGV4ID0gbGVmdEluZGV4KSk7XG4gICAgICAgICAgZWxzZSBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiAwID4gY29tcGFyZShyaWdodCwgbGFzdCkpXG4gICAgICAgICAgICAoaGVhcFtpbmRleF0gPSByaWdodCksXG4gICAgICAgICAgICAgIChoZWFwW3JpZ2h0SW5kZXhdID0gbGFzdCksXG4gICAgICAgICAgICAgIChpbmRleCA9IHJpZ2h0SW5kZXgpO1xuICAgICAgICAgIGVsc2UgYnJlYWsgYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIHZhciBkaWZmID0gYS5zb3J0SW5kZXggLSBiLnNvcnRJbmRleDtcbiAgICAgIHJldHVybiAwICE9PSBkaWZmID8gZGlmZiA6IGEuaWQgLSBiLmlkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKSB7XG4gICAgICBmb3IgKHZhciB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7IG51bGwgIT09IHRpbWVyOyApIHtcbiAgICAgICAgaWYgKG51bGwgPT09IHRpbWVyLmNhbGxiYWNrKSBwb3AodGltZXJRdWV1ZSk7XG4gICAgICAgIGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSlcbiAgICAgICAgICBwb3AodGltZXJRdWV1ZSksXG4gICAgICAgICAgICAodGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWUpLFxuICAgICAgICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KGN1cnJlbnRUaW1lKSB7XG4gICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gITE7XG4gICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpXG4gICAgICAgIGlmIChudWxsICE9PSBwZWVrKHRhc2tRdWV1ZSkpXG4gICAgICAgICAgKGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITApLFxuICAgICAgICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgfHxcbiAgICAgICAgICAgICAgKChpc01lc3NhZ2VMb29wUnVubmluZyA9ICEwKSwgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgICAgICBudWxsICE9PSBmaXJzdFRpbWVyICYmXG4gICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoXG4gICAgICAgICAgICAgIGhhbmRsZVRpbWVvdXQsXG4gICAgICAgICAgICAgIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkWWllbGRUb0hvc3QoKSB7XG4gICAgICByZXR1cm4gbmVlZHNQYWludFxuICAgICAgICA/ICEwXG4gICAgICAgIDogZXhwb3J0cy51bnN0YWJsZV9ub3coKSAtIHN0YXJ0VGltZSA8IGZyYW1lSW50ZXJ2YWxcbiAgICAgICAgICA/ICExXG4gICAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICAgICAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgICAgfSwgbXMpO1xuICAgIH1cbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KEVycm9yKCkpO1xuICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gdm9pZCAwO1xuICAgIGlmIChcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2Uubm93XG4gICAgKSB7XG4gICAgICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2FsRGF0ZSA9IERhdGUsXG4gICAgICAgIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciB0YXNrUXVldWUgPSBbXSxcbiAgICAgIHRpbWVyUXVldWUgPSBbXSxcbiAgICAgIHRhc2tJZENvdW50ZXIgPSAxLFxuICAgICAgY3VycmVudFRhc2sgPSBudWxsLFxuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSAzLFxuICAgICAgaXNQZXJmb3JtaW5nV29yayA9ICExLFxuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSxcbiAgICAgIG5lZWRzUGFpbnQgPSAhMSxcbiAgICAgIGxvY2FsU2V0VGltZW91dCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHNldFRpbWVvdXQgPyBzZXRUaW1lb3V0IDogbnVsbCxcbiAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0ID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2xlYXJUaW1lb3V0ID8gY2xlYXJUaW1lb3V0IDogbnVsbCxcbiAgICAgIGxvY2FsU2V0SW1tZWRpYXRlID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHNldEltbWVkaWF0ZSA/IHNldEltbWVkaWF0ZSA6IG51bGwsXG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9ICExLFxuICAgICAgdGFza1RpbWVvdXRJRCA9IC0xLFxuICAgICAgZnJhbWVJbnRlcnZhbCA9IDUsXG4gICAgICBzdGFydFRpbWUgPSAtMTtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9jYWxTZXRJbW1lZGlhdGUpXG4gICAgICB2YXIgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG4gICAgICB9O1xuICAgIGVsc2UgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcbiAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2NhbFNldFRpbWVvdXQocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lLCAwKTtcbiAgICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9JZGxlUHJpb3JpdHkgPSA1O1xuICAgIGV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xuICAgIGV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSA0O1xuICAgIGV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSAzO1xuICAgIGV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gbnVsbDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgIHRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZSA9IGZ1bmN0aW9uIChmcHMpIHtcbiAgICAgIDAgPiBmcHMgfHwgMTI1IDwgZnBzXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZm9yY2VGcmFtZVJhdGUgdGFrZXMgYSBwb3NpdGl2ZSBpbnQgYmV0d2VlbiAwIGFuZCAxMjUsIGZvcmNpbmcgZnJhbWUgcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3Qgc3VwcG9ydGVkXCJcbiAgICAgICAgICApXG4gICAgICAgIDogKGZyYW1lSW50ZXJ2YWwgPSAwIDwgZnBzID8gTWF0aC5mbG9vcigxZTMgLyBmcHMpIDogNSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gZnVuY3Rpb24gKGV2ZW50SGFuZGxlcikge1xuICAgICAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmlvcml0eUxldmVsID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbmVlZHNQYWludCA9ICEwO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHlMZXZlbCwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJpb3JpdHlMZXZlbCA9IDM7XG4gICAgICB9XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IGZ1bmN0aW9uIChcbiAgICAgIHByaW9yaXR5TGV2ZWwsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJiBudWxsICE9PSBvcHRpb25zXG4gICAgICAgID8gKChvcHRpb25zID0gb3B0aW9ucy5kZWxheSksXG4gICAgICAgICAgKG9wdGlvbnMgPVxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgMCA8IG9wdGlvbnNcbiAgICAgICAgICAgICAgPyBjdXJyZW50VGltZSArIG9wdGlvbnNcbiAgICAgICAgICAgICAgOiBjdXJyZW50VGltZSkpXG4gICAgICAgIDogKG9wdGlvbnMgPSBjdXJyZW50VGltZSk7XG4gICAgICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHZhciB0aW1lb3V0ID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aW1lb3V0ID0gMjUwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgdGltZW91dCA9IDEwNzM3NDE4MjM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0aW1lb3V0ID0gMWU0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRpbWVvdXQgPSA1ZTM7XG4gICAgICB9XG4gICAgICB0aW1lb3V0ID0gb3B0aW9ucyArIHRpbWVvdXQ7XG4gICAgICBwcmlvcml0eUxldmVsID0ge1xuICAgICAgICBpZDogdGFza0lkQ291bnRlcisrLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgICAgIHN0YXJ0VGltZTogb3B0aW9ucyxcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IHRpbWVvdXQsXG4gICAgICAgIHNvcnRJbmRleDogLTFcbiAgICAgIH07XG4gICAgICBvcHRpb25zID4gY3VycmVudFRpbWVcbiAgICAgICAgPyAoKHByaW9yaXR5TGV2ZWwuc29ydEluZGV4ID0gb3B0aW9ucyksXG4gICAgICAgICAgcHVzaCh0aW1lclF1ZXVlLCBwcmlvcml0eUxldmVsKSxcbiAgICAgICAgICBudWxsID09PSBwZWVrKHRhc2tRdWV1ZSkgJiZcbiAgICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPT09IHBlZWsodGltZXJRdWV1ZSkgJiZcbiAgICAgICAgICAgIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkXG4gICAgICAgICAgICAgID8gKGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpLCAodGFza1RpbWVvdXRJRCA9IC0xKSlcbiAgICAgICAgICAgICAgOiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBvcHRpb25zIC0gY3VycmVudFRpbWUpKSlcbiAgICAgICAgOiAoKHByaW9yaXR5TGV2ZWwuc29ydEluZGV4ID0gdGltZW91dCksXG4gICAgICAgICAgcHVzaCh0YXNrUXVldWUsIHByaW9yaXR5TGV2ZWwpLFxuICAgICAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIHx8XG4gICAgICAgICAgICBpc1BlcmZvcm1pbmdXb3JrIHx8XG4gICAgICAgICAgICAoKGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITApLFxuICAgICAgICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgfHxcbiAgICAgICAgICAgICAgKChpc01lc3NhZ2VMb29wUnVubmluZyA9ICEwKSxcbiAgICAgICAgICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKSkpKTtcbiAgICAgIHJldHVybiBwcmlvcml0eUxldmVsO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZCA9IHNob3VsZFlpZWxkVG9Ib3N0O1xuICAgIGV4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcGFyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHBhcmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChFcnJvcigpKTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/compiled/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/compiled/scheduler/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/scheduler/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/next/dist/compiled/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3NjaGVkdWxlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsNEpBQTBEO0FBQzVEIiwic291cmNlcyI6WyIvVm9sdW1lcy9Tb2Z0d2FhcmUgUHJvZ3JhbS9hcHB0aXZpdHkgZmluYWwgdjEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zY2hlZHVsZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/compiled/scheduler/index.js\n");

/***/ })

};
;